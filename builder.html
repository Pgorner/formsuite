<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Form Suite — Builder</title>
  <link rel="icon" href="favicon.ico" type="image/gif" sizes="32x32">
  <link rel="shortcut icon" href="favicon.ico" type="image/gif">
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
  <link rel="stylesheet" href="style.css">
  <script src="persistence.js"></script>

</head>
<body>
  <header>
    <div class="row">
      <span class="brand logo-md">
        <img src="logo.gif" alt="Form Suite logo" class="logo" />
        <strong>Form Suite</strong>
      </span>
      <span class="muted">·</span><a href="index.html">Form</a>
      <span class="muted">·</span><span class="muted">Form Builder</span>
      <span class="muted">·</span><a href="matcher.html">Tag Matcher</a>
      <span class="muted">·</span><a href="rules.html">Rules</a>
      <span class="muted">·</span><a href="extractor.html">Extractor</a>
    </div>
  </header>

  <main>
    <!-- Top: Title + status -->
    <section class="panel">
      <div class="row" style="align-items:center; gap:12px;">
        <label for="formTitle" class="small" style="min-width:48px;">Title</label>
        <input id="formTitle" type="text" placeholder="Form title (optional)" style="flex:1; max-width:520px;" />
      </div>
      <div class="row" style="margin-top:8px; align-items:center; gap:10px; font-size:13px;">
        <span id="docStatus" class="muted">No DOCX active.</span>
        <span class="dot"></span>
        <span id="fieldCount" class="muted">0 fields</span>
      </div>
    </section>

    <!-- Builder -->
    <section class="grid">
      <!-- Palette -->
      <aside class="panel">
        <h3 style="margin:0 0 10px">New / Edit Field</h3>

        <div class="row" style="gap:10px;">
          <div>
            <label for="pType" class="small">Type</label><br/>
            <select id="pType">
              <option value="text">text</option>
              <option value="number">number</option>
              <option value="select">select</option>
              <option value="multichoice">multichoice</option>
              <option value="date">date</option>
              <option value="address">address</option>
              <option value="table">table</option>
            </select>
          </div>
          <div class="grow">
            <label for="pId" class="small">id</label><br/>
            <input id="pId" type="text" placeholder="e.g. firstName" />
          </div>
        </div>

        <div class="row" style="gap:10px; margin-top:8px;">
          <div class="grow">
            <label for="pLabel" class="small">label</label><br/>
            <input id="pLabel" type="text" placeholder="What should be shown to the user" />
          </div>
          <div style="display:flex; align-items:flex-end;">
            <label class="switch">
              <input id="pRequired" type="checkbox" />
              <span>required</span>
            </label>
          </div>
        </div>

        <!-- Type-specific config -->
        <div id="typeSpecific" style="margin-top:10px;"></div>

        <div class="row" style="margin-top:10px; gap:8px; flex-wrap: wrap;">
          <button id="btnAdd">Add / Update field</button>
          <button id="btnCancel" class="ghost" disabled>Cancel</button>
          <button id="btnDelete" class="danger" disabled>Delete</button>
          <span class="muted" id="builderStatus" style="margin-left:auto;"></span>
        </div>
      </aside>

      <!-- Fields list -->
      <section class="panel">
        <h3 style="margin:0 0 8px;">Fields</h3>
        <div style="overflow:auto;">
          <table id="fieldTable">
            <thead>
              <tr>
                <th style="width:42px;">☰</th>
                <th>id</th>
                <th>label</th>
                <th>type</th>
                <th>details</th>
              </tr>
            </thead>
            <tbody id="tbodyFields">
              <tr><td colspan="5" class="empty">No fields yet.</td></tr>
            </tbody>
          </table>
        </div>
      </section>
    </section>
  </main>

  <script>
    // ---------- State ----------
    const STORAGE_KEY = 'FORM_SCHEMA_V1';
    const OLD_STORAGE_KEY = 'formSuite.builder.schema';
    const els = {
      formTitle: document.getElementById('formTitle'),
      docStatus: document.getElementById('docStatus'),
      fieldCount: document.getElementById('fieldCount'),
      tbodyFields: document.getElementById('tbodyFields'),
      fieldTable: document.getElementById('fieldTable'),
      builderStatus: document.getElementById('builderStatus'),

      pType: document.getElementById('pType'),
      pId: document.getElementById('pId'),
      pLabel: document.getElementById('pLabel'),
      pRequired: document.getElementById('pRequired'),
      typeSpecific: document.getElementById('typeSpecific'),

      btnAdd: document.getElementById('btnAdd'),
      btnDelete: document.getElementById('btnDelete'),
      btnCancel: document.getElementById('btnCancel'),
    };

    let currentDoc = null; // from persistence
    const FORM_BUILDER = {
      schema: { title: 'Untitled form', fields: [] },
      selectedIndex: -1,
      getSchema() { return this.schema; },
      getValues() { return window.formSuitePersist?.getLastKnownValues?.(currentDoc?.docId) || {}; }
    };

    // ---------- Broadcast helper (schema-updated) ----------
    const __bcastLegacy = ('BroadcastChannel' in window) ? new BroadcastChannel('form-suite-doc') : null;
    const __bcastCanon  = ('BroadcastChannel' in window) ? new BroadcastChannel('fs-active-doc') : null;
    function broadcastSchemaUpdated(docId) {
      const msg = { type: 'schema-updated', docId: docId || null, ts: Date.now() };
      try { __bcastLegacy?.postMessage(msg); } catch {}
      try { __bcastCanon?.postMessage(msg); } catch {}
    }

    // ---------- File-Guard helpers ----------
    function loadDocStatus() {
      if (currentDoc?.docTitle || currentDoc?.name) {
        els.docStatus.textContent = `DOCX: ${currentDoc.docTitle || currentDoc.name}`;
        els.docStatus.classList.remove('muted');
      } else {
        els.docStatus.innerHTML = 'No DOCX active.';
        els.docStatus.classList.add('muted');
      }
    }
    function setStatus(msg, ok) {
      els.builderStatus.textContent = msg || '';
      els.builderStatus.style.color = ok ? 'var(--good,#0a7)' : 'var(--muted,#6b7280)';
      if (msg) setTimeout(() => { els.builderStatus.textContent=''; }, 1200);
    }

    async function hardResetBuilder(reason = '') {
      try {} catch {}
      FORM_BUILDER.schema = { title: 'Untitled form', fields: [] };
      FORM_BUILDER.selectedIndex = -1;
      els.formTitle.value = '';
      renderAll({ persist:false });
      els.docStatus.innerHTML = reason ? `No DOCX active (${reason}).` : 'No DOCX active.';
      els.docStatus.classList.add('muted');
      setStatus('Cleared', true);
    }

    // Check if we still have byte access to active doc; otherwise reset
    async function ensureActiveOrReset() {
      try {
        currentDoc = readActiveDocSync() || currentDoc;
        if (!currentDoc?.docId) {
          const draft = loadLS() || { title: 'Untitled form', fields: [] };
          FORM_BUILDER.schema = draft;
          els.formTitle.value = draft.title || '';
          renderAll({ persist:false });
          els.docStatus.textContent = 'No DOCX active.';
          els.docStatus.classList.add('muted');
          return;
        }
        // Active doc → reload workspace state (no LS fallback)
        const st = await window.formSuitePersist.loadState?.(currentDoc.docId);
        FORM_BUILDER.schema = st?.schema || { title: 'Untitled form', fields: [] };
        els.formTitle.value = FORM_BUILDER.schema.title || '';
        renderAll({ persist:false });
        els.docStatus.textContent = `DOCX: ${currentDoc.name || currentDoc.docTitle || currentDoc.docId}`;
        els.docStatus.classList.remove('muted');
      } catch (e) {
        console.warn('ensureActiveOrReset failed:', e);
      }
    }

    // ---------- One Active-Doc Signal (unifier) ----------
    const ACTIVE_DOC_KEY = 'FS_ACTIVE_DOC_META'; // canonical key (same as index/extractor)

    // Read current active doc meta (pref: persistence → LS → legacy LS)
    function readActiveDocSync() {
      const meta = window.formSuitePersist?.getActiveDocMeta?.()
                || window.formSuitePersist?.getCurrentDocMeta?.();
      if (meta?.docId) {
        const m = { docId: meta.docId, name: meta.name || meta.docTitle || 'document' };
        try { localStorage.setItem(ACTIVE_DOC_KEY, JSON.stringify(m)); } catch {}
        return m;
      }
      try {
        const v = localStorage.getItem(ACTIVE_DOC_KEY);
        if (v) return JSON.parse(v);
      } catch {}
      try {
        const legacy = localStorage.getItem('FS_CURRENT_DOC_META');
        if (legacy) {
          const m = JSON.parse(legacy);
          if (m?.docId) {
            localStorage.setItem(ACTIVE_DOC_KEY, legacy);
            return m;
          }
        }
      } catch {}
      return null;
    }

    // Normalize all cross-tab signals into ACTIVE_DOC_KEY + callback
    function installActiveDocListener(onChange) {
      const bcLegacy = ('BroadcastChannel' in window) ? new BroadcastChannel('form-suite-doc') : null;
      const bcCanon  = ('BroadcastChannel' in window) ? new BroadcastChannel('fs-active-doc') : null;

      function emit(meta) {
        if (meta?.docId) {
          try { localStorage.setItem(ACTIVE_DOC_KEY, JSON.stringify({ docId: meta.docId, name: meta.name })); } catch {}
        } else {
          try { localStorage.removeItem(ACTIVE_DOC_KEY); } catch {}
        }
        onChange(meta || null);
      }

      // Map old messages → canonical
      bcLegacy?.addEventListener('message', async (ev) => {
        const m = ev?.data || {};
        if (m.type === 'doc-cleared') { emit(null); return; }
        if (m.type === 'doc-switched' || m.type === 'doc-updated') {
          emit((m.docId) ? { docId: m.docId, name: m.name } : readActiveDocSync());
          return;
        }
        if (m.type === 'schema-updated') {
          const meta = readActiveDocSync();
          if (meta?.docId && (!m.docId || m.docId === meta.docId)) emit(meta);
        }
      });

      // Canonical channel
      bcCanon?.addEventListener('message', (ev) => {
        const m = ev?.data || {};
        if (m.type === 'active:set')   emit({ docId: m.docId, name: m.name });
        if (m.type === 'active:clear') emit(null);
        if (m.type === 'active:updated') {
          const meta = readActiveDocSync();
          if (meta?.docId) emit(meta);
        }
        if (m.type === 'schema-updated') {
          const meta = readActiveDocSync();
          if (meta?.docId && (!m.docId || m.docId === meta.docId)) emit(meta);
        }
      });

      // Storage sync (also migrates legacy key once)
      window.addEventListener('storage', (e) => {
        if (e.key === ACTIVE_DOC_KEY) {
          const v = e.newValue ? JSON.parse(e.newValue) : null;
          emit(v);
        }
        if (e.key === 'FS_CURRENT_DOC_META' && !localStorage.getItem(ACTIVE_DOC_KEY)) {
          const v = e.newValue ? JSON.parse(e.newValue) : null;
          if (v?.docId) {
            try { localStorage.setItem(ACTIVE_DOC_KEY, e.newValue); } catch {}
            emit(v);
          }
        }
      });
    }

    // Drive Builder UI from the single signal
    installActiveDocListener(async (meta) => {
      currentDoc = meta;

      if (!currentDoc?.docId) {
        // No active doc → local draft
        const draft = loadLS() || { title: 'Untitled form', fields: [] };
        FORM_BUILDER.schema = draft;
        els.formTitle.value = draft.title || '';
        renderAll({ persist: false });
        els.docStatus.textContent = 'No DOCX active.';
        els.docStatus.classList.add('muted');
        return;
      }

      // Active doc → per-doc workspace state only (no LS fallback)
      const st = await window.formSuitePersist.loadState?.(currentDoc.docId);
      if (st?.schema) {
        FORM_BUILDER.schema = st.schema;
        els.formTitle.value = st.schema.title || '';
      } else {
        FORM_BUILDER.schema = { title: 'Untitled form', fields: [] };
        els.formTitle.value = '';
      }
      renderAll({ persist: false });
      els.docStatus.textContent = `DOCX: ${currentDoc.name || currentDoc.docTitle || currentDoc.docId}`;
      els.docStatus.classList.remove('muted');
    });


    // Focus/visibility checks
    document.addEventListener('visibilitychange', async () => {
      if (document.visibilityState !== 'visible') return;
      await ensureActiveOrReset();
    });
    window.addEventListener('focus', async () => { await ensureActiveOrReset(); });

    // ---------- Schema-aware pruning & migration (NEW) ----------

    function getValidFieldIds(schema) {
      const ids = new Set();
      for (const f of (schema?.fields || [])) {
        if (f?.id) ids.add(String(f.id));
      }
      return ids;
    }

    // Defensive copy
    function deepClone(o) {
      return (o && typeof o === 'object') ? JSON.parse(JSON.stringify(o)) : o;
    }

    /**
     * Prune values, tagMap, and rules so they only reference fields present in `schema`.
     * Returns { values, tagMap, rules } (all pruned) without saving; caller should persist.
     */
    async function pruneWorkspaceOnSchemaChange(docId, schema) {
      if (!docId || !window.formSuitePersist?.loadState) {
        // No per-doc workspace yet → nothing to prune at this layer
        return {
          values: FORM_BUILDER.getValues?.() || {},
          tagMap: {},
          rules: []
        };
      }

      const st = await window.formSuitePersist.loadState(docId) || {};
      const valid = getValidFieldIds(schema);

      // values: keep only keys that are valid field ids
      const values = {};
      const srcValues = st.values || {};
      Object.keys(srcValues || {}).forEach(k => {
        if (valid.has(k)) values[k] = srcValues[k];
      });

      // tagMap: drop any tag → fieldId mapping pointing at a deleted field
      const tagMap = {};
      const srcTagMap = st.tagMap || {};
      Object.keys(srcTagMap || {}).forEach(tag => {
        const fid = srcTagMap[tag];
        if (valid.has(fid)) tagMap[tag] = fid;
      });

      // rules: drop any rule whose primary fieldId is gone.
      // Also defensively prune rule.conditions entries that reference deleted fields.
      const srcRules = Array.isArray(st.rules) ? st.rules : [];
      const rules = [];
      for (const r of srcRules) {
        const rr = deepClone(r);
        if (!rr || !valid.has(String(rr.fieldId || ''))) continue; // drop entire rule

        if (Array.isArray(rr.conditions)) {
          rr.conditions = rr.conditions.filter(c => {
            if (!c) return false;
            // If a condition targets another field, drop if that field is gone.
            const refId = c.fieldId || c.leftFieldId || c.rightFieldId;
            return !refId || valid.has(String(refId));
          });
        }
        rules.push(rr);
      }

      return { values, tagMap, rules };
    }

    /**
     * Migrate workspace state when a field was renamed from oldId → newId.
     * We update values, tagMap, and rules (field targets & condition references).
     * Returns { values, tagMap, rules } (migrated) without saving; caller should persist.
     */
    async function migrateWorkspaceOnFieldRename(docId, oldId, newId) {
      if (!docId || !oldId || !newId || oldId === newId) return null;
      const st = await window.formSuitePersist.loadState?.(docId) || {};

      // values
      const values = deepClone(st.values || {});
      if (Object.prototype.hasOwnProperty.call(values, oldId) && !Object.prototype.hasOwnProperty.call(values, newId)) {
        values[newId] = values[oldId];
        delete values[oldId];
      }

      // tagMap
      const tagMap = deepClone(st.tagMap || {});
      Object.keys(tagMap).forEach(tag => {
        if (tagMap[tag] === oldId) tagMap[tag] = newId;
      });

      // rules
      const rules = Array.isArray(st.rules) ? deepClone(st.rules) : [];
      for (const r of rules) {
        if (r?.fieldId === oldId) r.fieldId = newId;
        if (Array.isArray(r?.conditions)) {
          r.conditions.forEach(c => {
            if (!c) return;
            if (c.fieldId === oldId) c.fieldId = newId;
            if (c.leftFieldId === oldId) c.leftFieldId = newId;
            if (c.rightFieldId === oldId) c.rightFieldId = newId;
          });
        }
      }

      return { values, tagMap, rules };
    }


    // ---------- Helpers ----------
    function saveLS(schema) {
      try { localStorage.setItem(STORAGE_KEY, JSON.stringify(schema)); } catch {}
    }
    function loadLS() {
      try {
        const v = localStorage.getItem(STORAGE_KEY);
        if (v) return JSON.parse(v);
        const old = localStorage.getItem(OLD_STORAGE_KEY);
        if (old) {
          const parsed = JSON.parse(old);
          localStorage.setItem(STORAGE_KEY, old);
          return parsed;
        }
      } catch {}
      return null;
    }
    function escapeHtml(s){
      return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
    }

    function fieldDetails(f) {
      if (f.type === 'date') return `Datepicker (${f.dateFormat || 'Y-m-d'})`;
      if (f.type === 'select') return `Select: ${(f.options||[]).join(', ') || '—'}`;
      if (f.type === 'multichoice') return `Multiple: ${(f.options||[]).join(', ') || '—'}`;
      if (f.type === 'table') {
        const cols = (f.columns||[]).map(c => `${c.label||c.id}${c.type?`:${c.type}${(c.type==='select'&&c.options?.length)?':'+c.options.join('/'):''}`:''}`);
        return `Table with ${f.columns?.length||0} column(s)${(f.minRows||f.maxRows)?` ${f.minRows||0}–${f.maxRows||'∞'}`:''} → [ ${cols.join(' | ')} ]`;
      }
      return '';
    }

    // ---------- Type-specific UI ----------
    function renderTypeSpecific() {
      const t = els.pType.value;
      const wrap = els.typeSpecific;
      wrap.innerHTML = '';

      if (t === 'select' || t === 'multichoice') {
        const div = document.createElement('div');
        div.innerHTML = `
          <label class="small">Options (comma separated)</label><br/>
          <input id="pOptions" type="text" placeholder="e.g. Red, Green, Blue" />
        `;
        wrap.appendChild(div);

      } else if (t === 'date') {
        const div = document.createElement('div');
        div.innerHTML = `
          <label class="small">Format</label><br/>
          <input id="pDateFmt" type="text" placeholder="Y-m-d" />
        `;
        wrap.appendChild(div);

      } else if (t === 'table') {
        const div = document.createElement('div');
        div.innerHTML = `
          <div class="tdz-toolbar">
            <div>
              <strong>Tabellen-Spalten</strong>
              <span class="tdz-muted" id="tdzCount"></span>
            </div>
            <div class="row" style="gap:6px;">
              <button type="button" id="tdzAdd">+ Spalte hinzufügen</button>
            </div>
          </div>

          <div id="tdzList" aria-live="polite"></div>

          <div class="row" style="gap:12px; margin-top:10px;">
            <div class="tdz-col">
              <label class="small">Min rows</label>
              <input id="pMinRows" type="number" value="0" min="0" style="width:140px"/>
            </div>
            <div class="tdz-col">
              <label class="small">Max rows</label>
              <input id="pMaxRows" type="number" value="0" min="0" style="width:140px"/>
            </div>
          </div>

          <!-- Compatibility: keep legacy string mirror hidden -->
          <input id="pCols" type="hidden" />
        `;
        wrap.appendChild(div);

        // Table Designer initialize
        window.TableDesigner?.destroy?.();
        window.TableDesigner = createTableDesigner({
          listEl: wrap.querySelector('#tdzList'),
          countEl: wrap.querySelector('#tdzCount'),
          addBtn:  wrap.querySelector('#tdzAdd'),
          hiddenColsEl: wrap.querySelector('#pCols'),
          minEl: wrap.querySelector('#pMinRows'),
          maxEl: wrap.querySelector('#pMaxRows'),
        });
      }
    }

    // ---------- Table Designer (visual editor for table columns) ----------
    function createTableDesigner(cfg) {
      let model = []; // [{id,label,type,options:[]}]
      const TYPES = ['text','number','select','date'];

      const api = {
        loadColumns(colsArr = []) {
          model = (colsArr || []).map(c => ({
            id: String(c.id || '').trim() || 'col',
            label: String(c.label != null ? c.label : c.id || 'col'),
            type: TYPES.includes(c.type) ? c.type : 'text',
            options: Array.isArray(c.options) ? c.options.map(o => String(o)) : []
          }));
          render();
        },
        setMinMax(min, max) {
          if (cfg.minEl) cfg.minEl.value = String(parseInt(min || 0, 10) || 0);
          if (cfg.maxEl) cfg.maxEl.value = String(parseInt(max || 0, 10) || 0);
        },
        getColumns() {
          return model.slice();
        },
        toLegacyString() {
          // id:label[:type[:opt1/opt2]]
          const parts = model.map(c => {
            const base = `${c.id}:${c.label}${c.type && c.type!=='text' ? `:${c.type}`:''}`;
            if (c.type === 'select' && c.options?.length) return `${base}:${c.options.join('/')}`;
            return base;
          });
          return parts.join(', ');
        },
        serializeToHidden() {
          if (cfg.hiddenColsEl) cfg.hiddenColsEl.value = api.toLegacyString();
        },
        addEmpty() {
          const baseId = 'col';
          let n = 1;
          let candidate = baseId;
          const ids = new Set(model.map(c => c.id));
          while (ids.has(candidate)) { n++; candidate = baseId + n; }
          model.push({ id: candidate, label: candidate.toUpperCase(), type:'text', options:[] });
          render();
        },
        move(idx, dir) {
          const j = idx + dir;
          if (idx < 0 || j < 0 || idx >= model.length || j >= model.length) return;
          [model[idx], model[j]] = [model[j], model[idx]];
          render();
        },
        remove(idx) {
          model.splice(idx, 1);
          render();
        },
        destroy() { /* future cleanup hook */ }
      };

      function render() {
        if (cfg.countEl) cfg.countEl.textContent = model.length ? `· ${model.length} Spalten` : '· keine Spalten';
        if (cfg.listEl) cfg.listEl.innerHTML = '';
        model.forEach((col, idx) => {
          const row = document.createElement('div');
          row.className = 'tdz-row';

          // ID
          const cId = document.createElement('div'); cId.className = 'tdz-col';
          cId.innerHTML = `<label class="small">ID</label>`;
          const inId = document.createElement('input'); inId.value = col.id; inId.placeholder = 'e.g. sku';
          inId.addEventListener('input', () => { col.id = inId.value.trim(); api.serializeToHidden(); });
          cId.appendChild(inId);

          // Label
          const cLabel = document.createElement('div'); cLabel.className = 'tdz-col tdz-grow';
          cLabel.innerHTML = `<label class="small">Label</label>`;
          const inLabel = document.createElement('input'); inLabel.value = col.label; inLabel.placeholder = 'z. B. Artikelnummer';
          inLabel.addEventListener('input', () => { col.label = inLabel.value; api.serializeToHidden(); });
          cLabel.appendChild(inLabel);

          // Typ
          const cType = document.createElement('div'); cType.className = 'tdz-col';
          cType.innerHTML = `<label class="small">Typ</label>`;
          const sel = document.createElement('select');
          TYPES.forEach(t => { const o=document.createElement('option'); o.value=t; o.textContent=t; sel.appendChild(o); });
          sel.value = col.type;
          cType.appendChild(sel);

          // Optionen (nur Select)
          const cOpts = document.createElement('div'); cOpts.className = 'tdz-col tdz-grow';
          cOpts.innerHTML = `<label class="small">Optionen (nur bei Select)</label>`;
          const optWrap = document.createElement('div'); optWrap.className = 'tdz-chipwrap';
          const optAddWrap = document.createElement('div'); optAddWrap.className = 'tdz-opts';
          const inOpt = document.createElement('input'); inOpt.placeholder = 'Option eingeben…';
          const btnAddOpt = document.createElement('button'); btnAddOpt.type='button'; btnAddOpt.textContent='Hinzufügen';
          btnAddOpt.addEventListener('click', () => {
            const v = (inOpt.value||'').trim();
            if (!v) return;
            col.options = Array.from(new Set([...(col.options||[]), v]));
            inOpt.value = '';
            drawChips();
            api.serializeToHidden();
          });
          optAddWrap.appendChild(inOpt); optAddWrap.appendChild(btnAddOpt);

          function drawChips() {
            optWrap.innerHTML = '';
            (col.options||[]).forEach((o, i) => {
              const chip = document.createElement('span'); chip.className='tdz-chip';
              chip.innerHTML = `<span>${escapeHtml(o)}</span>`;
              const x = document.createElement('button'); x.type='button'; x.setAttribute('aria-label', 'Option entfernen'); x.textContent='×';
              x.addEventListener('click', () => { col.options.splice(i,1); drawChips(); api.serializeToHidden(); });
              chip.appendChild(x); optWrap.appendChild(chip);
            });
          }
          drawChips();

          // Sichtbarkeit steuern
          function toggleOpts() {
            cOpts.style.display = (sel.value === 'select') ? '' : 'none';
          }
          sel.addEventListener('change', () => { col.type = sel.value; toggleOpts(); api.serializeToHidden(); });
          toggleOpts();

          // Actions
          const actions = document.createElement('div'); actions.className = 'tdz-actions';
          const up = document.createElement('button'); up.type='button'; up.textContent='▲'; up.title='Hoch';
          const down = document.createElement('button'); down.type='button'; down.textContent='▼'; down.title='Runter';
          const del = document.createElement('button'); del.type='button'; del.className='danger'; del.textContent='Löschen';

          up.addEventListener('click', () => api.move(idx, -1));
          down.addEventListener('click', () => api.move(idx, +1));
          del.addEventListener('click', () => api.remove(idx));

          actions.appendChild(up); actions.appendChild(down); actions.appendChild(del);

          // Compose
          row.appendChild(cId);
          row.appendChild(cLabel);
          row.appendChild(cType);
          // Add options area only for select
          if (true) {
            const optArea = document.createElement('div');
            optArea.appendChild(optWrap);
            optArea.appendChild(optAddWrap);
            cOpts.appendChild(optArea);
          }
          row.appendChild(cOpts);
          row.appendChild(actions);

          cfg.listEl.appendChild(row);
        });

        api.serializeToHidden();
      }

      cfg.addBtn?.addEventListener('click', () => api.addEmpty());
      return api;
    }

    // ---------- Fields list rendering (with DnD) ----------
    function renderFields() {
      const tb = els.tbodyFields;
      tb.innerHTML = '';
      if (!FORM_BUILDER.schema.fields.length) {
        tb.innerHTML = '<tr><td colspan="5" class="empty">No fields yet.</td></tr>';
        els.fieldCount.textContent = '0 fields';
        return;
      }

      FORM_BUILDER.schema.fields.forEach((f, i) => {
        const tr = document.createElement('tr');
        tr.dataset.i = i;
        tr.draggable = true;

        const tdGrip = document.createElement('td');
        tdGrip.className = 'mono dnd-handle';
        tdGrip.title = 'Drag to reorder';
        tdGrip.textContent = '☰';

        const tdId = document.createElement('td');
        tdId.className = 'mono';
        tdId.textContent = f.id;

        const tdLabel = document.createElement('td');
        tdLabel.textContent = f.label || '';

        const tdType = document.createElement('td');
        tdType.className = 'mono';
        tdType.textContent = f.type;

        const tdDet = document.createElement('td');
        tdDet.className = 'muted';
        tdDet.textContent = fieldDetails(f);

        tr.appendChild(tdGrip);
        tr.appendChild(tdId);
        tr.appendChild(tdLabel);
        tr.appendChild(tdType);
        tr.appendChild(tdDet);

        // click to edit
        tr.addEventListener('click', (ev) => {
          if (tr.classList.contains('dragging')) return;
          selectRow(i);
          loadFieldIntoEditor(f, i);
        });

        // DnD handlers
        tr.addEventListener('dragstart', (e) => {
          tr.classList.add('dragging');
          e.dataTransfer.effectAllowed = 'move';
          e.dataTransfer.setData('text/plain', String(i));
        });
        tr.addEventListener('dragend', () => {
          tr.classList.remove('dragging');
          clearDropHints();
        });
        tr.addEventListener('dragover', (e) => {
          e.preventDefault();
          const dragIndex = Number(getDataTransferIndex(e));
          if (Number.isNaN(dragIndex)) return;
          showDropHint(tr, e);
        });
        tr.addEventListener('drop', (e) => {
          e.preventDefault();
          const from = Number(e.dataTransfer.getData('text/plain') || -1);
          if (Number.isNaN(from) || from < 0) return clearDropHints();
          const to = indexFromDrop(e, tr);
          if (to < 0) return clearDropHints();
          reorderFields(from, to);
          clearDropHints();
        });

        tb.appendChild(tr);
      });
      els.fieldCount.textContent = `${FORM_BUILDER.schema.fields.length} fields`;
      highlightSelectedRow();
    }

    function getDataTransferIndex(e) {
      const v = e.dataTransfer?.getData('text/plain');
      return v != null ? Number(v) : NaN;
    }
    function indexFromRow(tr) {
      return Number(tr?.dataset?.i ?? -1);
    }
    function indexFromDrop(e, tr) {
      const rect = tr.getBoundingClientRect();
      const mid = rect.top + rect.height / 2;
      const overIdx = indexFromRow(tr);
      return (e.clientY < mid) ? overIdx : overIdx + 1;
    }
    function clearDropHints() {
      Array.from(els.tbodyFields.querySelectorAll('tr')).forEach(r => {
        r.classList.remove('drop-target-above','drop-target-below');
      });
    }
    function showDropHint(tr, e) {
      clearDropHints();
      const rect = tr.getBoundingClientRect();
      const mid = rect.top + rect.height / 2;
      if (e.clientY < mid) tr.classList.add('drop-target-above');
      else tr.classList.add('drop-target-below');
    }
    function reorderFields(from, to) {
      const list = FORM_BUILDER.schema.fields;
      const target = Math.max(0, Math.min(to, list.length));
      if (from === target || from+1 === target) return;

      const [moved] = list.splice(from, 1);
      const insertAt = (target > from) ? target - 1 : target;
      list.splice(insertAt, 0, moved);

      FORM_BUILDER.selectedIndex = -1;
      els.btnDelete.disabled = true;
      els.btnCancel.disabled = true;
      clearEditor();

      renderFields();
      mirror(true);
      setStatus('Reordered', true);
    }

    function selectRow(i) {
      FORM_BUILDER.selectedIndex = i;
      highlightSelectedRow();
      els.btnDelete.disabled = false;
      els.btnCancel.disabled = false;
    }
    function highlightSelectedRow() {
      Array.from(els.tbodyFields.querySelectorAll('tr')).forEach(r => r.classList.remove('is-active'));
      const i = FORM_BUILDER.selectedIndex;
      if (i >= 0) {
        const row = els.tbodyFields.querySelector(`tr[data-i="${i}"]`);
        if (row) row.classList.add('is-active');
      }
    }

    function loadFieldIntoEditor(f, i) {
      els.pType.value = f.type;
      els.pId.value = f.id;
      els.pLabel.value = f.label || '';
      els.pRequired.checked = !!f.required;
      renderTypeSpecific();

      if (f.type === 'select' || f.type === 'multichoice') {
        document.getElementById('pOptions').value = (f.options||[]).join(', ');
      } else if (f.type === 'date') {
        document.getElementById('pDateFmt').value = f.dateFormat || 'Y-m-d';
      } else if (f.type === 'table') {
        const colsLegacy = (f.columns||[]).map(c => {
          const base = `${c.id}:${c.label}${c.type && c.type!=='text' ? `:${c.type}`:''}`;
          if (c.type === 'select' && c.options?.length) return `${base}:${c.options.join('/')}`;
          return base;
        });
        document.getElementById('pCols').value = colsLegacy.join(', ');
        document.getElementById('pMinRows').value = f.minRows || 0;
        document.getElementById('pMaxRows').value = f.maxRows || 0;
        if (window.TableDesigner) {
          window.TableDesigner.loadColumns(Array.isArray(f.columns) ? f.columns : []);
          window.TableDesigner.setMinMax(f.minRows || 0, f.maxRows || 0);
        }
      }
    }

    // ---------- Parse, Save, Delete, Cancel ----------
    function parseFieldFromInputs() {
      const t  = els.pType.value;
      const id = (els.pId.value || '').trim();
      if (!id) { alert('Please enter a field id'); return null; }
      const f = { type: t, id, label: els.pLabel.value || id, required: !!els.pRequired.checked };

      if (t === 'select' || t === 'multichoice') {
        const raw = (document.getElementById('pOptions')?.value || '').trim();
        f.options = raw ? raw.split(',').map(s => s.trim()).filter(Boolean) : [];

      } else if (t === 'date') {
        f.dateFormat = (document.getElementById('pDateFmt')?.value || 'Y-m-d').trim();

      } else if (t === 'table') {
        const mr = parseInt(document.getElementById('pMinRows')?.value||'0',10);
        const xr = parseInt(document.getElementById('pMaxRows')?.value||'0',10);

        if (window.TableDesigner) {
          const cols = window.TableDesigner.getColumns();
          f.columns = cols;
        } else {
          const raw = (document.getElementById('pCols')?.value || '').trim();
          f.columns = raw ? raw.split(',').map(s => s.trim()).filter(Boolean).map(seg => {
            const [cid, label, ctype, opts] = seg.split(':');
            const col = { id: (cid||'col').trim(), label: (label||cid||'col').trim() };
            if (ctype) col.type = ctype.trim();
            if (col.type === 'select' && opts) col.options = opts.split('/').map(s=>s.trim()).filter(Boolean);
            return col;
          }) : [];
        }
        if (mr>0) f.minRows = mr;
        if (xr>0) f.maxRows = xr;
      }
      return f;
    }

    async function upsertField() {
      const f = parseFieldFromInputs();
      if (!f) return;

      const i = FORM_BUILDER.selectedIndex;
      const isUpdate = i >= 0;

      let oldId = null;
      if (isUpdate) {
        oldId = FORM_BUILDER.schema.fields[i].id;
        // Uniqueness check (allow same index to keep its id)
        if (f.id !== oldId && FORM_BUILDER.schema.fields.some(x => x.id === f.id)) {
          alert('Field id must be unique.');
          return;
        }
        FORM_BUILDER.schema.fields[i] = f;
        setStatus('Field updated', true);
      } else {
        if (FORM_BUILDER.schema.fields.some(x => x.id === f.id)) {
          alert('Field id must be unique.');
          return;
        }
        FORM_BUILDER.schema.fields.push(f);
        setStatus('Field added', true);
      }

      clearEditor();
      renderFields();

      // Single save path with migrate (if rename) and prune
      await mirror(true, { renamedFrom: oldId, renamedTo: isUpdate ? f.id : null });
    }

    async function deleteSelected() {
      const i = FORM_BUILDER.selectedIndex;
      if (i < 0) return;

      FORM_BUILDER.schema.fields.splice(i, 1);
      clearEditor();
      renderFields();

      // mirror() will prune values/tagMap/rules for removed fields
      await mirror(true);
    }


    function clearEditor() {
      FORM_BUILDER.selectedIndex = -1;
      els.btnDelete.disabled = true;
      els.btnCancel.disabled = true;

      // Reset inputs
      els.pType.value = 'text';
      els.pId.value = '';
      els.pLabel.value = '';
      els.pRequired.checked = false;
      renderTypeSpecific();
      highlightSelectedRow();
    }

    function cancelEditing() {
      clearEditor();
      setStatus('Edit canceled', true);
    }

    function renderAll({ persist = true } = {}) {
      renderFields();
      els.fieldCount.textContent = `${FORM_BUILDER.schema.fields.length} fields`;
      if (persist) saveLS(FORM_BUILDER.schema);
    }

    // ---------- Persistence ----------
    async function mirror(notify, opts = {}) {
      if (els.formTitle.value && FORM_BUILDER.schema) {
        FORM_BUILDER.schema.title = els.formTitle.value;
      }
      const nowIso = new Date().toISOString();

      // Always keep a local backup copy of the schema
      saveLS(FORM_BUILDER.schema);

      if (!currentDoc?.docId) {
        // No active doc → schema only (values/rules live in per-doc workspaces)
        broadcastSchemaUpdated(null);
        if (notify) setStatus('Saved locally.', 1);
        return;
      }

      // If we renamed a field, migrate state first (values/tagMap/rules)
      let migrated = null;
      if (opts?.renamedFrom && opts?.renamedTo && opts.renamedFrom !== opts.renamedTo) {
        migrated = await migrateWorkspaceOnFieldRename(currentDoc.docId, opts.renamedFrom, opts.renamedTo);
      }

      // Then prune everything against the new schema
      const pruned = await pruneWorkspaceOnSchemaChange(currentDoc.docId, FORM_BUILDER.getSchema());

      // Prefer migrated (if present), then prune again to be safe (order matters)
      const valuesToSave = (migrated?.values) ? migrated.values : pruned.values;
      const tagMapToSave = (migrated?.tagMap) ? migrated.tagMap : pruned.tagMap;
      const rulesToSave  = (migrated?.rules)  ? migrated.rules  : pruned.rules;

      await window.formSuitePersist.saveState(currentDoc.docId, {
        schema: FORM_BUILDER.getSchema(),
        values: valuesToSave || {},
        tagMap: tagMapToSave || {},
        rules:  rulesToSave  || [],
        schemaUpdatedAt: nowIso
      });

      broadcastSchemaUpdated(currentDoc.docId);
      if (notify) setStatus('Saved.', 1);
    }



    (async function boot(){
      try {
        currentDoc = readActiveDocSync();

        if (currentDoc?.docId) {
          const st = await window.formSuitePersist.loadState?.(currentDoc.docId);
          if (st?.schema) {
            FORM_BUILDER.schema = st.schema;
            els.formTitle.value = st.schema.title || '';
          } else {
            FORM_BUILDER.schema = { title: 'Untitled form', fields: [] };
            els.formTitle.value = '';
          }
          els.docStatus.textContent = `DOCX: ${currentDoc.name || currentDoc.docTitle || currentDoc.docId}`;
          els.docStatus.classList.remove('muted');
        } else {
          const ls = loadLS();
          if (ls) { FORM_BUILDER.schema = ls; els.formTitle.value = ls.title || ''; }
          els.docStatus.textContent = 'No DOCX active.';
          els.docStatus.classList.add('muted');
        }

        renderAll({ persist:false });

        // keep title mirrored
        els.formTitle.addEventListener('change', () => mirror(true));

        // Focus/visibility refresh uses unified guard
        document.addEventListener('visibilitychange', async () => {
          if (document.visibilityState === 'visible') await ensureActiveOrReset();
        });
        window.addEventListener('focus', async () => { await ensureActiveOrReset(); });

        window.addEventListener('beforeunload', () => {
          try { if (!currentDoc?.docId) saveLS(FORM_BUILDER.schema); } catch {}
        });

        // Ensure type-specific UI is visible on load
        renderTypeSpecific();
      } catch (e) {
        console.warn('Builder boot failed', e);
      }
    })();


    // ---------- Wire-up ----------
    els.pType.addEventListener('change', renderTypeSpecific);
    els.btnAdd.addEventListener('click', upsertField);
    els.btnDelete.addEventListener('click', deleteSelected);
    els.btnCancel.addEventListener('click', cancelEditing);
    els.formTitle.addEventListener('input', () => mirror(false));

    // Triple-click logo: focus mode + go to index, toggle header links
    (function() {
      const logo = document.querySelector('header .logo');
      const header = document.querySelector('header .row');
      if (!logo || !header) return;

      let clickCount = 0;
      let clickTimer = null;
      let focusMode = false;

      logo.addEventListener('click', () => {
        clickCount++;
        clearTimeout(clickTimer);
        clickTimer = setTimeout(() => { clickCount = 0; }, 600);

        if (clickCount === 3) {
          clickCount = 0;
          focusMode = !focusMode;

          if (focusMode) {
            header.querySelectorAll('a, span.muted').forEach(el => {
              if (!el.closest('.brand')) el.style.display = 'none';
            });
            if (!location.pathname.endsWith('index.html')) {
              location.href = 'index.html';
            }
          } else {
            header.querySelectorAll('a, span.muted').forEach(el => { el.style.display = ''; });
          }
        }
      });
    })();
  </script>
</body>
</html>
