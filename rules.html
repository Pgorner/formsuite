<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Form Suite — Rules</title>
  <link rel="icon" href="favicon.ico" type="image/gif" sizes="32x32">
  <link rel="shortcut icon" href="favicon.ico" type="image/gif">
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="style.css">
  <script src="persistence.js"></script>
</head>
<body class="rules">
<header>
  <div class="row">
    <span class="brand logo-md">
      <img src="logo.gif" alt="Form Suite logo" class="logo" />
      <strong>Form Suite</strong>
    </span>
    <span class="muted">·</span><a href="index.html">Form</a>
    <span class="muted">·</span><a href="builder.html">Form Builder</a>
    <span class="muted">·</span><a href="matcher.html">Tag Matcher</a>
    <span class="muted">·</span><span class="muted">Rules</span>
    <span class="muted">·</span><a href="extractor.html">Extractor</a>
  </div>
</header>

<main>
  <section class="panel">
    <div class="row" style="justify-content:space-between; align-items:center">
      <h2 style="margin:0">Rules</h2>
      <div id="rulesTabs" class="row" style="margin-left:8px; gap:6px;">
        <button id="tabHeadings" class="btn btn-ghost" aria-pressed="true">Headings</button>
        <button id="tabFields" class="btn btn-ghost" aria-pressed="false">Fields</button>
      </div>
      <div class="row">
        <span id="status" class="muted" style="margin-right:10px"></span>
        <button id="btnAddRule" class="btn btn-primary">Add rule</button>
      </div>
    </div>
    <div class="muted-note" id="rulesHint" style="margin-top:6px">
      SHOW or HIDE specific headings/subheaders based on a field’s selected value(s).
    </div>
  </section>

  <section class="panel" id="editorMount">
    <div class="empty">No rules yet — click “Add rule”.</div>
  </section>

  <section class="panel">
    <h3 style="margin-top:0">Existing rules</h3>
    <div id="rulesList" class="rules-list">
      <div class="empty">None.</div>
    </div>
  </section>
</main>

<script>
  // ===== Debug framework =====
  const DEBUG = {
    seq: 0,
    on:  true,     // master switch
    deep: true,    // include verbose validation/build logs
    tables: true   // use console.table where helpful
  };
  const _t = () => new Date().toISOString().slice(11,23);
  const tag = name => "%c[Rules "+_t()+" #"+(++DEBUG.seq)+"] "+name;
  const tagStyle = "color:#6b7280;font-weight:600";
  function TRACE(name, details){
    if (!DEBUG.on) {
      // Return a no-op tracer
      return { step(){}, warn(){}, error(){}, end(){} };
    }
    const label = name+" :: "+_t()+" :: #"+(DEBUG.seq+1);
    console.groupCollapsed(tag(name), tagStyle, details || "");
    console.time(label);
    return {
      step:(m,d)=>console.log(tag("  -> "+m),tagStyle,d||""),
      warn:(m,d)=>console.warn(tag("  ! "+m),tagStyle,d||""),
      error:(m,e)=>console.error(tag("  x "+m),tagStyle,e),
      end:(x)=>{ if(x) console.log(tag("done"),tagStyle,x); console.timeEnd(label); console.groupEnd(); }
    };
  }

  // Quick helpers available in DevTools
  window.RulesDebug = {
    dump(){
      console.log("[RulesDump] docId:", gDocId, "mode:", gMode);
      console.log("[RulesDump] schema fields:", (gSchema?.fields||[]).length);
      console.log("[RulesDump] headingsTree nodes:", (gHeadingsTree||[]).length);
      if (DEBUG.tables) {
        console.table((gSchema?.fields||[]).map(f=>({id:f.id,label:f.label,type:f.type,options:(f.options||[]).length})));
      }
      console.log("[RulesDump] rules (view):", gRules.length, gRules);
      if (DEBUG.tables) console.table(gRules);
      console.log("[RulesDump] rulesHeadings:", gRulesHeadings.length);
      console.log("[RulesDump] rulesFields:", gRulesFields.length);
    },
    validateAll(){
      const tr = TRACE("validateAll");
      let ok=0, bad=0;
      for (const r of gRules){
        const v = isRuleValid(r, gSchema, gHeadingsTree, gMode);
        v ? ok++ : bad++;
        if (!v) console.warn("[Invalid Rule]", r);
      }
      tr.end({ ok, bad });
    },
    simulatePersist(){
      const tr=TRACE("simulatePersist");
      const s = sanitizeRules(gRules, gMode);
      tr.step("sanitize summary", s);
      tr.end();
    }
  };

  // ===== constants & state =====
  const ACTIVE_LS_KEY= "FS_ACTIVE_DOC_META";
  const statusEl   = document.getElementById("status");
  const btnAddRule = document.getElementById("btnAddRule");
  const editorMount= document.getElementById("editorMount");
  const rulesList  = document.getElementById("rulesList");
  const tabHeadings= document.getElementById("tabHeadings");
  const tabFields  = document.getElementById("tabFields");
  const rulesHint  = (document.getElementById("rulesHint") || document.querySelector("section.panel .muted-note"));

  const bcLegacy = ("BroadcastChannel" in window) ? new BroadcastChannel("form-suite-doc") : null;
  const bcCanon  = ("BroadcastChannel" in window) ? new BroadcastChannel("fs-active-doc") : null;

  let gDocId   = null;
  let gSchema  = { title:"Form", fields:[] };
  let gHeadingsTree = [];
  let gMode    = 'headings'; // 'headings' | 'fields'
  let gRules   = []; // current view rules
  let gRulesHeadings = [];
  let gRulesFields   = [];
  let gEditingId = null; // editing existing rule id
  let gDraft   = null;   // unsaved draft rule
  let gPersistTail = Promise.resolve();

  function cloneRulesArray(rules){
    if (!Array.isArray(rules)) return [];
    if (typeof structuredClone === 'function'){
      try { return structuredClone(rules); }
      catch (_) { /* fall back */ }
    }
    return JSON.parse(JSON.stringify(rules));
  }

  const ACTIONS = new Set(["SHOW","HIDE"]);
  const CHOICE_TYPES = new Set(["select","multichoice","radio","dropdown","singlechoice","choice","single","options","combobox","list"]);

  function setStatus(t){ if (statusEl) statusEl.textContent = t; }

  // ===== ensure persistence (shim) =====
  (function ensurePersist(){
    if (window.formSuitePersist) return;
    let _meta=null, _state={};
    window.formSuitePersist = {
      getCurrentDocMeta(){ return _meta; },
      setCurrentDocFromBytes: async (_b,meta)=>{ _meta={docId:"inline-"+Date.now(), name:(meta&&meta.name)||"document"}; return _meta; },
      loadState: async (_)=>_state,
      saveState: async (_,obj)=>{ _state = Object.assign({}, _state, obj||{}); }
    };
  })();

  // ===== helpers =====
  function readActiveMeta(){
    try { const v = localStorage.getItem(ACTIVE_LS_KEY); return v ? JSON.parse(v) : null; }
    catch { return null; }
  }

  function getChoiceFields(schema){
    const t = TRACE("getChoiceFields", { fields: (schema?.fields||[]).length });
    const list = (schema?.fields||[]).filter(f => CHOICE_TYPES.has(String(f.type||"").toLowerCase()));
    t.end({ choiceFields: list.length });
    return list;
  }

  function slugify(s){
    return String(s||"")
      .normalize('NFKD')
      .replace(/[\u0300-\u036f]/g, '')
      .replace(/[^a-zA-Z0-9]+/g, '_')
      .replace(/^_+|_+$/g, '')
      .toLowerCase();
  }

  // Build condition sources: includes normal fields and boolean pseudo-fields for each multichoice option
  // Returns items: { id, label, type, options? }
  function buildConditionSources(schema){
    const tr = DEBUG.deep ? TRACE("buildConditionSources.start", { fields:(schema?.fields||[]).length }) : { step(){}, end(){} };
    const out = [];
    const seen = new Set();
    for (const f of (schema?.fields||[])){
      const t = String(f.type||'').toLowerCase();
      if (t === 'multichoice'){
        const items = [];
        if (Array.isArray(f.options)) items.push(...f.options);
        if (f.mc && Array.isArray(f.mc.groups)){
          for (const g of f.mc.groups){ (g.items||[]).forEach(it => items.push(it)); }
        }
        items.forEach(it => {
          const rawVal = it && typeof it === 'object' ? (it.value ?? it.label ?? it.text ?? it.name ?? '') : it;
          const rawLbl = it && typeof it === 'object' ? (it.label ?? it.text ?? it.name ?? rawVal) : rawVal;
          const valStr = String(rawVal || '').trim();
          const lblStr = String(rawLbl || '').trim();
          const slug = slugify(valStr);
          if (!valStr || !slug) return;
          const id = `${f.id}__opt__${slug}`;
          if (seen.has(id)) return;
          seen.add(id);
          out.push({ id, label: `${f.label||f.id}: ${lblStr}`, type: 'boolean' });
        });
      } else if (t === 'date') {
        const id = String(f.id); if (!seen.has(id)) { seen.add(id); out.push({ id, label: f.label||f.id, type: 'date' }); }
      } else if (t === 'select' || t === 'dropdown' || t === 'singlechoice' || t === 'choice' || t === 'single' || t === 'combobox' || t === 'list'){
        const id = String(f.id);
        if (!seen.has(id)) {
          seen.add(id);
          const options = (f.options||[]).map(o => (o && typeof o === 'object') ? String(o.value ?? o.label ?? o) : String(o));
          out.push({ id, label: f.label||f.id, type: 'select', options });
        }
      } else if (t === 'text') {
        const id = String(f.id); if (!seen.has(id)) { seen.add(id); out.push({ id, label: f.label||f.id, type: 'text' }); }
      } else if (t === 'number') {
        const id = String(f.id); if (!seen.has(id)) { seen.add(id); out.push({ id, label: f.label||f.id, type: 'number' }); }
      }
    }
    if (DEBUG.tables) {
      console.log("[buildConditionSources] result=", out.length);
      try { console.table(out); } catch {}
    }
    tr.end({ sources: out.length });
    return out;
  }

  function normOptions(field){
    const raw = field && field.options || [];
    return raw.map(o => {
      if (o && typeof o === "object") {
        const value = (o.value ?? o.id ?? o.key ?? o.code ?? String(o));
        const label = (o.label ?? o.text ?? o.name ?? String(value));
        return { value:String(value), label:String(label) };
      }
      return { value:String(o), label:String(o) };
    });
  }

  function flattenWithNumbers(tree){
    const tr = DEBUG.deep ? TRACE("flattenWithNumbers", { nodes: (tree||[]).length }) : { end(){} };
    const out=[], counters=[];
    function walk(nodes, depth){
      counters[depth]=0;
      for (const n of (nodes||[])){
        counters[depth]++;
        const number = counters.slice(0, depth+1).join(".");
        const label = (n.label?.trim?.() ? n.label : n.text) || "";
        out.push({ key:String(n.idx ?? (number+"|"+label)), label:number+" "+label, level:n.level || (depth+1) });
        if (n.children?.length) walk(n.children, depth+1);
      }
    }
    walk(tree||[],0);
    if (DEBUG.tables) try { console.table(out); } catch {}
    tr.end({ flat: out.length });
    return out;
  }

  // ===== validation that tolerates missing context =====
  function isRuleValid(rule, schema = gSchema, headingsTree = gHeadingsTree, mode = gMode){
    const tr = DEBUG.deep ? TRACE("isRuleValid", { mode, action: rule?.action, fieldId: rule?.fieldId }) : { step(){}, end(){} };
    if (!rule || !ACTIONS.has(rule.action)) { tr.end("fail: action"); return false; }

    const haveSchema = Array.isArray(schema?.fields) && schema.fields.length > 0;
    const haveHeads  = Array.isArray(headingsTree) && headingsTree.length > 0;

    if (!haveSchema) {
      const ok = !!(rule.fieldId && rule.op && Array.isArray(rule.values));
      tr.end(ok ? "ok: no schema yet" : "fail: shape");
      return ok;
    }

    const sources = buildConditionSources(schema);
    const src = sources.find(s => String(s.id) === String(rule.fieldId));
    if (!src) { tr.end("fail: no source"); return false; }

    const allowedOps = (src.type==='boolean') ? ['equals']
                    : (src.type==='date')    ? ['before','after','equals']
                    : (src.type==='text')    ? ['equals','notEquals','contains']
                    : (src.type==='number')  ? ['equals','notEquals']
                    : (src.type==='select')  ? ['equals','notEquals']
                    : [];
    if (!allowedOps.includes(rule.op)) { tr.end("fail: op not allowed"); return false; }

    if (!Array.isArray(rule.values)) { tr.end("fail: values not array"); return false; }
    if (src.type==='boolean') {
      if (rule.values.length!==1) { tr.end("fail: boolean len"); return false; }
      const v = rule.values[0];
      if (!(v === true || v === false || v === 'true' || v === 'false')) { tr.end("fail: boolean val"); return false; }
    } else if (src.type==='date') {
      if (rule.values.length!==1 || !String(rule.values[0])) { tr.end("fail: date val"); return false; }
    } else if (src.type==='text') {
      if (rule.values.length!==1) { tr.end("fail: text len"); return false; }
    } else if (src.type==='number') {
      if (rule.values.length!==1 || isNaN(Number(rule.values[0]))) { tr.end("fail: number val"); return false; }
    } else if (src.type==='select') {
      if (rule.values.length!==1) { tr.end("fail: select len"); return false; }
      const opts = new Set((src.options||[]).map(String));
      if (!opts.has(String(rule.values[0]))) { tr.end("fail: select not in options"); return false; }
    }

    if (mode === 'headings') {
      if (!haveHeads) { tr.end("ok: no headings yet"); return true; }
      const allowedHeads = new Set(flattenWithNumbers(headingsTree).map(h=>String(h.key)));
      const ok = Array.isArray(rule.targets) && rule.targets.length>0 && rule.targets.every(t => allowedHeads.has(String(t.key)));
      tr.end(ok ? "ok" : "fail: targets(headings)");
      return ok;
    } else {
      const allowedTargetIds = new Set(buildConditionSources(schema).map(s=>String(s.id)));
      const ok = Array.isArray(rule.targets) && rule.targets.length>0 && rule.targets.every(t => allowedTargetIds.has(String(t.id)));
      tr.end(ok ? "ok" : "fail: targets(fields)");
      return ok;
    }
  }

  function cloneRules(rules){
    const src = Array.isArray(rules) ? rules : [];
    if (typeof structuredClone === 'function') {
      try { return structuredClone(src); } catch {}
    }
    return JSON.parse(JSON.stringify(src));
  }

  function sanitizeRules(rules = gRules, mode = gMode){
    const tr = TRACE("sanitizeRules", { inCount: (rules||[]).length, mode });
    const working = cloneRules(rules);
    const haveSchema = Array.isArray(gSchema?.fields) && gSchema.fields.length > 0;
    const haveHeads  = (mode === 'fields') || (Array.isArray(gHeadingsTree) && gHeadingsTree.length > 0);

    if (!haveSchema) {
      tr.end("blocked: no schema");
      return { rules: working, removed: 0, status: 'Saved (awaiting schema).', blocked: true };
    }
    if (mode==='headings' && !haveHeads) {
      tr.end("blocked: no headings");
      return { rules: working, removed: 0, status: 'Saved (awaiting headings).', blocked: true };
    }

    const filtered = working.filter(r => isRuleValid(r, gSchema, gHeadingsTree, mode));
    const removed = working.length - filtered.length;
    const status = removed>0 ? `Removed ${removed} invalid rule${removed>1?'s':''}.` : null;
    if (DEBUG.tables) try { console.table(filtered); } catch {}
    tr.end({ outCount: filtered.length, removed, status, blocked: false });
    return { rules: filtered, removed, status, blocked: false };
  }

  // ===== persistence =====
  async function persistRules(reasonOrOptions, _maybeOptions){
    if (!gDocId) {
      console.warn("[persistRules] skipped — no docId");
      return;
    }

    // Serialize writes to avoid races with cross-tab reloads
    gPersistTail = gPersistTail.then(async () => {
      const tr = TRACE('persistRules', { docId: gDocId, mode: gMode, count: gRules.length, reason: reasonOrOptions });
      try {
        const before = { headings: gRulesHeadings.length, fields: gRulesFields.length };

        // Sanitize ONLY current view so we don’t clobber the other tab’s rules
        const san = sanitizeRules(gRules, gMode);
        tr.step('sanitize summary', san);

        const nextHeadings = (gMode === 'headings') ? san.rules.slice() : gRulesHeadings.slice();
        const nextFields   = (gMode === 'fields')   ? san.rules.slice() : gRulesFields.slice();

        // Commit to memory
        gRulesHeadings = nextHeadings;
        gRulesFields   = nextFields;

        tr.step('normalized rules', { before, after: { headings: gRulesHeadings.length, fields: gRulesFields.length } });

        // Load existing state so we can merge payload (keep title/fields/values/tagMap/etc.)
        let existingPayload = {};
        try {
          const st = await window.formSuitePersist?.loadState?.(gDocId);
          // Be defensive: accept any of the known slots
          existingPayload = (st?.payload?.CRONOS_PAYLOAD)
                        || (st?.CRONOS_PAYLOAD)
                        || (st?.cronos_payload)
                        || {};
          tr.step('payload loaded', { hadExisting: !!Object.keys(existingPayload||{}).length });
        } catch (e) {
          tr.warn('payload load failed', e);
        }

        const canonical = {
          ...(existingPayload || {}),
          rules: gRulesHeadings,
          fieldRules: gRulesFields,
          updatedAt: new Date().toISOString()
        };

        const saveInput = {
          // Keep explicit arrays for older tabs that rely on these
          rules: gRulesHeadings,
          fieldRules: gRulesFields,

          // Mirror across all common payload slots so every page can find them
          payload: { CRONOS_PAYLOAD: canonical },
          CRONOS_PAYLOAD: canonical,
          cronos_payload: canonical
        };

        if (DEBUG.tables) {
          console.log("[persistRules] saveInput.rules:");      try{ console.table(saveInput.rules);}catch{}
          console.log("[persistRules] saveInput.fieldRules:"); try{ console.table(saveInput.fieldRules);}catch{}
        }

        await window.formSuitePersist?.saveState?.(gDocId, saveInput);

        // Broadcast so other tabs refresh immediately
        try { bcCanon?.postMessage({ type: 'active:updated', docId: gDocId, ts: Date.now(), from:'rules' }); } catch {}
        try { bcLegacy?.postMessage({ type: 'doc-updated',    docId: gDocId, ts: Date.now(), from:'rules' }); } catch {}

        setStatus(`Rules saved — ${san.rules.length}${san.status ? " · "+san.status : ""}`);
        tr.end('saved');
      } catch (e) {
        tr.error('persist failed', e);
        setStatus('Save failed');
        tr.end();
      }
    });

    // Wait for this write chain before returning (important on tab-switch)
    try { await gPersistTail; } catch {}
  }

  // ===== editor (single) =====
  function currentEditorRule(){
    if (gDraft) return gDraft;
    if (gEditingId) return gRules.find(r=>r.id===gEditingId) || null;
    return null;
  }

  function renderEditor(){
    const tr = TRACE("renderEditor", { draft: !!gDraft, editingId: gEditingId, mode: gMode });
    try{
      editorMount.innerHTML = "";
      const rule = currentEditorRule();
      if (!rule){
        editorMount.innerHTML = '<div class="empty">No rules yet — click “Add rule”.</div>';
        tr.end("no rule");
        return;
      }

      const fields = getChoiceFields(gSchema);
      const allHeadings = flattenWithNumbers(gHeadingsTree);
      const isDraft = !!gDraft;

      if (DEBUG.tables) {
        console.log("[renderEditor] fields (choice):"); try{ console.table(fields);}catch{}
        console.log("[renderEditor] headings (flat):"); try{ console.table(allHeadings);}catch{}
      }

      const card = document.createElement("div");
      card.className = "rule-card";
      card.dataset.id = rule.id || "draft";

      // Row 0: Save/Cancel (for draft)
      if (isDraft){
        const top = document.createElement("div"); top.className="row"; top.style.justifyContent="flex-end"; top.style.gap="8px";
        const btnCancel = document.createElement("button"); btnCancel.className="btn btn-ghost"; btnCancel.textContent="Cancel";
        btnCancel.addEventListener("click", ()=>{ console.log("[Editor] Cancel draft"); gDraft=null; renderEditor(); });
        const btnSave = document.createElement("button"); btnSave.className="btn btn-primary"; btnSave.textContent="Save rule"; btnSave.disabled = !isRuleValid(rule, gSchema, gHeadingsTree, gMode);
        btnSave.addEventListener("click", ()=>{
          console.log("[Editor] Save draft click", rule);
          if (!isRuleValid(rule, gSchema, gHeadingsTree, gMode)){ alert("Please complete the rule."); return; }
          rule.id = "r_"+Math.random().toString(36).slice(2,8);
          gRules.push(rule);
          gDraft=null;
          persistRules('create'); renderEditor(); renderList();
        });
        const updateSaveState = ()=> { btnSave.disabled = !isRuleValid(currentEditorRule(), gSchema, gHeadingsTree, gMode); };
        card.dataset._updateSaveState = "1";
        card.appendChild(top);
        top.appendChild(btnCancel);
        top.appendChild(btnSave);
        card._updateSave = updateSaveState;
      }

      // Row 1: Action + Field
      const row1 = document.createElement("div"); row1.className="rule-row";

      // Action
      const pAction = document.createElement("div"); pAction.className="pair";
      const lblA = document.createElement("label"); lblA.textContent="Action";
      const selA = document.createElement("select");
      const defAct = document.createElement("option"); defAct.value=""; defAct.textContent="Select…";
      if (isDraft && !rule.action) selA.appendChild(defAct);
      ["SHOW","HIDE"].forEach(a => {
        const o=document.createElement("option"); o.value=a; o.textContent=a; if(rule.action===a) o.selected=true; selA.appendChild(o);
      });
      selA.addEventListener("change", () => {
        rule.action = selA.value || null;
        console.log("[Editor] action changed:", rule.action);
        if (!isDraft){ persistRules("change:action"); renderList(); }
        card._updateSave?.();
      });
      pAction.appendChild(lblA); pAction.appendChild(selA);

      // Effect selector when HIDE on Fields tab
      const pEffect = document.createElement('div'); pEffect.className = 'pair';
      const lblE = document.createElement('label'); lblE.textContent = 'Effect';
      const selE = document.createElement('select');
      const addOpt = (v,t) => { const o=document.createElement('option'); o.value=v; o.textContent=t; if((rule.hideMode||'hide')===v) o.selected=true; selE.appendChild(o); };
      addOpt('hide','hide (remove)'); addOpt('disable','disable (greyed)');
      selE.addEventListener('change', ()=>{ rule.hideMode = selE.value || 'hide'; console.log("[Editor] hideMode changed:", rule.hideMode); if(!isDraft){ persistRules("change:hideMode"); renderList(); } });

      row1.appendChild(pAction);
      if (gMode==='fields') { pEffect.appendChild(lblE); pEffect.appendChild(selE); row1.appendChild(pEffect); }

      // When source
      const pField = document.createElement("div"); pField.className="pair";
      const lblF = document.createElement("label"); lblF.textContent="When";
      const selF = document.createElement("select");
      const defF = document.createElement("option"); defF.value=""; defF.textContent="Select source…";
      if (isDraft && !rule.fieldId) selF.appendChild(defF);
      const __sources = buildConditionSources(gSchema);
      if (!__sources.length){
        const o=document.createElement("option"); o.value=""; o.textContent="(no fields)"; selF.appendChild(o);
      } else {
        __sources.forEach(s=>{
          const o=document.createElement("option");
          o.value=s.id; o.textContent=s.label; if(String(rule.fieldId)===String(s.id)) o.selected=true; selF.appendChild(o);
        });
      }
      selF.addEventListener("change", () => {
        rule.fieldId = selF.value || "";
        console.log("[Editor] fieldId changed:", rule.fieldId);
        if (!rule.fieldId){ rule.values=[]; rule.op=null; }
        else {
          const src = __sources.find(x=>String(x.id)===String(rule.fieldId));
          if (src){
            if (src.type==='boolean') { rule.op='equals'; rule.values=[true]; }
            else if (src.type==='date') { rule.op='equals'; rule.values=['']; }
            else if (src.type==='text') { rule.op='equals'; rule.values=['']; }
            else if (src.type==='number') { rule.op='equals'; rule.values=[0]; }
            else if (src.type==='select') { rule.op='equals'; rule.values=['']; }
          } else { rule.op=null; rule.values=[]; }
        }
        if (!isDraft){ persistRules("change:fieldId"); renderEditor(); renderList(); }
        else { renderEditor(); }
      });
      pField.appendChild(lblF); pField.appendChild(selF);
      row1.appendChild(pField);

      card.appendChild(row1);

      // Row 2: Condition (only when a source is chosen)
      const chosenSource = buildConditionSources(gSchema).find(s=>String(s.id)===String(rule.fieldId));
      if (chosenSource){
        const row2 = document.createElement("div"); row2.className="rule-row";
        const pCond = document.createElement("div"); pCond.className="pair";
        const lblC = document.createElement("label"); lblC.textContent="Condition";
        pCond.appendChild(lblC);

        const src = chosenSource;
        if (!Array.isArray(rule.values)) rule.values = [];
        if (src?.type !== 'boolean'){
          const opSel = document.createElement('select');
          const ops = (src?.type==='date') ? [{v:'before',l:'before'},{v:'equals',l:'equals'},{v:'after',l:'after'}]
                    : (src?.type==='text') ? [{v:'equals',l:'equals'},{v:'notEquals',l:'not equals'},{v:'contains',l:'contains'}]
                    : [{v:'equals',l:'equals'},{v:'notEquals',l:'not equals'}];
          ops.forEach(({v,l})=>{ const o=document.createElement('option'); o.value=v; o.textContent=l; if(rule.op===v) o.selected=true; opSel.appendChild(o); });
          opSel.addEventListener('change', ()=>{ rule.op = opSel.value; console.log("[Editor] op changed:", rule.op); if(!isDraft){ persistRules("change:op"); renderList(); } card._updateSave?.(); });
          pCond.appendChild(opSel);
        } else {
          const spanIs = document.createElement('span'); spanIs.className='muted'; spanIs.textContent='is'; pCond.appendChild(spanIs);
          rule.op = 'equals';
        }

        if (src?.type==='boolean'){
          const sel = document.createElement('select');
          ;[{v:true,l:'true'},{v:false,l:'false'}].forEach(({v,l})=>{ const o=document.createElement('option'); o.value=String(v); o.textContent=l; if(String(rule.values?.[0])===String(v)) o.selected=true; sel.appendChild(o); });
          sel.addEventListener('change', ()=>{ rule.values=[sel.value==='true']; console.log("[Editor] value changed (boolean):", rule.values[0]); if(!isDraft){ persistRules("change:value"); renderList(); } card._updateSave?.(); });
          pCond.appendChild(sel);
        } else if (src?.type==='date'){
          const inp = document.createElement('input'); inp.type='text'; inp.placeholder='YYYY-MM-DD'; inp.style.minWidth='140px';
          inp.value = String(rule.values?.[0]||'');
          setTimeout(()=>{ try{ flatpickr(inp,{ allowInput:true, dateFormat:'Y-m-d', onChange:()=>{ rule.values=[inp.value]; console.log("[Editor] value changed (date via FP):", rule.values[0]); if(!isDraft){ persistRules("change:value"); renderList(); } card._updateSave?.(); } }); }catch{} },0);
          inp.addEventListener('change', ()=>{ rule.values=[inp.value]; console.log("[Editor] value changed (date):", rule.values[0]); if(!isDraft){ persistRules("change:value"); renderList(); } card._updateSave?.(); });
          pCond.appendChild(inp);
        } else if (src?.type==='text'){
          const inp = document.createElement('input'); inp.type='text'; inp.value=String(rule.values?.[0]||'');
          inp.addEventListener('change', ()=>{ rule.values=[inp.value]; console.log("[Editor] value changed (text):", rule.values[0]); if(!isDraft){ persistRules("change:value"); renderList(); } card._updateSave?.(); });
          pCond.appendChild(inp);
        } else if (src?.type==='number'){
          const inp = document.createElement('input'); inp.type='number'; inp.value=String(rule.values?.[0]??'');
          inp.addEventListener('change', ()=>{ const v=inp.value; rule.values=[v===''? '': Number(v)]; console.log("[Editor] value changed (number):", rule.values[0]); if(!isDraft){ persistRules("change:value"); renderList(); } card._updateSave?.(); });
          pCond.appendChild(inp);
        } else if (src?.type==='select'){
          const sel = document.createElement('select');
          const def=document.createElement('option'); def.value=''; def.textContent='Select value…'; sel.appendChild(def);
          const base = (gSchema.fields||[]).find(ff => String(ff.id)===String(src.id));
          const opts = base ? normOptions(base) : (src.options||[]).map(x=>({value:String(x),label:String(x)}));
          opts.forEach(opt=>{ const o=document.createElement('option'); o.value=String(opt.value); o.textContent=String(opt.label); if(String(rule.values?.[0])===String(opt.value)) o.selected=true; sel.appendChild(o); });
          sel.addEventListener('change', ()=>{ rule.values = sel.value ? [sel.value] : ['']; console.log("[Editor] value changed (select):", rule.values[0]); if(!isDraft){ persistRules("change:value"); renderList(); } card._updateSave?.(); });
          pCond.appendChild(sel);
        }

        row2.appendChild(pCond);
        card.appendChild(row2);
      }

      // Row 3: Targets selector (Headings or Fields)
      if (gMode === 'headings') {
        const flatHeads = flattenWithNumbers(gHeadingsTree);
        if (flatHeads.length){
          const row3 = document.createElement("div"); row3.className="rule-row";
          const pHead = document.createElement("div"); pHead.className="pair";
          const lblH = document.createElement("label"); lblH.textContent="Add heading";
          const chosenKeys = new Set((rule.targets||[]).map(t=>t.key));
          const remainingHeads = flatHeads.filter(h => !chosenKeys.has(h.key));
          const selH = document.createElement("select");
          const defH = document.createElement("option"); defH.value=""; defH.textContent="Select…"; selH.appendChild(defH);
          remainingHeads.forEach(h=>{ const o=document.createElement("option"); o.value=h.key; o.textContent=h.label; selH.appendChild(o); });
          selH.addEventListener("change", ()=>{
            const key = selH.value; if (!key) return;
            const h = flatHeads.find(x=>x.key===key);
            if (!h) return;
            rule.targets = rule.targets || [];
            rule.targets.push({ key:h.key, label:h.label });
            console.log("[Editor] +heading target:", h);
            if (!isDraft) { persistRules("change:addHeading"); }
            renderEditor(); renderList();
          });
          pHead.appendChild(lblH); pHead.appendChild(selH);
          row3.appendChild(pHead);
          card.appendChild(row3);
        }
      } else {
        const sourcesT = buildConditionSources(gSchema);
        if (sourcesT.length){
          const row3 = document.createElement("div"); row3.className="rule-row";
          const pFld = document.createElement("div"); pFld.className="pair";
          const lblF = document.createElement("label"); lblF.textContent="Add field";
          const chosenIds = new Set((rule.targets||[]).map(t=>String(t.id)));
          const selF = document.createElement("select");
          const defF = document.createElement("option"); defF.value=""; defF.textContent="Select…"; selF.appendChild(defF);
          sourcesT.forEach(s=>{ if (!chosenIds.has(String(s.id))) { const o=document.createElement("option"); o.value=s.id; o.textContent=s.label; selF.appendChild(o); } });
          selF.addEventListener("change", ()=>{
            const id = selF.value; if (!id) return;
            const s = sourcesT.find(x=>String(x.id)===String(id));
            if (!s) return;
            rule.targets = rule.targets || [];
            rule.targets.push({ id:s.id, label:s.label });
            console.log("[Editor] +field target:", s);
            persistRules("change:addField"); renderEditor(); renderList();
          });
          pFld.appendChild(lblF); pFld.appendChild(selF);
          row3.appendChild(pFld);
          card.appendChild(row3);
        }
      }

      // Row 4: Selected target pills
      const row4 = document.createElement("div"); row4.className="rule-row";
      const lblSel = document.createElement("div"); lblSel.className="muted"; lblSel.textContent = (gMode==='headings' ? "Selected headings:" : "Selected fields:");
      const hpills = document.createElement("div"); hpills.className="pills";
      (rule.targets||[]).forEach(t=>{
        const pill = document.createElement("span"); pill.className="pill"; pill.title=(gMode==='headings' ? t.key : t.id);
        const txt = document.createElement("span"); txt.textContent=t.label;
        const x = document.createElement("button"); x.setAttribute("aria-label","Remove"); x.textContent="×";
        x.addEventListener("click", ()=>{
          console.log("[Editor] −remove target:", t);
          if (gMode==='headings') rule.targets = (rule.targets||[]).filter(z=>z.key!==t.key);
          else rule.targets = (rule.targets||[]).filter(z=>String(z.id)!==String(t.id));
          persistRules("change:removeTarget"); renderEditor(); renderList();
        });
        pill.appendChild(txt); pill.appendChild(x);
        hpills.appendChild(pill);
      });
      if (!hpills.children.length){
        const none=document.createElement("span"); none.className="empty"; none.textContent="(none)";
        hpills.appendChild(none);
      }
      row4.appendChild(lblSel); row4.appendChild(hpills);
      card.appendChild(row4);

      editorMount.appendChild(card);

      if (isDraft) card._updateSave?.();
      tr.end("rendered");
    } catch(e){ tr.error("renderEditor error", e); tr.end(); }
  }

  // ===== list =====
  function summarizeCondition(rule){
    const sources = buildConditionSources(gSchema);
    const src = sources.find(s=>String(s.id)===String(rule.fieldId));
    if (!src) return 'when (missing source)';
    const op = rule.op || 'equals';
    const v0 = Array.isArray(rule.values) ? rule.values[0] : rule.values;
    if (src.type === 'boolean') {
      return `when ${src.label} ${op} ${String(v0)}`;
    }
    if (src.type === 'date') {
      return `when ${src.label} ${op} ${String(v0||'')}`;
    }
    if (src.type === 'text' || src.type === 'number') {
      return `when ${src.label} ${op} "${String(v0||'')}"`;
    }
    if (src.type === 'select') {
      const base = (gSchema.fields||[]).find(ff => String(ff.id)===String(src.id));
      const options = base ? normOptions(base) : (src.options||[]).map(x=>({value:String(x),label:String(x)}));
      const label = options.find(o=>String(o.value)===String(v0))?.label ?? String(v0||'');
      return `when ${src.label} ${op} "${label}"`;
    }
    return `when ${src.label} ${op}`;
  }

  function renderList(){
    const tr = TRACE("renderList", { mode: gMode, count: gRules.length });
    try{
      rulesList.innerHTML = "";
      if (!gRules.length){
        rulesList.innerHTML = '<div class="empty">None.</div>';
        tr.end("empty");
        return;
      }
      if (DEBUG.tables) try{ console.table(gRules);}catch{}

      gRules.forEach(r=>{
        const div=document.createElement("div"); div.className="item";
        const left=document.createElement("div");
        const targets = (r.targets||[]).map(t=>t.label).join(", ") || (gMode==='headings' ? "(no headings selected)" : "(no fields selected)");
        left.innerHTML = `<strong>${r.action}</strong> — <em>${targets}</em> <span class="muted"> ${summarizeCondition(r)}</span>`;
        const right=document.createElement("div"); right.style.display='flex'; right.style.gap='8px';

        const edit=document.createElement("button"); edit.className="btn btn-ghost"; edit.textContent="Edit";
        edit.addEventListener("click", ()=>{
          console.log("[List] Edit clicked:", r.id);
          gDraft = null;
          gEditingId = r.id;
          renderEditor();
          editorMount.scrollIntoView({behavior:"smooth", block:"start"});
        });

        const del=document.createElement("button"); del.className="btn btn-danger"; del.textContent="Delete";
        del.addEventListener("click", ()=>{
          console.log("[List] Delete clicked:", r.id);
          if (!confirm("Delete this rule?")) return;
          const idx = gRules.findIndex(x=>x.id===r.id);
          if (idx >= 0) gRules.splice(idx,1);
          if (gEditingId === r.id) gEditingId = null;
          persistRules('delete'); renderEditor(); renderList();
        });

        right.appendChild(edit);
        right.appendChild(del);
        div.appendChild(left); div.appendChild(right);
        rulesList.appendChild(div);
      });
      tr.end("rendered");
    } catch(e){ tr.error("renderList error", e); tr.end(); }
  }

  // ===== reloadState (defensive hydrate across all payload slots) =====
  async function reloadState(reason){
    const tr = TRACE("reloadState",{reason, docId:gDocId});
    try {
      if (!gDocId) { tr.end("no docId"); return; }

      const st = await window.formSuitePersist?.loadState?.(gDocId);
      if (!st) { tr.end("no state"); return; }

      // Update schema & headings if present
      if (st.schema) gSchema = st.schema;
      if (Array.isArray(st.headingsTree)) gHeadingsTree = st.headingsTree;

      if (DEBUG.tables) {
        console.log("[reloadState] schema fields:"); try{ console.table(gSchema?.fields||[]);}catch{}
        console.log("[reloadState] headingsTree (flat):"); try{ console.table(flattenWithNumbers(gHeadingsTree)); }catch{}
      }

      // Workspace arrays (preferred if non-empty)
      const wsHeadings = Array.isArray(st.rules) ? st.rules : [];
      const wsFields   = Array.isArray(st.fieldRules) ? st.fieldRules : [];

      // Payload variants (mirror-friendly)
      const plNested  = st?.payload?.CRONOS_PAYLOAD;
      const plTop     = st?.CRONOS_PAYLOAD;
      const plAlt     = st?.cronos_payload;

      const plHeadings = Array.isArray(plNested?.rules)   ? plNested.rules
                      : Array.isArray(plTop?.rules)      ? plTop.rules
                      : Array.isArray(plAlt?.rules)      ? plAlt.rules : [];

      const plFields   = Array.isArray(plNested?.fieldRules) ? plNested.fieldRules
                      : Array.isArray(plTop?.fieldRules)    ? plTop.fieldRules
                      : Array.isArray(plAlt?.fieldRules)    ? plAlt.fieldRules : [];

      // Pick sources: workspace wins; else payload; else keep in-memory as last resort
      const nextHeadings = wsHeadings.length ? wsHeadings
                          : (plHeadings.length ? plHeadings : gRulesHeadings);

      const nextFields   = wsFields.length ? wsFields
                          : (plFields.length ? plFields : gRulesFields);

      // Commit
      gRulesHeadings = cloneRules(nextHeadings);
      gRulesFields   = cloneRules(nextFields);
      gRules = (gMode==='headings') ? gRulesHeadings.slice() : gRulesFields.slice();

      // Editor safety
      if (!gRules.find(r=>r?.id===gEditingId)) gEditingId = null;

      // Logs for visibility
      tr.step("hydrate chosen", {
        wsHeadings: wsHeadings.length, wsFields: wsFields.length,
        plHeadings: plHeadings.length, plFields: plFields.length,
        intoView: gRules.length, mode: gMode
      });

      setStatus(`Loaded — fields: ${(gSchema.fields||[]).length}, headings: ${(gHeadingsTree||[]).length}, ${gMode==='headings'?'heading-rules':'field-rules'}: ${gRules.length}`);

      if (DEBUG.tables) {
        console.log("[reloadState] gRulesHeadings"); try{ console.table(gRulesHeadings);}catch{}
        console.log("[reloadState] gRulesFields");   try{ console.table(gRulesFields);}catch{}
      }

      renderEditor(); renderList();
      tr.end("ok");
    } catch(e){ tr.error("failed", e); tr.end(); }
  }

  function hookSync(){
    const tr = TRACE("hookSync");
    bcLegacy?.addEventListener("message",(ev)=>{
      const m = ev?.data || {};
      console.log("[BC:legacy]", m);
      if (m.type==="schema-updated"   && m.docId===gDocId) reloadState("schema-updated");
      if (m.type==="headings-updated" && m.docId===gDocId) reloadState("headings-updated");
      if (m.type==="doc-updated"      && m.docId===gDocId) reloadState("doc-updated");
      if (m.type==="doc-switched"     && m.docId && m.docId!==gDocId){ gDocId=m.docId; reloadState("doc-switched"); }
      if (m.type==="doc-cleared"){ gDocId=null; setStatus("Cleared."); editorMount.innerHTML='<div class="empty">No rules yet — click “Add rule”.</div>'; rulesList.innerHTML='<div class="empty">None.</div>'; }
    });
    bcCanon?.addEventListener("message",(ev)=>{
      const m = ev?.data || {};
      console.log("[BC:canon]", m);
      if (m.type==="active:set"){ if (m.docId && m.docId!==gDocId){ gDocId=m.docId; reloadState("active:set"); } }
      if (m.type==="active:updated"){ if (m.docId===gDocId) reloadState("active:updated"); }
      if (m.type==="active:clear"){ gDocId=null; setStatus("Cleared."); }
    });
    window.addEventListener("storage",(e)=>{
      if (e.key===ACTIVE_LS_KEY && e.newValue){
        const meta = JSON.parse(e.newValue||"null");
        console.log("[storage] ACTIVE_LS_KEY changed:", meta);
        if (meta?.docId && meta.docId!==gDocId){ gDocId=meta.docId; reloadState("storage switch"); }
      }
    });
    tr.end("listeners attached");
  }

  // ===== add rule (draft only; not persisted) =====
  btnAddRule.addEventListener("click", ()=>{
    console.log("[UI] Add rule clicked");
    gEditingId = null;
    gDraft = {
      id: null,
      action: null,
      fieldId: "",
      op: null,
      values: [],
      targets: []
    };
    renderEditor();
    editorMount.scrollIntoView({behavior:"smooth", block:"start"});
  });

  // ===== tabs =====
  function applyTabUI(){
    const tr = TRACE("applyTabUI", { mode: gMode });
    const isHead = gMode==='headings';
    if (tabHeadings) {
      tabHeadings.setAttribute('aria-pressed', String(isHead));
      tabHeadings.className = 'btn ' + (isHead ? 'btn-secondary' : 'btn-ghost');
    }
    if (tabFields) {
      tabFields.setAttribute('aria-pressed', String(!isHead));
      tabFields.className   = 'btn ' + (!isHead ? 'btn-secondary' : 'btn-ghost');
    }
    if (rulesHint) {
      rulesHint.textContent = isHead
        ? 'SHOW or HIDE specific headings/subheaders based on a field’s selected value(s).'
        : 'SHOW or HIDE specific form fields based on another field’s selected value(s).';
    }
    tr.end("ok");
  }
  tabHeadings?.addEventListener('click', async ()=>{
    if (gMode==='headings') return;
    console.log("[Tabs] -> headings");
    await persistRules('tab-switch', { mode: gMode, rules: gRules });
    gMode='headings';
    gDraft = null; gEditingId = null;
    gRules = gRulesHeadings.slice();
    applyTabUI();
    await reloadState('tab:headings');
  });
  tabFields?.addEventListener('click', async ()=>{
    if (gMode==='fields') return;
    console.log("[Tabs] -> fields");
    await persistRules('tab-switch', { mode: gMode, rules: gRules });
    gMode='fields';
    gDraft = null; gEditingId = null;
    gRules = gRulesFields.slice();
    applyTabUI();
    await reloadState('tab:fields');
  });

  // ===== boot =====
  (async function boot(){
    const tr = TRACE("boot");
    try{
      hookSync();
      let meta = window.formSuitePersist?.getCurrentDocMeta?.() || readActiveMeta();
      if (!meta?.docId){ setStatus("No active document. Open one first."); tr.end("no active doc"); return; }
      gDocId = meta.docId;
      tr.step("active doc", meta);
      applyTabUI();
      await reloadState("boot");
    } catch(e){ tr.error("boot failed", e); setStatus("Failed to load state."); }
    finally{ tr.end(); }
  })();
</script>
</body>
</html>
