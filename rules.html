<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Form Suite — Rules</title>
  <link rel="icon" href="favicon.ico" type="image/gif" sizes="32x32">
  <link rel="shortcut icon" href="favicon.ico" type="image/gif">
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/themes/material_blue.css">
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <link rel="stylesheet" href="style.css">
  <script src="persistence.js"></script>
</head>
<body class="rules">
<header>
  <div class="row">
    <span class="brand logo-md">
      <img src="logo.gif" alt="Form Suite logo" class="logo" />
      <strong>Form Suite</strong>
    </span>
    <span class="muted">·</span><a href="index.html">Form</a>
    <span class="muted">·</span><a href="builder.html">Form Builder</a>
    <span class="muted">·</span><a href="matcher.html">Tag Matcher</a>
    <span class="muted">·</span><span class="muted">Rules</span>
    <span class="muted">·</span><a href="extractor.html">Extractor</a>
  </div>
</header>

<main>
  <section class="panel">
    <div class="row" style="justify-content:space-between; align-items:center">
      <h2 style="margin:0">Rules</h2>
      <div id="rulesTabs" class="row" style="margin-left:8px; gap:6px;">
        <button id="tabHeadings" class="btn btn-secondary" aria-pressed="true">Headings</button>
        <button id="tabFields" class="btn btn-ghost" aria-pressed="false">Fields</button>
      </div>
      <div class="row">
        <span id="status" class="muted" style="margin-right:10px"></span>
        <button id="btnAddRule" class="btn btn-primary">Add rule</button>
      </div>
    </div>
    <div class="muted-note" id="rulesHint" style="margin-top:6px">
      SHOW or HIDE specific headings/subheaders or form fields based on a field’s value(s).
    </div>
  </section>

  <section class="panel" id="editorMount">
    <div class="empty">No rules yet — click “Add rule”.</div>
  </section>

  <section class="panel">
    <h3 style="margin-top:0">Existing rules</h3>
    <div id="rulesList" class="rules-list">
      <div class="empty">None.</div>
    </div>
  </section>
</main>

<script>
/* ------------------------------------------------------------------ *
 * Bulletproof Rules editor
 *  - Authoritative store: state.rules / state.fieldRules
 *  - Mirrors into payload.CRONOS_PAYLOAD / CRONOS_PAYLOAD / cronos_payload
 *  - Broadcasts 'rules-updated' (both channels) + bumps LS stamp
 *  - Logs read-back verification after each persist
 *  - F9 dumps quick diagnostics
 * ------------------------------------------------------------------ */

const nowt = () => new Date().toISOString().slice(11,23);
const ACTIVE_LS_KEY= "FS_ACTIVE_DOC_META";

const els = {
  status: document.getElementById("status"),
  btnAddRule: document.getElementById("btnAddRule"),
  editorMount: document.getElementById("editorMount"),
  rulesList: document.getElementById("rulesList"),
  tabHeadings: document.getElementById("tabHeadings"),
  tabFields: document.getElementById("tabFields"),
  rulesHint: document.getElementById("rulesHint"),
};

const bcCanon   = ("BroadcastChannel" in window) ? new BroadcastChannel("fs-active-doc")   : null;
const bcLegacy  = ("BroadcastChannel" in window) ? new BroadcastChannel("form-suite-doc")  : null;

// ---- DEBUG: pretty payload logger ----
async function debugLogPayload(where) {
  try {
    const st = await window.formSuitePersist.loadState(gDocId) || {};
    const payload = st?.payload?.CRONOS_PAYLOAD || st?.CRONOS_PAYLOAD || st?.cronos_payload || {};
    const wsRules      = Array.isArray(st.rules) ? st.rules : [];
    const wsFieldRules = Array.isArray(st.fieldRules) ? st.fieldRules : [];

    console.groupCollapsed(`[rules][${where}] docId=${gDocId}`);
    console.log('workspace.rules        (%d):', wsRules.length, wsRules);
    console.log('workspace.fieldRules   (%d):', wsFieldRules.length, wsFieldRules);
    console.log('workspace.rulesVersion :', st.rulesVersion);
    console.log('payload.rules          (%d):', Array.isArray(payload.rules) ? payload.rules.length : 0, payload.rules || []);
    console.log('payload.fieldRules     (%d):', Array.isArray(payload.fieldRules) ? payload.fieldRules.length : 0, payload.fieldRules || []);
    console.log('payload.rulesVersion   :', payload.rulesVersion);
    console.log('payload.updatedAt      :', payload.updatedAt);
    try {
      const lsScoped = localStorage.getItem(`CRONOS_PAYLOAD:${gDocId}`);
      const lsParsed = lsScoped ? JSON.parse(lsScoped) : null;
      console.log('localStorage(scoped)   :', !!lsScoped, lsParsed?.rules?.length ?? 0, lsParsed?.fieldRules?.length ?? 0, lsParsed?.rulesVersion ?? null);
    } catch (e) {
      console.warn('localStorage parse fail:', e);
    }
    console.groupEnd();
  } catch (e) {
    console.error('[rules][debugLogPayload] failed', e);
  }
}


// app state
let gDocId   = null;
let gSchema  = { title:"Form", fields:[] };
let gHeadingsTree = [];
let gMode    = 'headings'; // 'headings' | 'fields'
let gRulesHeadings = [];   // persisted
let gRulesFields   = [];   // persisted
let gRules   = [];         // current list in view
let gEditingId = null;     // current editor
let gDraft   = null;

// UI helpers
const setStatus = (s) => { try { els.status.textContent = s || ""; } catch {} };
const slugify = (s)=> String(s||"").normalize('NFKD').replace(/[\u0300-\u036f]/g,'').replace(/[^a-zA-Z0-9]+/g,'_').replace(/^_+|_+$/g,'').toLowerCase();
const ACTIONS = new Set(["SHOW","HIDE"]);
const debounce = (fn, ms)=>{ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a), ms); }; };

// schema/headings helpers
function normOptions(field){
  const raw = field && field.options || [];
  return raw.map(o => {
    if (o && typeof o === "object") {
      const value = (o.value ?? o.id ?? o.key ?? o.code ?? String(o));
      const label = (o.label ?? o.text ?? o.name ?? String(value));
      return { value:String(value), label:String(label) };
    }
    return { value:String(o), label:String(o) };
  });
}
function getFieldLabelById(id){
  const f = (gSchema.fields||[]).find(x => String(x.id)===String(id));
  return f?.label || f?.name || f?.id || String(id);
}
function flattenWithNumbers(tree){
  const out=[], counters=[];
  function walk(nodes, depth){
    counters[depth]=0;
    for (const n of (nodes||[])){
      counters[depth]++;
      const number = counters.slice(0, depth+1).join(".");
      const label = (n.label?.trim?.() ? n.label : n.text) || "";
      out.push({
        key: String(n.idx ?? number),
        label: number + " " + label,
        titleOnly: label,
        number,
        level: n.level || (depth+1)
      });
      if (n.children?.length) walk(n.children, depth+1);
    }
  }
  walk(tree||[],0);
  return out;
}
function toCompositeKeyFromFlat(h){
  if (!h) return '';
  const raw = String(h.key ?? '');
  if (raw.includes('|')) return raw;
  return `${h.number}|${h.titleOnly || ''}`.trim();
}
function getHeadingLabelFromKey(key){
  if (!key) return '';
  if (key.includes('|')) return key.split('|').slice(1).join('|');
  const flat = flattenWithNumbers(gHeadingsTree);
  const hit = flat.find(h => h.number === key);
  return hit?.titleOnly || key;
}

// target normalization
function normalizeHeadingsRuleTargetsInPlace(rule){
  if (!rule || !Array.isArray(rule.targets)) return {changed:false};
  const flat = flattenWithNumbers(gHeadingsTree);
  const byNumber = new Map(); const byComp=new Map();
  flat.forEach(h=>{ const comp=toCompositeKeyFromFlat(h); byNumber.set(h.number,comp); byComp.set(comp,h.label);});
  let changed=false;
  rule.targets = rule.targets.map(t=>{
    let compKey='';
    if (typeof t === 'string'){ compKey = t.includes('|')? t : (byNumber.get(t)||t); }
    else if (t && typeof t==='object'){ const k=String(t.key||''); compKey = k? (k.includes('|')? k : (byNumber.get(k)||k)) : ''; }
    if (!compKey) return t;
    const label = byComp.get(compKey) || compKey.split('|').slice(1).join('|') || compKey;
    const normalized = { key:compKey, label };
    if (typeof t==='string' || !t.label || String(t.key)!==compKey) changed=true;
    return normalized;
  });
  return {changed};
}
function normalizeFieldTargetsInPlace(rule){
  if (!rule || !Array.isArray(rule.targets)) return {changed:false};
  const lbl = new Map((gSchema.fields||[]).map(f=>[String(f.id), f.label||f.name||f.id]));
  let changed=false;
  rule.targets = rule.targets.map(t=>{
    if (typeof t==='string'){ changed=true; return { id:t, label: lbl.get(String(t)) || String(t)}; }
    if (t && typeof t==='object'){
      const id=String(t.id||''); const want = lbl.get(id);
      if (id && (!t.label || t.label!==want)){ changed=true; return { id, label: want || (t.label||id)}; }
      return t;
    }
    return t;
  });
  return {changed};
}
function normalizeAllTargets(){
  let cH=0, cF=0;
  (gRulesHeadings||[]).forEach(r=>{ if (normalizeHeadingsRuleTargetsInPlace(r).changed) cH++; });
  (gRulesFields||[]).forEach(r=>{ if (normalizeFieldTargetsInPlace(r).changed) cF++; });
  if (cH) console.log(`[${nowt()}] normalized ${cH} heading rule(s)`);
  if (cF) console.log(`[${nowt()}] normalized ${cF} field rule(s)`);
}

// condition sources + validation
function buildConditionSources(schema){
  const out=[]; const seen=new Set();
  for (const f of (schema?.fields||[])){
    const t=String(f.type||'').toLowerCase(); const id=String(f.id); const label=f.label||f.id;
    if (t==='boolean'||t==='checkbox'||t==='switch'){ if(!seen.has(id)){ seen.add(id); out.push({id,label,type:'boolean'});} continue; }
    if (t==='multichoice'){
      if(!seen.has(id)){ seen.add(id); out.push({id,label,type:'boolean',meta:{anySelected:true}}); }
      const items=[]; if (Array.isArray(f.options)) items.push(...f.options);
      if (f.mc?.groups) (f.mc.groups||[]).forEach(g=> (g.items||[]).forEach(it=>items.push(it)));
      items.forEach(it=>{
        const rawV = it && typeof it==='object' ? (it.value ?? it.label ?? it.text ?? it.name ?? '') : it;
        const rawL = it && typeof it==='object' ? (it.label ?? it.text ?? it.name ?? rawV) : rawV;
        const v=String(rawV||'').trim(); const l=String(rawL||'').trim(); const slug=slugify(v);
        if (!v||!slug) return; const optId = `${id}__opt__${slug}`; if (seen.has(optId)) return;
        seen.add(optId); out.push({id:optId, label:`${label}: ${l}`, type:'boolean'});
      });
      continue;
    }
    if (t==='date'){ if(!seen.has(id)){ seen.add(id); out.push({id,label,type:'date'});} continue; }
    if (t==='datediff'||t==='duration'||t==='number'){ if(!seen.has(id)){ seen.add(id); out.push({id,label,type:'number'});} continue; }
    if (t==='select'||t==='dropdown'||t==='singlechoice'||t==='choice'||t==='single'||t==='combobox'||t==='list'){
      if(!seen.has(id)){ seen.add(id); out.push({id,label,type:'select', options:(f.options||[]).map(o=> (o&&typeof o==='object')? String(o.value??o.label??o) : String(o))});}
      continue;
    }
    if (t==='text'||t==='string'||t==='textarea'){ if(!seen.has(id)){ seen.add(id); out.push({id,label,type:'text'});} continue; }
    if(!seen.has(id)){ seen.add(id); out.push({id,label,type:'text'}); }
  }
  return out;
}
function isRuleValid(rule){
  if (!rule || !ACTIONS.has(rule.action)) return false;
  const srcs = buildConditionSources(gSchema);
  const src = srcs.find(s=>String(s.id)===String(rule.fieldId));
  if (!src) return false;
  const allowed = (src.type==='boolean')?['equals']
                : (src.type==='date')?['before','equals','after']
                : (src.type==='text')?['equals','notEquals','contains']
                : (src.type==='number')?['equals','notEquals']
                : (src.type==='select')?['equals','notEquals']
                : ['equals'];
  if (!allowed.includes(rule.op)) return false;
  if (!Array.isArray(rule.values)) return false;
  if (!Array.isArray(rule.targets) || rule.targets.length===0) return false;
  return true;
}

// ----------------------------- PERSISTENCE ------------------------------
// hard-write to workspace + mirror to payload, mirror to localStorage, verify, broadcast
async function persistRules(reason) {
  if (!gDocId) return;

  // Normalize targets before writing (keeps labels in sync)
  normalizeAllTargets();

  // Snapshot arrays (de-ref any reactive objects)
  const rules      = (gRulesHeadings || []).map(x => JSON.parse(JSON.stringify(x)));
  const fieldRules = (gRulesFields   || []).map(x => JSON.parse(JSON.stringify(x)));
  const stamp = Date.now();

  console.log(`[${nowt()}] WRITE (${reason}) rules=${rules.length}, fieldRules=${fieldRules.length}`);

  // --- Build a canonical payload object by patching whatever exists ----
  const st0 = await window.formSuitePersist.loadState(gDocId) || {};
  const basePayload =
      (st0?.payload?.CRONOS_PAYLOAD)
   || (st0?.CRONOS_PAYLOAD)
   || (st0?.cronos_payload)
   || {};

  const canonical = {
    ...basePayload,
    rules,
    fieldRules,
    rulesVersion: stamp,
    updatedAt: new Date(stamp).toISOString()
  };

  // ---- Preferred path: setState (if available) ----
  try {
    if (window.formSuitePersist?.setState) {
      await window.formSuitePersist.setState(gDocId, {
        rules, fieldRules, rulesVersion: stamp,
        payload:        { CRONOS_PAYLOAD: canonical },
        CRONOS_PAYLOAD:  canonical,
        cronos_payload:  canonical
      });
    } else {
      await window.formSuitePersist.saveState(gDocId, {
        rules, fieldRules, rulesVersion: stamp,
        payload:        { ...(st0.payload || {}), CRONOS_PAYLOAD: canonical },
        CRONOS_PAYLOAD:  canonical,
        cronos_payload:  canonical
      });
    }
  } catch (e) {
    console.error('[rules] persistRules: write failed', e);
    throw e;
  }

  // ---- Mirror to localStorage (plain + scoped) + bump a stamp ----
  try {
    localStorage.setItem('CRONOS_PAYLOAD', JSON.stringify(canonical));
    localStorage.setItem(`CRONOS_PAYLOAD:${gDocId}`, JSON.stringify(canonical));
    localStorage.setItem(`FS_RULES_STAMP:${gDocId}`, String(stamp));
  } catch (e) {
    console.warn('[rules] localStorage mirror failed', e);
  }

  // ---- Read-back verification (counts + stamp) ----
  try {
    const st1 = await window.formSuitePersist.loadState(gDocId) || {};
    const p1  = st1?.payload?.CRONOS_PAYLOAD || st1?.CRONOS_PAYLOAD || st1?.cronos_payload || {};
    const ok  = Array.isArray(st1.rules) && Array.isArray(st1.fieldRules)
             && JSON.stringify(p1.rules||[]) === JSON.stringify(rules)
             && JSON.stringify(p1.fieldRules||[]) === JSON.stringify(fieldRules)
             && (p1.rulesVersion === stamp || st1.rulesVersion === stamp);

    console.log(
      `[${nowt()}] VERIFY after persist → ` +
      `workspace: r=${(st1.rules||[]).length}/${rules.length}, fr=${(st1.fieldRules||[]).length}/${fieldRules.length}; ` +
      `payload: r=${(p1.rules||[]).length}/${rules.length}, fr=${(p1.fieldRules||[]).length}/${fieldRules.length}; ` +
      `stamp=${stamp} ok=${ok}`
    );
  } catch (e) {
    console.warn('[rules] read-back verification failed', e);
  }

  // ---- Broadcast everywhere ----
  try { bcCanon?.postMessage({  type: 'rules-updated',  docId: gDocId, ts: stamp, from: 'rules.html' }); } catch {}
  try { bcLegacy?.postMessage({ type: 'rules-updated',  docId: gDocId, ts: stamp, from: 'rules.html' }); } catch {}
  try { bcCanon?.postMessage({  type: 'active:updated', docId: gDocId, ts: stamp, from: 'rules.html' }); } catch {}
  try { bcLegacy?.postMessage({ type: 'doc-updated',    docId: gDocId, ts: stamp, from: 'rules.html' }); } catch {}

  console.log(`[${nowt()}] AFTER persist → workspace + all payload mirrors + LS updated; broadcast sent`);
  await debugLogPayload(`persist:${reason}`);
}

// ------------------------------- RENDERING ------------------------------
function summarizeCondition(rule){
  const srcs = buildConditionSources(gSchema);
  let src = srcs.find(s=>String(s.id)===String(rule.fieldId));
  const srcLabel = src?.label || getFieldLabelById(rule.fieldId) || String(rule.fieldId);
  const op = rule.op || 'equals';
  const v0 = Array.isArray(rule.values) ? rule.values[0] : rule.values;

  if (!src) return `when ${srcLabel} ${op} ${JSON.stringify(v0)}`;
  if (src.type==='boolean') return `when ${srcLabel} ${op} ${String(v0)}`;
  if (src.type==='date')    return `when ${srcLabel} ${op} ${String(v0||'')}`;
  if (src.type==='text')    return `when ${srcLabel} ${op} "${String(v0||'')}"`;
  if (src.type==='number')  return `when ${srcLabel} ${op} ${String(v0)}`;
  if (src.type==='select') {
    const base = (gSchema.fields||[]).find(ff => String(ff.id)===String(src.id));
    const options = base ? normOptions(base) : (src.options||[]).map(x=>({value:String(x),label:String(x)}));
    const label = options.find(o=>String(o.value)===String(v0))?.label ?? String(v0||'');
    return `when ${srcLabel} ${op} "${label}"`;
  }
  return `when ${srcLabel} ${op}`;
}

function renderList(){
  els.rulesList.innerHTML = "";
  const list = gRules || [];
  if (!list.length){ els.rulesList.innerHTML = '<div class="empty">None.</div>'; return; }

  list.forEach(r=>{
    const row = document.createElement('div'); row.className='item';
    const left = document.createElement('div');

    const labels = (gMode==='headings')
      ? (r.targets||[]).map(t=> (typeof t==='object' && t.label) ? t.label : getHeadingLabelFromKey(String((typeof t==='string')? t : (t.key||''))) ).filter(Boolean)
      : (r.targets||[]).map(t=> (typeof t==='object' && t.label) ? t.label : getFieldLabelById(String((typeof t==='string')? t : (t.id||'')))).filter(Boolean);

    left.innerHTML = `<strong>${r.action}</strong> — <em>${labels.join(', ') || '(no targets selected)'}</em> <span class="muted">${summarizeCondition(r)}</span>`;

    const right = document.createElement('div'); right.style.display='flex'; right.style.gap='8px';

    const edit = document.createElement('button'); edit.className='btn btn-ghost'; edit.textContent='Edit';
    edit.addEventListener('click', ()=>{ gDraft=null; gEditingId=r.id; renderEditor(); });

    const del = document.createElement('button'); del.className='btn btn-danger'; del.textContent='Delete';
    del.addEventListener('click', async ()=>{
      if (!confirm('Delete this rule?')) return;
      const arr = (gMode==='headings') ? gRulesHeadings : gRulesFields;
      const idx = arr.findIndex(x=>x.id===r.id);
      if (idx>=0) arr.splice(idx,1);
      if (gMode==='headings') gRules = gRulesHeadings.slice(); else gRules = gRulesFields.slice();
      if (gEditingId === r.id) gEditingId = null;
      console.log(`[${nowt()}] DELETE id=${r.id}`);
      await persistRules('delete');
      renderEditor(); renderList();
    });

    right.appendChild(edit); right.appendChild(del);
    row.appendChild(left); row.appendChild(right);
    els.rulesList.appendChild(row);
  });
}

function currentEditorRule(){ if (gDraft) return gDraft; if (gEditingId) return (gRules||[]).find(r=>r.id===gEditingId) || null; return null; }

function renderEditor(){
  const mount = els.editorMount;
  mount.innerHTML = "";
  const rule = currentEditorRule();
  if (!rule){ mount.innerHTML = '<div class="empty">No rules yet — click “Add rule”.</div>'; return; }

  // Normalize targets for display
  if (gMode==='headings') normalizeHeadingsRuleTargetsInPlace(rule);
  else normalizeFieldTargetsInPlace(rule);

  const card = document.createElement('div'); card.className='rule-card'; card.dataset.id = rule.id || 'draft';

  // Save/Cancel for draft
  if (gDraft){
    const top = document.createElement('div'); top.className='row'; top.style.justifyContent='flex-end'; top.style.gap='8px';
    const btnCancel = document.createElement('button'); btnCancel.className='btn btn-ghost'; btnCancel.textContent='Cancel';
    btnCancel.addEventListener('click', ()=>{ gDraft=null; renderEditor(); });

    const btnSave = document.createElement('button'); btnSave.className='btn btn-primary'; btnSave.textContent='Save rule';
    btnSave.disabled = !isRuleValid(rule);
    btnSave.addEventListener('click', async ()=>{
      if (!isRuleValid(rule)){ alert('Please complete the rule.'); return; }
      rule.id = "r_"+Math.random().toString(36).slice(2,8);
      if (gMode==='headings') gRulesHeadings.push(rule); else gRulesFields.push(rule);
      gDraft=null; gRules = (gMode==='headings')? gRulesHeadings.slice() : gRulesFields.slice();
      console.log(`[${nowt()}] CREATE ${JSON.stringify(rule)}`);
      await persistRules('create');
      renderEditor(); renderList();
    });

    const updateSaveState = ()=> { btnSave.disabled = !isRuleValid(currentEditorRule()); };
    card._updateSave = updateSaveState;

    top.appendChild(btnCancel); top.appendChild(btnSave); card.appendChild(top);
  }

  // Row 1: Action + Effect + When
  const row1 = document.createElement('div'); row1.className='rule-row';

  // Action
  const pAction = document.createElement('div'); pAction.className='pair';
  const lblA = document.createElement('label'); lblA.textContent='Action';
  const selA = document.createElement('select');
  const defAct = document.createElement('option'); defAct.value=''; defAct.textContent='Select…';
  if (gDraft && !rule.action) selA.appendChild(defAct);
  ['SHOW','HIDE'].forEach(a=>{ const o=document.createElement('option'); o.value=a; o.textContent=a; if(rule.action===a) o.selected=true; selA.appendChild(o);});
  selA.addEventListener('change', async ()=>{
    rule.action = selA.value || null;
    if (!gDraft){ await persistRules('change:action'); renderList(); }
    card._updateSave?.();
  });
  pAction.appendChild(lblA); pAction.appendChild(selA);
  row1.appendChild(pAction);

  // Effect (fields only)
  const pEffect = document.createElement('div'); pEffect.className='pair';
  const lblE = document.createElement('label'); lblE.textContent='Effect';
  const selE = document.createElement('select');
  ;[{v:'hide',t:'hide (remove)'},{v:'disable',t:'disable (greyed)'}].forEach(({v,t})=>{
    const o=document.createElement('option'); o.value=v; o.textContent=t; if((rule.hideMode||'hide')===v) o.selected=true; selE.appendChild(o);
  });
  selE.addEventListener('change', async ()=>{
    rule.hideMode = selE.value || 'hide';
    if (!gDraft){ await persistRules('change:hideMode'); renderList(); }
  });
  if (gMode==='fields'){ pEffect.appendChild(lblE); pEffect.appendChild(selE); row1.appendChild(pEffect); }

  // When (source)
  const pField = document.createElement('div'); pField.className='pair';
  const lblF = document.createElement('label'); lblF.textContent='When';
  const selF = document.createElement('select');
  const srcs = buildConditionSources(gSchema);
  const defF = document.createElement('option'); defF.value=''; defF.textContent='Select source…';
  if (gDraft && !rule.fieldId) selF.appendChild(defF);
  if (!srcs.length){ const o=document.createElement('option'); o.value=''; o.textContent='(no fields)'; selF.appendChild(o); }
  else srcs.forEach(s=>{ const o=document.createElement('option'); o.value=s.id; o.textContent=s.label; if(String(rule.fieldId)===String(s.id)) o.selected=true; selF.appendChild(o); });
  selF.addEventListener('change', async ()=>{
    rule.fieldId = selF.value || '';
    if (!rule.fieldId){ rule.op=null; rule.values=[]; }
    else{
      const src = srcs.find(x=>String(x.id)===String(rule.fieldId));
      if (src){
        if (src.type==='boolean'){ rule.op='equals'; rule.values=[true]; }
        else if (src.type==='date'){ rule.op='equals'; rule.values=['']; }
        else if (src.type==='text'){ rule.op='equals'; rule.values=['']; }
        else if (src.type==='number'){ rule.op='equals'; rule.values=[0]; }
        else if (src.type==='select'){ rule.op='equals'; rule.values=['']; }
        else { rule.op='equals'; rule.values=['']; }
      }
    }
    if (!gDraft){ await persistRules('change:fieldId'); renderEditor(); renderList(); }
    else { renderEditor(); }
  });
  pField.appendChild(lblF); pField.appendChild(selF);
  row1.appendChild(pField);

  card.appendChild(row1);

  // Row 2: condition controls
  const chosenSource = buildConditionSources(gSchema).find(s=>String(s.id)===String(rule.fieldId));
  if (chosenSource){
    const row2 = document.createElement('div'); row2.className='rule-row';
    const pCond = document.createElement('div'); pCond.className='pair';
    const lblC = document.createElement('label'); lblC.textContent='Condition'; pCond.appendChild(lblC);

    const src = chosenSource; if (!Array.isArray(rule.values)) rule.values = [];
    const schedulePersist = debounce(()=>persistRules('typing:value'), 150);

    if (src.type!=='boolean'){
      const opSel = document.createElement('select');
      const ops = (src.type==='date')? ['before','equals','after']
                : (src.type==='text')? ['equals','notEquals','contains']
                : (src.type==='number'||src.type==='select')? ['equals','notEquals']
                : ['equals'];
      ops.forEach(v=>{ const o=document.createElement('option'); o.value=v; o.textContent=v; if(rule.op===v) o.selected=true; opSel.appendChild(o); });
      opSel.addEventListener('change', async ()=>{ rule.op = opSel.value; if(!gDraft){ await persistRules('change:op'); renderList(); } card._updateSave?.(); });
      pCond.appendChild(opSel);
    } else {
      const spanIs = document.createElement('span'); spanIs.className='muted'; spanIs.textContent='is'; pCond.appendChild(spanIs);
      rule.op = 'equals';
    }

    if (src.type==='boolean'){
      const sel=document.createElement('select');
      ;[{v:true,l:'true'},{v:false,l:'false'}].forEach(({v,l})=>{ const o=document.createElement('option'); o.value=String(v); o.textContent=l; if(String(rule.values?.[0])===String(v)) o.selected=true; sel.appendChild(o); });
      sel.addEventListener('change', async ()=>{ rule.values=[sel.value==='true']; if(!gDraft){ await persistRules('change:value'); renderList(); } card._updateSave?.(); });
      pCond.appendChild(sel);
    } else if (src.type==='date'){
      const inp=document.createElement('input'); inp.type='text'; inp.placeholder='YYYY-MM-DD'; inp.style.minWidth='140px'; inp.value=String(rule.values?.[0]||'');
      setTimeout(()=>{ try{ flatpickr(inp,{ allowInput:true, dateFormat:'Y-m-d', onChange:async()=>{ rule.values=[inp.value]; if(!gDraft){ await persistRules('change:value'); renderList(); } card._updateSave?.(); } }); }catch{} },0);
      inp.addEventListener('input', ()=>{ rule.values=[inp.value]; schedulePersist(); card._updateSave?.(); });
      pCond.appendChild(inp);
    } else if (src.type==='text'){
      const inp=document.createElement('input'); inp.type='text'; inp.value=String(rule.values?.[0]||'');
      inp.addEventListener('input', ()=>{ rule.values=[inp.value]; schedulePersist(); card._updateSave?.(); });
      pCond.appendChild(inp);
    } else if (src.type==='number'){
      const inp=document.createElement('input'); inp.type='number'; inp.value=String(rule.values?.[0]??'');
      inp.addEventListener('input', ()=>{ const v=inp.value; rule.values=[v===''? '': Number(v)]; schedulePersist(); card._updateSave?.(); });
      pCond.appendChild(inp);
    } else if (src.type==='select'){
      const sel=document.createElement('select');
      const def=document.createElement('option'); def.value=''; def.textContent='Select value…'; sel.appendChild(def);
      const base=(gSchema.fields||[]).find(ff=>String(ff.id)===String(src.id));
      const opts = base ? normOptions(base) : (src.options||[]).map(x=>({value:String(x),label:String(x)}));
      opts.forEach(opt=>{ const o=document.createElement('option'); o.value=String(opt.value); o.textContent=String(opt.label); if(String(rule.values?.[0])===String(opt.value)) o.selected=true; sel.appendChild(o); });
      sel.addEventListener('change', async ()=>{ rule.values = sel.value ? [sel.value] : ['']; if(!gDraft){ await persistRules('change:value'); renderList(); } card._updateSave?.(); });
      pCond.appendChild(sel);
    } else {
      const inp=document.createElement('input'); inp.type='text'; inp.value=String(rule.values?.[0]||'');
      inp.addEventListener('input', ()=>{ rule.values=[inp.value]; schedulePersist(); card._updateSave?.(); });
      pCond.appendChild(inp);
    }

    row2.appendChild(pCond);
    card.appendChild(row2);
  }

  // Row 3: targets
  if (gMode==='headings'){
    const flat = flattenWithNumbers(gHeadingsTree);
    if (flat.length){
      const row3=document.createElement('div'); row3.className='rule-row';
      const pair=document.createElement('div'); pair.className='pair';
      const lbl=document.createElement('label'); lbl.textContent='Add heading';
      const sel=document.createElement('select'); const def=document.createElement('option'); def.value=''; def.textContent='Select…'; sel.appendChild(def);
      const chosen = new Set((rule.targets||[]).map(t=> (typeof t==='string')? t : t.key));
      flat.forEach(h=>{ const comp = toCompositeKeyFromFlat(h); if (chosen.has(comp)) return; const o=document.createElement('option'); o.value=comp; o.textContent=h.label; sel.appendChild(o); });
      sel.addEventListener('change', async ()=>{
        const comp=sel.value; if (!comp) return;
        const label = (flat.find(h=>toCompositeKeyFromFlat(h)===comp)?.label)||comp;
        rule.targets = rule.targets || []; rule.targets.push({ key:comp, label });
        await persistRules('change:addHeading'); renderEditor(); renderList();
      });
      pair.appendChild(lbl); pair.appendChild(sel); row3.appendChild(pair); card.appendChild(row3);
    }
  } else {
    const all = (gSchema.fields||[]).map(f=>({id:String(f.id), label:f.label||f.id}));
    const row3=document.createElement('div'); row3.className='rule-row';
    const pair=document.createElement('div'); pair.className='pair';
    const lbl=document.createElement('label'); lbl.textContent='Add field';
    const sel=document.createElement('select'); const def=document.createElement('option'); def.value=''; def.textContent='Select…'; sel.appendChild(def);
    const chosen = new Set((rule.targets||[]).map(t=> String((typeof t==='string')? t : t.id)));
    all.forEach(s=>{ if(!chosen.has(String(s.id))){ const o=document.createElement('option'); o.value=s.id; o.textContent=s.label; sel.appendChild(o);} });
    sel.addEventListener('change', async ()=>{
      const id=sel.value; if (!id) return;
      const s = all.find(x=>String(x.id)===String(id)); if (!s) return;
      rule.targets = rule.targets || []; rule.targets.push({ id:s.id, label:s.label });
      await persistRules('change:addField'); renderEditor(); renderList();
    });
    pair.appendChild(lbl); pair.appendChild(sel); row3.appendChild(pair); card.appendChild(row3);
  }

  // Row 4: selected target pills
  const row4=document.createElement('div'); row4.className='rule-row';
  const lblSel=document.createElement('div'); lblSel.className='muted'; lblSel.textContent=(gMode==='headings'?'Selected headings:':'Selected fields:');
  const pills=document.createElement('div'); pills.className='pills';
  (rule.targets||[]).forEach(t=>{
    const isHead = (gMode==='headings');
    const idOrKey = isHead ? (typeof t==='string'? t : t.key) : (typeof t==='string'? t : t.id);
    const label = isHead ? ((typeof t==='object' && t.label) ? t.label : getHeadingLabelFromKey(String(idOrKey)))
                         : ((typeof t==='object' && t.label) ? t.label : getFieldLabelById(String(idOrKey)));
    const pill=document.createElement('span'); pill.className='pill'; pill.title=String(idOrKey);
    const txt=document.createElement('span'); txt.textContent=label || String(idOrKey);
    const x=document.createElement('button'); x.setAttribute('aria-label','Remove'); x.textContent='×';
    x.addEventListener('click', async ()=>{
      if (isHead) rule.targets=(rule.targets||[]).filter(z=> String((typeof z==='string'? z : z.key)) !== String(idOrKey));
      else rule.targets=(rule.targets||[]).filter(z=> String((typeof z==='string'? z : z.id)) !== String(idOrKey));
      await persistRules('change:removeTarget'); renderEditor(); renderList();
    });
    pill.appendChild(txt); pill.appendChild(x); pills.appendChild(pill);
  });
  if (!pills.children.length){ const none=document.createElement('span'); none.className='empty'; none.textContent='(none)'; pills.appendChild(none); }
  row4.appendChild(lblSel); row4.appendChild(pills); card.appendChild(row4);

  mount.appendChild(card);
  if (gDraft) card._updateSave?.();
}

// ------------------------------ RELOAD/SYNC -----------------------------
function applyTabUI(){
  const isHead=gMode==='headings';
  els.tabHeadings.setAttribute('aria-pressed', String(isHead));
  els.tabHeadings.className = 'btn ' + (isHead ? 'btn-secondary' : 'btn-ghost');
  els.tabFields.setAttribute('aria-pressed', String(!isHead));
  els.tabFields.className   = 'btn ' + (!isHead ? 'btn-secondary' : 'btn-ghost');
  els.rulesHint.textContent = isHead
    ? 'SHOW or HIDE specific headings/subheaders based on a field’s selected value(s).'
    : 'SHOW or HIDE specific form fields based on another field’s selected value(s).';
}

// NOTE: we never import rules from payload here; workspace is authoritative.
async function reloadState(reason){
  if (!gDocId) return;
  const st = await window.formSuitePersist.loadState(gDocId) || {};
  if (st.schema) gSchema = st.schema;
  if (Array.isArray(st.headingsTree)) gHeadingsTree = st.headingsTree;

  gRulesHeadings = Array.isArray(st.rules) ? st.rules.slice() : [];
  gRulesFields   = Array.isArray(st.fieldRules) ? st.fieldRules.slice() : [];

  normalizeAllTargets();

  gRules = (gMode==='headings') ? gRulesHeadings.slice() : gRulesFields.slice();
  if (!gRules.find(r=>r?.id===gEditingId)) gEditingId = null;

  setStatus(`Loaded — fields: ${(gSchema.fields||[]).length}, headings: ${(gHeadingsTree||[]).length}, ${gMode==='headings'?'heading-rules':'field-rules'}: ${gRules.length}`);
  renderEditor(); renderList();

  // DEBUG: print payload after any load/reload
  await debugLogPayload(`reload:${reason}`);
}

// tab switches
els.tabHeadings?.addEventListener('click', async ()=>{
  if (gMode==='headings') return;
  gMode='headings'; gDraft=null; gEditingId=null; applyTabUI(); await reloadState('tab:headings');
});
els.tabFields?.addEventListener('click', async ()=>{
  if (gMode==='fields') return;
  gMode='fields'; gDraft=null; gEditingId=null; applyTabUI(); await reloadState('tab:fields');
});

// add rule
els.btnAddRule.addEventListener("click", ()=>{
  gEditingId = null;
  gDraft = { id:null, action:null, fieldId:"", op:null, values:[], targets:[], ...(gMode==='fields'? {hideMode:'hide'} : {}) };
  renderEditor();
  els.editorMount.scrollIntoView({behavior:"smooth", block:"start"});
});

// quick diagnostics (F9)
window.addEventListener('keydown', async (e) => {
  if (e.key === 'F9') {
    const st = await window.formSuitePersist.loadState(gDocId) || {};
    const p  = st?.payload?.CRONOS_PAYLOAD || st?.CRONOS_PAYLOAD || st?.cronos_payload || {};
    console.log('[rules][F9] dump', {
      docId: gDocId,
      ws_rules: st.rules?.length || 0,
      ws_fieldRules: st.fieldRules?.length || 0,
      ws_rulesVersion: st.rulesVersion || null,
      pl_rules: p.rules?.length || 0,
      pl_fieldRules: p.fieldRules?.length || 0,
      pl_rulesVersion: p.rulesVersion || null,
      ls_has_plain: !!localStorage.getItem('CRONOS_PAYLOAD'),
      ls_has_scoped: !!localStorage.getItem(`CRONOS_PAYLOAD:${gDocId}`),
      ls_stamp: localStorage.getItem(`FS_RULES_STAMP:${gDocId}`)
    });
  }
});

// boot
(function boot(){
  try{
    try { window.formSuitePersist?.ensureHydrated?.(); } catch {}
    const meta = window.formSuitePersist?.getActiveDoc?.sync?.()
              || window.formSuitePersist?.getCurrentDocMeta?.()
              || (function(){ try{ const v=localStorage.getItem(ACTIVE_LS_KEY); return v? JSON.parse(v):null; } catch { return null; } })();
    if (!meta?.docId){ setStatus("No active document. Open one first."); return; }
    gDocId = meta.docId;
    applyTabUI();
    reloadState("boot");
  } catch(e){ console.error("boot failed:", e); setStatus("Failed to load state."); }
})();
</script>
</body>
</html>
