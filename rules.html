<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Form Suite — Rules</title>
  <link rel="icon" href="favicon.ico" type="image/gif" sizes="32x32">
  <link rel="shortcut icon" href="favicon.ico" type="image/gif">
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/themes/material_blue.css">
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <link rel="stylesheet" href="style.css">
  <script src="persistence.js"></script>
</head>
<body class="rules">
<header>
  <div class="row">
    <span class="brand logo-md">
      <img src="logo.gif" alt="Form Suite logo" class="logo" />
      <strong>Form Suite</strong>
    </span>
    <span class="muted">·</span><a href="index.html">Form</a>
    <span class="muted">·</span><a href="builder.html">Form Builder</a>
    <span class="muted">·</span><a href="matcher.html">Tag Matcher</a>
    <span class="muted">·</span><span class="muted">Rules</span>
    <span class="muted">·</span><a href="extractor.html">Extractor</a>
  </div>
</header>

<main>
  <section class="panel">
    <div class="row" style="justify-content:space-between; align-items:center">
      <h2 style="margin:0">Rules</h2>
      <div id="rulesTabs" class="row" style="margin-left:8px; gap:6px;">
        <button id="tabHeadings" class="btn btn-secondary" aria-pressed="true">Headings</button>
        <button id="tabFields" class="btn btn-ghost" aria-pressed="false">Fields</button>
      </div>
      <div class="row">
        <span id="status" class="muted" style="margin-right:10px"></span>
        <button id="btnAddRule" class="btn btn-primary">Add rule</button>
      </div>
    </div>
    <div class="muted-note" id="rulesHint" style="margin-top:6px">
      SHOW or HIDE specific headings/subheaders or form fields based on a field’s value(s).
    </div>
  </section>

  <section class="panel" id="editorMount">
    <div class="empty">No rules yet — click “Add rule”.</div>
  </section>

  <section class="panel">
    <h3 style="margin-top:0">Existing rules</h3>
    <div id="rulesList" class="rules-list">
      <div class="empty">None.</div>
    </div>
  </section>
</main>

<script>
/* ------------------------------------------------------------------ *
 * Bulletproof Rules editor
 * ------------------------------------------------------------------ */

const nowt = () => new Date().toISOString().slice(11,23);
const ACTIVE_LS_KEY= "FS_ACTIVE_DOC_META";

const els = {
  status: document.getElementById("status"),
  btnAddRule: document.getElementById("btnAddRule"),
  editorMount: document.getElementById("editorMount"),
  rulesList: document.getElementById("rulesList"),
  tabHeadings: document.getElementById("tabHeadings"),
  tabFields: document.getElementById("tabFields"),
  rulesHint: document.getElementById("rulesHint"),
};

const bcCanon   = ("BroadcastChannel" in window) ? new BroadcastChannel("fs-active-doc")   : null;
const bcLegacy  = ("BroadcastChannel" in window) ? new BroadcastChannel("form-suite-doc")  : null;

// ---- DEBUG: pretty payload logger ----
async function debugLogPayload(where) {
  try {
    const st = await window.formSuitePersist.loadState(gDocId) || {};
    const payload = st?.payload?.CRONOS_PAYLOAD || st?.CRONOS_PAYLOAD || st?.cronos_payload || {};
    const wsRules      = Array.isArray(st.rules) ? st.rules : [];
    const wsFieldRules = Array.isArray(st.fieldRules) ? st.fieldRules : [];

    console.groupCollapsed(`[rules][${where}] docId=${gDocId}`);
    console.log('workspace.rules        (%d):', wsRules.length, wsRules);
    console.log('workspace.fieldRules   (%d):', wsFieldRules.length, wsFieldRules);
    console.log('workspace.rulesVersion :', st.rulesVersion);
    console.log('payload.rules          (%d):', Array.isArray(payload.rules) ? payload.rules.length : 0, payload.rules || []);
    console.log('payload.fieldRules     (%d):', Array.isArray(payload.fieldRules) ? payload.fieldRules.length : 0, payload.fieldRules || []);
    console.log('payload.rulesVersion   :', payload.rulesVersion);
    console.log('payload.updatedAt      :', payload.updatedAt);
    try {
      const lsScoped = localStorage.getItem(`CRONOS_PAYLOAD:${gDocId}`);
      const lsParsed = lsScoped ? JSON.parse(lsScoped) : null;
      console.log('localStorage(scoped)   :', !!lsScoped, lsParsed?.rules?.length ?? 0, lsParsed?.fieldRules?.length ?? 0, lsParsed?.rulesVersion ?? null);
    } catch (e) {
      console.warn('localStorage parse fail:', e);
    }
    console.groupEnd();
  } catch (e) {
    console.error('[rules][debugLogPayload] failed', e);
  }
}


// app state
let gDocId   = null;
let gSchema  = { title:"Form", fields:[] };
let gHeadingsTree = [];
let gMode    = 'headings'; // 'headings' | 'fields'
let gRulesHeadings = [];   // persisted
let gRulesFields   = [];   // persisted
let gRules   = [];         // current list in view
let gEditingId = null;     // current editor
let gDraft   = null;

// UI helpers
const setStatus = (s) => { try { els.status.textContent = s || ""; } catch {} };
const slugify = (s)=> String(s||"").normalize('NFKD').replace(/[\u0300-\u036f]/g,'').replace(/[^a-zA-Z0-9]+/g,'_').replace(/^_+|_+$/g,'').toLowerCase();
const ACTIONS = new Set(["SHOW","HIDE"]);
const debounce = (fn, ms)=>{ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a), ms); }; };
const valueToSlug = (v)=> slugify(String(v));

// ---- unified type helpers ----
const isMultiOption = (t) => ['multichoice','multiselect'].includes(t);
const isSelectLike  = (t) => ['select','dropdown','singlechoice','choice','single','combobox','list'].includes(t);
const isNumericLike = (t) => ['datediff','duration','number'].includes(t);

// schema/headings helpers
function normOptions(field){
  const raw = field && field.options || [];
  return raw.map(o => {
    if (o && typeof o === "object") {
      const value = (o.value ?? o.id ?? o.key ?? o.code ?? String(o));
      const label = (o.label ?? o.text ?? o.name ?? String(value));
      return { value:String(value), label:String(label) };
    }
    return { value:String(o), label:String(o) };
  });
}
function getFieldLabelById(id){
  const f = (gSchema.fields||[]).find(x => String(x.id)===String(id));
  return f?.label || f?.name || f?.id || String(id);
}
function flattenWithNumbers(tree){
  const out=[], counters=[];
  function walk(nodes, depth){
    counters[depth]=0;
    for (const n of (nodes||[])){
      counters[depth]++;
      const number = counters.slice(0, depth+1).join(".");
      const label = (n.label?.trim?.() ? n.label : n.text) || "";
      out.push({
        key: String(n.idx ?? number),
        label: number + " " + label,
        titleOnly: label,
        number,
        level: n.level || (depth+1)
      });
      if (n.children?.length) walk(n.children, depth+1);
    }
  }
  walk(tree||[],0);
  return out;
}
function toCompositeKeyFromFlat(h){
  if (!h) return '';
  const raw = String(h.key ?? '');
  if (raw.includes('|')) return raw;
  return `${h.number}|${h.titleOnly || ''}`.trim();
}
function getHeadingLabelFromKey(key){
  if (!key) return '';
  if (key.includes('|')) return key.split('|').slice(1).join('|');
  const flat = flattenWithNumbers(gHeadingsTree);
  const hit = flat.find(h => h.number === key);
  return hit?.titleOnly || key;
}

// target normalization
function normalizeHeadingsRuleTargetsInPlace(rule){
  if (!rule || !Array.isArray(rule.targets)) return {changed:false};
  const flat = flattenWithNumbers(gHeadingsTree);
  const byNumber = new Map(); const byComp=new Map();
  flat.forEach(h=>{ const comp=toCompositeKeyFromFlat(h); byNumber.set(h.number,comp); byComp.set(comp,h.label);});
  let changed=false;
  rule.targets = rule.targets.map(t=>{
    let compKey='';
    if (typeof t === 'string'){ compKey = t.includes('|')? t : (byNumber.get(t)||t); }
    else if (t && typeof t==='object'){ const k=String(t.key||''); compKey = k? (k.includes('|')? k : (byNumber.get(k)||k)) : ''; }
    if (!compKey) return t;
    const label = byComp.get(compKey) || compKey.split('|').slice(1).join('|') || compKey;
    const normalized = { key:compKey, label };
    if (typeof t==='string' || !t.label || String(t.key)!==compKey) changed=true;
    return normalized;
  });
  return {changed};
}

// keep option labels for child targets
function normalizeFieldTargetsInPlace(rule){
  if (!rule || !Array.isArray(rule.targets)) return {changed:false};
  const fieldLabel = new Map((gSchema.fields||[]).map(f=>[String(f.id), f.label||f.name||f.id]));
  let changed=false;

  rule.targets = rule.targets.map(t=>{
    if (!t) return t;

    if (typeof t==='string'){
      changed=true;
      return { id:t, label: fieldLabel.get(String(t)) || String(t) };
    }

    const id = String(t.id||'');
    const parentLabel = fieldLabel.get(id) || id;

    if ('optionValue' in t){
      const optionValue = String(t.optionValue ?? '');
      const optionLabel = String(t.optionLabel ?? '');
      const composed = t.label || `${parentLabel}: ${optionLabel || optionValue}`;
      const out = { id, optionValue, optionLabel, label: composed };
      if (t.id!==id || t.optionValue!==optionValue || t.optionLabel!==optionLabel || t.label!==composed) changed=true;
      return out;
    }

    const out = { id, label: parentLabel };
    if (t.label!==out.label) changed=true;
    return out;
  });

  return {changed};
}
function normalizeAllTargets(){
  let cH=0, cF=0;
  (gRulesHeadings||[]).forEach(r=>{ if (normalizeHeadingsRuleTargetsInPlace(r).changed) cH++; });
  (gRulesFields||[]).forEach(r=>{ if (normalizeFieldTargetsInPlace(r).changed) cF++; });
  if (cH) console.log(`[${nowt()}] normalized ${cH} heading rule(s)`);
  if (cF) console.log(`[${nowt()}] normalized ${cF} field rule(s)`);
}

// condition sources + validation
function buildConditionSources(schema){
  const out=[]; const seen=new Set();
  for (const f of (schema?.fields||[])){
    const t=String(f.type||'').toLowerCase(); const id=String(f.id); const label=f.label||f.id;

    if (t==='boolean'||t==='checkbox'||t==='switch'){
      if(!seen.has(id)){ seen.add(id); out.push({id,label,type:'boolean'}); }
      continue;
    }

    if (isMultiOption(t)){
      if(!seen.has(id)){ seen.add(id); out.push({id,label,type:'boolean',meta:{anySelected:true}}); }
      const items=[];
      if (Array.isArray(f.options)) items.push(...f.options);
      if (f.mc?.groups) (f.mc.groups||[]).forEach(g=> (g.items||[]).forEach(it=>items.push(it)));
      items.forEach(it=>{
        const rawV = it && typeof it==='object' ? (it.value ?? it.label ?? it.text ?? it.name ?? '') : it;
        const rawL = it && typeof it==='object' ? (it.label ?? it.text ?? it.name ?? rawV) : rawV;
        const v=String(rawV||'').trim(); const l=String(rawL||'').trim(); const sl=slugify(v);
        if (!v||!sl) return; const optId = `${id}__opt__${sl}`; if (seen.has(optId)) return;
        seen.add(optId); out.push({id:optId, label:`${label}: ${l}`, type:'boolean'});
      });
      continue;
    }

    if (t==='date'){ if(!seen.has(id)){ seen.add(id); out.push({id,label,type:'date'});} continue; }
    if (isNumericLike(t)){ if(!seen.has(id)){ seen.add(id); out.push({id,label,type:'number'});} continue; }
    if (isSelectLike(t)){
      if(!seen.has(id)){ seen.add(id); out.push({id,label,type:'select', options:(f.options||[]).map(o=> (o&&typeof o==='object')? String(o.value??o.label??o) : String(o))});}
      continue;
    }
    if (t==='text'||t==='string'||t==='textarea'){ if(!seen.has(id)){ seen.add(id); out.push({id,label,type:'text'});} continue; }
    if(!seen.has(id)){ seen.add(id); out.push({id,label,type:'text'}); }
  }
  return out;
}

// ---------- TREE-/F STYLE LIST RENDERER (single-line ASCII, always expanded)
function flattenTreeLines(nodes, prefixBag=[], out=[]){
  nodes.forEach((node, idx) => {
    const isLast = idx === nodes.length - 1;
    const prefix = prefixBag.map(last => last ? '   ' : '│  ').join('') + (prefixBag.length ? (isLast ? '└─ ' : '├─ ') : '');
    out.push({ id: String(node.id), text: prefix + (node.label || node.id), isLast });
    if (node.children && node.children.length){
      flattenTreeLines(node.children, [...prefixBag, isLast], out);
    }
  });
  return out;
}

function renderTreeMenu(container, nodes, { currentId=null, onPick, disableIds=new Set() } = {}){
  container.innerHTML = '';
  container.className = 'tree-menu';
  container.style.maxHeight = '260px';
  container.style.overflow = 'auto';
  container.style.padding = '6px 0';
  container.style.border = '1px solid var(--border)';
  container.style.borderRadius = '6px';
  container.style.background = 'var(--card)';
  container.style.fontFamily = 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
  container.style.fontSize = '12.5px';

  const list = document.createElement('div');
  list.setAttribute('role','listbox');

  const lines = flattenTreeLines(nodes);
  lines.forEach(({id, text})=>{
    const row = document.createElement('div');
    row.setAttribute('role','option');
    row.dataset.id = id;
    row.textContent = text;
    row.style.whiteSpace = 'pre';
    row.style.padding = '2px 10px';
    row.style.cursor = disableIds.has(id) ? 'not-allowed' : 'pointer';
    row.style.userSelect = 'none';

    if (String(currentId) === String(id)){
      row.style.background = 'var(--primary-ghost, rgba(0,0,0,0.06))';
      row.style.fontWeight = '600';
    }
    if (disableIds.has(id)){
      row.classList.add('muted');
      row.style.opacity = '0.55';
      row.style.pointerEvents = 'none';
    }

    row.addEventListener('mouseenter', ()=>{ if (!disableIds.has(id)) row.style.background='rgba(0,0,0,0.05)'; });
    row.addEventListener('mouseleave', ()=>{ if (String(currentId) !== String(id)) row.style.background='transparent'; });

    if (!disableIds.has(id)){
      row.addEventListener('click', ()=> onPick && onPick(id));
    }

    list.appendChild(row);
  });

  container.appendChild(list);
}

// ---- Build trees for pickers
function buildConditionTree(schema){
  const flat = buildConditionSources(schema) || [];
  const byId = new Map();
  const roots = [];
  for (const f of (schema?.fields || [])) {
    const id = String(f.id);
    const label = f.label || f.id;
    const type = String(f.type || '').toLowerCase();
    const node = { id, label, type, children: [] };
    byId.set(id, node);
    roots.push(node);
  }
  for (const src of flat) {
    const sid = String(src.id || '');
    if (!sid.includes('__opt__')) continue;
    const parentId = sid.split('__opt__')[0];
    const parent = byId.get(parentId);
    if (!parent) continue;
    parent.children.push({ id: sid, label: src.label, type: src.type || 'boolean', children: [] });
  }
  return roots;
}

// Headings tree with numbering in labels
function buildHeadingsTreeNodes(){
  function walk(nodes, depth, counters){
    const out = [];
    counters[depth] = 0;
    (nodes || []).forEach(n => {
      counters[depth]++;
      const number = counters.slice(0, depth + 1).join('.');
      const title  = (n.label?.trim?.() ? n.label : n.text) || '';
      out.push({
        id: `${number}|${title}`,
        label: `${number} ${title}`,
        children: walk(n.children || [], depth + 1, counters.slice())
      });
    });
    return out;
  }
  return walk(gHeadingsTree || [], 0, []);
}

// Field targets tree — parent = field, children = options (selectable)
function buildFieldTargetsTree(){
  const nodes=[];
  for (const f of (gSchema.fields||[])){
    const id = String(f.id);
    const type = String(f.type||'').toLowerCase();
    const node = { id, label: f.label || f.id, children: [] };

    if (isMultiOption(type) || isSelectLike(type)){
      const opts = normOptions(f);
      node.children = opts.map(o => ({ id: `${id}__opt__${valueToSlug(o.value)}`, value:String(o.value), label: String(o.label), children: [] }));
    }
    nodes.push(node);
  }
  return nodes;
}

// ---------- helper: selection logic for Fields targets ----------
function hasParentTarget(rule, fieldId){
  return (rule.targets||[]).some(t => t && typeof t==='object' && String(t.id)===String(fieldId) && !('optionValue' in t));
}
function hasOptionTarget(rule, fieldId, optionValue){
  return (rule.targets||[]).some(t => t && typeof t==='object'
    && String(t.id)===String(fieldId)
    && String(t.optionValue)===String(optionValue));
}
function addParentWithAllOptions(rule, fieldId){
  const f = (gSchema.fields||[]).find(x=> String(x.id)===String(fieldId));
  if (!f) return;
  const fieldLabel = f.label || f.id;
  const type = String(f.type||'').toLowerCase();
  if (!hasParentTarget(rule, fieldId)){
    rule.targets = rule.targets || [];
    rule.targets.push({ id:String(fieldId), label: fieldLabel });
  }
  if (isMultiOption(type) || isSelectLike(type)){
    const opts = normOptions(f);
    opts.forEach(o => {
      if (!hasOptionTarget(rule, fieldId, o.value)){
        rule.targets.push({
          id: String(fieldId),
          optionValue: String(o.value),
          optionLabel: String(o.label),
          label: `${fieldLabel}: ${o.label}`
        });
      }
    });
  }
}
function removeParent(rule, fieldId){
  rule.targets = (rule.targets||[]).filter(t => !(t && typeof t==='object' && String(t.id)===String(fieldId) && !('optionValue' in t)));
}
function removeAllChildren(rule, fieldId){
  rule.targets = (rule.targets||[]).filter(t => !(t && typeof t==='object' && String(t.id)===String(fieldId) && ('optionValue' in t)));
}
function removeOneChildAndParent(rule, fieldId, optionValue){
  rule.targets = (rule.targets||[]).filter(t => !(t && typeof t==='object'
    && String(t.id)===String(fieldId)
    && String(t.optionValue)===String(optionValue)));
  removeParent(rule, fieldId);
}

function isRuleValid(rule){
  if (!rule || !ACTIONS.has(rule.action)) return false;
  const srcs = buildConditionSources(gSchema);
  const src = srcs.find(s=>String(s.id)===String(rule.fieldId));
  if (!src) return false;
  const allowed = (src.type==='boolean')?['equals']
                : (src.type==='date')?['before','equals','after']
                : (src.type==='text')?['equals','notEquals','contains']
                : (src.type==='number')?['equals','notEquals']
                : (src.type==='select')?['equals','notEquals']
                : ['equals'];
  if (!allowed.includes(rule.op)) return false;
  if (!Array.isArray(rule.values)) return false;
  if (!Array.isArray(rule.targets) || rule.targets.length===0) return false;
  return true;
}

// ----------------------------- PERSISTENCE ------------------------------
async function persistRules(reason) {
  if (!gDocId) return;
  normalizeAllTargets();

  const rules      = (gRulesHeadings || []).map(x => JSON.parse(JSON.stringify(x)));
  const fieldRules = (gRulesFields   || []).map(x => JSON.parse(JSON.stringify(x)));
  const stamp = Date.now();

  console.log(`[${nowt()}] WRITE (${reason}) rules=${rules.length}, fieldRules=${fieldRules.length}`);

  const st0 = await window.formSuitePersist.loadState(gDocId) || {};
  const basePayload =
      (st0?.payload?.CRONOS_PAYLOAD)
   || (st0?.CRONOS_PAYLOAD)
   || (st0?.cronos_payload)
   || {};

  const canonical = {
    ...basePayload,
    rules,
    fieldRules,
    rulesVersion: stamp,
    updatedAt: new Date(stamp).toISOString()
  };

  try {
    if (window.formSuitePersist?.setState) {
      await window.formSuitePersist.setState(gDocId, {
        rules, fieldRules, rulesVersion: stamp,
        payload:        { CRONOS_PAYLOAD: canonical },
        CRONOS_PAYLOAD:  canonical,
        cronos_payload:  canonical
      });
    } else {
      await window.formSuitePersist.saveState(gDocId, {
        rules, fieldRules, rulesVersion: stamp,
        payload:        { ...(st0.payload || {}), CRONOS_PAYLOAD: canonical },
        CRONOS_PAYLOAD:  canonical,
        cronos_payload:  canonical
      });
    }
  } catch (e) {
    console.error('[rules] persistRules: write failed', e);
    throw e;
  }

  try {
    localStorage.setItem('CRONOS_PAYLOAD', JSON.stringify(canonical));
    localStorage.setItem(`CRONOS_PAYLOAD:${gDocId}`, JSON.stringify(canonical));
    localStorage.setItem(`FS_RULES_STAMP:${gDocId}`, String(stamp));
  } catch (e) {
    console.warn('[rules] localStorage mirror failed', e);
  }

  try {
    const st1 = await window.formSuitePersist.loadState(gDocId) || {};
    const p1  = st1?.payload?.CRONOS_PAYLOAD || st1?.CRONOS_PAYLOAD || st1?.cronos_payload || {};
    const ok  = Array.isArray(st1.rules) && Array.isArray(st1.fieldRules)
             && JSON.stringify(p1.rules||[]) === JSON.stringify(rules)
             && JSON.stringify(p1.fieldRules||[]) === JSON.stringify(fieldRules)
             && (p1.rulesVersion === stamp || st1.rulesVersion === stamp);

    console.log(
      `[${nowt()}] VERIFY after persist → ` +
      `workspace: r=${(st1.rules||[]).length}/${rules.length}, fr=${(st1.fieldRules||[]).length}/${fieldRules.length}; ` +
      `payload: r=${(p1.rules||[]).length}/${rules.length}, fr=${(p1.fieldRules||[]).length}/${fieldRules.length}; ` +
      `stamp=${stamp} ok=${ok}`
    );
  } catch (e) {
    console.warn('[rules] read-back verification failed', e);
  }

  try { bcCanon?.postMessage({  type: 'rules-updated',  docId: gDocId, ts: stamp, from: 'rules.html' }); } catch {}
  try { bcLegacy?.postMessage({ type: 'rules-updated',  docId: gDocId, ts: stamp, from: 'rules.html' }); } catch {}
  try { bcCanon?.postMessage({  type: 'active:updated', docId: gDocId, ts: stamp, from: 'rules.html' }); } catch {}
  try { bcLegacy?.postMessage({ type: 'doc-updated',    docId: gDocId, ts: stamp, from: 'rules.html' }); } catch {}

  console.log(`[${nowt()}] AFTER persist → workspace + all payload mirrors + LS updated; broadcast sent`);
  await debugLogPayload(`persist:${reason}`);
}

// ------------------------------- RENDERING ------------------------------
function summarizeCondition(rule){
  const srcs = buildConditionSources(gSchema);
  let src = srcs.find(s=>String(s.id)===String(rule.fieldId));
  const srcLabel = src?.label || getFieldLabelById(rule.fieldId) || String(rule.fieldId);
  const op = rule.op || 'equals';
  const v0 = Array.isArray(rule.values) ? rule.values[0] : rule.values;

  if (!src) return `when ${srcLabel} ${op} ${JSON.stringify(v0)}`;
  if (src.type==='boolean') return `when ${srcLabel} ${op} ${String(v0)}`;
  if (src.type==='date')    return `when ${srcLabel} ${op} ${String(v0||'')}`;
  if (src.type==='text')    return `when ${srcLabel} ${op} "${String(v0||'')}"`;
  if (src.type==='number')  return `when ${srcLabel} ${op} ${String(v0)}`;
  if (src.type==='select') {
    const base = (gSchema.fields||[]).find(ff => String(ff.id)===String(src.id));
    const options = base ? normOptions(base) : (src.options||[]).map(x=>({value:String(x),label:String(x)}));
    const label = options.find(o=>String(o.value)===String(v0))?.label ?? String(v0||'');
    return `when ${srcLabel} ${op} "${label}"`;
  }
  return `when ${srcLabel} ${op}`;
}

function renderList(){
  els.rulesList.innerHTML = "";
  const list = gRules || [];
  if (!list.length){ els.rulesList.innerHTML = '<div class="empty">None.</div>'; return; }

  list.forEach(r=>{
    const row = document.createElement('div'); row.className='item';
    const left = document.createElement('div');

    const labels = (gMode==='headings')
      ? (r.targets||[]).map(t=> (typeof t==='object' && t.label) ? t.label : getHeadingLabelFromKey(String((typeof t==='string')? t : (t.key||''))) ).filter(Boolean)
      : (r.targets||[]).map(t=>{
          if (typeof t==='object'){
            if (t.optionLabel!=null) return t.label || `${getFieldLabelById(String(t.id))}: ${t.optionLabel}`;
            return t.label || getFieldLabelById(String(t.id));
          }
          return getFieldLabelById(String(t));
        }).filter(Boolean);

    left.innerHTML = `<strong>${r.action}</strong> — <em>${labels.join(', ') || '(no targets selected)'}</em> <span class="muted">${summarizeCondition(r)}</span>`;

    const right = document.createElement('div'); right.style.display='flex'; right.style.gap='8px';

    const edit = document.createElement('button'); edit.className='btn btn-ghost'; edit.textContent='Edit';
    edit.addEventListener('click', ()=>{ gDraft=null; gEditingId=r.id; renderEditor(); });

    const del = document.createElement('button'); del.className='btn btn-danger'; del.textContent='Delete';
    del.addEventListener('click', async ()=>{
      if (!confirm('Delete this rule?')) return;
      const arr = (gMode==='headings') ? gRulesHeadings : gRulesFields;
      const idx = arr.findIndex(x=>x.id===r.id);
      if (idx>=0) arr.splice(idx,1);
      if (gMode==='headings') gRules = gRulesHeadings.slice(); else gRules = gRulesFields.slice();
      if (gEditingId === r.id) gEditingId = null;
      console.log(`[${nowt()}] DELETE id=${r.id}`);
      await persistRules('delete');
      renderEditor(); renderList();
    });

    right.appendChild(edit); right.appendChild(del);
    row.appendChild(left); row.appendChild(right);
    els.rulesList.appendChild(row);
  });
}

function currentEditorRule(){ if (gDraft) return gDraft; if (gEditingId) return (gRules||[]).find(r=>r.id===gEditingId) || null; return null; }

function renderEditor(){
  const mount = els.editorMount;
  mount.innerHTML = "";
  const rule = currentEditorRule();
  if (!rule){ mount.innerHTML = '<div class="empty">No rules yet — click “Add rule”.</div>'; return; }

  // Normalize targets for display
  if (gMode==='headings') normalizeHeadingsRuleTargetsInPlace(rule);
  else normalizeFieldTargetsInPlace(rule);

  const card = document.createElement('div'); card.className='rule-card'; card.dataset.id = rule.id || 'draft';

  // Save/Cancel for draft
  if (gDraft){
    const top = document.createElement('div'); top.className='row'; top.style.justifyContent='flex-end'; top.style.gap='8px';
    const btnCancel = document.createElement('button'); btnCancel.className='btn btn-ghost'; btnCancel.textContent='Cancel';
    btnCancel.addEventListener('click', ()=>{ gDraft=null; renderEditor(); });

    const btnSave = document.createElement('button'); btnSave.className='btn btn-primary'; btnSave.textContent='Save rule';
    btnSave.disabled = !isRuleValid(rule);
    btnSave.addEventListener('click', async ()=>{
      if (!isRuleValid(rule)){ alert('Please complete the rule.'); return; }
      rule.id = "r_"+Math.random().toString(36).slice(2,8);
      if (gMode==='headings') gRulesHeadings.push(rule); else gRulesFields.push(rule);
      gDraft=null; gRules = (gMode==='headings')? gRulesHeadings.slice() : gRulesFields.slice();
      console.log(`[${nowt()}] CREATE ${JSON.stringify(rule)}`);
      await persistRules('create');
      renderEditor(); renderList();
    });

    const updateSaveState = ()=> { btnSave.disabled = !isRuleValid(currentEditorRule()); };
    card._updateSave = updateSaveState;

    top.appendChild(btnCancel); top.appendChild(btnSave); card.appendChild(top);
  }

  // Row 1: Action + Effect + When
  const row1 = document.createElement('div'); row1.className='rule-row';

  // Action
  const pAction = document.createElement('div'); pAction.className='pair';
  const lblA = document.createElement('label'); lblA.textContent='Action';
  const selA = document.createElement('select');
  const defAct = document.createElement('option'); defAct.value=''; defAct.textContent='Select…';
  if (gDraft && !rule.action) selA.appendChild(defAct);
  ['SHOW','HIDE'].forEach(a=>{ const o=document.createElement('option'); o.value=a; o.textContent=a; if(rule.action===a) o.selected=true; selA.appendChild(o);});
  selA.addEventListener('change', async ()=>{
    rule.action = selA.value || null;
    if (!gDraft){ await persistRules('change:action'); renderList(); }
    card._updateSave?.();
  });
  pAction.appendChild(lblA); pAction.appendChild(selA);
  row1.appendChild(pAction);

  // Effect (fields only)
  const pEffect = document.createElement('div'); pEffect.className='pair';
  const lblE = document.createElement('label'); lblE.textContent='Effect';
  const selE = document.createElement('select');
  ;[{v:'hide',t:'hide (remove)'},{v:'disable',t:'disable (greyed)'}].forEach(({v,t})=>{
    const o=document.createElement('option'); o.value=v; o.textContent=t; if((rule.hideMode||'hide')===v) o.selected=true; selE.appendChild(o);
  });
  selE.addEventListener('change', async ()=>{
    rule.hideMode = selE.value || 'hide';
    if (!gDraft){ await persistRules('change:hideMode'); renderList(); }
  });
  if (gMode==='fields'){ pEffect.appendChild(lblE); pEffect.appendChild(selE); row1.appendChild(pEffect); }

  // When (source) — TREE/F SINGLE-LINE PICKER
  const pField = document.createElement('div'); pField.className='pair';
  const lblF = document.createElement('label'); lblF.textContent='When';

  const pickWrap = document.createElement('div');
  pickWrap.style.position = 'relative';
  pickWrap.style.display = 'inline-block';

  const btnPick = document.createElement('button');
  btnPick.type = 'button';
  btnPick.className = 'btn';
  btnPick.textContent = (function(){
    const srcsFlat = buildConditionSources(gSchema);
    const cur = srcsFlat.find(s => String(s.id) === String(rule.fieldId));
    return cur ? cur.label : 'Select source…';
  })();
  pickWrap.appendChild(btnPick);

  const pop = document.createElement('div');
  pop.style.position = 'absolute';
  pop.style.top = '110%';
  pop.style.left = '0';
  pop.style.zIndex = '10';
  pop.style.display = 'none';
  pop.style.minWidth = '320px';
  pickWrap.appendChild(pop);

  function closePop(){ pop.style.display='none'; document.removeEventListener('click', outsideClose); }
  function outsideClose(e){ if (!pickWrap.contains(e.target)) closePop(); }

  const tree = buildConditionTree(gSchema);
  renderTreeMenu(pop, tree, {
    currentId: rule.fieldId,
    onPick: async (pickedId) => {
      rule.fieldId = pickedId || '';
      const srcs = buildConditionSources(gSchema);
      const src = srcs.find(x => String(x.id) === String(rule.fieldId));
      if (!rule.fieldId){ rule.op=null; rule.values=[]; }
      else if (src){
        if (src.type==='boolean'){ rule.op='equals'; rule.values=[true]; }
        else if (src.type==='date'){ rule.op='equals'; rule.values=['']; }
        else if (src.type==='text'){ rule.op='equals'; rule.values=['']; }
        else if (src.type==='number'){ rule.op='equals'; rule.values=[0]; }
        else if (src.type==='select'){ rule.op='equals'; rule.values=['']; }
        else { rule.op='equals'; rule.values=['']; }
      }
      btnPick.textContent = src ? src.label : 'Select source…';
      if (!gDraft){ await persistRules('change:fieldId'); renderEditor(); renderList(); }
      else { renderEditor(); }
      closePop();
    }
  });

  btnPick.addEventListener('click', (e) => {
    e.stopPropagation();
    if (pop.style.display === 'none') {
      renderTreeMenu(pop, buildConditionTree(gSchema), {
        currentId: rule.fieldId,
        onPick: async (pickedId)=>{
          rule.fieldId = pickedId || '';
          const srcs = buildConditionSources(gSchema);
          const src = srcs.find(x => String(x.id) === String(rule.fieldId));
          if (!rule.fieldId){ rule.op=null; rule.values=[]; }
          else if (src){
            if (src.type==='boolean'){ rule.op='equals'; rule.values=[true]; }
            else if (src.type==='date'){ rule.op='equals'; rule.values=['']; }
            else if (src.type==='text'){ rule.op='equals'; rule.values=['']; }
            else if (src.type==='number'){ rule.op='equals'; rule.values=[0]; }
            else if (src.type==='select'){ rule.op='equals'; rule.values=['']; }
            else { rule.op='equals'; rule.values=['']; }
          }
          btnPick.textContent = src ? src.label : 'Select source…';
          if (!gDraft){ await persistRules('change:fieldId'); renderEditor(); renderList(); }
          else { renderEditor(); }
          closePop();
        }
      });
      pop.style.display = 'block';
      setTimeout(() => document.addEventListener('click', outsideClose), 0);
    } else {
      closePop();
    }
  });

  pField.appendChild(lblF);
  pField.appendChild(pickWrap);
  row1.appendChild(pField);

  card.appendChild(row1);

  // Row 2: condition controls
  const chosenSource = buildConditionSources(gSchema).find(s=>String(s.id)===String(rule.fieldId));
  if (chosenSource){
    const row2 = document.createElement('div'); row2.className='rule-row';
    const pCond = document.createElement('div'); pCond.className='pair';
    const lblC = document.createElement('label'); lblC.textContent='Condition'; pCond.appendChild(lblC);

    const src = chosenSource; if (!Array.isArray(rule.values)) rule.values = [];
    const schedulePersist = debounce(()=>persistRules('typing:value'), 150);

    if (src.type!=='boolean'){
      const opSel = document.createElement('select');
      const ops = (src.type==='date')? ['before','equals','after']
                : (src.type==='text')? ['equals','notEquals','contains']
                : (src.type==='number'||src.type==='select')? ['equals','notEquals']
                : ['equals'];
      ops.forEach(v=>{ const o=document.createElement('option'); o.value=v; o.textContent=v; if(rule.op===v) o.selected=true; opSel.appendChild(o); });
      opSel.addEventListener('change', async ()=>{ rule.op = opSel.value; if(!gDraft){ await persistRules('change:op'); renderList(); } card._updateSave?.(); });
      pCond.appendChild(opSel);
    } else {
      const spanIs = document.createElement('span'); spanIs.className='muted'; spanIs.textContent='is'; pCond.appendChild(spanIs);
      rule.op = 'equals';
    }

    if (src.type==='boolean'){
      const sel=document.createElement('select');
      ;[{v:true,l:'true'},{v:false,l:'false'}].forEach(({v,l})=>{ const o=document.createElement('option'); o.value=String(v); o.textContent=l; if(String(rule.values?.[0])===String(v)) o.selected=true; sel.appendChild(o); });
      sel.addEventListener('change', async ()=>{ rule.values=[sel.value==='true']; if(!gDraft){ await persistRules('change:value'); renderList(); } card._updateSave?.(); });
      pCond.appendChild(sel);
    } else if (src.type==='date'){
      const inp=document.createElement('input'); inp.type='text'; inp.placeholder='YYYY-MM-DD'; inp.style.minWidth='140px'; inp.value=String(rule.values?.[0]||'');
      setTimeout(()=>{ try{ flatpickr(inp,{ allowInput:true, dateFormat:'Y-m-d', onChange:async()=>{ rule.values=[inp.value]; if(!gDraft){ await persistRules('change:value'); renderList(); } card._updateSave?.(); } }); }catch{} },0);
      inp.addEventListener('input', ()=>{ rule.values=[inp.value]; schedulePersist(); card._updateSave?.(); });
      pCond.appendChild(inp);
    } else if (src.type==='text'){
      const inp=document.createElement('input'); inp.type='text'; inp.value=String(rule.values?.[0]||'');
      inp.addEventListener('input', ()=>{ rule.values=[inp.value]; schedulePersist(); card._updateSave?.(); });
      pCond.appendChild(inp);
    } else if (src.type==='number'){
      const inp=document.createElement('input'); inp.type='number'; inp.value=String(rule.values?.[0]??'');
      inp.addEventListener('input', ()=>{ const v=inp.value; rule.values=[v===''? '': Number(v)]; schedulePersist(); card._updateSave?.(); });
      pCond.appendChild(inp);
    } else if (src.type==='select'){
      const sel=document.createElement('select');
      const def=document.createElement('option'); def.value=''; def.textContent='Select value…'; sel.appendChild(def);
      const base=(gSchema.fields||[]).find(ff=>String(ff.id)===String(src.id));
      const opts = base ? normOptions(base) : (src.options||[]).map(x=>({value:String(x),label:String(x)}));
      opts.forEach(opt=>{ const o=document.createElement('option'); o.value=String(opt.value); o.textContent=String(opt.label); if(String(rule.values?.[0])===String(opt.value)) o.selected=true; sel.appendChild(o); });
      sel.addEventListener('change', async ()=>{ rule.values = sel.value ? [sel.value] : ['']; if(!gDraft){ await persistRules('change:value'); renderList(); } card._updateSave?.(); });
      pCond.appendChild(sel);
    } else {
      const inp=document.createElement('input'); inp.type='text'; inp.value=String(rule.values?.[0]||'');
      inp.addEventListener('input', ()=>{ rule.values=[inp.value]; schedulePersist(); card._updateSave?.(); });
      pCond.appendChild(inp);
    }

    row2.appendChild(pCond);
    card.appendChild(row2);
  }

  // Row 3: targets — both modes use TREE/F PICKERS
  if (gMode==='headings'){
    const row3=document.createElement('div'); row3.className='rule-row';
    const pair=document.createElement('div'); pair.className='pair';
    const lbl=document.createElement('label'); lbl.textContent='Add heading';
    const wrap=document.createElement('div'); wrap.style.position='relative'; wrap.style.display='inline-block';

    const btn=document.createElement('button'); btn.type='button'; btn.className='btn'; btn.textContent='Open headings…';
    wrap.appendChild(btn);

    const pop=document.createElement('div');
    pop.style.position='absolute'; pop.style.top='110%'; pop.style.left='0'; pop.style.zIndex='10';
    pop.style.display='none'; pop.style.minWidth='360px';
    wrap.appendChild(pop);

    function close(){ pop.style.display='none'; document.removeEventListener('click', outside); }
    function outside(e){ if (!wrap.contains(e.target)) close(); }

    btn.addEventListener('click', (e)=>{
      e.stopPropagation();
      if (pop.style.display==='none'){
        const nodes = buildHeadingsTreeNodes();
        renderTreeMenu(pop, nodes, {
          onPick: async (id)=>{
            const already = (rule.targets||[]).some(t=> String(typeof t==='string'? t : t.key)===String(id));
            if (already) return;
            const label = id.includes('|') ? id.split('|').slice(1).join('|') : getHeadingLabelFromKey(String(id));
            rule.targets = rule.targets || []; rule.targets.push({ key:id, label });
            await persistRules('change:addHeading'); renderEditor(); renderList();
          }
        });
        pop.style.display='block';
        setTimeout(()=>document.addEventListener('click', outside),0);
      } else close();
    });

    pair.appendChild(lbl); pair.appendChild(wrap); row3.appendChild(pair); card.appendChild(row3);

  } else {
    // FIELDS PICKER (toggleable)
    const row3=document.createElement('div'); row3.className='rule-row';
    const pair=document.createElement('div'); pair.className='pair';
    const lbl=document.createElement('label'); lbl.textContent='Add field';
    const wrap=document.createElement('div'); wrap.style.position='relative'; wrap.style.display='inline-block';

    const btn=document.createElement('button'); btn.type='button'; btn.className='btn'; btn.textContent='Open fields…';
    wrap.appendChild(btn);

    const pop=document.createElement('div');
    pop.style.position='absolute'; pop.style.top='110%'; pop.style.left='0'; pop.style.zIndex='10';
    pop.style.display='none'; pop.style.minWidth='360px';
    wrap.appendChild(pop);

    function close(){ pop.style.display='none'; document.removeEventListener('click', outside); }
    function outside(e){ if (!wrap.contains(e.target)) close(); }

    btn.addEventListener('click', (e)=>{
      e.stopPropagation();
      if (pop.style.display==='none'){
        const nodes = buildFieldTargetsTree();

        // No disabling: every row is clickable (we will toggle add/remove)
        renderTreeMenu(pop, nodes, {
          disableIds: new Set(),
          onPick: async (pickedId)=>{
            if (pickedId.includes('__opt__')){
              // option node toggle
              const [fieldId, , optSlug] = pickedId.split('__opt__');
              const f = (gSchema.fields||[]).find(x=> String(x.id)===String(fieldId));
              if (!f) return;
              const hit = normOptions(f).find(o => valueToSlug(o.value)===optSlug);
              if (!hit) return;

              if (hasOptionTarget(rule, fieldId, hit.value)){
                // remove child + parent
                removeOneChildAndParent(rule, fieldId, String(hit.value));
                await persistRules('toggle:removeFieldOption'); renderEditor(); renderList();
              } else {
                // add child
                const fieldLabel = f.label || f.id;
                rule.targets = rule.targets || [];
                rule.targets.push({
                  id: String(fieldId),
                  optionValue: String(hit.value),
                  optionLabel: String(hit.label),
                  label: `${fieldLabel}: ${hit.label}`
                });
                await persistRules('toggle:addFieldOption'); renderEditor(); renderList();
              }
              return;
            }

            // parent node toggle
            const fieldId = pickedId;
            if (hasParentTarget(rule, fieldId)){
              removeAllChildren(rule, fieldId);
              removeParent(rule, fieldId);
              await persistRules('toggle:removeFieldAll'); renderEditor(); renderList();
            } else {
              addParentWithAllOptions(rule, fieldId);
              await persistRules('toggle:addFieldAll'); renderEditor(); renderList();
            }
          }
        });
        pop.style.display='block';
        setTimeout(()=>document.addEventListener('click', outside),0);
      } else close();
    });

    pair.appendChild(lbl); pair.appendChild(wrap); row3.appendChild(pair); card.appendChild(row3);
  }

  // Row 4: selected target pills (with cascade remove rules)
  const row4=document.createElement('div'); row4.className='rule-row';
  const lblSel=document.createElement('div'); lblSel.className='muted'; lblSel.textContent=(gMode==='headings'?'Selected headings:':'Selected fields:');
  const pills=document.createElement('div'); pills.className='pills';
  (rule.targets||[]).forEach(t=>{
    const isHead = (gMode==='headings');
    let uniqId, labelText, isParent=false, fieldId=null, optValue=null;

    if (isHead){
      const key = (typeof t==='string'? t : t.key);
      uniqId = String(key);
      labelText = (typeof t==='object' && t.label) ? t.label : getHeadingLabelFromKey(String(key));
    } else {
      fieldId = String(typeof t==='object' ? t.id : t);
      if (typeof t==='object' && t.optionValue!=null){
        optValue = String(t.optionValue);
        uniqId = `${fieldId}__opt__${valueToSlug(optValue)}`;
        labelText = t.label || `${getFieldLabelById(String(fieldId))}: ${t.optionLabel}`;
      } else {
        uniqId = String(fieldId);
        labelText = (typeof t==='object' && t.label) ? t.label : getFieldLabelById(String(fieldId));
        isParent = true;
      }
    }

    const pill=document.createElement('span'); pill.className='pill'; pill.title=uniqId;
    const txt=document.createElement('span'); txt.textContent=labelText || uniqId;
    const x=document.createElement('button'); x.setAttribute('aria-label','Remove'); x.textContent='×';
    x.addEventListener('click', async ()=>{
      if (isHead){
        rule.targets=(rule.targets||[]).filter(z=>{
          const zk = String((typeof z==='string'? z : z.key));
          return zk !== uniqId;
        });
      } else if (isParent){
        removeParent(rule, fieldId);
        removeAllChildren(rule, fieldId);
      } else {
        removeOneChildAndParent(rule, fieldId, optValue);
      }
      await persistRules('change:removeTarget'); renderEditor(); renderList();
    });
    pill.appendChild(txt); pill.appendChild(x); pills.appendChild(pill);
  });
  if (!pills.children.length){ const none=document.createElement('span'); none.className='empty'; none.textContent='(none)'; pills.appendChild(none); }
  row4.appendChild(lblSel); row4.appendChild(pills); card.appendChild(row4);

  mount.appendChild(card);
  if (gDraft) card._updateSave?.();
}

// ------------------------------ RELOAD/SYNC -----------------------------
function applyTabUI(){
  const isHead=gMode==='headings';
  els.tabHeadings.setAttribute('aria-pressed', String(isHead));
  els.tabHeadings.className = 'btn ' + (isHead ? 'btn-secondary' : 'btn-ghost');
  els.tabFields.setAttribute('aria-pressed', String(!isHead));
  els.tabFields.className   = 'btn ' + (!isHead ? 'btn-secondary' : 'btn-ghost');
  els.rulesHint.textContent = isHead
    ? 'SHOW or HIDE specific headings/subheaders based on a field’s selected value(s).'
    : 'SHOW or HIDE specific form fields based on another field’s selected value(s).';
}

// NOTE: we never import rules from payload here; workspace is authoritative.
async function reloadState(reason){
  if (!gDocId) return;
  const st = await window.formSuitePersist.loadState(gDocId) || {};
  if (st.schema) gSchema = st.schema;
  if (Array.isArray(st.headingsTree)) gHeadingsTree = st.headingsTree;

  gRulesHeadings = Array.isArray(st.rules) ? st.rules.slice() : [];
  gRulesFields   = Array.isArray(st.fieldRules) ? st.fieldRules.slice() : [];

  normalizeAllTargets();

  gRules = (gMode==='headings') ? gRulesHeadings.slice() : gRulesFields.slice();
  if (!gRules.find(r=>r?.id===gEditingId)) gEditingId = null;

  setStatus(`Loaded — fields: ${(gSchema.fields||[]).length}, headings: ${(gHeadingsTree||[]).length}, ${gMode==='headings'?'heading-rules':'field-rules'}: ${gRules.length}`);
  renderEditor(); renderList();

  await debugLogPayload(`reload:${reason}`);
}

// tab switches
els.tabHeadings?.addEventListener('click', async ()=>{
  if (gMode==='headings') return;
  gMode='headings'; gDraft=null; gEditingId=null; applyTabUI(); await reloadState('tab:headings');
});
els.tabFields?.addEventListener('click', async ()=>{
  if (gMode==='fields') return;
  gMode='fields'; gDraft=null; gEditingId=null; applyTabUI(); await reloadState('tab:fields');
});

// add rule
els.btnAddRule.addEventListener("click", ()=>{
  gEditingId = null;
  gDraft = { id:null, action:null, fieldId:"", op:null, values:[], targets:[], ...(gMode==='fields'? {hideMode:'hide'} : {}) };
  renderEditor();
  els.editorMount.scrollIntoView({behavior:"smooth", block:"start"});
});

// quick diagnostics (F9)
window.addEventListener('keydown', async (e) => {
  if (e.key === 'F9') {
    const st = await window.formSuitePersist.loadState(gDocId) || {};
    const p  = st?.payload?.CRONOS_PAYLOAD || st?.CRONOS_PAYLOAD || st?.cronos_payload || {};
    console.log('[rules][F9] dump]', {
      docId: gDocId,
      ws_rules: st.rules?.length || 0,
      ws_fieldRules: st.fieldRules?.length || 0,
      ws_rulesVersion: st.rulesVersion || null,
      pl_rules: p.rules?.length || 0,
      pl_fieldRules: p.fieldRules?.length || 0,
      pl_rulesVersion: p.rulesVersion || null,
      ls_has_plain: !!localStorage.getItem('CRONOS_PAYLOAD'),
      ls_has_scoped: !!localStorage.getItem(`CRONOS_PAYLOAD:${gDocId}`),
      ls_stamp: localStorage.getItem(`FS_RULES_STAMP:${gDocId}`)
    });
  }
});

// boot
(function boot(){
  try{
    try { window.formSuitePersist?.ensureHydrated?.(); } catch {}
    const meta = window.formSuitePersist?.getActiveDoc?.sync?.()
              || window.formSuitePersist?.getCurrentDocMeta?.()
              || (function(){ try{ const v=localStorage.getItem(ACTIVE_LS_KEY); return v? JSON.parse(v):null; } catch { return null; } })();
    if (!meta?.docId){ setStatus("No active document. Open one first."); return; }
    gDocId = meta.docId;
    applyTabUI();
    reloadState("boot");
  } catch(e){ console.error("boot failed:", e); setStatus("Failed to load state."); }
})();
</script>
</body>
</html>
