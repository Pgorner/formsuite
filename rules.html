<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <title>Form Suite — Regeln</title>
  <link rel="icon" href="favicon.ico" type="image/gif" sizes="32x32">
  <link rel="shortcut icon" href="favicon.ico" type="image/gif">
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <!-- flatpickr -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/themes/material_blue.css">
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

  <link rel="stylesheet" href="style.css">

  <!-- Canonical plumbing -->
  <script src="persistence.js"></script>
  <script src="fs-active-doc.js"></script>
  <script src="fs-focus-nav.js"></script>
</head>

<body class="rules">
<header>
  <div class="row">
    <span class="brand logo-md">
      <img src="logo.gif" alt="Form Suite Logo" class="logo" />
      <strong>Form Suite</strong>
    </span>
    <span class="muted">·</span><a href="index.html">Formular</a>
    <span class="muted">·</span><a href="builder.html">Formular-Builder</a>
    <span class="muted">·</span><a href="matcher.html">Tag-Zuordnung</a>
    <span class="muted">·</span><span class="muted">Regeln</span>
    <span class="muted">·</span><a href="extractor.html">Extraktor</a>
  </div>
</header>

<main>
  <section class="panel">
    <div class="row" style="justify-content:space-between; align-items:center">
      <h2 style="margin:0">Regeln</h2>

      <div id="rulesTabs" class="row" style="margin-left:8px; gap:6px;">
        <button id="tabHeadings" class="btn btn-secondary" aria-pressed="true">Überschriften</button>
        <button id="tabFields" class="btn btn-ghost" aria-pressed="false">Felder</button>
      </div>

      <div class="row">
        <span id="status" class="muted" style="margin-right:10px"></span>
        <button id="btnAddRule" class="btn btn-primary">Regel hinzufügen</button>
      </div>
    </div>

    <div class="muted-note" id="rulesHint" style="margin-top:6px">
      Bestimmte Überschriften/Unterüberschriften oder Formularfelder abhängig von Feldwert(en) EIN- oder AUSBLENDEN.
    </div>
  </section>

  <section class="panel" id="editorMount">
    <div class="empty">Noch keine Regeln — klicke auf „Regel hinzufügen“.</div>
  </section>

  <section class="panel">
    <h3 style="margin-top:0">Vorhandene Regeln</h3>
    <div id="rulesList" class="rules-list">
      <div class="empty">Keine.</div>
    </div>
  </section>
</main>

<script>
/* ------------------------------------------------------------------ *
 * Bulletproof Rules editor (canonical, no LS/legacy broadcasts)
 * ------------------------------------------------------------------ */

const nowt = () => new Date().toISOString().slice(11,23);

const els = {
  status:      document.getElementById("status"),
  btnAddRule:  document.getElementById("btnAddRule"),
  editorMount: document.getElementById("editorMount"),
  rulesList:   document.getElementById("rulesList"),
  tabHeadings: document.getElementById("tabHeadings"),
  tabFields:   document.getElementById("tabFields"),
  rulesHint:   document.getElementById("rulesHint"),
};

const bcPayload = ("BroadcastChannel" in window) ? new BroadcastChannel("fs-payload-v1") : null;

const setStatus = (s) => { try { els.status.textContent = s || ""; } catch {} };
const debounce = (fn, ms)=>{ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a), ms); }; };

const slugify = (s)=> String(s||"")
  .normalize('NFKD')
  .replace(/[\u0300-\u036f]/g,'')
  .replace(/[^a-zA-Z0-9]+/g,'_')
  .replace(/^_+|_+$/g,'')
  .toLowerCase();

const valueToSlug = (v)=> slugify(String(v));
const ACTIONS = new Set(["SHOW","HIDE"]);

const isMultiOption = (t) => ['multichoice','multiselect'].includes(t);
const isSelectLike  = (t) => ['select','dropdown','singlechoice','choice','single','combobox','list'].includes(t);
const isNumericLike = (t) => ['datediff','duration','number'].includes(t);

// app state
let gDoc = null;
let gDocId = null;
let gSchema = { title:"Formular", fields:[] };
let gHeadingsTree = [];
let gHeadingsFlat = [];
let gMode = 'headings'; // 'headings' | 'fields'
let gRulesHeadings = [];
let gRulesFields   = [];
let gRules = [];
let gEditingId = null;
let gDraft = null;

let __reloadBusy = false;
let __reloadPending = false;
let __suppressNextPayloadReload = false;

/* ------------------------- small utils ------------------------- */

function safeArr(x){ return Array.isArray(x) ? x : []; }

function deepClone(x){
  try { return JSON.parse(JSON.stringify(x)); } catch { return x; }
}

function parseStamp(v){
  const n = Number(v);
  return Number.isFinite(n) ? n : 0;
}

function stampOf(payloadOrState){
  if (!payloadOrState) return 0;
  const v = payloadOrState.rulesVersion ?? payloadOrState.updatedAt ?? payloadOrState.ts ?? payloadOrState.stamp;
  if (typeof v === 'number') return parseStamp(v);
  if (typeof v === 'string') {
    const asNum = parseStamp(v);
    if (asNum) return asNum;
    const d = Date.parse(v);
    return Number.isFinite(d) ? d : 0;
  }
  return 0;
}

function getFieldLabelById(id){
  const f = (gSchema.fields||[]).find(x => String(x.id)===String(id));
  return f?.label || f?.name || f?.id || String(id);
}

function normOptions(field){
  const raw = field && field.options || [];
  return raw.map(o => {
    if (o && typeof o === "object") {
      const value = (o.value ?? o.id ?? o.key ?? o.code ?? String(o));
      const label = (o.label ?? o.text ?? o.name ?? String(value));
      return { value:String(value), label:String(label) };
    }
    return { value:String(o), label:String(o) };
  });
}

/* ------------------------- DEBUG logger ------------------------- */
async function debugLogPayload(where) {
  try {
    const st = await window.formSuitePersist.loadState(gDocId) || {};
    const payload =
        (st?.payload?.CRONOS_PAYLOAD)
     || (st?.CRONOS_PAYLOAD)
     || (st?.cronos_payload)
     || {};
    const wsRules      = safeArr(st.rules);
    const wsFieldRules = safeArr(st.fieldRules);

    console.groupCollapsed(`[rules][${where}] docId=${gDocId}`);
    console.log('workspace.rules        (%d):', wsRules.length, wsRules);
    console.log('workspace.fieldRules   (%d):', wsFieldRules.length, wsFieldRules);
    console.log('workspace.rulesVersion :', st.rulesVersion);
    console.log('payload.rules          (%d):', safeArr(payload.rules).length, payload.rules || []);
    console.log('payload.fieldRules     (%d):', safeArr(payload.fieldRules).length, payload.fieldRules || []);
    console.log('payload.rulesVersion   :', payload.rulesVersion);
    console.log('payload.updatedAt      :', payload.updatedAt);
    console.groupEnd();
  } catch (e) {
    console.error('[rules][debugLogPayload] failed', e);
  }
}

/* ------------------------- heading helpers ------------------------- */

function flattenWithNumbers(tree){
  const out=[], counters=[];
  function walk(nodes, depth){
    counters[depth]=0;
    for (const n of (nodes||[])){
      counters[depth]++;
      const number = counters.slice(0, depth+1).join(".");
      const label = (n.label?.trim?.() ? n.label : n.text) || "";
      out.push({
        key: String(n.idx ?? number),
        label: number + " " + label,
        titleOnly: label,
        number,
        level: n.level || (depth+1)
      });
      if (n.children?.length) walk(n.children, depth+1);
    }
  }
  walk(tree||[],0);
  return out;
}

// kept resolver logic
function buildHeadingTargetIndex(baseline) {
  const flat = Array.isArray(baseline?.flat)
    ? baseline.flat
    : Array.isArray(baseline) ? baseline
    : Array.isArray(baseline?.headings) ? baseline.headings
    : [];
  const tree = Array.isArray(baseline?.tree)
    ? baseline.tree
    : Array.isArray(baseline?.headingsTree) ? baseline.headingsTree
    : [];

  const byIdx = new Map();
  const byUid = new Map();
  const byComposite = new Map();
  const byNumber = new Map();

  const normComposite = (entry) => {
    const idx = Number(entry?.idx ?? entry?.key);
    const text = entry?.text || entry?.title || entry?.label || '';
    const num = entry?.number || entry?.num;
    if (num) return `${String(num)}|${text}`.trim();
    if (Number.isFinite(idx)) return `${idx + 1}|${text}`.trim();
    return text ? `|${text}` : '';
  };

  const add = (entry) => {
    if (!entry) return;
    const idx = Number(entry.idx ?? entry.key);
    if (Number.isFinite(idx) && !byIdx.has(idx)) byIdx.set(idx, entry);
    const uid = entry.uid || entry.id;
    if (uid && !byUid.has(String(uid))) byUid.set(String(uid), entry);
    const num = entry.number || entry.num;
    if (num && !byNumber.has(String(num))) byNumber.set(String(num), entry);
    const composite = entry.compositeKey || normComposite(entry);
    if (composite) {
      if (!byComposite.has(composite)) byComposite.set(composite, entry);
      const head = composite.split('|', 1)[0];
      if (head && !byNumber.has(head)) byNumber.set(head, entry);
    }
  };

  flat.forEach(add);

  const walk = (nodes) => {
    if (!Array.isArray(nodes)) return;
    nodes.forEach((n) => {
      add(n);
      if (Array.isArray(n.children) && n.children.length) walk(n.children);
    });
  };
  walk(tree);

  const resolve = (target) => {
    if (target && typeof target === 'object') {
      if (target.uid && byUid.has(String(target.uid))) return byUid.get(String(target.uid));
      if (target.idx != null) {
        const idx = Number(target.idx);
        if (Number.isFinite(idx)) {
          if (byIdx.has(idx)) return byIdx.get(idx);
          const legacy = idx - 1;
          if (byIdx.has(legacy)) return byIdx.get(legacy);
        }
      }
      if (target.key != null) {
        const idx = Number(target.key);
        if (Number.isFinite(idx)) {
          if (byIdx.has(idx)) return byIdx.get(idx);
          const legacy = idx - 1;
          if (byIdx.has(legacy)) return byIdx.get(legacy);
        }
        const keyStr = String(target.key);
        if (byComposite.has(keyStr)) return byComposite.get(keyStr);
        if (byNumber.has(keyStr)) return byNumber.get(keyStr);
      }
      if (target.label) {
        const lbl = String(target.label);
        const head = lbl.split(' ')[0];
        if (byNumber.has(head)) return byNumber.get(head);
      }
    }

    const rawStr = String((target && typeof target === 'object')
      ? (target.key ?? target.idx ?? target.id ?? target.uid ?? target.number ?? '')
      : target ?? '').trim();

    if (rawStr) {
      if (byComposite.has(rawStr)) return byComposite.get(rawStr);
      if (byUid.has(rawStr)) return byUid.get(rawStr);
      if (byNumber.has(rawStr)) return byNumber.get(rawStr);
      const num = Number(rawStr.includes('|') ? rawStr.split('|',1)[0] : rawStr);
      if (Number.isFinite(num)) {
        if (byIdx.has(num)) return byIdx.get(num);
        const legacy = num - 1;
        if (byIdx.has(legacy)) return byIdx.get(legacy);
      }
    }
    return null;
  };

  const resolveIdx = (target) => {
    const entry = resolve(target);
    if (entry && Number.isFinite(Number(entry.idx))) return Number(entry.idx);
    const raw = (target && typeof target === 'object')
      ? (target.key ?? target.idx ?? target.id ?? target.number ?? target.uid ?? null)
      : target;
    const n = Number(raw);
    return Number.isFinite(n) ? n : NaN;
  };

  const buildLabel = (entry, fallback) => {
    if (!entry) return fallback || '';
    const text = entry.text || entry.title || entry.label || '';
    const num = entry.number || entry.num;
    if (num) return `${num} ${text}`.trim();
    if (text) return text;
    return fallback || '';
  };

  const normalizeTarget = (target) => {
    const entry = resolve(target);
    let idx = entry ? Number(entry.idx) : resolveIdx(target);
    if (!Number.isFinite(idx)) return null;

    const normalized = { key: idx, idx };
    if (entry?.uid) normalized.uid = entry.uid;
    else if (target && typeof target === 'object' && target.uid) normalized.uid = target.uid;

    const fallbackLabel = (target && typeof target === 'object') ? target.label : null;
    const label = buildLabel(entry, fallbackLabel) || `Überschrift ${idx + 1}`;
    normalized.label = label;

    const number = entry?.number || entry?.num;
    normalized.number = number ? String(number) : String(idx + 1);

    return normalized;
  };

  return { resolve, resolveIdx, normalizeTarget, buildLabel };
}

function currentHeadingIndex() {
  return buildHeadingTargetIndex({ flat: gHeadingsFlat, tree: gHeadingsTree });
}

function getHeadingLabelFromKey(key){
  if (!key) return '';
  if (String(key).includes('|')) return String(key).split('|').slice(1).join('|');
  const flat = flattenWithNumbers(gHeadingsTree);
  const hit = flat.find(h => h.number === String(key));
  return hit?.titleOnly || String(key);
}

function normalizeHeadingsRuleTargetsInPlace(rule){
  if (!rule || !Array.isArray(rule.targets)) return {changed:false};
  const idx = currentHeadingIndex();
  let changed=false;
  rule.targets = rule.targets.map(t=>{
    if (t == null) return t;
    const normalized = idx.normalizeTarget(t);
    if (!normalized) return t;
    const same = (typeof t === 'object')
      ? (Number(t.key ?? t.idx) === normalized.idx
         && t.label === normalized.label
         && (t.uid ?? null) === (normalized.uid ?? null))
      : false;
    if (!same) changed = true;
    return normalized;
  }).filter(Boolean);
  return {changed};
}

function normalizeFieldTargetsInPlace(rule){
  if (!rule || !Array.isArray(rule.targets)) return {changed:false};
  const fieldLabel = new Map((gSchema.fields||[]).map(f=>[String(f.id), f.label||f.name||f.id]));
  let changed=false;

  rule.targets = rule.targets.map(t=>{
    if (!t) return t;

    if (typeof t==='string'){
      changed=true;
      return { id:t, label: fieldLabel.get(String(t)) || String(t) };
    }

    const id = String(t.id||'');
    const parentLabel = fieldLabel.get(id) || id;

    if ('optionValue' in t){
      const optionValue = String(t.optionValue ?? '');
      const optionLabel = String(t.optionLabel ?? '');
      const composed = t.label || `${parentLabel}: ${optionLabel || optionValue}`;
      const out = { id, optionValue, optionLabel, label: composed };
      if (t.id!==id || t.optionValue!==optionValue || t.optionLabel!==optionLabel || t.label!==composed) changed=true;
      return out;
    }

    const out = { id, label: parentLabel };
    if (t.label!==out.label) changed=true;
    return out;
  });

  return {changed};
}

function normalizeAllTargets(){
  (gRulesHeadings||[]).forEach(r=> normalizeHeadingsRuleTargetsInPlace(r));
  (gRulesFields||[]).forEach(r=> normalizeFieldTargetsInPlace(r));
}

/* ------------------------- condition sources ------------------------- */
function buildConditionSources(schema){
  const out=[]; const seen=new Set();
  for (const f of (schema?.fields||[])){
    const t=String(f.type||'').toLowerCase(); const id=String(f.id); const label=f.label||f.id;

    if (t==='boolean'||t==='checkbox'||t==='switch'){
      if(!seen.has(id)){ seen.add(id); out.push({id,label,type:'boolean'}); }
      continue;
    }

    if (isMultiOption(t)){
      if(!seen.has(id)){ seen.add(id); out.push({id,label,type:'boolean',meta:{anySelected:true}}); }
      const items=[];
      if (Array.isArray(f.options)) items.push(...f.options);
      if (f.mc?.groups) (f.mc.groups||[]).forEach(g=> (g.items||[]).forEach(it=>items.push(it)));
      items.forEach(it=>{
        const rawV = it && typeof it==='object' ? (it.value ?? it.label ?? it.text ?? it.name ?? '') : it;
        const rawL = it && typeof it==='object' ? (it.label ?? it.text ?? it.name ?? rawV) : rawV;
        const v=String(rawV||'').trim(); const l=String(rawL||'').trim(); const sl=slugify(v);
        if (!v||!sl) return;
        const optId = `${id}__opt__${sl}`;
        if (seen.has(optId)) return;
        seen.add(optId); out.push({id:optId, label:`${label}: ${l}`, type:'boolean'});
      });
      continue;
    }

    if (t==='date'){ if(!seen.has(id)){ seen.add(id); out.push({id,label,type:'date'});} continue; }
    if (isNumericLike(t)){ if(!seen.has(id)){ seen.add(id); out.push({id,label,type:'number'});} continue; }
    if (isSelectLike(t)){
      if(!seen.has(id)){
        seen.add(id);
        out.push({
          id,label,type:'select',
          options:(f.options||[]).map(o=> (o&&typeof o==='object')? String(o.value??o.label??o) : String(o))
        });
      }
      continue;
    }
    if (t==='text'||t==='string'||t==='textarea'){ if(!seen.has(id)){ seen.add(id); out.push({id,label,type:'text'});} continue; }
    if(!seen.has(id)){ seen.add(id); out.push({id,label,type:'text'}); }
  }
  return out;
}

function isRuleValid(rule){
  if (!rule || !ACTIONS.has(rule.action)) return false;
  const srcs = buildConditionSources(gSchema);
  const src = srcs.find(s=>String(s.id)===String(rule.fieldId));
  if (!src) return false;

  const allowed = (src.type==='boolean')?['equals']
                : (src.type==='date')?['before','equals','after']
                : (src.type==='text')?['equals','notEquals','contains']
                : (src.type==='number')?['equals','notEquals']
                : (src.type==='select')?['equals','notEquals']
                : ['equals'];

  if (!allowed.includes(rule.op)) return false;
  if (!Array.isArray(rule.values)) return false;
  if (!Array.isArray(rule.targets) || rule.targets.length===0) return false;
  return true;
}

/* ------------------------- pickers (same UI logic) ------------------------- */

function flattenTreeLines(nodes, prefixBag=[], out=[]){
  (nodes||[]).forEach((node, idx) => {
    const isLast = idx === nodes.length - 1;
    const prefix = prefixBag.map(last => last ? '   ' : '│  ').join('') + (prefixBag.length ? (isLast ? '└─ ' : '├─ ') : '');
    out.push({ id: String(node.id), text: prefix + (node.label || node.id) });
    if (node.children && node.children.length){
      flattenTreeLines(node.children, [...prefixBag, isLast], out);
    }
  });
  return out;
}

function renderTreeMenu(container, nodes, { currentId=null, onPick, disableIds=new Set() } = {}){
  container.innerHTML = '';
  container.className = 'tree-menu';
  container.style.maxHeight = '260px';
  container.style.overflow = 'auto';
  container.style.padding = '6px 0';
  container.style.border = '1px solid var(--border)';
  container.style.borderRadius = '6px';
  container.style.background = 'var(--card)';
  container.style.fontFamily = 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
  container.style.fontSize = '12.5px';

  const list = document.createElement('div');
  list.setAttribute('role','listbox');

  const lines = flattenTreeLines(nodes);
  lines.forEach(({id, text})=>{
    const row = document.createElement('div');
    row.setAttribute('role','option');
    row.dataset.id = id;
    row.textContent = text;
    row.style.whiteSpace = 'pre';
    row.style.padding = '2px 10px';
    row.style.cursor = disableIds.has(id) ? 'not-allowed' : 'pointer';
    row.style.userSelect = 'none';

    if (String(currentId) === String(id)){
      row.style.background = 'var(--primary-ghost, rgba(0,0,0,0.06))';
      row.style.fontWeight = '600';
    }
    if (disableIds.has(id)){
      row.classList.add('muted');
      row.style.opacity = '0.55';
      row.style.pointerEvents = 'none';
    }

    row.addEventListener('mouseenter', ()=>{ if (!disableIds.has(id)) row.style.background='rgba(0,0,0,0.05)'; });
    row.addEventListener('mouseleave', ()=>{ if (String(currentId) !== String(id)) row.style.background='transparent'; });

    if (!disableIds.has(id)){
      row.addEventListener('click', ()=> onPick && onPick(id));
    }
    list.appendChild(row);
  });

  container.appendChild(list);
}

function buildConditionTree(schema){
  const flat = buildConditionSources(schema) || [];
  const byId = new Map();
  const roots = [];
  for (const f of (schema?.fields || [])) {
    const id = String(f.id);
    const label = f.label || f.id;
    const type = String(f.type || '').toLowerCase();
    const node = { id, label, type, children: [] };
    byId.set(id, node);
    roots.push(node);
  }
  for (const src of flat) {
    const sid = String(src.id || '');
    if (!sid.includes('__opt__')) continue;
    const parentId = sid.split('__opt__')[0];
    const parent = byId.get(parentId);
    if (!parent) continue;
    parent.children.push({ id: sid, label: src.label, type: src.type || 'boolean', children: [] });
  }
  return roots;
}

function buildHeadingsTreeNodes(){
  function walk(nodes, depth, counters){
    const out = [];
    counters[depth] = 0;

    (nodes || []).forEach(n => {
      counters[depth]++;
      const number = counters.slice(0, depth + 1).join('.');
      const title  = (n.label?.trim?.() ? n.label : n.text) || '';
      const idx = Number(n.idx);
      const id  = Number.isFinite(idx) ? String(idx) : `${number}|${title}`;

      out.push({
        id,
        label: `${number} ${title}`.trim(),
        children: walk(n.children || [], depth + 1, counters.slice())
      });
    });

    return out;
  }
  return walk(gHeadingsTree || [], 0, []);
}

function buildFieldTargetsTree(){
  const nodes=[];
  for (const f of (gSchema.fields||[])){
    const id = String(f.id);
    const type = String(f.type||'').toLowerCase();
    const node = { id, label: f.label || f.id, children: [] };

    if (isMultiOption(type) || isSelectLike(type)){
      const opts = normOptions(f);
      node.children = opts.map(o => ({
        id: `${id}__opt__${valueToSlug(o.value)}`,
        value:String(o.value),
        label: String(o.label),
        children: []
      }));
    }
    nodes.push(node);
  }
  return nodes;
}

/* ------------------------- field target toggles ------------------------- */
function hasParentTarget(rule, fieldId){
  return (rule.targets||[]).some(t => t && typeof t==='object' && String(t.id)===String(fieldId) && !('optionValue' in t));
}
function hasOptionTarget(rule, fieldId, optionValue){
  return (rule.targets||[]).some(t => t && typeof t==='object'
    && String(t.id)===String(fieldId)
    && String(t.optionValue)===String(optionValue));
}
function addParentWithAllOptions(rule, fieldId){
  const f = (gSchema.fields||[]).find(x=> String(x.id)===String(fieldId));
  if (!f) return;
  const fieldLabel = f.label || f.id;
  const type = String(f.type||'').toLowerCase();
  if (!hasParentTarget(rule, fieldId)){
    rule.targets = rule.targets || [];
    rule.targets.push({ id:String(fieldId), label: fieldLabel });
  }
  if (isMultiOption(type) || isSelectLike(type)){
    const opts = normOptions(f);
    opts.forEach(o => {
      if (!hasOptionTarget(rule, fieldId, o.value)){
        rule.targets.push({
          id: String(fieldId),
          optionValue: String(o.value),
          optionLabel: String(o.label),
          label: `${fieldLabel}: ${o.label}`
        });
      }
    });
  }
}
function removeParent(rule, fieldId){
  rule.targets = (rule.targets||[]).filter(t => !(t && typeof t==='object' && String(t.id)===String(fieldId) && !('optionValue' in t)));
}
function removeAllChildren(rule, fieldId){
  rule.targets = (rule.targets||[]).filter(t => !(t && typeof t==='object' && String(t.id)===String(fieldId) && ('optionValue' in t)));
}
function removeOneChildAndParent(rule, fieldId, optionValue){
  rule.targets = (rule.targets||[]).filter(t => !(t && typeof t==='object'
    && String(t.id)===String(fieldId)
    && String(t.optionValue)===String(optionValue)));
  removeParent(rule, fieldId);
}

/* ------------------------- CANONICAL persistence ------------------------- */

async function persistRules(reason) {
  if (!gDocId) return;

  normalizeAllTargets();

  const rules      = deepClone(gRulesHeadings || []);
  const fieldRules = deepClone(gRulesFields   || []);
  const stamp = Date.now();

  try {
    const r0 = rules[0] || null;
    const f0 = fieldRules[0] || null;
    const r0t = (r0 && Array.isArray(r0.targets) && r0.targets[0]) ? r0.targets[0] : null;
    const f0t = (f0 && Array.isArray(f0.targets) && f0.targets[0]) ? f0.targets[0] : null;
    console.log(`[DBG rules.persistRules] ${nowt()} reason=${reason} mode=${gMode} rules=${rules.length} fieldRules=${fieldRules.length} r0.id=${r0?.id||''} r0.t=${r0t?JSON.stringify(r0t):''} f0.id=${f0?.id||''} f0.t=${f0t?JSON.stringify(f0t):''}`);
  } catch {}

  console.log(`[${nowt()}] WRITE (${reason}) rules=${rules.length}, fieldRules=${fieldRules.length}`);

  __suppressNextPayloadReload = true;
  try {
    if (window.formSuitePersist?.setState) {
      // Minimal patch: persistence.js is responsible for mirroring into payload.CRONOS_PAYLOAD and broadcasting fs-payload-v1
      await window.formSuitePersist.setState(gDocId, {
        rules,
        fieldRules,
        rulesVersion: stamp
      });
    } else {
      await window.formSuitePersist.saveState(gDocId, {
        rules,
        fieldRules,
        rulesVersion: stamp
      });
    }
  } catch (e) {
    console.error('[rules] persistRules: write failed', e);
    throw e;
  } finally {
    setTimeout(() => { __suppressNextPayloadReload = false; }, 50);
  }

  // Verify (workspace + payload should both match after persistence mirrors)
  try {
    const st1 = await window.formSuitePersist.loadState(gDocId) || {};
    const p1  = st1?.payload?.CRONOS_PAYLOAD || st1?.CRONOS_PAYLOAD || st1?.cronos_payload || {};
    const ok  = safeArr(st1.rules).length === rules.length
             && safeArr(st1.fieldRules).length === fieldRules.length
             && safeArr(p1.rules).length === rules.length
             && safeArr(p1.fieldRules).length === fieldRules.length
             && (p1.rulesVersion === stamp || st1.rulesVersion === stamp);

    console.log(
      `[${nowt()}] VERIFY after persist → workspace: r=${safeArr(st1.rules).length}/${rules.length}, fr=${safeArr(st1.fieldRules).length}/${fieldRules.length}; ` +
      `payload: r=${safeArr(p1.rules).length}/${rules.length}, fr=${safeArr(p1.fieldRules).length}/${fieldRules.length}; ` +
      `stamp=${stamp} ok=${ok}`
    );
  } catch (e) {
    console.warn('[rules] read-back verification failed', e);
  }

  await debugLogPayload(`persist:${reason}`);
}

/* ------------------------- reconcile/restore ------------------------- */

async function reconcileAndAutoRestoreIfNeeded(reason){
  if (!gDocId) return;

  const st = await window.formSuitePersist.loadState(gDocId) || {};
  const wsRules      = safeArr(st.rules);
  const wsFieldRules = safeArr(st.fieldRules);
  const wsStamp      = stampOf(st);

  const payload = (st?.payload?.CRONOS_PAYLOAD) || st?.CRONOS_PAYLOAD || st?.cronos_payload || {};
  const plRules      = safeArr(payload.rules);
  const plFieldRules = safeArr(payload.fieldRules);
  const plStamp      = stampOf(payload);

  // Choose best between workspace and payload (no localStorage sources)
  let best = { src:'workspace', stamp: wsStamp, rules: wsRules, fieldRules: wsFieldRules };
  if (plStamp > best.stamp) best = { src:'payload', stamp: plStamp, rules: plRules, fieldRules: plFieldRules };

  // Special case: workspace got clobbered (empty) while payload has rules
  if (best.src === 'workspace' && wsRules.length === 0 && plRules.length) {
    best = { src:'payload', stamp: plStamp, rules: plRules, fieldRules: plFieldRules };
  }

  const shouldRestore =
      (best.src !== 'workspace')
   && (wsRules.length === 0 || wsStamp < best.stamp);

  if (!shouldRestore) return;

  console.warn(`[rules] AUTO-RESTORE (${reason}) from ${best.src} stamp=${best.stamp} → workspace was r=${wsRules.length},fr=${wsFieldRules.length},stamp=${wsStamp}`);

  try {
    if (window.formSuitePersist?.setState) {
      await window.formSuitePersist.setState(gDocId, {
        rules: best.rules,
        fieldRules: best.fieldRules,
        rulesVersion: best.stamp || Date.now()
      });
    } else {
      await window.formSuitePersist.saveState(gDocId, {
        rules: best.rules,
        fieldRules: best.fieldRules,
        rulesVersion: best.stamp || Date.now()
      });
    }
  } catch (e) {
    console.error('[rules] AUTO-RESTORE write failed', e);
  }
}

/* ------------------------- UI + rendering ------------------------- */

function applyTabUI(){
  const isHead=gMode==='headings';
  els.tabHeadings.setAttribute('aria-pressed', String(isHead));
  els.tabHeadings.className = 'btn ' + (isHead ? 'btn-secondary' : 'btn-ghost');
  els.tabFields.setAttribute('aria-pressed', String(!isHead));
  els.tabFields.className   = 'btn ' + (!isHead ? 'btn-secondary' : 'btn-ghost');
  els.rulesHint.textContent = isHead
    ? 'Bestimmte Überschriften/Unterüberschriften abhängig von Feldwert(en) EIN- oder AUSBLENDEN.'
    : 'Bestimmte Formularfelder abhängig von Feldwert(en) eines anderen Feldes EIN- oder AUSBLENDEN.';
}

function summarizeCondition(rule){
  const srcs = buildConditionSources(gSchema);
  const src = srcs.find(s=>String(s.id)===String(rule.fieldId));
  const srcLabel = src?.label || getFieldLabelById(rule.fieldId) || String(rule.fieldId);
  const op = rule.op || 'equals';
  const v0 = Array.isArray(rule.values) ? rule.values[0] : rule.values;

  if (!src) return `wenn ${srcLabel} ${op} ${JSON.stringify(v0)}`;
  if (src.type==='boolean') return `wenn ${srcLabel} ${op} ${String(v0)}`;
  if (src.type==='date')    return `wenn ${srcLabel} ${op} ${String(v0||'')}`;
  if (src.type==='text')    return `wenn ${srcLabel} ${op} "${String(v0||'')}"`;
  if (src.type==='number')  return `wenn ${srcLabel} ${op} ${String(v0)}`;
  if (src.type==='select') {
    const base = (gSchema.fields||[]).find(ff => String(ff.id)===String(src.id));
    const options = base ? normOptions(base) : (src.options||[]).map(x=>({value:String(x),label:String(x)}));
    const label = options.find(o=>String(o.value)===String(v0))?.label ?? String(v0||'');
    return `wenn ${srcLabel} ${op} "${label}"`;
  }
  return `wenn ${srcLabel} ${op}`;
}

function renderList(){
  els.rulesList.innerHTML = "";
  const list = gRules || [];
  if (!list.length){ els.rulesList.innerHTML = '<div class="empty">Keine.</div>'; return; }

  list.forEach(r=>{
    const row = document.createElement('div'); row.className='item';
    const left = document.createElement('div');

    const labels = (gMode==='headings')
      ? (r.targets||[]).map(t=> (typeof t==='object' && t.label) ? t.label : getHeadingLabelFromKey(String((typeof t==='string')? t : (t.key||''))) ).filter(Boolean)
      : (r.targets||[]).map(t=>{
          if (typeof t==='object'){
            if (t.optionLabel!=null) return t.label || `${getFieldLabelById(String(t.id))}: ${t.optionLabel}`;
            return t.label || getFieldLabelById(String(t.id));
          }
          return getFieldLabelById(String(t));
        }).filter(Boolean);

    left.innerHTML = `<strong>${r.action}</strong> — <em>${labels.join(', ') || '(keine Ziele ausgewählt)'}</em> <span class="muted">${summarizeCondition(r)}</span>`;

    const right = document.createElement('div'); right.style.display='flex'; right.style.gap='8px';

    const edit = document.createElement('button'); edit.className='btn btn-ghost'; edit.textContent='Bearbeiten';
    edit.addEventListener('click', ()=>{ gDraft=null; gEditingId=r.id; renderEditor(); });

    const del = document.createElement('button'); del.className='btn btn-danger'; del.textContent='Löschen';
    del.addEventListener('click', async ()=>{
      if (!confirm('Diese Regel löschen?')) return;
      const arr = (gMode==='headings') ? gRulesHeadings : gRulesFields;
      const idx = arr.findIndex(x=>x.id===r.id);
      if (idx>=0) arr.splice(idx,1);
      gRules = (gMode==='headings') ? gRulesHeadings.slice() : gRulesFields.slice();
      if (gEditingId === r.id) gEditingId = null;
      await persistRules('delete');
      renderEditor(); renderList();
    });

    right.appendChild(edit); right.appendChild(del);
    row.appendChild(left); row.appendChild(right);
    els.rulesList.appendChild(row);
  });
}

function currentEditorRule(){
  if (gDraft) return gDraft;
  if (gEditingId) return (gRules||[]).find(r=>r.id===gEditingId) || null;
  return null;
}

function getMultiOptionHeaderIdsForConditions(){
  const ids = new Set();
  for (const f of (gSchema?.fields || [])){
    const t = String(f.type || '').toLowerCase();
    if (isMultiOption(t)) ids.add(String(f.id));
  }
  return ids;
}

/* ------------------------- editor (unchanged UI, canonical writes) ------------------------- */

function renderEditor(){
  const mount = els.editorMount;
  mount.innerHTML = "";
  const rule = currentEditorRule();
  if (!rule){ mount.innerHTML = '<div class="empty">Noch keine Regeln — klicke auf „Regel hinzufügen“.</div>'; return; }

  if (gMode==='headings') normalizeHeadingsRuleTargetsInPlace(rule);
  else normalizeFieldTargetsInPlace(rule);

  const card = document.createElement('div'); card.className='rule-card'; card.dataset.id = rule.id || 'draft';

  if (gDraft){
    const top = document.createElement('div'); top.className='row'; top.style.justifyContent='flex-end'; top.style.gap='8px';
    const btnCancel = document.createElement('button'); btnCancel.className='btn btn-ghost'; btnCancel.textContent='Abbrechen';
    btnCancel.addEventListener('click', ()=>{ gDraft=null; renderEditor(); });

    const btnSave = document.createElement('button'); btnSave.className='btn btn-primary'; btnSave.textContent='Regel speichern';
    btnSave.disabled = !isRuleValid(rule);
    btnSave.addEventListener('click', async ()=>{
      if (!isRuleValid(rule)){ alert('Bitte vervollständige die Regel.'); return; }
      rule.id = "r_"+Math.random().toString(36).slice(2,8);
      if (gMode==='headings') gRulesHeadings.push(rule); else gRulesFields.push(rule);
      gDraft=null;
      gRules = (gMode==='headings')? gRulesHeadings.slice() : gRulesFields.slice();
      console.log(`[${nowt()}] CREATE ${JSON.stringify(rule)}`);
      await persistRules('create');
      renderEditor(); renderList();
    });

    card._updateSave = ()=> { btnSave.disabled = !isRuleValid(currentEditorRule()); };

    top.appendChild(btnCancel); top.appendChild(btnSave); card.appendChild(top);
  }

  const row1 = document.createElement('div'); row1.className='rule-row';

  // Action
  const pAction = document.createElement('div'); pAction.className='pair';
  const lblA = document.createElement('label'); lblA.textContent='Aktion';
  const selA = document.createElement('select');
  const defAct = document.createElement('option'); defAct.value=''; defAct.textContent='Auswählen…';
  if (gDraft && !rule.action) selA.appendChild(defAct);
  ['SHOW','HIDE'].forEach(a=>{
    const o=document.createElement('option'); o.value=a; o.textContent=a;
    if(rule.action===a) o.selected=true; selA.appendChild(o);
  });
  selA.addEventListener('change', async ()=>{
    rule.action = selA.value || null;
    if (!gDraft){ await persistRules('change:action'); renderList(); }
    card._updateSave?.();
  });
  pAction.appendChild(lblA); pAction.appendChild(selA);
  row1.appendChild(pAction);

  // Effect (fields only)
  if (gMode==='fields'){
    const pEffect = document.createElement('div'); pEffect.className='pair';
    const lblE = document.createElement('label'); lblE.textContent='Effekt';
    const selE = document.createElement('select');
    ;[{v:'hide',t:'ausblenden (entfernen)'},{v:'disable',t:'deaktivieren (ausgegraut)'}].forEach(({v,t})=>{
      const o=document.createElement('option'); o.value=v; o.textContent=t;
      if((rule.hideMode||'hide')===v) o.selected=true; selE.appendChild(o);
    });
    selE.addEventListener('change', async ()=>{
      rule.hideMode = selE.value || 'hide';
      if (!gDraft){ await persistRules('change:hideMode'); renderList(); }
    });
    pEffect.appendChild(lblE); pEffect.appendChild(selE);
    row1.appendChild(pEffect);
  }

  // When picker
  const pField = document.createElement('div'); pField.className='pair';
  const lblF = document.createElement('label'); lblF.textContent='Wenn';

  const pickWrap = document.createElement('div');
  pickWrap.style.position = 'relative';
  pickWrap.style.display = 'inline-block';

  const btnPick = document.createElement('button');
  btnPick.type = 'button';
  btnPick.className = 'btn';
  btnPick.textContent = (() => {
    const srcsFlat = buildConditionSources(gSchema);
    const cur = srcsFlat.find(s => String(s.id) === String(rule.fieldId));
    return cur ? cur.label : 'Quelle auswählen…';
  })();

  pickWrap.appendChild(btnPick);

  const pop = document.createElement('div');
  pop.style.position = 'absolute';
  pop.style.top = '110%';
  pop.style.left = '0';
  pop.style.zIndex = '10';
  pop.style.display = 'none';
  pop.style.minWidth = '320px';
  pickWrap.appendChild(pop);

  function closePop(){ pop.style.display='none'; document.removeEventListener('click', outsideClose); }
  function outsideClose(e){ if (!pickWrap.contains(e.target)) closePop(); }

  btnPick.addEventListener('click', (e) => {
    e.stopPropagation();
    if (pop.style.display === 'none') {
      const disabledIds2 = getMultiOptionHeaderIdsForConditions();
      renderTreeMenu(pop, buildConditionTree(gSchema), {
        currentId: rule.fieldId,
        disableIds: disabledIds2,
        onPick: async (pickedId)=>{
          if (disabledIds2.has(String(pickedId))) return;

          rule.fieldId = pickedId || '';
          const srcs = buildConditionSources(gSchema);
          const src = srcs.find(x => String(x.id) === String(rule.fieldId));
          if (!rule.fieldId){ rule.op=null; rule.values=[]; }
          else if (src){
            if (src.type==='boolean'){ rule.op='equals'; rule.values=[true]; }
            else if (src.type==='date'){ rule.op='equals'; rule.values=['']; }
            else if (src.type==='text'){ rule.op='equals'; rule.values=['']; }
            else if (src.type==='number'){ rule.op='equals'; rule.values=[0]; }
            else if (src.type==='select'){ rule.op='equals'; rule.values=['']; }
            else { rule.op='equals'; rule.values=['']; }
          }
          btnPick.textContent = src ? src.label : 'Quelle auswählen…';
          if (!gDraft){ await persistRules('change:fieldId'); renderEditor(); renderList(); }
          else { renderEditor(); }
          closePop();
        }
      });
      pop.style.display = 'block';
      setTimeout(() => document.addEventListener('click', outsideClose), 0);
    } else {
      closePop();
    }
  });

  pField.appendChild(lblF);
  pField.appendChild(pickWrap);
  row1.appendChild(pField);

  card.appendChild(row1);

  // condition controls
  const chosenSource = buildConditionSources(gSchema).find(s=>String(s.id)===String(rule.fieldId));
  if (chosenSource){
    const row2 = document.createElement('div'); row2.className='rule-row';
    const pCond = document.createElement('div'); pCond.className='pair';
    const lblC = document.createElement('label'); lblC.textContent='Bedingung'; pCond.appendChild(lblC);

    const src = chosenSource;
    if (!Array.isArray(rule.values)) rule.values = [];
    const schedulePersist = debounce(()=>persistRules('typing:value'), 150);

    if (src.type!=='boolean'){
      const opSel = document.createElement('select');
      const ops = (src.type==='date')? ['before','equals','after']
                : (src.type==='text')? ['equals','notEquals','contains']
                : (src.type==='number'||src.type==='select')? ['equals','notEquals']
                : ['equals'];
      ops.forEach(v=>{
        const o=document.createElement('option'); o.value=v; o.textContent=v;
        if(rule.op===v) o.selected=true;
        opSel.appendChild(o);
      });
      opSel.addEventListener('change', async ()=>{
        rule.op = opSel.value;
        if(!gDraft){ await persistRules('change:op'); renderList(); }
        card._updateSave?.();
      });
      pCond.appendChild(opSel);
    } else {
      const spanIs = document.createElement('span'); spanIs.className='muted'; spanIs.textContent='ist';
      pCond.appendChild(spanIs);
      rule.op = 'equals';
    }

    if (src.type==='boolean'){
      const sel=document.createElement('select');
      ;[{v:true,l:'wahr'},{v:false,l:'falsch'}].forEach(({v,l})=>{
        const o=document.createElement('option'); o.value=String(v); o.textContent=l;
        if(String(rule.values?.[0])===String(v)) o.selected=true;
        sel.appendChild(o);
      });
      sel.addEventListener('change', async ()=>{
        rule.values=[sel.value==='true'];
        if(!gDraft){ await persistRules('change:value'); renderList(); }
        card._updateSave?.();
      });
      pCond.appendChild(sel);
    } else if (src.type==='date'){
      const inp=document.createElement('input');
      inp.type='text'; inp.placeholder='JJJJ-MM-TT';
      inp.style.minWidth='140px';
      inp.value=String(rule.values?.[0]||'');
      setTimeout(()=>{ try{ flatpickr(inp,{ allowInput:true, dateFormat:'Y-m-d', onChange:async()=>{ rule.values=[inp.value]; if(!gDraft){ await persistRules('change:value'); renderList(); } card._updateSave?.(); } }); }catch{} },0);
      inp.addEventListener('input', ()=>{ rule.values=[inp.value]; schedulePersist(); card._updateSave?.(); });
      pCond.appendChild(inp);
    } else if (src.type==='text'){
      const inp=document.createElement('input'); inp.type='text'; inp.value=String(rule.values?.[0]||'');
      inp.addEventListener('input', ()=>{ rule.values=[inp.value]; schedulePersist(); card._updateSave?.(); });
      pCond.appendChild(inp);
    } else if (src.type==='number'){
      const inp=document.createElement('input'); inp.type='number'; inp.value=String(rule.values?.[0]??'');
      inp.addEventListener('input', ()=>{ const v=inp.value; rule.values=[v===''? '': Number(v)]; schedulePersist(); card._updateSave?.(); });
      pCond.appendChild(inp);
    } else if (src.type==='select'){
      const sel=document.createElement('select');
      const def=document.createElement('option'); def.value=''; def.textContent='Wert auswählen…'; sel.appendChild(def);
      const base=(gSchema.fields||[]).find(ff=>String(ff.id)===String(src.id));
      const opts = base ? normOptions(base) : (src.options||[]).map(x=>({value:String(x),label:String(x)}));
      opts.forEach(opt=>{
        const o=document.createElement('option'); o.value=String(opt.value); o.textContent=String(opt.label);
        if(String(rule.values?.[0])===String(opt.value)) o.selected=true;
        sel.appendChild(o);
      });
      sel.addEventListener('change', async ()=>{
        rule.values = sel.value ? [sel.value] : [''];
        if(!gDraft){ await persistRules('change:value'); renderList(); }
        card._updateSave?.();
      });
      pCond.appendChild(sel);
    } else {
      const inp=document.createElement('input'); inp.type='text'; inp.value=String(rule.values?.[0]||'');
      inp.addEventListener('input', ()=>{ rule.values=[inp.value]; schedulePersist(); card._updateSave?.(); });
      pCond.appendChild(inp);
    }

    row2.appendChild(pCond);
    card.appendChild(row2);
  }

  // Targets (unchanged from your implementation)
  if (gMode==='headings'){
    const row3=document.createElement('div'); row3.className='rule-row';
    const pair=document.createElement('div'); pair.className='pair';
    const lbl=document.createElement('label'); lbl.textContent='Überschrift hinzufügen';
    const wrap=document.createElement('div'); wrap.style.position='relative'; wrap.style.display='inline-block';
    const btn=document.createElement('button'); btn.type='button'; btn.className='btn'; btn.textContent='Überschriften öffnen…';
    wrap.appendChild(btn);

    const pop=document.createElement('div');
    pop.style.position='absolute'; pop.style.top='110%'; pop.style.left='0'; pop.style.zIndex='10';
    pop.style.display='none'; pop.style.minWidth='360px';
    wrap.appendChild(pop);

    function close(){ pop.style.display='none'; document.removeEventListener('click', outside); }
    function outside(e){ if (!wrap.contains(e.target)) close(); }

    btn.addEventListener('click', (e)=>{
      e.stopPropagation();
      if (pop.style.display==='none'){
        const nodes = buildHeadingsTreeNodes();
        renderTreeMenu(pop, nodes, {
          disableIds: new Set(),
          onPick: async (id) => {
            const idx = Number(id);
            if (!Number.isFinite(idx)) return;

            const already = (rule.targets || []).some(t => Number(t.idx ?? t.key) === idx);
            if (already) return;

            const hIdx = currentHeadingIndex();
            const entry = hIdx.resolve({ idx }) || null;
            const label = hIdx.buildLabel(entry, `Überschrift ${idx + 1}`);

            rule.targets = rule.targets || [];
            rule.targets.push({ idx, key: idx, label });

            await persistRules('change:addHeading');
            renderEditor();
            renderList();
          }
        });
        pop.style.display='block';
        setTimeout(()=>document.addEventListener('click', outside),0);
      } else close();
    });

    pair.appendChild(lbl); pair.appendChild(wrap); row3.appendChild(pair); card.appendChild(row3);
  } else {
    const row3=document.createElement('div'); row3.className='rule-row';
    const pair=document.createElement('div'); pair.className='pair';
    const lbl=document.createElement('label'); lbl.textContent='Feld hinzufügen';
    const wrap=document.createElement('div'); wrap.style.position='relative'; wrap.style.display='inline-block';

    const btn=document.createElement('button'); btn.type='button'; btn.className='btn'; btn.textContent='Felder öffnen…';
    wrap.appendChild(btn);

    const pop=document.createElement('div');
    pop.style.position='absolute'; pop.style.top='110%'; pop.style.left='0'; pop.style.zIndex='10';
    pop.style.display='none'; pop.style.minWidth='360px';
    wrap.appendChild(pop);

    function close(){ pop.style.display='none'; document.removeEventListener('click', outside); }
    function outside(e){ if (!wrap.contains(e.target)) close(); }

    btn.addEventListener('click', (e)=>{
      e.stopPropagation();
      if (pop.style.display==='none'){
        const nodes = buildFieldTargetsTree();
        renderTreeMenu(pop, nodes, {
          disableIds: new Set(),
          onPick: async (pickedId)=>{
            if (pickedId.includes('__opt__')){
              const [fieldId, optSlug] = pickedId.split('__opt__');
              const f = (gSchema.fields||[]).find(x=> String(x.id)===String(fieldId));
              if (!f) return;

              const hit = normOptions(f).find(o => valueToSlug(String(o.value)) === String(optSlug));
              if (!hit) return;

              if (hasOptionTarget(rule, fieldId, hit.value)){
                removeOneChildAndParent(rule, fieldId, String(hit.value));
                await persistRules('toggle:removeFieldOption'); renderEditor(); renderList();
              } else {
                const fieldLabel = f.label || f.id;
                rule.targets = rule.targets || [];
                rule.targets.push({
                  id: String(fieldId),
                  optionValue: String(hit.value),
                  optionLabel: String(hit.label),
                  label: `${fieldLabel}: ${hit.label}`
                });
                await persistRules('toggle:addFieldOption'); renderEditor(); renderList();
              }
              return;
            }

            const fieldId = pickedId;
            if (hasParentTarget(rule, fieldId)){
              removeAllChildren(rule, fieldId);
              removeParent(rule, fieldId);
              await persistRules('toggle:removeFieldAll'); renderEditor(); renderList();
            } else {
              addParentWithAllOptions(rule, fieldId);
              await persistRules('toggle:addFieldAll'); renderEditor(); renderList();
            }
          }
        });
        pop.style.display='block';
        setTimeout(()=>document.addEventListener('click', outside),0);
      } else close();
    });

    pair.appendChild(lbl); pair.appendChild(wrap); row3.appendChild(pair); card.appendChild(row3);
  }

  // Selected pills
  const row4=document.createElement('div'); row4.className='rule-row';
  const lblSel=document.createElement('div'); lblSel.className='muted';
  lblSel.textContent=(gMode==='headings'?'Ausgewählte Überschriften:':'Ausgewählte Felder:');
  const pills=document.createElement('div'); pills.className='pills';

  (rule.targets||[]).forEach(t=>{
    const isHead = (gMode==='headings');
    let uniqId, labelText, isParent=false, fieldId=null, optValue=null;

    if (isHead){
      const key = (typeof t==='string'? t : t.key);
      uniqId = String(key);
      labelText = (typeof t==='object' && t.label) ? t.label : getHeadingLabelFromKey(String(key));
    } else {
      fieldId = String(typeof t==='object' ? t.id : t);
      if (typeof t==='object' && t.optionValue!=null){
        optValue = String(t.optionValue);
        uniqId = `${fieldId}__opt__${valueToSlug(optValue)}`;
        labelText = t.label || `${getFieldLabelById(String(fieldId))}: ${t.optionLabel}`;
      } else {
        uniqId = String(fieldId);
        labelText = (typeof t==='object' && t.label) ? t.label : getFieldLabelById(String(fieldId));
        isParent = true;
      }
    }

    const pill=document.createElement('span'); pill.className='pill'; pill.title=uniqId;
    const txt=document.createElement('span'); txt.textContent=labelText || uniqId;
    const x=document.createElement('button'); x.setAttribute('aria-label','Entfernen'); x.textContent='×';
    x.addEventListener('click', async ()=>{
      if (isHead){
        rule.targets=(rule.targets||[]).filter(z=>{
          const zk = String((typeof z==='string'? z : z.key));
          return zk !== uniqId;
        });
      } else if (isParent){
        removeParent(rule, fieldId);
        removeAllChildren(rule, fieldId);
      } else {
        removeOneChildAndParent(rule, fieldId, optValue);
      }
      await persistRules('change:removeTarget');
      renderEditor(); renderList();
    });
    pill.appendChild(txt); pill.appendChild(x);
    pills.appendChild(pill);
  });

  if (!pills.children.length){
    const none=document.createElement('span'); none.className='empty'; none.textContent='(keine)';
    pills.appendChild(none);
  }

  row4.appendChild(lblSel); row4.appendChild(pills);
  card.appendChild(row4);

  mount.appendChild(card);
  if (gDraft) card._updateSave?.();
}

/* ------------------------- reload/sync ------------------------- */

async function reloadState(reason){
  if (!gDocId) return;

  if (__reloadBusy) { __reloadPending = true; return; }
  __reloadBusy = true;
  try {
    await reconcileAndAutoRestoreIfNeeded(reason);

    const st = await window.formSuitePersist.loadState(gDocId) || {};

    if (st.schema) gSchema = st.schema;

    if (Array.isArray(st.headingsTree)) gHeadingsTree = st.headingsTree;
    if (Array.isArray(st.headingsFlat)) gHeadingsFlat = st.headingsFlat;
    if (!Array.isArray(gHeadingsFlat) || !gHeadingsFlat.length) gHeadingsFlat = flattenWithNumbers(gHeadingsTree);

    gRulesHeadings = safeArr(st.rules).slice();
    gRulesFields   = safeArr(st.fieldRules).slice();

    normalizeAllTargets();

    gRules = (gMode==='headings') ? gRulesHeadings.slice() : gRulesFields.slice();
    if (!gRules.find(r=>r?.id===gEditingId)) gEditingId = null;

    setStatus(`Geladen — Felder: ${(gSchema.fields||[]).length}, Überschriften: ${(gHeadingsTree||[]).length}, ${gMode==='headings'?'Überschriften-Regeln':'Feld-Regeln'}: ${gRules.length}`);
    renderEditor(); renderList();

    await debugLogPayload(`reload:${reason}`);
  } finally {
    __reloadBusy = false;
    if (__reloadPending) { __reloadPending = false; reloadState('coalesced'); }
  }
}

/* ------------------------- tab switches + add ------------------------- */

els.tabHeadings?.addEventListener('click', async ()=>{
  if (gMode==='headings') return;
  gMode='headings'; gDraft=null; gEditingId=null; applyTabUI();
  await reloadState('tab:headings');
});

els.tabFields?.addEventListener('click', async ()=>{
  if (gMode==='fields') return;
  gMode='fields'; gDraft=null; gEditingId=null; applyTabUI();
  await reloadState('tab:fields');
});

els.btnAddRule.addEventListener("click", ()=>{
  gEditingId = null;
  gDraft = { id:null, action:null, fieldId:"", op:null, values:[], targets:[], ...(gMode==='fields'? {hideMode:'hide'} : {}) };
  renderEditor();
  els.editorMount.scrollIntoView({behavior:"smooth", block:"start"});
});

// F9 diagnostic
window.addEventListener('keydown', async (e) => {
  if (e.key === 'F9') {
    const st = await window.formSuitePersist.loadState(gDocId) || {};
    const p  = st?.payload?.CRONOS_PAYLOAD || st?.CRONOS_PAYLOAD || st?.cronos_payload || {};
    console.log('[rules][F9] dump]', {
      docId: gDocId,
      ws_rules: safeArr(st.rules).length,
      ws_fieldRules: safeArr(st.fieldRules).length,
      ws_rulesVersion: st.rulesVersion || null,
      pl_rules: safeArr(p.rules).length,
      pl_fieldRules: safeArr(p.fieldRules).length,
      pl_rulesVersion: p.rulesVersion || null
    });
  }
});

/* ------------------------- broadcasts (canonical only) ------------------------- */

// Active doc changes
if (typeof installActiveDocListener === 'function') {
  installActiveDocListener(async (meta) => {
    gDoc = meta || null;
    gDocId = meta?.docId || null;
    gDraft = null;
    gEditingId = null;
    applyTabUI();
    if (!gDocId) { setStatus('Kein aktives Dokument. Öffne zuerst eins.'); return; }
    await reloadState('active-doc');
  });
}

// State changes (payload patches)
bcPayload?.addEventListener('message', async (ev) => {
  const msg = ev?.data || {};
  if (msg?.t !== 'payload') return;
  if (!gDocId || msg.docId !== gDocId) return;

  if (__suppressNextPayloadReload) {
    console.log('[rules] payload event suppressed (self-write)', msg);
    return;
  }
  await reloadState('payload');
});

// Visibility / focus guard
document.addEventListener('visibilitychange', async () => {
  if (document.visibilityState !== 'visible') return;
  await reloadState('visibility');
});
window.addEventListener('focus', async () => { await reloadState('focus'); });

/* ------------------------- boot ------------------------- */

(function boot(){
  try{
    try { window.formSuitePersist?.ensureHydrated?.(); } catch {}
    gDoc = (typeof readActiveDocSync === 'function') ? readActiveDocSync() : null;
    if (!gDoc?.docId){ setStatus("Kein aktives Dokument. Öffne zuerst eins."); return; }
    gDocId = gDoc.docId;
    applyTabUI();
    reloadState("boot");
  } catch(e){
    console.error("boot failed:", e);
    setStatus("Status konnte nicht geladen werden.");
  }
})();

// Triple-click logo: focus mode + go to index, toggle header links
installLogoFocusNav();
</script>
</body>
</html>
