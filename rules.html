<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Form Suite — Rules</title>
  <link rel="icon" href="favicon.ico" type="image/gif" sizes="32x32">
  <link rel="shortcut icon" href="favicon.ico" type="image/gif">
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <!-- Optional (for date condition picker) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/themes/material_blue.css">
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <link rel="stylesheet" href="style.css">
  <script src="persistence.js"></script>
</head>
<body class="rules">
<header>
  <div class="row">
    <span class="brand logo-md">
      <img src="logo.gif" alt="Form Suite logo" class="logo" />
      <strong>Form Suite</strong>
    </span>
    <span class="muted">·</span><a href="index.html">Form</a>
    <span class="muted">·</span><a href="builder.html">Form Builder</a>
    <span class="muted">·</span><a href="matcher.html">Tag Matcher</a>
    <span class="muted">·</span><span class="muted">Rules</span>
    <span class="muted">·</span><a href="extractor.html">Extractor</a>
  </div>
</header>

<main>
  <section class="panel">
    <div class="row" style="justify-content:space-between; align-items:center">
      <h2 style="margin:0">Rules</h2>
      <div id="rulesTabs" class="row" style="margin-left:8px; gap:6px;">
        <button id="tabHeadings" class="btn btn-ghost" aria-pressed="true">Headings</button>
        <button id="tabFields" class="btn btn-ghost" aria-pressed="false">Fields</button>
      </div>
      <div class="row">
        <span id="status" class="muted" style="margin-right:10px"></span>
        <button id="btnAddRule" class="btn btn-primary">Add rule</button>
      </div>
    </div>
    <div class="muted-note" id="rulesHint" style="margin-top:6px">
      SHOW or HIDE specific headings/subheaders or form fields based on a field’s value(s).
    </div>
  </section>

  <section class="panel" id="editorMount">
    <div class="empty">No rules yet — click “Add rule”.</div>
  </section>

  <section class="panel">
    <h3 style="margin-top:0">Existing rules</h3>
    <div id="rulesList" class="rules-list">
      <div class="empty">None.</div>
    </div>
  </section>
</main>

<script>
/* ============================ Debug printing ============================ */
const nowt = () => new Date().toISOString().slice(11,23);
function asTextRule(rule, mode) {
  const id = rule?.id ?? null;
  const action = rule?.action ?? null;
  const fieldId = (rule?.fieldId ?? '');
  const op = (rule?.op ?? null);
  const values = Array.isArray(rule?.values) ? rule.values : [];
  const targets = Array.isArray(rule?.targets) ? rule.targets : [];
  const tCompact = (mode === 'headings')
    ? targets.map(t => String((typeof t==='string')? t : (t?.key ?? '')))
    : targets.map(t => String((typeof t==='string')? t : (t?.id ?? '')));
  const hideMode = (mode === 'fields') ? (rule?.hideMode || 'hide') : undefined;
  const ordered = (hideMode !== undefined)
    ? { id, action, fieldId, op, values, targets: tCompact, hideMode }
    : { id, action, fieldId, op, values, targets: tCompact };
  return JSON.stringify(ordered);
}
function printRuleArray(title, rules, mode){
  console.log(`[${nowt()}] ${title}: count=${(rules||[]).length}`);
  (rules||[]).forEach((r, i) => console.log(`  #${i+1}: ${asTextRule(r, mode)}`));
}
function printPayloadSnapshot(st){
  const pl = st?.payload?.CRONOS_PAYLOAD || st?.CRONOS_PAYLOAD || st?.cronos_payload || null;
  if (!pl) { console.log(`[${nowt()}] STATE payload: (none)`); return; }
  const rBoth = Array.isArray(pl.rules) ? pl.rules
               : (Array.isArray(pl.headingRules) ? pl.headingRules : []);
  const f = Array.isArray(pl.fieldRules) ? pl.fieldRules : [];
  console.log(`[${nowt()}] STATE payload present`);
  if (Array.isArray(pl.rules)) printRuleArray('STATE payload.rules', pl.rules, 'headings');
  if (Array.isArray(pl.headingRules)) printRuleArray('STATE payload.headingRules', pl.headingRules, 'headings');
  printRuleArray('STATE payload (effective: headings)', rBoth, 'headings');
  printRuleArray('STATE payload.fieldRules', f, 'fields');
}

/* =============================== Globals ================================ */
const ACTIVE_LS_KEY= "FS_ACTIVE_DOC_META";
const statusEl   = document.getElementById("status");
const btnAddRule = document.getElementById("btnAddRule");
const editorMount= document.getElementById("editorMount");
const rulesList  = document.getElementById("rulesList");
const tabHeadings= document.getElementById("tabHeadings");
const tabFields  = document.getElementById("tabFields");
const rulesHint  = document.getElementById("rulesHint") || document.querySelector("section.panel .muted-note");

const bcLegacy  = ("BroadcastChannel" in window) ? new BroadcastChannel("form-suite-doc")  : null;
const bcCanon   = ("BroadcastChannel" in window) ? new BroadcastChannel("fs-active-doc")   : null;
const bcPayload = ("BroadcastChannel" in window) ? new BroadcastChannel("fs-payload-v1")   : null;

let gDocId   = null;
let gSchema  = { title:"Form", fields:[] };
let gHeadingsTree = [];
let gMode    = 'headings'; // 'headings' | 'fields'
let gRules   = [];         // rules currently shown/edited in the view
let gRulesHeadings = [];   // backing store (headings rules)
let gRulesFields   = [];   // backing store (field rules)
let gEditingId = null;     // currently edited rule id
let gDraft   = null;       // unsaved draft

/* ========================= Utility + Builders =========================== */
function setStatus(t){ if (statusEl) statusEl.textContent = t || ""; }
function readActiveMeta(){
  try { const v = localStorage.getItem(ACTIVE_LS_KEY); return v ? JSON.parse(v) : null; }
  catch { return null; }
}
function slugify(s){
  return String(s||"")
    .normalize('NFKD')
    .replace(/[\u0300-\u036f]/g, '')
    .replace(/[^a-zA-Z0-9]+/g, '_')
    .replace(/^_+|_+$/g, '')
    .toLowerCase();
}
const debounce = (fn, ms)=>{ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a), ms); }; };

const ACTIONS = new Set(["SHOW","HIDE"]);

/* ============================ Schema helpers ============================ */
function printSchemaDebug(schema){
  const fields = Array.isArray(schema?.fields) ? schema.fields : [];
  console.log(`[${nowt()}] SCHEMA fields: count=${fields.length}`);
  fields.forEach((f,i)=>{
    const base = { idx:i+1, id:f.id, type:f.type, label:f.label||'', name:f.name||'', slug:f.slug||'' };
    console.log(`[${nowt()}]   #${i+1}: ${JSON.stringify(base)}`);
    const opts = normOptions(f);
    if (opts.length) console.log(`[${nowt()}]      options: ${opts.map(o=>o.label+"="+o.value).join(', ')}`);
  });
}
function normOptions(field){
  const raw = field && field.options || [];
  return raw.map(o => {
    if (o && typeof o === "object") {
      const value = (o.value ?? o.id ?? o.key ?? o.code ?? String(o));
      const label = (o.label ?? o.text ?? o.name ?? String(value));
      return { value:String(value), label:String(label) };
    }
    return { value:String(o), label:String(o) };
  });
}
function getFieldLabelById(id){
  const f = (gSchema.fields||[]).find(x => String(x.id)===String(id));
  return f?.label || f?.name || f?.id || String(id);
}
function fieldTypeOf(id){
  return String((gSchema.fields||[]).find(x=>String(x.id)===String(id))?.type || '').toLowerCase();
}

/* ============================ Headings helpers ========================== */
function flattenWithNumbers(tree){
  const out=[], counters=[];
  function walk(nodes, depth){
    counters[depth]=0;
    for (const n of (nodes||[])){
      counters[depth]++;
      const number = counters.slice(0, depth+1).join(".");
      const label = (n.label?.trim?.() ? n.label : n.text) || "";
      out.push({
        key: String(n.idx ?? number),        // raw key (might be numeric-only)
        label: number + " " + label,         // "3.1 Title"
        titleOnly: label,                    // "Title"
        number,                              // "3.1"
        level: n.level || (depth+1)
      });
      if (n.children?.length) walk(n.children, depth+1);
    }
  }
  walk(tree||[],0);
  return out;
}
function toCompositeKeyFromFlat(h){
  if (!h) return '';
  const raw = String(h.key ?? '');
  if (raw.includes('|')) return raw;
  return `${h.number}|${h.titleOnly || ''}`.trim();
}
function getHeadingLabelFromKey(key){
  if (!key) return '';
  if (key.includes('|')) return key.split('|').slice(1).join('|');
  const flat = flattenWithNumbers(gHeadingsTree);
  const hit = flat.find(h => h.number === key);
  return hit?.titleOnly || key;
}
function printHeadingsDebug(headingsTree){
  const flat = flattenWithNumbers(headingsTree);
  console.log(`[${nowt()}] HEADINGS flat: count=${flat.length}`);
  flat.forEach(h=>{
    const comp = toCompositeKeyFromFlat(h);
    console.log(`[${nowt()}]   ${h.number} | ${h.titleOnly}  => key="${comp}"  label="${h.label}"`);
  });
}

/* ====================== Target normalization (universal) ================ */
// Headings: accept string ("3" or "3|Title") or {key,label}
function normalizeHeadingsRuleTargetsInPlace(rule, flatHeads){
  if (!rule || !Array.isArray(rule.targets)) return { changed:false };
  let changed = false;
  const byNumber = new Map();   // "3.1" -> composite
  const byComp   = new Map();   // "3.1|Title" -> label
  flatHeads.forEach(h => {
    const comp = toCompositeKeyFromFlat(h);
    byNumber.set(h.number, comp);
    byComp.set(comp, h.label);
  });
  rule.targets = rule.targets.map(t => {
    let compKey = '';
    if (typeof t === 'string') {
      compKey = t.includes('|') ? t : (byNumber.get(t) || t);
    } else if (t && typeof t === 'object') {
      const k = String(t.key ?? '');
      compKey = k ? (k.includes('|') ? k : (byNumber.get(k) || k)) : '';
    }
    if (!compKey) return (typeof t === 'object' ? t : { key: t });
    const label = byComp.get(compKey) || compKey.split('|').slice(1).join('|') || compKey;
    const normalized = { key: compKey, label };
    if (typeof t === 'string' || String((t.key ?? '')) !== compKey || !t.label) changed = true;
    return normalized;
  });
  return { changed };
}
function normalizeAllHeadingsRulesInPlace(rules, flatHeads){
  let c = 0;
  (rules||[]).forEach(r=>{
    const { changed } = normalizeHeadingsRuleTargetsInPlace(r, flatHeads);
    if (changed) c++;
  });
  if (c>0) console.log(`[${nowt()}] NORMALIZED headings target keys -> composite for ${c} rule(s)`);
  return c;
}

// Fields: accept string id or {id,label}
function normalizeFieldTargetsInPlace(rule, schema){
  if (!rule || !Array.isArray(rule.targets)) return { changed:false };
  const fields = Array.isArray(schema?.fields) ? schema.fields : [];
  const labelById = new Map(fields.map(f => [String(f.id), (f.label || f.name || f.id)]));
  let changed=false;
  rule.targets = rule.targets.map(t => {
    if (typeof t === 'string') {
      changed = true;
      return { id: t, label: labelById.get(String(t)) || String(t) };
    } else if (t && typeof t === 'object') {
      const id = String(t.id ?? '');
      const want = labelById.get(id);
      if (id && (!t.label || t.label !== want)) {
        changed = true;
        return { id, label: want || (t.label||id) };
      }
      return t;
    } else {
      return t;
    }
  });
  return { changed };
}
function normalizeAllFieldRulesInPlace(rules, schema){
  let c = 0;
  (rules||[]).forEach(r=>{
    const { changed } = normalizeFieldTargetsInPlace(r, schema);
    if (changed) c++;
  });
  if (c>0) console.log(`[${nowt()}] NORMALIZED field rule targets -> labeled for ${c} rule(s)`);
  return c;
}

/* ================== Condition Sources (UNIVERSAL) ======================= */
/**
 * Produces a universal list of sources (id, label, type) that rules can use in the "When..." part.
 * Supported types:
 *  - boolean (checkbox/switch; multichoice base; multichoice per-option booleans)
 *  - date
 *  - number (including "datediff")
 *  - text
 *  - select (single choice)
 * Unknown types fall back to text.
 */
function buildConditionSources(schema){
  const out = [];
  const seen = new Set();
  const fields = Array.isArray(schema?.fields) ? schema.fields : [];

  for (const f of fields){
    const t = String(f.type||'').toLowerCase();
    const id = String(f.id);
    const label = f.label || f.id;

    // boolean-like fields in your schema (add aliases if you have them)
    if (t === 'boolean' || t === 'checkbox' || t === 'switch') {
      if (!seen.has(id)) { seen.add(id); out.push({ id, label, type:'boolean' }); }
      continue;
    }

    // multichoice: base boolean + per-option booleans
    if (t === 'multichoice'){
      if (!seen.has(id)) { seen.add(id); out.push({ id, label, type:'boolean', meta:{ anySelected:true } }); }
      const items = [];
      if (Array.isArray(f.options)) items.push(...f.options);
      if (f.mc && Array.isArray(f.mc.groups)){
        for (const g of f.mc.groups){ (g.items||[]).forEach(it => items.push(it)); }
      }
      items.forEach(it => {
        const rawVal = it && typeof it === 'object' ? (it.value ?? it.label ?? it.text ?? it.name ?? '') : it;
        const rawLbl = it && typeof it === 'object' ? (it.label ?? it.text ?? it.name ?? rawVal) : rawVal;
        const valStr = String(rawVal || '').trim();
        const lblStr = String(rawLbl || '').trim();
        const slug = slugify(valStr);
        if (!valStr || !slug) return;
        const optId = `${id}__opt__${slug}`;
        if (seen.has(optId)) return;
        seen.add(optId);
        out.push({ id: optId, label: `${label}: ${lblStr}`, type: 'boolean' });
      });
      continue;
    }

    // date / datediff / number / text / select (single choice)
    if (t === 'date') {
      if (!seen.has(id)) { seen.add(id); out.push({ id, label, type:'date' }); }
      continue;
    }
    if (t === 'datediff' || t === 'duration' || t === 'number') {
      if (!seen.has(id)) { seen.add(id); out.push({ id, label, type:'number' }); }
      continue;
    }
    if (t === 'select' || t === 'dropdown' || t === 'singlechoice' || t === 'choice' || t === 'single' || t === 'combobox' || t === 'list'){
      if (!seen.has(id)) {
        seen.add(id);
        const options = (f.options||[]).map(o => (o && typeof o === 'object') ? String(o.value ?? o.label ?? o) : String(o));
        out.push({ id, label, type:'select', options });
      }
      continue;
    }
    if (t === 'text' || t === 'string' || t === 'textarea') {
      if (!seen.has(id)) { seen.add(id); out.push({ id, label, type:'text' }); }
      continue;
    }

    // Fallback: treat unknowns as text so they still work
    if (!seen.has(id)) { seen.add(id); out.push({ id, label, type:'text' }); }
  }

  return out;
}

/* ============================== Validation ============================== */
function isRuleValid(rule, schema = gSchema, headingsTree = gHeadingsTree, mode = gMode){
  if (!rule || !ACTIONS.has(rule.action)) return false;

  const haveSchema = Array.isArray(schema?.fields) && schema.fields.length > 0;
  const haveHeads  = Array.isArray(headingsTree) && headingsTree.length > 0;

  if (!haveSchema) return !!(rule.fieldId && rule.op && Array.isArray(rule.values));

  const sources = buildConditionSources(schema);
  const src = sources.find(s => String(s.id) === String(rule.fieldId));
  if (!src) return false;

  const allowedOps = (src.type==='boolean') ? ['equals']
                  : (src.type==='date')    ? ['before','equals','after']
                  : (src.type==='text')    ? ['equals','notEquals','contains']
                  : (src.type==='number')  ? ['equals','notEquals']
                  : (src.type==='select')  ? ['equals','notEquals']
                  : ['equals'];
  if (!allowedOps.includes(rule.op)) return false;

  if (!Array.isArray(rule.values)) return false;
  if (src.type==='boolean') {
    if (rule.values.length!==1) return false;
    const v = rule.values[0];
    if (!(v === true || v === false || v === 'true' || v === 'false')) return false;
  } else if (src.type==='date') {
    if (rule.values.length!==1 || !String(rule.values[0])) return false;
  } else if (src.type==='text') {
    if (rule.values.length!==1) return false;
  } else if (src.type==='number') {
    if (rule.values.length!==1 || (rule.values[0]!=='' && isNaN(Number(rule.values[0])))) return false;
  } else if (src.type==='select') {
    if (rule.values.length!==1) return false;
    const opts = new Set((src.options||[]).map(String));
    if (!opts.has(String(rule.values[0]))) return false;
  }

  if (mode === 'headings') {
    if (!haveHeads) return true;
    const flat = flattenWithNumbers(headingsTree);
    const allowedHeads = new Set(flat.map(toCompositeKeyFromFlat));
    return Array.isArray(rule.targets) && rule.targets.length>0 && rule.targets.every(t => {
      const key = String((typeof t==='string')? t : (t.key ?? ''));
      const k = key.includes('|') ? key : key;
      return allowedHeads.has(k) || allowedHeads.has(k.split('|')[0]);
    });
  } else {
    const allowedTargetIds = new Set((schema.fields||[]).map(s=>String(s.id)));
    return Array.isArray(rule.targets) && rule.targets.length>0 && rule.targets.every(t => {
      const id = String((typeof t==='string')? t : (t.id ?? ''));
      return allowedTargetIds.has(id);
    });
  }
}

/* ============================ Persistence glue ========================== */
function cloneRulesArray(rules){
  if (!Array.isArray(rules)) return [];
  if (typeof structuredClone === 'function'){ try { return structuredClone(rules); } catch {} }
  return JSON.parse(JSON.stringify(rules));
}
async function _ensureSchemaFromPayload(st) {
  if (st?.schema?.fields?.length) return st;
  const pl = (st?.payload?.CRONOS_PAYLOAD) || st?.CRONOS_PAYLOAD || st?.cronos_payload;
  if (Array.isArray(pl?.fields) && pl.fields.length) {
    const derivedSchema = { title: pl.title || 'Form', fields: pl.fields };
    await window.formSuitePersist.saveState(gDocId, {
      schema: derivedSchema,
      schemaUpdatedAt: new Date().toISOString()
    });
    return await window.formSuitePersist.loadState?.(gDocId);
  }
  return st;
}
function _deepEqual(a, b) {
  if (a === b) return true;
  if (!Array.isArray(a) || !Array.isArray(b) || a.length !== b.length) return false;
  for (let i = 0; i < a.length; i++) {
    if (JSON.stringify(a[i]) !== JSON.stringify(b[i])) return false;
  }
  return true;
}
async function persistRulesNow(reason = 'manual') {
  if (!gDocId) return;

  const st = await window.formSuitePersist?.loadState?.(gDocId) || {};
  const wsHeadings = Array.isArray(st.rules) ? st.rules
                     : (Array.isArray(st.headingRules) ? st.headingRules : []);
  const wsFields   = Array.isArray(st.fieldRules) ? st.fieldRules : [];
  const wantHeadings = Array.isArray(gRulesHeadings) ? gRulesHeadings : [];
  const wantFields   = Array.isArray(gRulesFields)   ? gRulesFields   : [];
  const isViewChange = /^tab-switch/.test(reason) || /^view-change/.test(reason) || /^normalize:/.test(reason);
  const patch = {};

  if (wantHeadings.length === 0 && wsHeadings.length > 0 && isViewChange) {
    // skip empty wipe
  } else if (!_deepEqual(wantHeadings, wsHeadings)) {
    patch.rules = wantHeadings.slice();
  }
  if (wantFields.length === 0 && wsFields.length > 0 && isViewChange) {
    // skip empty wipe
  } else if (!_deepEqual(wantFields, wsFields)) {
    patch.fieldRules = wantFields.slice();
  }

  if (Object.keys(patch).length === 0) return;

  console.log(`[${nowt()}] WRITE reason=${JSON.stringify(reason)} (workspace patch)`);
  if (patch.rules) console.log(`[${nowt()}] WRITE patch.rules: count=${patch.rules.length}`);
  if (patch.fieldRules) console.log(`[${nowt()}] WRITE patch.fieldRules: count=${patch.fieldRules.length}`);

  await window.formSuitePersist.saveState(gDocId, patch);

  // Mirror into payload
  const st2 = await window.formSuitePersist?.loadState?.(gDocId) || {};
  const payloadBox =
    (st2.payload && st2.payload.CRONOS_PAYLOAD) ? { kind: 'nested', obj: st2.payload.CRONOS_PAYLOAD } :
    (st2.CRONOS_PAYLOAD)                        ? { kind: 'top',    obj: st2.CRONOS_PAYLOAD } :
    (st2.cronos_payload)                        ? { kind: 'alt',    obj: st2.cronos_payload } :
                                                  null;
  if (payloadBox) {
    if ('rules' in patch) payloadBox.obj.rules = patch.rules;
    if ('fieldRules' in patch) payloadBox.obj.fieldRules = patch.fieldRules;

    if (payloadBox.kind === 'nested') {
      await window.formSuitePersist.saveState(gDocId, { payload: { ...(st2.payload || {}), CRONOS_PAYLOAD: payloadBox.obj } });
    } else if (payloadBox.kind === 'top') {
      await window.formSuitePersist.saveState(gDocId, { CRONOS_PAYLOAD: payloadBox.obj });
    } else {
      await window.formSuitePersist.saveState(gDocId, { cronos_payload: payloadBox.obj });
    }

    if ('rules' in patch)      console.log(`[${nowt()}] LIVE payload patch -> rules: count=${payloadBox.obj.rules?.length || 0}`);
    if ('fieldRules' in patch) console.log(`[${nowt()}] LIVE payload patch -> fieldRules: count=${payloadBox.obj.fieldRules?.length || 0}`);
  }

  const stAfter = await window.formSuitePersist?.loadState?.(gDocId) || {};
  console.log(`[${nowt()}] AFTER state snapshot`);
  console.log(`[${nowt()}] AFTER workspace.rules: count=${Array.isArray(stAfter.rules) ? stAfter.rules.length : 0}`);
  console.log(`[${nowt()}] AFTER workspace.fieldRules: count=${Array.isArray(stAfter.fieldRules) ? stAfter.fieldRules.length : 0}`);
}

/* =============================== UI: editor ============================== */
function currentEditorRule(){ if (gDraft) return gDraft; if (gEditingId) return gRules.find(r=>r.id===gEditingId) || null; return null; }

function renderEditor(){
  editorMount.innerHTML = "";
  const rule = currentEditorRule();
  if (!rule){
    editorMount.innerHTML = '<div class="empty">No rules yet — click “Add rule”.</div>';
    return;
  }

  const flatHeads = flattenWithNumbers(gHeadingsTree);
  const isDraft = !!gDraft;

  // Normalize current rule in memory
  if (gMode==='headings') normalizeHeadingsRuleTargetsInPlace(rule, flatHeads);
  else normalizeFieldTargetsInPlace(rule, gSchema);

  const card = document.createElement("div");
  card.className = "rule-card";
  card.dataset.id = rule.id || "draft";

  // Row 0: Save/Cancel (for draft)
  if (isDraft){
    const top = document.createElement("div"); top.className="row"; top.style.justifyContent="flex-end"; top.style.gap="8px";
    const btnCancel = document.createElement("button"); btnCancel.className="btn btn-ghost"; btnCancel.textContent="Cancel";
    btnCancel.addEventListener("click", ()=>{ gDraft=null; renderEditor(); });
    const btnSave = document.createElement("button"); btnSave.className="btn btn-primary"; btnSave.textContent="Save rule";
    btnSave.disabled = !isRuleValid(rule, gSchema, gHeadingsTree, gMode);
    btnSave.addEventListener("click", ()=>{
      if (!isRuleValid(rule, gSchema, gHeadingsTree, gMode)){ alert("Please complete the rule."); return; }
      rule.id = "r_"+Math.random().toString(36).slice(2,8);
      gRules.push(rule);
      gDraft=null;
      console.log(`[${nowt()}] CREATE ${asTextRule(rule, gMode)}`);
      persistRulesNow('create'); renderEditor(); renderList();
    });
    const updateSaveState = ()=> { btnSave.disabled = !isRuleValid(currentEditorRule(), gSchema, gHeadingsTree, gMode); };
    card.dataset._updateSaveState = "1";
    card.appendChild(top);
    top.appendChild(btnCancel);
    top.appendChild(btnSave);
    card._updateSave = updateSaveState;
  }

  // Row 1: Action + Effect + When
  const row1 = document.createElement("div"); row1.className="rule-row";

  // Action
  const pAction = document.createElement("div"); pAction.className="pair";
  const lblA = document.createElement("label"); lblA.textContent="Action";
  const selA = document.createElement("select");
  const defAct = document.createElement("option"); defAct.value=""; defAct.textContent="Select…";
  if (isDraft && !rule.action) selA.appendChild(defAct);
  ["SHOW","HIDE"].forEach(a => { const o=document.createElement("option"); o.value=a; o.textContent=a; if(rule.action===a) o.selected=true; selA.appendChild(o); });
  selA.addEventListener("change", () => {
    rule.action = selA.value || null;
    console.log(`[${nowt()}] EDIT action -> ${asTextRule(rule, gMode)}`);
    if (!isDraft){ persistRulesNow("change:action"); renderList(); }
    card._updateSave?.();
  });
  pAction.appendChild(lblA); pAction.appendChild(selA);
  row1.appendChild(pAction);

  // Effect (fields mode only)
  const pEffect = document.createElement('div'); pEffect.className = 'pair';
  const lblE = document.createElement('label'); lblE.textContent = 'Effect';
  const selE = document.createElement('select');
  const addOpt = (v,t) => { const o=document.createElement('option'); o.value=v; o.textContent=t; if((rule.hideMode||'hide')===v) o.selected=true; selE.appendChild(o); };
  addOpt('hide','hide (remove)'); addOpt('disable','disable (greyed)');
  selE.addEventListener('change', ()=>{ rule.hideMode = selE.value || 'hide'; console.log(`[${nowt()}] EDIT hideMode -> ${asTextRule(rule, gMode)}`); if(!isDraft){ persistRulesNow("change:hideMode"); renderList(); } });
  if (gMode==='fields') { pEffect.appendChild(lblE); pEffect.appendChild(selE); row1.appendChild(pEffect); }

  // When (source field)
  const pField = document.createElement("div"); pField.className="pair";
  const lblF = document.createElement("label"); lblF.textContent="When";
  const selF = document.createElement("select");
  const defF = document.createElement("option"); defF.value=""; defF.textContent="Select source…";
  const __sources = buildConditionSources(gSchema);
  if (isDraft && !rule.fieldId) selF.appendChild(defF);
  if (!__sources.length){
    const o=document.createElement("option"); o.value=""; o.textContent="(no fields)"; selF.appendChild(o);
  } else {
    __sources.forEach(s=>{
      const o=document.createElement("option");
      o.value=s.id; o.textContent=s.label; if(String(rule.fieldId)===String(s.id)) o.selected=true; selF.appendChild(o);
    });
  }
  selF.addEventListener("change", () => {
    rule.fieldId = selF.value || "";
    if (!rule.fieldId){ rule.values=[]; rule.op=null; }
    else {
      const src = __sources.find(x=>String(x.id)===String(rule.fieldId));
      if (src){
        if (src.type==='boolean') { rule.op='equals'; rule.values=[true]; }
        else if (src.type==='date') { rule.op='equals'; rule.values=['']; }
        else if (src.type==='text') { rule.op='equals'; rule.values=['']; }
        else if (src.type==='number') { rule.op='equals'; rule.values=[0]; }
        else if (src.type==='select') { rule.op='equals'; rule.values=['']; }
        else { rule.op='equals'; rule.values=['']; }
      } else { rule.op=null; rule.values=[]; }
    }
    console.log(`[${nowt()}] EDIT source -> ${asTextRule(rule, gMode)}`);
    if (!isDraft){ persistRulesNow("change:fieldId"); renderEditor(); renderList(); }
    else { renderEditor(); }
  });
  pField.appendChild(lblF); pField.appendChild(selF);
  row1.appendChild(pField);

  card.appendChild(row1);

  // Row 2: Condition editor (universal)
  const chosenSource = buildConditionSources(gSchema).find(s=>String(s.id)===String(rule.fieldId));
  if (chosenSource){
    const row2 = document.createElement("div"); row2.className="rule-row";
    const pCond = document.createElement("div"); pCond.className="pair";
    const lblC = document.createElement("label"); lblC.textContent="Condition";
    pCond.appendChild(lblC);

    const src = chosenSource;
    if (!Array.isArray(rule.values)) rule.values = [];
    const schedulePersist = debounce(() => persistRulesNow("typing"), 150);

    // Operators
    if (src?.type !== 'boolean'){
      const opSel = document.createElement('select');
      const ops = (src?.type==='date') ? [{v:'before',l:'before'},{v:'equals',l:'equals'},{v:'after',l:'after'}]
                : (src?.type==='text') ? [{v:'equals',l:'equals'},{v:'notEquals',l:'not equals'},{v:'contains',l:'contains'}]
                : (src?.type==='number') ? [{v:'equals',l:'equals'},{v:'notEquals',l:'not equals'}]
                : (src?.type==='select') ? [{v:'equals',l:'equals'},{v:'notEquals',l:'not equals'}]
                : [{v:'equals',l:'equals'}];
      ops.forEach(({v,l})=>{ const o=document.createElement('option'); o.value=v; o.textContent=l; if(rule.op===v) o.selected=true; opSel.appendChild(o); });
      opSel.addEventListener('change', ()=>{ rule.op = opSel.value; console.log(`[${nowt()}] EDIT op -> ${asTextRule(rule, gMode)}`); if(!isDraft){ persistRulesNow("change:op"); renderList(); } card._updateSave?.(); });
      pCond.appendChild(opSel);
    } else {
      const spanIs = document.createElement('span'); spanIs.className='muted'; spanIs.textContent='is'; pCond.appendChild(spanIs);
      rule.op = 'equals';
    }

    // Value controls
    if (src?.type==='boolean'){
      const sel = document.createElement('select');
      ;[{v:true,l:'true'},{v:false,l:'false'}].forEach(({v,l})=>{ const o=document.createElement('option'); o.value=String(v); o.textContent=l; if(String(rule.values?.[0])===String(v)) o.selected=true; sel.appendChild(o); });
      sel.addEventListener('change', ()=>{ rule.values=[sel.value==='true']; console.log(`[${nowt()}] EDIT value -> ${asTextRule(rule, gMode)}`); if(!isDraft){ persistRulesNow("change:value"); renderList(); } card._updateSave?.(); });
      pCond.appendChild(sel);
    } else if (src?.type==='date'){
      const inp = document.createElement('input'); inp.type='text'; inp.placeholder='YYYY-MM-DD'; inp.style.minWidth='140px';
      inp.value = String(rule.values?.[0]||'');
      setTimeout(()=>{ try{ flatpickr(inp,{ allowInput:true, dateFormat:'Y-m-d', onChange:()=>{ rule.values=[inp.value]; console.log(`[${nowt()}] EDIT value -> ${asTextRule(rule, gMode)}`); if(!isDraft){ persistRulesNow("change:value"); renderList(); } card._updateSave?.(); } }); }catch{} },0);
      inp.addEventListener('input', ()=>{ rule.values=[inp.value]; console.log(`[${nowt()}] EDIT value -> ${asTextRule(rule, gMode)}`); schedulePersist(); card._updateSave?.(); });
      pCond.appendChild(inp);
    } else if (src?.type==='text'){
      const inp = document.createElement('input'); inp.type='text'; inp.value=String(rule.values?.[0]||'');
      inp.addEventListener('input', ()=>{ rule.values=[inp.value]; console.log(`[${nowt()}] EDIT value -> ${asTextRule(rule, gMode)}`); schedulePersist(); card._updateSave?.(); });
      pCond.appendChild(inp);
    } else if (src?.type==='number'){
      const inp = document.createElement('input'); inp.type='number'; inp.value=String(rule.values?.[0]??'');
      inp.addEventListener('input', ()=>{ const v=inp.value; rule.values=[v===''? '': Number(v)]; console.log(`[${nowt()}] EDIT value -> ${asTextRule(rule, gMode)}`); schedulePersist(); card._updateSave?.(); });
      pCond.appendChild(inp);
    } else if (src?.type==='select'){
      const sel = document.createElement('select');
      const def=document.createElement('option'); def.value=''; def.textContent='Select value…'; sel.appendChild(def);
      const base = (gSchema.fields||[]).find(ff => String(ff.id)===String(src.id));
      const opts = base ? normOptions(base) : (src.options||[]).map(x=>({value:String(x),label:String(x)}));
      opts.forEach(opt=>{ const o=document.createElement('option'); o.value=String(opt.value); o.textContent=String(opt.label); if(String(rule.values?.[0])===String(opt.value)) o.selected=true; sel.appendChild(o); });
      sel.addEventListener('change', ()=>{ rule.values = sel.value ? [sel.value] : ['']; console.log(`[${nowt()}] EDIT value -> ${asTextRule(rule, gMode)}`); if(!isDraft){ persistRulesNow("change:value"); renderList(); } card._updateSave?.(); });
      pCond.appendChild(sel);
    } else {
      // Fallback text
      const inp = document.createElement('input'); inp.type='text'; inp.value=String(rule.values?.[0]||'');
      inp.addEventListener('input', ()=>{ rule.values=[inp.value]; console.log(`[${nowt()}] EDIT value(fallback) -> ${asTextRule(rule, gMode)}`); schedulePersist(); card._updateSave?.(); });
      pCond.appendChild(inp);
    }

    row2.appendChild(pCond);
    card.appendChild(row2);
  }

  // Row 3: Targets selector
  if (gMode === 'headings') {
    const flatHeads = flattenWithNumbers(gHeadingsTree);
    if (flatHeads.length){
      const row3 = document.createElement("div"); row3.className="rule-row";
      const pHead = document.createElement("div"); pHead.className="pair";
      const lblH = document.createElement("label"); lblH.textContent="Add heading";
      const chosenKeys = new Set((rule.targets||[]).map(t=> (typeof t==='string') ? t : t.key));
      const selH = document.createElement("select");
      const defH = document.createElement("option"); defH.value=""; defH.textContent="Select…"; selH.appendChild(defH);

      const options = flatHeads.map(h=>{
        const compKey = toCompositeKeyFromFlat(h);
        return { value: compKey, label: h.label };
      }).filter(h => !chosenKeys.has(h.value));

      options.forEach(h=>{
        const o=document.createElement("option"); o.value=h.value; o.textContent=h.label; selH.appendChild(o);
      });

      selH.addEventListener("change", ()=>{
        const compKey = selH.value; if (!compKey) return;
        const label = (options.find(x=>x.value===compKey)?.label) || compKey;
        rule.targets = rule.targets || [];
        rule.targets.push({ key: compKey, label });
        console.log(`[${nowt()}] EDIT addTarget -> ${asTextRule(rule, gMode)}`);
        persistRulesNow("change:addHeading"); renderEditor(); renderList();
      });

      pHead.appendChild(lblH); pHead.appendChild(selH);
      row3.appendChild(pHead);
      card.appendChild(row3);
    }
  } else {
    const sourcesT = (gSchema.fields||[]).map(f => ({ id:String(f.id), label: f.label||f.id }));
    if (sourcesT.length){
      const row3 = document.createElement("div"); row3.className="rule-row";
      const pFld = document.createElement("div"); pFld.className="pair";
      const lblF = document.createElement("label"); lblF.textContent="Add field";
      const chosenIds = new Set((rule.targets||[]).map(t=> String((typeof t==='string')? t : t.id) ));
      const selF = document.createElement("select");
      const defF = document.createElement("option"); defF.value=""; defF.textContent="Select…"; selF.appendChild(defF);
      sourcesT.forEach(s=>{ if (!chosenIds.has(String(s.id))) { const o=document.createElement("option"); o.value=s.id; o.textContent=s.label; selF.appendChild(o); } });
      selF.addEventListener("change", ()=>{
        const id = selF.value; if (!id) return;
        const s = sourcesT.find(x=>String(x.id)===String(id));
        if (!s) return;
        rule.targets = rule.targets || [];
        rule.targets.push({ id:s.id, label:s.label });
        console.log(`[${nowt()}] EDIT addTarget -> ${asTextRule(rule, gMode)}`);
        persistRulesNow("change:addField"); renderEditor(); renderList();
      });
      pFld.appendChild(lblF); pFld.appendChild(selF);
      row3.appendChild(pFld);
      card.appendChild(row3);
    }
  }

  // Row 4: Selected target pills
  const row4 = document.createElement("div"); row4.className="rule-row";
  const lblSel = document.createElement("div"); lblSel.className="muted"; lblSel.textContent = (gMode==='headings' ? "Selected headings:" : "Selected fields:");
  const hpills = document.createElement("div"); hpills.className="pills";
  (rule.targets||[]).forEach(t=>{
    const isHead = (gMode==='headings');
    const idOrKey = isHead ? (typeof t==='string'? t : t.key) : (typeof t==='string'? t : t.id);
    const label = isHead ? ( (typeof t==='object' && t.label) ? t.label : getHeadingLabelFromKey(String(idOrKey)) )
                         : ( (typeof t==='object' && t.label) ? t.label : getFieldLabelById(String(idOrKey)) );
    const pill = document.createElement("span"); pill.className="pill"; pill.title=String(idOrKey);
    const txt = document.createElement("span"); txt.textContent=label || String(idOrKey);
    const x = document.createElement("button"); x.setAttribute("aria-label","Remove"); x.textContent="×";
    x.addEventListener("click", ()=>{
      if (isHead) rule.targets = (rule.targets||[]).filter(z=> String((typeof z==='string'? z : z.key)) !== String(idOrKey) );
      else rule.targets = (rule.targets||[]).filter(z=> String((typeof z==='string'? z : z.id)) !== String(idOrKey) );
      console.log(`[${nowt()}] EDIT removeTarget -> ${asTextRule(rule, gMode)}`);
      persistRulesNow("change:removeTarget"); renderEditor(); renderList();
    });
    pill.appendChild(txt); pill.appendChild(x);
    hpills.appendChild(pill);
  });
  if (!hpills.children.length){
    const none=document.createElement("span"); none.className="empty"; none.textContent="(none)";
    hpills.appendChild(none);
  }
  row4.appendChild(lblSel); row4.appendChild(hpills);
  card.appendChild(row4);

  editorMount.appendChild(card);
  if (isDraft) card._updateSave?.();
}

/* ================================ List UI =============================== */
function summarizeCondition(rule){
  const sources = buildConditionSources(gSchema);
  let src = sources.find(s=>String(s.id)===String(rule.fieldId));
  const fallbackLabel = getFieldLabelById(rule.fieldId);
  const srcLabel = src?.label || fallbackLabel || String(rule.fieldId);
  const op = rule.op || 'equals';
  const v0 = Array.isArray(rule.values) ? rule.values[0] : rule.values;

  if (!src) return `when ${srcLabel} ${op} ${JSON.stringify(v0)}`;
  if (src.type === 'boolean') return `when ${srcLabel} ${op} ${String(v0)}`;
  if (src.type === 'date')    return `when ${srcLabel} ${op} ${String(v0||'')}`;
  if (src.type === 'text')    return `when ${srcLabel} ${op} "${String(v0||'')}"`;
  if (src.type === 'number')  return `when ${srcLabel} ${op} ${String(v0)}`;
  if (src.type === 'select') {
    const base = (gSchema.fields||[]).find(ff => String(ff.id)===String(src.id));
    const options = base ? normOptions(base) : (src.options||[]).map(x=>({value:String(x),label:String(x)}));
    const label = options.find(o=>String(o.value)===String(v0))?.label ?? String(v0||'');
    return `when ${srcLabel} ${op} "${label}"`;
  }
  return `when ${srcLabel} ${op}`;
}
function renderList(){
  rulesList.innerHTML = "";
  if (!gRules.length){
    rulesList.innerHTML = '<div class="empty">None.</div>';
    return;
  }

  gRules.forEach(r=>{
    const div=document.createElement("div"); div.className="item";
    const left=document.createElement("div");

    let targetsText = '';
    if (gMode==='headings') {
      const labels = (r.targets||[]).map(t=>{
        const k = String((typeof t==='string')? t : (t.key ?? ''));
        const lbl = (typeof t==='object' && t.label) ? t.label : getHeadingLabelFromKey(k);
        return lbl || k;
      }).filter(Boolean);
      targetsText = labels.join(', ') || '(no headings selected)';
    } else {
      const labels = (r.targets||[]).map(t=>{
        const id = String((typeof t==='string')? t : (t.id ?? ''));
        return (typeof t==='object' && t.label) ? t.label : getFieldLabelById(id);
      }).filter(Boolean);
      targetsText = labels.join(', ') || '(no fields selected)';
    }

    left.innerHTML = `<strong>${r.action}</strong> — <em>${targetsText}</em> <span class="muted"> ${summarizeCondition(r)}</span>`;
    const right=document.createElement("div"); right.style.display='flex'; right.style.gap='8px';

    const edit=document.createElement("button"); edit.className="btn btn-ghost"; edit.textContent="Edit";
    edit.addEventListener("click", ()=>{
      gDraft = null;
      gEditingId = r.id;
      renderEditor();
      editorMount.scrollIntoView({behavior:"smooth", block:"start"});
    });

    const del=document.createElement("button"); del.className="btn btn-danger"; del.textContent="Delete";
    del.addEventListener("click", ()=>{
      if (!confirm("Delete this rule?")) return;
      const idx = gRules.findIndex(x=>x.id===r.id);
      if (idx >= 0) gRules.splice(idx,1);
      if (gEditingId === r.id) gEditingId = null;
      console.log(`[${nowt()}] DELETE id=${r.id}`);
      persistRulesNow('delete'); renderEditor(); renderList();
    });

    right.appendChild(edit);
    right.appendChild(del);
    div.appendChild(left); div.appendChild(right);
    rulesList.appendChild(div);
  });
}

/* ============================== Reload / Sync =========================== */
async function reloadState(reason){
  try {
    if (!gDocId) { return; }

    let st = await window.formSuitePersist?.loadState?.(gDocId);
    st = await _ensureSchemaFromPayload(st);
    if (!st) { return; }
    if (st?.schema) gSchema = st.schema;
    if (Array.isArray(st.headingsTree)) gHeadingsTree = st.headingsTree;

    // Debug: print schema + headings early
    printSchemaDebug(gSchema);
    printHeadingsDebug(gHeadingsTree);

    // Pull payload mirrors
    const plObj = st?.payload?.CRONOS_PAYLOAD || st?.CRONOS_PAYLOAD || st?.cronos_payload || {};

    // Workspace (support both shapes)
    const wsHeadings = Array.isArray(st.rules) ? st.rules
                      : (Array.isArray(st.headingRules) ? st.headingRules : []);
    const wsFields   = Array.isArray(st.fieldRules) ? st.fieldRules : [];

    // Payload (support both shapes)
    const plHeadings = Array.isArray(plObj.rules) ? plObj.rules
                      : (Array.isArray(plObj.headingRules) ? plObj.headingRules : []);
    const plFields   = Array.isArray(plObj.fieldRules) ? plObj.fieldRules : [];

    printPayloadSnapshot(st);
    if (Array.isArray(st.headingRules)) printRuleArray('STATE workspace.headingRules', st.headingRules, 'headings');
    printRuleArray('STATE workspace.rules', Array.isArray(st.rules)?st.rules:[], 'headings');
    printRuleArray('STATE workspace.fieldRules', wsFields, 'fields');

    // Prefer workspace; fall back to payload; else keep existing
    const nextHeadings = wsHeadings.length ? cloneRulesArray(wsHeadings)
                        : (plHeadings.length ? cloneRulesArray(plHeadings) : cloneRulesArray(gRulesHeadings));
    const nextFields   = wsFields.length   ? cloneRulesArray(wsFields)
                        : (plFields.length ? cloneRulesArray(plFields)   : cloneRulesArray(gRulesFields));

    // Update in-memory stores
    gRulesHeadings = nextHeadings;
    gRulesFields   = nextFields;

    // Normalize targets + labels
    const flatHeads = flattenWithNumbers(gHeadingsTree);
    const normH = normalizeAllHeadingsRulesInPlace(gRulesHeadings, flatHeads);
    const normF = normalizeAllFieldRulesInPlace(gRulesFields, gSchema);
    if (normH>0) console.log(`[${nowt()}] NORMALIZE persist queued (headings targets)`);
    if (normF>0) console.log(`[${nowt()}] NORMALIZE persist queued (field targets)`);

    // Reflect what's chosen
    printRuleArray('CHOSEN rules (headings)', gRulesHeadings, 'headings');
    printRuleArray('CHOSEN fieldRules (fields)', gRulesFields, 'fields');

    gRules = (gMode==='headings') ? gRulesHeadings.slice() : gRulesFields.slice();
    if (!gRules.find(r=>r?.id===gEditingId)) gEditingId = null;

    if (normH>0 || normF>0) await persistRulesNow('normalize:headKeys');

    setStatus(`Loaded — fields: ${(gSchema.fields||[]).length}, headings: ${(gHeadingsTree||[]).length}, ${gMode==='headings'?'heading-rules':'field-rules'}: ${gRules.length}`);

    renderEditor(); renderList();
  } catch(e){ console.error("reloadState failed:", e); }
}

/* ============================== Sync wiring ============================= */
function hookSync(){
  bcLegacy?.addEventListener("message",(ev)=>{
    const m = ev?.data || {};
    if (m.type==="schema-updated"   && m.docId===gDocId) reloadState("schema-updated");
    if (m.type==="headings-updated" && m.docId===gDocId) reloadState("headings-updated");
    if (m.type==="doc-updated"      && m.docId===gDocId) reloadState("doc-updated");
    if (m.type==="doc-switched"     && m.docId && m.docId!==gDocId){ gDocId=m.docId; reloadState("doc-switched"); }
    if (m.type==="doc-cleared"){ gDocId=null; setStatus("Cleared."); editorMount.innerHTML='<div class="empty">No rules yet — click “Add rule”.</div>'; rulesList.innerHTML='<div class="empty">None.</div>'; }
  });
  bcCanon?.addEventListener("message",(ev)=>{
    const m = ev?.data || {};
    if (m.type==="active:set"){ if (m.docId && m.docId!==gDocId){ gDocId=m.docId; reloadState("active:set"); } }
    if (m.type==="active:updated"){ if (m.docId===gDocId) reloadState("active:updated"); }
    if (m.type==="active:clear"){ gDocId=null; setStatus("Cleared."); }
  });

  // Payload patch channel (instant)
  bcPayload?.addEventListener("message", (ev) => {
    const msg = ev?.data || {};
    if (msg?.t !== 'payload' || !msg.docId || msg.docId !== gDocId) return;
    const patch = msg.patch || {};
    let changed = false;

    if (Array.isArray(patch.rules)) {
      const flatHeads = flattenWithNumbers(gHeadingsTree);
      normalizeAllHeadingsRulesInPlace(patch.rules, flatHeads);
      gRulesHeadings = cloneRulesArray(patch.rules);
      if (gMode==='headings') { gRules = gRulesHeadings.slice(); changed = true; }
      printRuleArray('LIVE payload patch -> rules', patch.rules, 'headings');
    }
    if (Array.isArray(patch.fieldRules)) {
      normalizeAllFieldRulesInPlace(patch.fieldRules, gSchema);
      gRulesFields = cloneRulesArray(patch.fieldRules);
      if (gMode==='fields') { gRules = gRulesFields.slice(); changed = true; }
      printRuleArray('LIVE payload patch -> fieldRules', patch.fieldRules, 'fields');
    }
    if (patch.schema) { gSchema = patch.schema; changed = true; }
    if (Array.isArray(patch.headingsTree)) { gHeadingsTree = patch.headingsTree; changed = true; }

    if (changed) { renderEditor(); renderList(); setStatus("Live-updated from another tab."); }
  });

  // Storage switch
  window.addEventListener("storage", (e)=>{
    if (e.key===ACTIVE_LS_KEY && e.newValue){
      const meta = JSON.parse(e.newValue||"null");
      if (meta?.docId && meta.docId!==gDocId){ gDocId=meta.docId; reloadState("storage switch"); }
    }
  });
}

/* ============================== Tabs + Boot ============================= */
function applyTabUI(){
  const isHead = gMode==='headings';
  if (tabHeadings) {
    tabHeadings.setAttribute('aria-pressed', String(isHead));
    tabHeadings.className = 'btn ' + (isHead ? 'btn-secondary' : 'btn-ghost');
  }
  if (tabFields) {
    tabFields.setAttribute('aria-pressed', String(!isHead));
    tabFields.className   = 'btn ' + (!isHead ? 'btn-secondary' : 'btn-ghost');
  }
  if (rulesHint) {
    rulesHint.textContent = isHead
      ? 'SHOW or HIDE specific headings/subheaders based on a field’s selected value(s).'
      : 'SHOW or HIDE specific form fields based on another field’s selected value(s).';
  }
}
tabHeadings?.addEventListener('click', async ()=>{
  if (gMode==='headings') return;
  gMode='headings';
  gDraft = null; gEditingId = null;
  gRules = gRulesHeadings.slice();
  applyTabUI();
  await reloadState('tab:headings');
});
tabFields?.addEventListener('click', async ()=>{
  if (gMode==='fields') return;
  gMode='fields';
  gDraft = null; gEditingId = null;
  gRules = gRulesFields.slice();
  applyTabUI();
  await reloadState('tab:fields');
});

/* ================================= Boot ================================= */
btnAddRule.addEventListener("click", ()=>{
  gEditingId = null;
  gDraft = { id:null, action:null, fieldId:"", op:null, values:[], targets:[] };
  console.log(`[${nowt()}] DRAFT ${asTextRule(gDraft, gMode)}`);
  renderEditor();
  editorMount.scrollIntoView({behavior:"smooth", block:"start"});
});

(async function boot(){
  try{
    hookSync();
    try { window.formSuitePersist?.ensureHydrated?.(); } catch {}
    let meta = window.formSuitePersist?.getActiveDocMeta?.() || window.formSuitePersist?.getCurrentDocMeta?.() || readActiveMeta();
    if (!meta?.docId){ setStatus("No active document. Open one first."); return; }
    gDocId = meta.docId;
    applyTabUI();
    await reloadState("boot");
  } catch(e){ console.error("boot failed:", e); setStatus("Failed to load state."); }
})();
</script>
</body>
</html>
