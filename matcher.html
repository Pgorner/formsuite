<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Form Suite — Tag ↔ Field mapping</title>
  <link rel="icon" href="favicon.ico" type="image/gif" sizes="32x32">
  <link rel="shortcut icon" href="favicon.ico" type="image/gif">
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="style.css">
  <!-- Tiny helpers that don't affect page width -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="persistence.js"></script>
</head>
<body>
  <header>
    <div class="row">
      <span class="brand logo-md">
        <img src="logo.gif" alt="Form Suite logo" class="logo" />
        <strong>Form Suite</strong>
      </span>
      <span class="muted">·</span><a href="index.html">Form</a>
      <span class="muted">·</span><a href="builder.html">Form Builder</a>
      <span class="muted">·</span><span class="muted">Tag Matcher</span>
      <span class="muted">·</span><a href="rules.html">Rules</a>
      <span class="muted">·</span><a href="extractor.html">Extractor</a>
    </div>
  </header>

  <main>
    <!-- Status row -->
    <section class="panel">
      <div class="row" style="justify-content:space-between; align-items:center;">
        <div>
          <span class="muted">Active schema:</span>
          <span id="schema-pill" class="pill muted">—</span>
        </div>
        <div>
          <span class="muted">Active DOCX:</span>
          <span id="doc-pill" class="pill">—</span>
        </div>
      </div>
      <div id="permNote" class="warn" style="margin-top:8px; display:none;">
        Permission to the original file isn’t granted. You can still work from the cached copy.
        <button id="btnRegrant" class="ghost" style="margin-left:8px;">Re-grant file access</button>
      </div>
    </section>

    <!-- Mapping table -->
    <section class="panel">
      <h3 style="margin:0 0 8px;">Tag ↔ Field mapping</h3>
      <div style="overflow:auto;">
        <table id="map-table">
          <thead>
            <tr>
              <th class="nowrap">#</th>
              <th class="nowrap"><code>w:tag</code></th>
              <th class="nowrap">alias</th>
              <th>Current SDT text</th>
              <th class="nowrap" style="width:320px">Map to field id</th>
            </tr>
          </thead>
          <tbody id="tbody">
            <tr><td colspan="5" class="empty">No document loaded. Open a DOCX in <strong>Extractor</strong> first.</td></tr>
          </tbody>
        </table>
      </div>
    </section>
  </main>

  <script>
    const $ = sel => document.querySelector(sel);
    const supportsFS = 'showOpenFilePicker' in window && 'showSaveFilePicker' in window;

    // === DEBUG helpers ===
    const _ts = () => new Date().toISOString().slice(11, 23);
    const DBG = (...a) => console.log(`[Matcher ${_ts()}]`, ...a);
    async function sha256Hex(bufOrU8) {
      const ab = (bufOrU8 instanceof ArrayBuffer) ? bufOrU8
                : (bufOrU8?.buffer instanceof ArrayBuffer) ? bufOrU8.buffer
                : new Uint8Array(bufOrU8 || []).buffer;
      const d = await crypto.subtle.digest('SHA-256', ab);
      return [...new Uint8Array(d)].map(b => b.toString(16).padStart(2, '0')).join('');
    }

    // ---- File-Guard: clear UI to avoid stale data ----
    async function hardResetMatcher(reason = '') {
      try {} catch {}
      const tb = $('#tbody');
      if (tb) {
        tb.innerHTML = '';
        const tr = document.createElement('tr');
        const td = document.createElement('td');
        td.colSpan = 5;
        td.className = 'empty';
        td.innerHTML = 'No document loaded. Open a DOCX in <strong>Extractor</strong> first.';
        tr.appendChild(td);
        tb.appendChild(tr);
      }
      $('#schema-pill').textContent = '—';
      $('#schema-pill').classList.add('muted');
      $('#doc-pill').textContent = '—';
      $('#permNote').style.display = 'none';
      gDocId = null;
      gSDTs = [];
      DBG('hardResetMatcher:', reason || '(no reason)');
    }

    // ---- Bytes fetch (OPFS → currentDocBytes → handle) ----
    async function getWorkingBytes(docId) {
      try {
        const opfs = await window.formSuitePersist.getBytes(docId);
        if (opfs && opfs.byteLength) return opfs;
      } catch {}
      try {
        const cur = await window.formSuitePersist.getCurrentDocBytes();
        if (cur && cur.byteLength) return cur;
      } catch {}
      try {
        const h = await window.formSuitePersist.getHandle(docId);
        if (h?.getFile) {
          let perm = await h.queryPermission?.({ mode: 'readwrite' });
          if (perm !== 'granted') {
            try { perm = await h.queryPermission?.({ mode: 'read' }); } catch {}
          }
          if (perm === 'granted') {
            const file = await h.getFile();
            return await file.arrayBuffer();
          }
        }
      } catch {}
      return null;
    }

    function xmlText(el) {
      let s = '';
      const rec = n => {
        if (n.nodeType === 3) { s += n.nodeValue; return; }
        if (n.nodeType === 1) {
          if (n.localName === 'p' || n.localName === 'cr' || n.localName === 'br') s += '\n';
          for (const ch of n.childNodes) rec(ch);
        }
      };
      rec(el);
      return s.replace(/\s+\n/g,'\n').replace(/\n{3,}/g,'\n\n').trim();
    }

    async function readSDTsFromDocx(docBytes) {
      if (!docBytes) { DBG('readSDTsFromDocx: no bytes'); return []; }
      DBG('readSDTsFromDocx: bytes=', docBytes.byteLength, 'sha=', await sha256Hex(docBytes));
      const zip = await JSZip.loadAsync(docBytes);
      const parts = zip.file(/^word\/(?!_rels\/|theme\/|fontTable\.xml|styles\.xml|numbering\.xml|settings\.xml|webSettings\.xml).*\.xml$/i);
      DBG('Parts to scan:', parts.map(p => p.name));
      if (!parts.length) return [];
      const parser = new DOMParser();
      const W_NS = "http://schemas.openxmlformats.org/wordprocessingml/2006/main";
      const rows = [];
      let totalSeen = 0, totalKept = 0;

      for (const f of parts) {
        const xmlTextContent = await f.async('string');
        const xml = parser.parseFromString(xmlTextContent, "application/xml");
        const sdts = Array.from(xml.getElementsByTagNameNS(W_NS, 'sdt'));
        totalSeen += sdts.length;

        sdts.forEach((sdt) => {
          const pr = sdt.getElementsByTagNameNS(W_NS, 'sdtPr')[0];
          const content = sdt.getElementsByTagNameNS(W_NS, 'sdtContent')[0] || sdt;
          let tag = '', alias = '';
          const tEl = pr ? pr.getElementsByTagNameNS(W_NS, 'tag')[0] : null;
          if (tEl) tag = tEl.getAttributeNS(W_NS, 'val') || tEl.getAttribute('w:val') || '';
          const aEl = pr ? pr.getElementsByTagNameNS(W_NS, 'alias')[0] : null;
          if (aEl) alias = aEl.getAttributeNS(W_NS, 'val') || aEl.getAttribute('w:val') || '';
          // keep SDTs that have BOTH tag and alias (as before)
          if (tag && alias) {
            totalKept++;
            rows.push({
              idx: rows.length + 1,
              tag, alias,
              text: xmlText(content),
              sdtKey: tag
            });
          }
        });
      }
      DBG('Total SDTs seen:', totalSeen, ' · kept (tag+alias):', totalKept);
      return rows;
    }

    function deriveSchemaInfo(state) {
      const schemaObj = state?.schema && typeof state.schema === 'object' ? state.schema : null;
      const fieldsArr = Array.isArray(schemaObj?.fields) ? schemaObj.fields
                        : Array.isArray(state?.schema) ? state.schema : [];
      const title = schemaObj?.title || state?.schemaTitle || state?.title || 'Schema';

      // local helpers (match other pages)
      const slugifyMc = (s) => String(s || '')
        .normalize('NFKD')
        .replace(/[\u0300-\u036f]/g, '')
        .replace(/[^a-zA-Z0-9]+/g, '_')
        .replace(/^_+|_+$/g, '')
        .toLowerCase();
      const mcExtraKey = (fieldId, optionValue, extraId) => `${fieldId}__${slugifyMc(optionValue)}__${slugifyMc(extraId)}`;

      const uniq = new Map(); // key -> { type, label }
      const addField = (k, t, label) => {
        const key = String(k || '');
        if (!key) return;
        if (!uniq.has(key)) uniq.set(key, { type: t || 'text', label: String(label || key) });
      };

      for (const f of fieldsArr) {
        if (!f) continue;
        const key = (f.id != null) ? String(f.id) : (f.key != null) ? String(f.key) : null;
        if (key) addField(key, f.type || 'text', key);

        // Flatten MultiChoice extras as mappable fields as well
        if (f.type === 'multichoice' && f.mc && Array.isArray(f.mc.groups)) {
          for (const g of f.mc.groups) {
            for (const it of (g.items || [])) {
              const optVal = String(it?.value ?? it?.label ?? '');
              const extras = Array.isArray(it?.fields) ? it.fields : [];
              for (const ex of extras) {
                let exId = String(ex?.id || '').trim();
                if (!exId && String(ex?.type) === 'datediff') {
                  const fromId = String(ex?.fromId || '').trim();
                  const toId   = String(ex?.toId   || '').trim();
                  if (fromId || toId) exId = `datediff_${fromId}_${toId}`.replace(/__+/g,'_').replace(/^_|_$/g,'');
                }
                if (!exId) continue;
                const k = mcExtraKey(f.id, optVal, exId);
                // Label = just the subfield id (clearer for users)
                addField(k, ex?.type || 'text', exId);
              }
            }
          }
        }
      }
      const fields = Array.from(uniq.entries()).map(([key, v]) => ({ key, type: v.type, label: v.label }));
      return { title, fields, count: fields.length };
    }

    function renderSchemaPill(info) {
      $('#schema-pill').textContent = `${info.title} · ${info.count} ${info.count===1?'field':'fields'}`;
      $('#schema-pill').classList.toggle('muted', !(info.count >= 0));
    }
    function renderDocPill(meta) {
      $('#doc-pill').textContent = meta?.name || '—';
    }

    function buildFieldOptions(fields) {
      const frag = document.createDocumentFragment();
      const sorted = fields.slice().sort((a,b)=> (a.label||a.key).localeCompare(b.label||b.key));
      const optNone = document.createElement('option');
      optNone.value = '';
      optNone.textContent = '— not mapped —';
      frag.appendChild(optNone);
      for (const f of sorted) {
        const opt = document.createElement('option');
        opt.value = f.key;
        opt.textContent = f.label || f.key;
        frag.appendChild(opt);
      }
      return frag;
    }

    function escapeHtml(s) {
      return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
    }

    // Keep tagMap clean with current SDTs and current field ids
    function sanitizeTagMap(tagMap, fields, sdts) {
      const out = {};
      const validFieldIds = new Set((fields || []).map(f => f.key));
      const presentTags   = new Set((sdts   || []).map(s => s.sdtKey));
      for (const [tag, id] of Object.entries(tagMap || {})) {
        if (presentTags.has(tag) && validFieldIds.has(String(id))) out[tag] = String(id);
      }
      return out;
    }

    // Build a patch that mirrors to all known slots and uses setState (instant, cross-tab)
    async function persistTagMapPatch(docId, cleanedMap) {
      const state = await window.formSuitePersist?.loadState?.(docId);
      const basePayload = (state?.payload?.CRONOS_PAYLOAD)
                       || (state?.CRONOS_PAYLOAD)
                       || (state?.cronos_payload)
                       || {};
      const canonical = { ...basePayload, tagMap: cleanedMap, updatedAt: new Date().toISOString() };

      const patch = {
        tagMap: cleanedMap,                    // legacy convenience
        payload: { CRONOS_PAYLOAD: canonical },
        CRONOS_PAYLOAD: canonical,
        cronos_payload: canonical
      };

      try {
        if (window.formSuitePersist?.setState) {
          window.formSuitePersist.setState(docId, patch); // broadcasts via fs-payload-v1
        } else {
          await window.formSuitePersist?.saveState?.(docId, patch);
          // Fallback broadcast for older tabs
          try {
            bcCanon?.postMessage({ type: 'active:updated', docId, ts: Date.now(), from: 'matcher' });
            bcLegacy?.postMessage({ type: 'schema-updated', docId, ts: Date.now(), from: 'matcher' });
          } catch {}
        }
      } catch (e) {
        console.warn('persistTagMapPatch failed', e);
      }
    }

    function renderRows(sdts, fields, tagMap, onChange) {
      const tbody = $('#tbody');
      tbody.innerHTML = '';
      if (!sdts.length) {
        const tr = document.createElement('tr');
        const td = document.createElement('td');
        td.colSpan = 5;
        td.className = 'empty';
        td.innerHTML = 'No SDTs with both <code>w:tag</code> and alias found.';
        tr.appendChild(td);
        tbody.appendChild(tr);
        return;
      }

      // Build one shared options fragment reuse
      const optionsFrag = buildFieldOptions(fields);

      sdts.forEach((row, i) => {
        const tr = document.createElement('tr');

        const tdIdx = document.createElement('td');
        tdIdx.textContent = String(i + 1);
        tr.appendChild(tdIdx);

        const tdTag = document.createElement('td');
        tdTag.innerHTML = `<code>${escapeHtml(row.tag)}</code>`;
        tr.appendChild(tdTag);

        const tdAlias = document.createElement('td');
        tdAlias.textContent = row.alias || '—';
        tr.appendChild(tdAlias);

        const tdText = document.createElement('td');
        const spanText = document.createElement('span');
        spanText.className = 'truncate';
        spanText.title = row.text || '';
        spanText.textContent = row.text || '';
        tdText.appendChild(spanText);
        tr.appendChild(tdText);

        const tdMap = document.createElement('td');
        const sel = document.createElement('select');
        sel.appendChild(optionsFrag.cloneNode(true));
        sel.value = tagMap?.[row.sdtKey] || '';
        sel.addEventListener('change', () => onChange(row.sdtKey, sel.value || ''));
        tdMap.appendChild(sel);
        tr.appendChild(tdMap);

        tbody.appendChild(tr);
      });
    }

    // ---------- Live sync / guards ----------
    const bcLegacy = ('BroadcastChannel' in window) ? new BroadcastChannel('form-suite-doc')  : null;
    const bcCanon  = ('BroadcastChannel' in window) ? new BroadcastChannel('fs-active-doc')   : null;
    const bcPayload= ('BroadcastChannel' in window) ? new BroadcastChannel('fs-payload-v1')   : null;

    let gDocId = null;
    let gSDTs = []; // cache parsed SDTs to avoid re-parse on schema-only updates
    let __refreshBusy = false, __refreshPending = false;

    async function refreshAll(reason = '') {
      if (__refreshBusy) { __refreshPending = true; return; }
      __refreshBusy = true;
      try {
        const meta = window.formSuitePersist?.getActiveDocMeta?.()
                  || window.formSuitePersist?.getCurrentDocMeta?.()
                  || null;
        if (!meta?.docId) { await hardResetMatcher('no meta'); return; }
        gDocId = meta.docId;
        renderDocPill(meta);

        // Permission banner only when a handle exists and permission is NOT granted
        try {
          const h = await window.formSuitePersist.getHandle(gDocId);
          if (supportsFS && h) {
            let perm = await h.queryPermission?.({ mode: 'readwrite' });
            $('#permNote').style.display = (perm === 'granted') ? 'none' : 'block';
          } else {
            $('#permNote').style.display = 'none';
          }
        } catch { $('#permNote').style.display = 'none'; }

        // Ensure bytes; if not, clear UI
        const bytes = await getWorkingBytes(gDocId);
        if (!bytes) { await hardResetMatcher('no bytes / no permission'); return; }

        // Re-parse SDTs for this byte snapshot
        try { gSDTs = await readSDTsFromDocx(bytes); } catch (e) { console.warn('SDT scan failed:', e); gSDTs = []; }

        // Load state -> derive schema + tagMap and render
        const state = await window.formSuitePersist?.loadState?.(gDocId);
        const { title, fields } = deriveSchemaInfo(state || {});
        renderSchemaPill({ title, count: fields.length });

        const payload = (state?.payload?.CRONOS_PAYLOAD)
                     || (state?.cronos_payload)
                     || state?.CRONOS_PAYLOAD
                     || {};
        let tagMap = sanitizeTagMap(payload.tagMap || state?.tagMap || {}, fields, gSDTs);

        // If sanitization removed entries, persist the cleaned map
        const orig = payload.tagMap || state?.tagMap || {};
        if (JSON.stringify(tagMap) !== JSON.stringify(orig)) {
          await persistTagMapPatch(gDocId, tagMap);
        }

        renderRows(gSDTs, fields, tagMap, async (key, mappedTo) => {
          const nextMap = { ...(tagMap || {}) };
          if (mappedTo) nextMap[key] = mappedTo; else delete nextMap[key];
          const cleaned = sanitizeTagMap(nextMap, fields, gSDTs);
          await persistTagMapPatch(gDocId, cleaned);
          tagMap = cleaned;
        });

        DBG('refreshAll done', reason);
      } finally {
        __refreshBusy = false;
        if (__refreshPending) { __refreshPending = false; refreshAll('coalesced'); }
      }
    }

    // Broadcast listeners (legacy + canonical + payload)
    bcLegacy?.addEventListener('message', async (ev) => {
      const m = ev?.data || {};
      try {
        if (m.type === 'doc-cleared') {
          await hardResetMatcher('cleared by another tab');
          return;
        }
        if (m.type === 'doc-switched') {
          const meta = window.formSuitePersist?.getActiveDocMeta?.()
                    || window.formSuitePersist?.getCurrentDocMeta?.()
                    || null;
          if (!meta?.docId || (m.docId && meta.docId !== m.docId)) return;
          await refreshAll('doc-switched');
          return;
        }
        if (m.type === 'doc-updated' || m.type === 'schema-updated') {
          const meta = window.formSuitePersist?.getActiveDocMeta?.()
                    || window.formSuitePersist?.getCurrentDocMeta?.()
                    || null;
          if (!meta?.docId) return;
          if (m.docId != null && m.docId !== meta.docId) return;
          await refreshAll(m.type);
          return;
        }
      } catch (e) {
        console.warn('Matcher legacy broadcast handling failed:', e);
      }
    });

    bcCanon?.addEventListener('message', async (ev) => {
      const m = ev?.data || {};
      try {
        if (m.type === 'active:clear') { await hardResetMatcher('active:clear'); return; }
        if (m.type === 'active:set')   { await refreshAll('active:set'); return; }
        if (m.type === 'active:updated') {
          if (!gDocId || (m.docId && m.docId !== gDocId)) return;
          await refreshAll('active:updated');
        }
      } catch (e) { console.warn('Matcher canon broadcast failed:', e); }
    });

    // Instant payload patches from any tab
    bcPayload?.addEventListener('message', async (ev) => {
      const msg = ev?.data || {};
      if (msg?.t !== 'payload' || !msg.docId || msg.docId !== gDocId) return;
      // Only react to tagMap/schema relevant changes; keep current SDTs (already parsed)
      try {
        const st = await window.formSuitePersist?.loadState?.(gDocId);
        const { title, fields } = deriveSchemaInfo(st || {});
        renderSchemaPill({ title, count: fields.length });

        const srcMap = (st?.payload?.CRONOS_PAYLOAD?.tagMap)
                    || (st?.CRONOS_PAYLOAD?.tagMap)
                    || (st?.cronos_payload?.tagMap)
                    || st?.tagMap
                    || {};
        const tagMap = sanitizeTagMap(srcMap, fields, gSDTs);
        renderRows(gSDTs, fields, tagMap, async (key, mappedTo) => {
          const nextMap = { ...(tagMap || {}) };
          if (mappedTo) nextMap[key] = mappedTo; else delete nextMap[key];
          const cleaned = sanitizeTagMap(nextMap, fields, gSDTs);
          await persistTagMapPatch(gDocId, cleaned);
        });
      } catch (e) {
        console.warn('payload listener refresh failed', e);
      }
    });

    // Visibility / focus guards
    document.addEventListener('visibilitychange', async () => {
      if (document.visibilityState !== 'visible') return;
      await refreshAll('visibility');
    });
    window.addEventListener('focus', async () => { await refreshAll('focus'); });

    // ---------- Boot ----------
    (async function init() {
      try { window.formSuitePersist?.ensureHydrated?.(); } catch {}
      const meta = window.formSuitePersist?.getActiveDocMeta?.()
                || window.formSuitePersist?.getCurrentDocMeta?.()
                || null;
      renderDocPill(meta);
      if (!meta?.docId) { await hardResetMatcher('no meta at boot'); return; }
      gDocId = meta.docId;

      // Permission banner (only when a handle exists and not granted)
      try {
        const h = await window.formSuitePersist.getHandle(gDocId);
        if (supportsFS && h) {
          let perm = await h.queryPermission?.({ mode: 'readwrite' });
          $('#permNote').style.display = (perm === 'granted') ? 'none' : 'block';
        } else {
          $('#permNote').style.display = 'none';
        }
      } catch { $('#permNote').style.display = 'none'; }

      // Ensure bytes & render or reset
      const bytes = await getWorkingBytes(gDocId);
      if (!bytes) { await hardResetMatcher('no bytes / no permission'); return; }

      // Parse SDTs + render once at boot
      try { gSDTs = await readSDTsFromDocx(bytes); } catch { gSDTs = []; }
      const state = await window.formSuitePersist?.loadState?.(gDocId);
      const { title, fields } = deriveSchemaInfo(state || {});
      renderSchemaPill({ title, count: fields.length });

      const payload = (state?.payload?.CRONOS_PAYLOAD)
                   || (state?.cronos_payload)
                   || state?.CRONOS_PAYLOAD
                   || {};
      let tagMap = sanitizeTagMap(payload.tagMap || state?.tagMap || {}, fields, gSDTs);

      // persist cleanup if needed
      const orig = payload.tagMap || state?.tagMap || {};
      if (JSON.stringify(tagMap) !== JSON.stringify(orig)) {
        await persistTagMapPatch(gDocId, tagMap);
      }

      renderRows(gSDTs, fields, tagMap, async (key, mappedTo) => {
        const nextMap = { ...(tagMap || {}) };
        if (mappedTo) nextMap[key] = mappedTo; else delete nextMap[key];
        const cleaned = sanitizeTagMap(nextMap, fields, gSDTs);
        await persistTagMapPatch(gDocId, cleaned);
        tagMap = cleaned;
      });
    })();

    // Re-grant button (user activation → safe to request permission)
    document.getElementById('btnRegrant')?.addEventListener('click', async () => {
      try {
        if (!gDocId || !supportsFS) return;
        const handle = await window.formSuitePersist.getHandle(gDocId);
        if (!handle) return;
        let perm = await handle.queryPermission?.({ mode: 'readwrite' });
        if (perm !== 'granted') {
          const res = await handle.requestPermission?.({ mode: 'readwrite' });
          if (res !== 'granted') return;
        }
        document.getElementById('permNote').style.display = 'none';
        await refreshAll('regrant');
      } catch (e) {
        console.warn('Re-grant failed (matcher):', e);
      }
    });

    // Triple-click logo: focus mode + go to index, toggle header links
    (function() {
      const logo = document.querySelector('header .logo');
      const header = document.querySelector('header .row');
      if (!logo || !header) return;
      let clickCount = 0;
      let clickTimer = null;
      let focusMode = false;

      logo.addEventListener('click', () => {
        clickCount++;
        clearTimeout(clickTimer);
        clickTimer = setTimeout(() => { clickCount = 0; }, 600);
        if (clickCount === 3) {
          clickCount = 0;
          focusMode = !focusMode;
          if (focusMode) {
            header.querySelectorAll('a, span.muted').forEach(el => { if (!el.closest('.brand')) el.style.display = 'none'; });
            if (!location.pathname.endsWith('index.html')) location.href = 'index.html';
          } else {
            header.querySelectorAll('a, span.muted').forEach(el => { el.style.display = ''; });
          }
        }
      });
    })();
  </script>
</body>
</html>
