<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <title>Form Suite — Tag ↔ Feld-Zuordnung</title>
  <link rel="icon" href="favicon.ico" type="image/gif" sizes="32x32">
  <link rel="shortcut icon" href="favicon.ico" type="image/gif">
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="style.css">

  <!-- SDT-Scan -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

  <!-- Zentrales App-Plumbing -->
  <script src="persistence.js"></script>
  <script src="fs-active-doc.js"></script>
  <script src="fs-focus-nav.js"></script>
</head>
<body>
  <header>
    <div class="row">
      <span class="brand logo-md">
        <img src="logo.gif" alt="Form Suite Logo" class="logo" />
        <strong>Form Suite</strong>
      </span>
      <span class="muted">·</span><a href="index.html">Formular</a>
      <span class="muted">·</span><a href="builder.html">Formular-Builder</a>
      <span class="muted">·</span><span class="muted">Tag-Zuordnung</span>
      <span class="muted">·</span><a href="rules.html">Regeln</a>
      <span class="muted">·</span><a href="extractor.html">Extraktor</a>
    </div>
  </header>

  <main>
    <!-- Statuszeile -->
    <section class="panel">
      <div class="row" style="justify-content:space-between; align-items:center;">
        <div>
          <span class="muted">Aktives Schema:</span>
          <span id="schema-pill" class="pill muted">—</span>
        </div>
        <div>
          <span class="muted">Aktive DOCX:</span>
          <span id="doc-pill" class="pill">—</span>
        </div>
      </div>

      <div id="permNote" class="warn" style="margin-top:8px; display:none;">
        Zugriff auf die Originaldatei ist nicht gewährt. Du kannst weiterhin mit der zwischengespeicherten Kopie arbeiten.
        <button id="btnRegrant" class="ghost" style="margin-left:8px;">Dateizugriff erneut erlauben</button>
      </div>
    </section>

    <!-- Zuordnungstabelle -->
    <section class="panel">
      <h3 style="margin:0 0 8px;">Tag ↔ Feld-Zuordnung</h3>
      <div style="overflow:auto;">
        <table id="map-table">
          <thead>
            <tr>
              <th class="nowrap">#</th>
              <th class="nowrap"><code>w:tag</code></th>
              <th class="nowrap">Alias</th>
              <th>Aktueller SDT-Text</th>
              <th class="nowrap" style="width:320px">Zu Feld-ID zuordnen</th>
            </tr>
          </thead>
          <tbody id="tbody">
            <tr><td colspan="5" class="empty">Kein Dokument geladen. Öffne zuerst eine DOCX im <strong>Extraktor</strong>.</td></tr>
          </tbody>
        </table>
      </div>
    </section>
  </main>

  <script>
    const $ = (sel) => document.querySelector(sel);
    const supportsFS = ('showOpenFilePicker' in window) && ('showSaveFilePicker' in window);

    // ========= DEBUG =========
    const _ts = () => new Date().toISOString().slice(11, 23);
    const DBG = (...a) => console.log(`[Matcher ${_ts()}]`, ...a);
    const WARN = (...a) => console.warn(`[Matcher ${_ts()}]`, ...a);

    async function sha256Hex(bufOrU8) {
      const ab = (bufOrU8 instanceof ArrayBuffer) ? bufOrU8
        : (bufOrU8?.buffer instanceof ArrayBuffer) ? bufOrU8.buffer
        : new Uint8Array(bufOrU8 || []).buffer;
      const d = await crypto.subtle.digest('SHA-256', ab);
      return [...new Uint8Array(d)].map(b => b.toString(16).padStart(2, '0')).join('');
    }

    // ========= Canonical channels =========
    const bcPayload = ('BroadcastChannel' in window) ? new BroadcastChannel('fs-payload-v1') : null;

    // ========= Page state =========
    let gDoc = null;        // { docId, name, ... }
    let gDocId = null;
    let gSDTs = [];         // cached parsed SDTs
    let gBytesSha12 = '';   // detect when DOCX changed

    let __refreshBusy = false;
    let __refreshPending = false;
    let __suppressNextPayloadRefresh = false; // used after we write tagMap

    // ========= UI resets =========
    function renderDocPill(meta) {
      $('#doc-pill').textContent = meta?.name || meta?.docTitle || '—';
    }
    function renderSchemaPill(info) {
      $('#schema-pill').textContent = `${info.title} · ${info.count} ${info.count === 1 ? 'Feld' : 'Felder'}`;
      $('#schema-pill').classList.toggle('muted', !(info.count >= 0));
    }

    function resetTableNoDoc() {
      const tb = $('#tbody');
      tb.innerHTML = '';
      const tr = document.createElement('tr');
      const td = document.createElement('td');
      td.colSpan = 5;
      td.className = 'empty';
      td.innerHTML = 'Kein Dokument geladen. Öffne zuerst eine DOCX im <strong>Extraktor</strong>.';
      tr.appendChild(td);
      tb.appendChild(tr);
    }

    async function hardResetMatcher(reason = '') {
      resetTableNoDoc();
      $('#schema-pill').textContent = '—';
      $('#schema-pill').classList.add('muted');
      $('#doc-pill').textContent = '—';
      $('#permNote').style.display = 'none';

      gDoc = null;
      gDocId = null;
      gSDTs = [];
      gBytesSha12 = '';

      DBG('hardResetMatcher', { reason: reason || '(no reason)' });
    }

    // ========= Bytes (canonical preference order) =========
    async function getWorkingBytes(docId) {
      // 1) OPFS bytes (best: always works without re-grant)
      try {
        const opfs = await window.formSuitePersist?.getBytes?.(docId);
        if (opfs && opfs.byteLength) return opfs;
      } catch (e) { /* ignore */ }

      // 2) In-memory current bytes (Extractor may set/update)
      try {
        const cur = await window.formSuitePersist?.getCurrentDocBytes?.();
        if (cur && cur.byteLength) return cur;
      } catch (e) { /* ignore */ }

      // 3) Original handle (needs permission)
      try {
        const h = await window.formSuitePersist?.getHandle?.(docId);
        if (h?.getFile) {
          let perm = await h.queryPermission?.({ mode: 'readwrite' });
          if (perm !== 'granted') {
            try { perm = await h.queryPermission?.({ mode: 'read' }); } catch {}
          }
          if (perm === 'granted') {
            const file = await h.getFile();
            return await file.arrayBuffer();
          }
        }
      } catch (e) { /* ignore */ }

      return null;
    }

    async function updatePermissionBanner(docId) {
      try {
        const h = await window.formSuitePersist?.getHandle?.(docId);
        if (!supportsFS || !h) { $('#permNote').style.display = 'none'; return; }
        let perm = await h.queryPermission?.({ mode: 'readwrite' });
        if (perm !== 'granted') {
          try { perm = await h.queryPermission?.({ mode: 'read' }); } catch {}
        }
        $('#permNote').style.display = (perm === 'granted') ? 'none' : 'block';
      } catch {
        $('#permNote').style.display = 'none';
      }
    }

    // ========= SDT parsing =========
    function xmlText(el) {
      let s = '';
      const rec = (n) => {
        if (n.nodeType === 3) { s += n.nodeValue; return; }
        if (n.nodeType === 1) {
          if (n.localName === 'p' || n.localName === 'cr' || n.localName === 'br') s += '\n';
          for (const ch of n.childNodes) rec(ch);
        }
      };
      rec(el);
      return s.replace(/\s+\n/g, '\n').replace(/\n{3,}/g, '\n\n').trim();
    }

    async function readSDTsFromDocx(docBytes) {
      if (!docBytes) { DBG('readSDTsFromDocx: no bytes'); return []; }

      const sha = await sha256Hex(docBytes);
      DBG('readSDTsFromDocx', { bytes: docBytes.byteLength, sha12: sha.slice(0, 12) });

      const zip = await JSZip.loadAsync(docBytes);
      const parts = zip.file(/^word\/(?!_rels\/|theme\/|fontTable\.xml|styles\.xml|numbering\.xml|settings\.xml|webSettings\.xml).*\.xml$/i);

      DBG('Parts to scan', parts.map(p => p.name));
      if (!parts.length) return [];

      const parser = new DOMParser();
      const W_NS = "http://schemas.openxmlformats.org/wordprocessingml/2006/main";
      const rows = [];

      let totalSeen = 0, totalKept = 0;

      for (const f of parts) {
        const xmlTextContent = await f.async('string');
        const xml = parser.parseFromString(xmlTextContent, "application/xml");
        const sdts = Array.from(xml.getElementsByTagNameNS(W_NS, 'sdt'));
        totalSeen += sdts.length;

        sdts.forEach((sdt) => {
          const pr = sdt.getElementsByTagNameNS(W_NS, 'sdtPr')[0];
          const content = sdt.getElementsByTagNameNS(W_NS, 'sdtContent')[0] || sdt;

          let tag = '', alias = '';
          const tEl = pr ? pr.getElementsByTagNameNS(W_NS, 'tag')[0] : null;
          if (tEl) tag = tEl.getAttributeNS(W_NS, 'val') || tEl.getAttribute('w:val') || '';
          const aEl = pr ? pr.getElementsByTagNameNS(W_NS, 'alias')[0] : null;
          if (aEl) alias = aEl.getAttributeNS(W_NS, 'val') || aEl.getAttribute('w:val') || '';

          // Keep SDTs that have BOTH tag and alias (as before)
          if (tag && alias) {
            totalKept++;
            rows.push({
              idx: rows.length + 1,
              tag, alias,
              text: xmlText(content),
              sdtKey: tag
            });
          }
        });
      }

      DBG('SDT scan summary', { totalSeen, totalKept });
      return rows;
    }

    // ========= Schema + options =========
    function deriveSchemaInfo(state) {
      const schemaObj = state?.schema && typeof state.schema === 'object' ? state.schema : null;
      const fieldsArr = Array.isArray(schemaObj?.fields) ? schemaObj.fields
        : Array.isArray(state?.schema) ? state.schema : [];
      const title = schemaObj?.title || state?.schemaTitle || state?.title || 'Schema';

      const slugifyMc = (s) => String(s || '')
        .normalize('NFKD')
        .replace(/[\u0300-\u036f]/g, '')
        .replace(/[^a-zA-Z0-9]+/g, '_')
        .replace(/^_+|_+$/g, '')
        .toLowerCase();
      const mcExtraKey = (fieldId, optionValue, extraId) =>
        `${fieldId}__${slugifyMc(optionValue)}__${slugifyMc(extraId)}`;

      const uniq = new Map(); // key -> { type, label }
      const addField = (k, t, label) => {
        const key = String(k || '');
        if (!key) return;
        if (!uniq.has(key)) uniq.set(key, { type: t || 'text', label: String(label || key) });
      };

      for (const f of fieldsArr) {
        if (!f) continue;
        const key = (f.id != null) ? String(f.id) : (f.key != null) ? String(f.key) : null;
        if (key) addField(key, f.type || 'text', key);

        // Flatten MultiChoice extras as mappable fields as well
        if (f.type === 'multichoice' && f.mc && Array.isArray(f.mc.groups)) {
          for (const g of f.mc.groups) {
            for (const it of (g.items || [])) {
              const optVal = String(it?.value ?? it?.label ?? '');
              const extras = Array.isArray(it?.fields) ? it.fields : [];
              for (const ex of extras) {
                let exId = String(ex?.id || '').trim();
                if (!exId && String(ex?.type) === 'datediff') {
                  const fromId = String(ex?.fromId || '').trim();
                  const toId   = String(ex?.toId   || '').trim();
                  if (fromId || toId) exId = `datediff_${fromId}_${toId}`.replace(/__+/g, '_').replace(/^_|_$/g, '');
                }
                if (!exId) continue;
                const k = mcExtraKey(f.id, optVal, exId);
                addField(k, ex?.type || 'text', exId);
              }
            }
          }
        }
      }

      const fields = Array.from(uniq.entries()).map(([key, v]) => ({ key, type: v.type, label: v.label }));
      return { title, fields, count: fields.length };
    }

    function buildFieldOptions(fields) {
      const frag = document.createDocumentFragment();
      const sorted = fields.slice().sort((a, b) => (a.label || a.key).localeCompare(b.label || b.key));

      const optNone = document.createElement('option');
      optNone.value = '';
      optNone.textContent = '— nicht zugeordnet —';
      frag.appendChild(optNone);

      for (const f of sorted) {
        const opt = document.createElement('option');
        opt.value = f.key;
        opt.textContent = f.label || f.key;
        frag.appendChild(opt);
      }
      return frag;
    }

    function escapeHtml(s) {
      return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
    }

    // Keep tagMap clean with current SDTs and current field ids
    function sanitizeTagMap(tagMap, fields, sdts) {
      const out = {};
      const validFieldIds = new Set((fields || []).map(f => f.key));
      const presentTags = new Set((sdts || []).map(s => s.sdtKey));
      for (const [tag, id] of Object.entries(tagMap || {})) {
        if (presentTags.has(tag) && validFieldIds.has(String(id))) out[tag] = String(id);
      }
      return out;
    }

    // ========= Rendering =========
    function renderRows(sdts, fields, tagMap, onChange) {
      const tbody = $('#tbody');
      tbody.innerHTML = '';

      if (!sdts.length) {
        const tr = document.createElement('tr');
        const td = document.createElement('td');
        td.colSpan = 5;
        td.className = 'empty';
        td.innerHTML = 'Keine SDTs mit sowohl <code>w:tag</code> als auch Alias gefunden.';
        tr.appendChild(td);
        tbody.appendChild(tr);
        return;
      }

      const optionsFrag = buildFieldOptions(fields);

      sdts.forEach((row, i) => {
        const tr = document.createElement('tr');

        const tdIdx = document.createElement('td');
        tdIdx.textContent = String(i + 1);
        tr.appendChild(tdIdx);

        const tdTag = document.createElement('td');
        tdTag.innerHTML = `<code>${escapeHtml(row.tag)}</code>`;
        tr.appendChild(tdTag);

        const tdAlias = document.createElement('td');
        tdAlias.textContent = row.alias || '—';
        tr.appendChild(tdAlias);

        const tdText = document.createElement('td');
        const spanText = document.createElement('span');
        spanText.className = 'truncate';
        spanText.title = row.text || '';
        spanText.textContent = row.text || '';
        tdText.appendChild(spanText);
        tr.appendChild(tdText);

        const tdMap = document.createElement('td');
        const sel = document.createElement('select');
        sel.appendChild(optionsFrag.cloneNode(true));
        sel.value = tagMap?.[row.sdtKey] || '';
        sel.addEventListener('change', () => onChange(row.sdtKey, sel.value || ''));
        tdMap.appendChild(sel);
        tr.appendChild(tdMap);

        tbody.appendChild(tr);
      });
    }

    // ========= Single mirror: write tagMap via persistence =========
    async function persistTagMap(docId, cleanedMap) {
      if (!docId) return;

      __suppressNextPayloadRefresh = true;
      try {
        // Minimal patch: persistence mirrors into payload.CRONOS_PAYLOAD and broadcasts via fs-payload-v1
        if (window.formSuitePersist?.setState) {
          window.formSuitePersist.setState(docId, { tagMap: cleanedMap });
        } else {
          await window.formSuitePersist?.saveState?.(docId, { tagMap: cleanedMap });
        }
        DBG('persistTagMap', { docId, size: Object.keys(cleanedMap || {}).length });
      } catch (e) {
        WARN('persistTagMap failed', e);
      } finally {
        // allow subsequent payload events
        setTimeout(() => { __suppressNextPayloadRefresh = false; }, 50);
      }
    }

    // ========= Coordinated refresh =========
    async function refreshAll(reason = '') {
      if (__refreshBusy) { __refreshPending = true; return; }
      __refreshBusy = true;

      try {
        // Active doc meta is owned by fs-active-doc
        gDoc = (typeof readActiveDocSync === 'function') ? readActiveDocSync() : null;
        gDocId = gDoc?.docId || null;

        if (!gDocId) {
          await hardResetMatcher('no active doc');
          DBG('refreshAll: no active doc', { reason });
          return;
        }

        renderDocPill(gDoc);
        await updatePermissionBanner(gDocId);

        // Ensure bytes exist; if not, reset (prevents stale SDTs shown)
        const bytes = await getWorkingBytes(gDocId);
        if (!bytes || !bytes.byteLength) {
          await hardResetMatcher('no bytes / no permission');
          DBG('refreshAll: missing bytes', { reason });
          return;
        }

        // Re-parse SDTs only if DOCX changed
        const sha12 = (await sha256Hex(bytes)).slice(0, 12);
        if (sha12 !== gBytesSha12) {
          DBG('DOCX bytes changed -> reparse SDTs', { prev: gBytesSha12, next: sha12, reason });
          gBytesSha12 = sha12;
          try { gSDTs = await readSDTsFromDocx(bytes); }
          catch (e) { WARN('SDT scan failed', e); gSDTs = []; }
        } else {
          DBG('DOCX bytes unchanged -> keep SDT cache', { sha12, reason });
        }

        // Load state (schema + tagMap) and render
        const state = await window.formSuitePersist?.loadState?.(gDocId) || {};
        const schemaInfo = deriveSchemaInfo(state);
        renderSchemaPill({ title: schemaInfo.title, count: schemaInfo.fields.length });

        const payloadTagMap =
          state?.payload?.CRONOS_PAYLOAD?.tagMap ||
          state?.CRONOS_PAYLOAD?.tagMap ||
          state?.cronos_payload?.tagMap ||
          state?.tagMap ||
          {};

        const cleaned = sanitizeTagMap(payloadTagMap, schemaInfo.fields, gSDTs);

        // Persist cleanup if sanitization changed anything
        const same = JSON.stringify(cleaned) === JSON.stringify(payloadTagMap || {});
        if (!same) {
          DBG('sanitizeTagMap removed invalid entries -> persist cleanup', {
            before: Object.keys(payloadTagMap || {}).length,
            after: Object.keys(cleaned || {}).length
          });
          await persistTagMap(gDocId, cleaned);
        }

        renderRows(gSDTs, schemaInfo.fields, cleaned, async (key, mappedTo) => {
          const nextMap = { ...(cleaned || {}) };
          if (mappedTo) nextMap[key] = mappedTo;
          else delete nextMap[key];

          const reCleaned = sanitizeTagMap(nextMap, schemaInfo.fields, gSDTs);
          await persistTagMap(gDocId, reCleaned);
          // local in-scope update so subsequent changes use latest baseline
          Object.assign(cleaned, reCleaned);
        });

        DBG('refreshAll done', { reason, docId: gDocId, sdtCount: gSDTs.length });
      } finally {
        __refreshBusy = false;
        if (__refreshPending) {
          __refreshPending = false;
          refreshAll('coalesced');
        }
      }
    }

    // ========= Live updates (single broadcast path) =========
    // - Active doc changes: fs-active-doc listener
    // - State patches: fs-payload-v1 listener (emitted by persist.setState/saveState)
    if (typeof installActiveDocListener === 'function') {
      installActiveDocListener(async (meta) => {
        DBG('active-doc event', meta);
        // Always re-evaluate bytes + schema; refresh is guarded/coalesced
        await refreshAll('active-doc');
      });
    } else {
      WARN('installActiveDocListener missing; matcher will rely on focus/visibility refresh only');
    }

    bcPayload?.addEventListener('message', async (ev) => {
      const msg = ev?.data || {};
      if (!msg || msg.t !== 'payload') return;
      if (!gDocId || msg.docId !== gDocId) return;

      // If we just wrote tagMap ourselves, ignore the immediate echo and rely on UI baseline update
      if (__suppressNextPayloadRefresh) {
        DBG('payload event suppressed (self-write)', msg);
        return;
      }

      // Fast path: schema/tagMap changes typically do NOT require SDT re-parse.
      // But we still call refreshAll so any docId mismatches or handle permissions are handled.
      DBG('payload event', msg);
      await refreshAll('payload');
    });

    // ========= Visibility / focus guard =========
    document.addEventListener('visibilitychange', async () => {
      if (document.visibilityState !== 'visible') return;
      await refreshAll('visibility');
    });
    window.addEventListener('focus', async () => { await refreshAll('focus'); });

    // ========= Boot =========
    (async function boot() {
      try {
        DBG('boot');
        try { window.formSuitePersist?.ensureHydrated?.(); } catch {}

        gDoc = (typeof readActiveDocSync === 'function') ? readActiveDocSync() : null;
        renderDocPill(gDoc);

        if (!gDoc?.docId) {
          await hardResetMatcher('no active doc at boot');
          return;
        }

        gDocId = gDoc.docId;
        await updatePermissionBanner(gDocId);

        // Ensure we start with SDTs parsed if bytes exist
        const bytes = await getWorkingBytes(gDocId);
        if (!bytes) {
          await hardResetMatcher('no bytes at boot');
          return;
        }

        gBytesSha12 = (await sha256Hex(bytes)).slice(0, 12);
        try { gSDTs = await readSDTsFromDocx(bytes); } catch (e) { WARN('SDT scan failed at boot', e); gSDTs = []; }

        // Render state
        const st = await window.formSuitePersist?.loadState?.(gDocId) || {};
        const schemaInfo = deriveSchemaInfo(st);
        renderSchemaPill({ title: schemaInfo.title, count: schemaInfo.fields.length });

        const payloadTagMap =
          st?.payload?.CRONOS_PAYLOAD?.tagMap ||
          st?.CRONOS_PAYLOAD?.tagMap ||
          st?.cronos_payload?.tagMap ||
          st?.tagMap ||
          {};

        const cleaned = sanitizeTagMap(payloadTagMap, schemaInfo.fields, gSDTs);
        if (JSON.stringify(cleaned) !== JSON.stringify(payloadTagMap || {})) {
          await persistTagMap(gDocId, cleaned);
        }

        renderRows(gSDTs, schemaInfo.fields, cleaned, async (key, mappedTo) => {
          const nextMap = { ...(cleaned || {}) };
          if (mappedTo) nextMap[key] = mappedTo;
          else delete nextMap[key];

          const reCleaned = sanitizeTagMap(nextMap, schemaInfo.fields, gSDTs);
          await persistTagMap(gDocId, reCleaned);
          Object.assign(cleaned, reCleaned);
        });

        DBG('boot complete', { docId: gDocId, sdtCount: gSDTs.length });
      } catch (e) {
        WARN('boot failed', e);
        await hardResetMatcher('boot exception');
      }
    })();

    // ========= Re-grant permission button =========
    document.getElementById('btnRegrant')?.addEventListener('click', async () => {
      try {
        if (!gDocId || !supportsFS) return;
        const handle = await window.formSuitePersist?.getHandle?.(gDocId);
        if (!handle) return;

        let perm = await handle.queryPermission?.({ mode: 'readwrite' });
        if (perm !== 'granted') {
          try { perm = await handle.queryPermission?.({ mode: 'read' }); } catch {}
        }
        if (perm !== 'granted') {
          const res = await handle.requestPermission?.({ mode: 'readwrite' });
          if (res !== 'granted') return;
        }

        document.getElementById('permNote').style.display = 'none';
        await refreshAll('regrant');
      } catch (e) {
        WARN('Re-grant failed', e);
      }
    });

    // Triple-click logo: focus mode + go to index, toggle header links
    installLogoFocusNav();
  </script>
</body>
</html>
