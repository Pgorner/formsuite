<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Form Suite — Extractor</title>
  <link rel="icon" href="favicon.ico" type="image/gif" sizes="32x32">
  <link rel="shortcut icon" href="favicon.ico" type="image/gif">
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
  <link rel="stylesheet" href="style.css">

  <!-- Core app plumbing -->
  <script src="persistence.js"></script>
  <script src="rules-core.js"></script>
  <script src="docx-core.js"></script>
  <script src="fs-active-doc.js"></script>
  <script src="fs-focus-nav.js"></script>
  <script src="fs-export-core.js"></script>

  <!-- flatpickr JS (date inputs) -->
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

  <!-- JSZip for SDT scanning -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

  <!-- Address autocomplete widget -->
  <script src="address-autocomplete.js"></script>
</head>
<body>
<header>
  <div class="row">
    <span class="brand logo-md">
      <img src="logo.gif" alt="Form Suite logo" class="logo" />
      <strong>Form Suite</strong>
    </span>
    <span class="muted">·</span><a href="index.html">Form</a>
    <span class="muted">·</span><a href="builder.html" id="openBuilder">Form Builder</a>
    <span class="muted">·</span><a href="matcher.html">Tag Matcher</a>
    <span class="muted">·</span><a href="rules.html">Rules</a>
    <span class="muted">·</span><span class="muted">Extractor</span>
  </div>
</header>

<main>
  <section class="panel">
    <h2 style="margin:0 0 10px">Inspect SDTs & store manual form payload in the DOCX</h2>
    <div class="row" style="gap:8px;flex-wrap:wrap">
      <button id="btnOpen">Open DOCX…</button>
      <button id="btnSave" disabled>Save (payload only)</button>
      <button id="btnExport" disabled>Export (payload + apply rules)</button>
      <span class="muted" id="status" style="margin-left:auto">Idle</span>
    </div>

    <!-- Restored banner -->
    <div id="permNote" class="note warn" style="display:none;margin-top:10px">
      This DOCX was opened via picker but I don’t have write permission to the original file.
      Clicking <em>Save</em> will write to a copy instead of the original.
      <button id="btnRegrant" class="ghost" style="margin-left:8px">Grant write access</button>
    </div>
  </section>

  <div class="grid-3">
    <section class="panel">
      <details open>
        <summary><strong>Found SDTs</strong></summary>
        <div style="overflow:auto;">
          <table id="sdt-table">
            <thead>
            <tr>
              <th>#</th>
              <th>Part</th>
              <th>w:tag</th>
              <th>w:alias</th>
              <th>Text</th>
            </tr>
            </thead>
            <tbody id="sdt-tbody"></tbody>
          </table>
        </div>
      </details>
    </section>

    <section class="panel">
      <details open>
        <summary><strong>CRONOS_PAYLOAD Preview</strong></summary>
        <textarea id="payloadPreview" spellcheck="false" style="min-height:420px"></textarea>
        <div class="row" style="margin-top:6px; gap:8px;">
          <button id="btnSaveFromPreview" class="secondary" disabled>Apply JSON & Save</button>
          <span class="muted" id="previewStatus"></span>
        </div>
      </details>
    </section>

    <section class="panel">
      <details>
        <summary><strong>Headers/Subheaders</strong></summary>
        <div id="headersTree" class="tree" style="max-height:420px;overflow:auto;padding:6px 4px;"></div>
      </details>
    </section>

    <section class="panel">
      <details open>
        <summary><strong>Live Form (from payload schema)</strong></summary>
        <div id="formMount"></div>
      </details>
    </section>
  </div>
</main>

<script>
  // =========================
  // DEBUG / TRACE
  // =========================
  const DEBUG = { on: true, seq: 0 };
  const _t = () => new Date().toISOString().slice(11, 23);
  const tag = (name) => `%c[Extractor ${_t()} #${++DEBUG.seq}] ${name}`;
  const tagStyle = 'color:#6b7280;font-weight:600';

  function TRACE(name, details) {
    const label = `${name} :: ${_t()} :: #${DEBUG.seq + 1}`;
    try { console.groupCollapsed(tag(name), tagStyle, details ?? ''); } catch {}
    try { console.time(label); } catch {}
    let ended = false;
    return {
      step(msg, data) { console.log(tag(`  ↳ ${msg}`), tagStyle, data ?? ''); },
      warn(msg, data) { console.warn(tag(`  ⚠ ${msg}`), tagStyle, data ?? ''); },
      error(msg, err) { console.error(tag(`  ✖ ${msg}`), tagStyle, err); },
      end(extra) {
        if (ended) return;
        ended = true;
        if (extra) console.log(tag('done'), tagStyle, extra);
        try { console.timeEnd(label); } catch {}
        try { console.groupEnd(); } catch {}
      }
    };
  }

  window.addEventListener('error', (e) => {
    console.error(tag('window.error'), tagStyle, {
      message: e.message,
      filename: e.filename,
      lineno: e.lineno,
      colno: e.colno,
      error: e.error
    });
  });
  window.addEventListener('unhandledrejection', (e) => {
    console.error(tag('window.unhandledrejection'), tagStyle, e.reason);
  });

  // =========================
  // CONSTANTS & STATE
  // =========================
  const STORAGE_KEY   = 'FORM_SCHEMA_V1';
  const PAYLOAD_KEY   = 'CRONOS_PAYLOAD';
  const ACTIVE_LS_KEY = 'FS_ACTIVE_DOC_META';
  const META_LS_KEY   = 'FS_CURRENT_DOC_META';
  const supportsFS    = 'showOpenFilePicker' in window && 'showSaveFilePicker' in window;

  const W_NS = "http://schemas.openxmlformats.org/wordprocessingml/2006/main";

  let gArrayBuffer   = null;
  let gFileName      = null;       // basename (no extension)
  let gFileExt       = 'docx';
  let gFileHandle    = null;
  let gDocId         = null;
  let gSchema        = { title: 'Form', fields: [] };
  let gValues        = {};
  let gSDTs          = [];
  let gHeadingBaseline = { flat: [], tree: [] };
  let gDirty         = false;

  // Structured address field backing store
  const __addressValues = Object.create(null);

  // UI refs
  const btnOpen   = document.getElementById('btnOpen');
  const btnSave   = document.getElementById('btnSave');
  const btnExport = document.getElementById('btnExport');
  const statusEl  = document.getElementById('status');
  const permNote  = document.getElementById('permNote');
  const payloadEl = document.getElementById('payloadPreview');
  const formMount = document.getElementById('formMount');
  const tableBody = document.getElementById('sdt-tbody');
  const btnRegrant = document.getElementById('btnRegrant');
  const btnSaveFromPreview = document.getElementById('btnSaveFromPreview');
  const previewStatus = document.getElementById('previewStatus');
  const headersTreeEl = document.getElementById('headersTree');

  // Broadcast channels
  const bcLegacy = ('BroadcastChannel' in window) ? new BroadcastChannel('form-suite-doc') : null;
  const bcCanon  = ('BroadcastChannel' in window) ? new BroadcastChannel('fs-active-doc') : null;

  // =========================
  // UTILS
  // =========================
  function splitNameAndExt(fileName) {
    const m = String(fileName).match(/\.(docx|docm|dotx|dotm)$/i);
    return {
      base: String(fileName).replace(/\.(docx|docm|dotx|dotm)$/i, ''),
      ext:  (m ? m[1] : 'docx').toLowerCase()
    };
  }

  async function sha256Hex(bufOrU8) {
    const tr = TRACE('sha256Hex', { type: bufOrU8?.constructor?.name, len: bufOrU8?.byteLength || bufOrU8?.length });
    try {
      const ab = (bufOrU8 instanceof ArrayBuffer)
        ? bufOrU8
        : (bufOrU8?.buffer instanceof ArrayBuffer)
          ? bufOrU8.buffer
          : new Uint8Array(bufOrU8 || []).buffer;
      const d = await crypto.subtle.digest('SHA-256', ab);
      const hex = [...new Uint8Array(d)].map(b => b.toString(16).padStart(2, '0')).join('');
      tr.end({ hex });
      return hex;
    } catch (e) {
      tr.error('sha failed', e);
      tr.end();
      return '(hash-error)';
    }
  }

  const setStatus = (m) => {
    const tr = TRACE('setStatus', { text: m });
    try { statusEl.textContent = m; } finally { tr.end(); }
  };

  function adoptHeadingBaseline(baseline) {
    const flat = baseline?.flat
      ? (Array.isArray(baseline.flat) ? baseline.flat.slice() : [])
      : (Array.isArray(baseline?.headings) ? baseline.headings.slice() : []);
    const tree = baseline?.tree
      ? (Array.isArray(baseline.tree) ? baseline.tree.slice() : [])
      : (Array.isArray(baseline?.headingsTree) ? baseline.headingsTree.slice() : []);
    gHeadingBaseline = { flat, tree };
  }

  function loadSchemaFromLocalStorage() {
    const tr = TRACE('loadSchemaFromLocalStorage');
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) { tr.end('none'); return null; }
      const s = JSON.parse(raw);
      tr.end({ fields: s?.fields?.length || 0 });
      return s;
    } catch (e) {
      tr.error('parse fail', e);
      tr.end();
      return null;
    }
  }

  function clearUiForNewDoc(message = 'Loading new document…') {
    const tr = TRACE('clearUiForNewDoc', { message });
    try {
      tableBody.innerHTML = '<tr><td colspan="5" class="empty">No document loaded.</td></tr>';
      formMount.innerHTML = '<div class="empty">No schema found.</div>';
      payloadEl.value = '';
      previewStatus.textContent = '';
      if (headersTreeEl) headersTreeEl.innerHTML = '<div class="empty">No headings.</div>';
      btnSave.disabled = true;
      btnExport.disabled = true;
      if (btnSaveFromPreview) btnSaveFromPreview.disabled = true;
      permNote.style.display = 'none';
      setStatus(message);
    } catch (e) {
      tr.warn('DOM reset failed', e);
    } finally {
      tr.end();
    }
  }

  function persistActiveMeta(meta) {
    if (!meta || !meta.docId) return;
    const compact = { docId: meta.docId, name: meta.name || meta.fileName || 'document.docx' };
    try { localStorage.setItem(ACTIVE_LS_KEY, JSON.stringify(compact)); } catch {}
    try { localStorage.setItem(META_LS_KEY, JSON.stringify(compact)); } catch {}
    try { if (typeof window.setActiveDocMeta === 'function') window.setActiveDocMeta(compact); } catch {}
  }

  function announceDocUpdated(meta) {
    const docId = meta?.docId || gDocId;
    if (!docId) return;
    try { bcCanon?.postMessage({ type: 'active:updated', docId }); } catch {}
    try { bcLegacy?.postMessage({ type: 'doc-updated', docId }); } catch {}
  }

  // =========================
  // PERSISTENCE SHIM (fallback)
  // =========================
  (function ensurePersist() {
    const tr = TRACE('ensurePersist');
    try {
      if (window.formSuitePersist) { tr.step('already present'); return; }
      tr.step('installing shim');
      const _state = {};
      let _meta = null;

      window.formSuitePersist = {
        getCurrentDocMeta() { return _meta; },
        async setCurrentDoc({ bytes, handle, name }) {
          _meta = { docId: 'inline-' + Date.now(), name: name || 'document.docx' };
          return _meta;
        },
        async setCurrentDocFromBytes(bytes, meta) {
          _meta = { docId: 'inline-' + Date.now(), name: meta?.name || 'document.docx' };
          return _meta;
        },
        async getCurrentDocBytes() { return null; },
        async getBytes(docId) { return null; },
        async getHandle(docId) { return null; },
        async saveState(docId, obj) {
          _state[docId] = { ...(_state[docId] || {}), ...(obj || {}) };
        },
        async loadState(docId) {
          return _state[docId] || {};
        },
        async putBytes(docId, bytes) {
          // noop in shim
        },
        async ensurePermission(handle, mode) {
          return 'granted';
        }
      };
    } finally {
      tr.end();
    }
  })();

  // =========================
  // SAFE BYTES FETCH + RESET
  // =========================
  async function safeGetBytes(docId) {
    const tr = TRACE('safeGetBytes', { docId });
    try {
      if (!docId) return null;

      let bytes = await window.formSuitePersist.getBytes?.(docId);
      if (!bytes) {
        bytes = await window.formSuitePersist.getCurrentDocBytes?.();
      }

      if (!bytes) {
        const h = await window.formSuitePersist.getHandle?.(docId);
        if (h && typeof h.getFile === 'function') {
          try {
            const f = await h.getFile();
            bytes = new Uint8Array(await f.arrayBuffer());
            gFileHandle = h;
          } catch (e) {
            tr.warn('handle.getFile failed', e);
          }
        }
      }

      if (bytes) {
        tr.end({ len: bytes.byteLength || bytes.length });
        return bytes;
      }

      tr.end('no bytes');
      return null;
    } catch (e) {
      tr.error('safeGetBytes failed', e);
      tr.end();
      return null;
    }
  }

  async function hardResetDocContext(reason = '') {
    const tr = TRACE('hardResetDocContext', { reason, docId: gDocId });
    try {
      gArrayBuffer = null;
      gFileHandle  = null;
      gFileName    = null;
      gFileExt     = 'docx';
      gDocId       = null;
      gSchema      = { title: 'Form', fields: [] };
      gValues      = {};
      gSDTs        = [];
      gHeadingBaseline = { flat: [], tree: [] };
      clearUiForNewDoc(reason ? `Cleared: ${reason}` : 'Cleared.');
    } finally {
      tr.end('reset complete');
    }
  }

  let __fgRefreshLock = false;
  async function rehydrateOnForeground(source) {
    const tr = TRACE('rehydrateOnForeground', { source, docId: gDocId, locked: __fgRefreshLock });
    if (__fgRefreshLock) { tr.end('locked'); return; }
    __fgRefreshLock = true;
    try {
      if (!gDocId) { tr.end('no docId'); return; }

      await new Promise(r => setTimeout(r, 120));
      let bytes = await safeGetBytes(gDocId);
      if (!bytes) {
        await new Promise(r => setTimeout(r, 150));
        bytes = await safeGetBytes(gDocId);
      }
      if (!bytes) {
        tr.end('no bytes; keeping current buffer');
        return;
      }

      gArrayBuffer = bytes.buffer ?? bytes;
      await renderFromCurrentBytes(`(${source} refreshed) `);
      await updateWriteAccessBanner();
      tr.end('refreshed');
    } catch (e) {
      tr.error('rehydrate failed', e);
    } finally {
      __fgRefreshLock = false;
    }
  }

  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible') rehydrateOnForeground('visible');
  });
  window.addEventListener('focus', () => {
    rehydrateOnForeground('focus');
  });

  // =========================
  // WRITE ACCESS BANNER
  // =========================
  async function updateWriteAccessBanner({ tryPrompt = false } = {}) {
    const tr = TRACE('updateWriteAccessBanner', { tryPrompt, docId: gDocId, supportsFS });
    try {
      if (!supportsFS || !gDocId) {
        permNote.style.display = 'none';
        tr.end('unsupported/no-doc');
        return 'unsupported';
      }

      let handle = gFileHandle || await window.formSuitePersist.getHandle?.(gDocId);
      if (!handle || typeof handle.queryPermission !== 'function') {
        permNote.style.display = 'none';
        tr.end('no-handle');
        return 'no-handle';
      }

      let p = await handle.queryPermission({ mode: 'readwrite' });
      tr.step('queryPermission', p);

      if (p !== 'granted' && tryPrompt && typeof handle.requestPermission === 'function') {
        try {
          const r = await handle.requestPermission({ mode: 'readwrite' });
          p = r || p;
          tr.step('requestPermission', r);
        } catch (e) {
          tr.warn('requestPermission failed', e);
        }
      }

      permNote.style.display = (p === 'granted') ? 'none' : 'block';
      if (p === 'granted') gFileHandle = handle;
      tr.end({ final: p });
      return p || 'denied';
    } catch (e) {
      tr.error('updateWriteAccessBanner failed', e);
      permNote.style.display = 'block';
      return 'error';
    }
  }

  // =========================
  // CROSS-TAB MESSAGES
  // =========================
  async function switchToDoc(docId, name) {
    const tr = TRACE('switchToDoc', { docId, name });
    try {
      if (!docId) return;
      if (docId === gDocId && gArrayBuffer) { tr.end('already active'); return; }

      clearUiForNewDoc('Switching to another document…');
      const bytes = await safeGetBytes(docId);
      if (!bytes) {
        await hardResetDocContext('no bytes / no permission');
        return;
      }

      gDocId = docId;
      const nm = name || 'document.docx';
      const { base, ext } = splitNameAndExt(nm);
      gFileName = base || 'document';
      gFileExt  = ext || 'docx';
      gArrayBuffer = bytes.buffer ?? bytes;

      await renderFromCurrentBytes('(switched by other tab) ');
      await updateWriteAccessBanner();
    } finally {
      tr.end();
    }
  }

  bcLegacy?.addEventListener('message', async (ev) => {
    const tr = TRACE('BroadcastChannel(legacy):message', ev?.data);
    try {
      const m = ev.data || {};
      if (!m || typeof m !== 'object') return;

      if (m.type === 'doc-switched' && m.docId && m.docId !== gDocId) {
        await switchToDoc(m.docId, m.name);
      }

      if (m.type === 'doc-updated' && m.docId && m.docId === gDocId) {
        const bytes = await safeGetBytes(gDocId);
        if (!bytes) {
          await hardResetDocContext('no bytes / no permission');
          return;
        }
        gArrayBuffer = bytes.buffer ?? bytes;
        await renderFromCurrentBytes('(updated by other tab) ');
        await updateWriteAccessBanner();
      }

      if (m.type === 'doc-cleared') {
        await hardResetDocContext('cleared by another tab');
      }

      if (m.type === 'schema-updated' && m.docId && m.docId === gDocId) {
        const st = await window.formSuitePersist.loadState(gDocId);
        if (st?.schema) {
          adoptHeadingBaseline({
            flat: Array.isArray(st.headingsFlat) ? st.headingsFlat : Array.isArray(st.headings) ? st.headings : [],
            tree: Array.isArray(st.headingsTree) ? st.headingsTree : gHeadingBaseline.tree
          });
          gSchema = st.schema;
          gValues = st.values || {};
          buildForm(formMount, gSchema, gValues);
          await updatePreview(gValues);
          setStatus('Schema updated from Builder/Rules.');
        }
      }

      if (m.type === 'rules-updated' && (!m.docId || m.docId === gDocId)) {
        await updatePreview(collectFormValues(gSchema));
        setStatus('Rules updated (BC legacy).');
      }
    } finally {
      tr.end();
    }
  });

  bcCanon?.addEventListener('message', async (ev) => {
    const tr = TRACE('BroadcastChannel(canon):message', ev?.data);
    try {
      const m = ev.data || {};
      if (!m || typeof m !== 'object') return;

      if (m.type === 'active:set' && m.docId && m.docId !== gDocId) {
        await switchToDoc(m.docId, m.name);
      }

      if (m.type === 'active:updated' && m.docId && m.docId === gDocId) {
        const bytes = await safeGetBytes(gDocId);
        if (!bytes) return;
        gArrayBuffer = bytes.buffer ?? bytes;
        await renderFromCurrentBytes('(updated by other tab) ');
      }

      if (m.type === 'active:clear') {
        await hardResetDocContext('cleared by another tab');
      }

      if (m.type === 'rules-updated' && (!m.docId || m.docId === gDocId)) {
        await updatePreview(collectFormValues(gSchema));
        setStatus('Rules updated (BC canon).');
      }
    } finally {
      tr.end();
    }
  });

  window.addEventListener('storage', async (e) => {
    const tr = TRACE('storage:event', { key: e.key, hasNew: !!e.newValue });
    try {
      if (e.key === ACTIVE_LS_KEY && e.newValue) {
        try {
          const meta = JSON.parse(e.newValue);
          if (meta?.docId && meta.docId !== gDocId) {
            await switchToDoc(meta.docId, meta.name);
          }
        } catch (err) {
          tr.warn('parse active meta failed', err);
        }
      }
    } finally {
      tr.end();
    }
  });

  // =========================
  // RULES WATCHDOG (polling)
  // =========================
  (function setupRulesWatchdog() {
    const tr = TRACE('setupRulesWatchdog');
    let lastRV = null;

    async function tick() {
      if (!gDocId) return;
      try {
        const st = await window.formSuitePersist.loadState(gDocId);
        const rv = st?.rulesVersion
          ?? st?.payload?.CRONOS_PAYLOAD?.rulesVersion
          ?? st?.CRONOS_PAYLOAD?.rulesVersion
          ?? st?.cronos_payload?.rulesVersion
          ?? null;

        if (rv !== lastRV) {
          const ttr = TRACE('rulesWatchdog:change', { prev: lastRV, next: rv });
          lastRV = rv;
          await updatePreview(collectFormValues(gSchema));
          setStatus('Rules updated (poll).');
          ttr.end();
        }
      } catch (e) {
        console.warn('[Extractor][Watchdog] tick failed', e);
      }
    }

    setInterval(tick, 1500);
    tr.end('installed');
  })();

  // =========================
  // NORMALIZATION HELPERS
  // =========================
  function normalizeForSchema(schema, values, tagMap) {
    const fieldIds = new Set((schema?.fields || []).map(f => String(f.id)));
    const prunedValues = {};
    for (const [k, v] of Object.entries(values || {})) {
      if (fieldIds.has(String(k))) prunedValues[k] = v;
    }
    const prunedTagMap = {};
    for (const [tag, fieldId] of Object.entries(tagMap || {})) {
      if (fieldIds.has(String(fieldId))) prunedTagMap[tag] = fieldId;
    }
    return { values: prunedValues, tagMap: prunedTagMap };
  }

  async function getTagMapFor(docId) {
    try {
      if (!docId) return {};
      const st = await window.formSuitePersist.loadState(docId);
      const tagMap =
        st?.payload?.CRONOS_PAYLOAD?.tagMap ||
        st?.CRONOS_PAYLOAD?.tagMap ||
        st?.cronos_payload?.tagMap ||
        st?.tagMap ||
        {};
      return tagMap;
    } catch {
      return {};
    }
  }

  function collectFormValues(schema) {
    const form = document.getElementById('liveForm');
    const out = {};
    if (!form || !schema) return out;

    for (const f of (schema.fields || [])) {
      if (f.type === 'multichoice') {
        const nodes = form.querySelectorAll(`input[type="checkbox"][name="${CSS.escape(f.id)}"]`);
        out[f.id] = Array.from(nodes).filter(n => n.checked).map(n => n.value);
        continue;
      }
      if (f.type === 'address') {
        out[f.id] = __addressValues[f.id] ?? null;
        continue;
      }
      const el = form.elements[f.id];
      out[f.id] = el ? el.value : null;
    }
    return out;
  }

  // =========================
  // FORM RENDERING
  // =========================
  let previewTimer = null;
  function schedulePreviewUpdate() {
    clearTimeout(previewTimer);
    previewTimer = setTimeout(async () => {
      const vals = collectFormValues(gSchema);
      if (gDocId) {
        await window.formSuitePersist.saveState(gDocId, { schema: gSchema, values: vals });
      }
      await updatePreview(vals);
      gDirty = true;
      setStatus('Unsaved changes — press Save to update DOCX.');
    }, 250);
  }

  function buildForm(container, schema, values) {
    const tr = TRACE('buildForm', { fields: schema?.fields?.length || 0 });
    try {
      container.innerHTML = '';
      if (!schema || !Array.isArray(schema.fields) || schema.fields.length === 0) {
        container.innerHTML = '<div class="empty">No manual schema. Create one in the Builder, or load a DOCX that already contains a payload schema.</div>';
        tr.end('empty schema');
        return;
      }

      const form = document.createElement('form');
      form.id = 'liveForm';
      form.noValidate = true;
      form.style.display = 'grid';
      form.style.gap = '12px';

      if (schema.title) {
        const h = document.createElement('h4');
        h.textContent = schema.title;
        h.style.margin = '0 0 6px';
        form.appendChild(h);
      }

      for (const f of schema.fields) {
        const tf = TRACE('buildForm:field', { id: f.id, type: f.type });
        const wrap = document.createElement('div');
        wrap.className = 'field';

        const label = document.createElement('label');
        label.htmlFor = f.id;
        label.style.display = 'flex';
        label.style.justifyContent = 'space-between';
        label.style.alignItems = 'center';

        const labelText = document.createElement('span');
        labelText.textContent = f.label || f.id || '(field)';
        label.appendChild(labelText);

        if (f.required) {
          const star = document.createElement('span');
          star.textContent = '•';
          star.title = 'Required';
          star.style.fontWeight = '600';
          star.style.color = '#ef4444';
          label.appendChild(star);
        }

        wrap.appendChild(label);

        let input;

        if (f.type === 'multichoice') {
          const box = document.createElement('div');
          box.style.display = 'grid';
          box.style.gap = '6px';
          (f.options || []).forEach(opt => {
            const id = `${f.id}__${String(opt?.value ?? opt).replace(/\s+/g, '_')}`;
            const row = document.createElement('label');
            row.style.display = 'flex';
            row.style.gap = '8px';
            row.style.alignItems = 'center';

            const cb = document.createElement('input');
            cb.type = 'checkbox';
            cb.name = f.id;
            cb.id = id;
            cb.value = String(opt?.value ?? opt);

            if (Array.isArray(values?.[f.id]) && values[f.id].includes(cb.value)) {
              cb.checked = true;
            }

            const span = document.createElement('span');
            span.textContent = String(opt?.label ?? opt?.text ?? opt?.value ?? opt);

            row.appendChild(cb);
            row.appendChild(span);
            box.appendChild(row);
          });

          wrap.appendChild(box);
          box.addEventListener('change', schedulePreviewUpdate);
          form.appendChild(wrap);
          tf.end();
          continue;
        }

        if (f.type === 'select') {
          input = document.createElement('select');
          (f.options || []).forEach(opt => {
            const o = document.createElement('option');
            o.value = String(opt?.value ?? opt?.id ?? opt);
            o.textContent = String(opt?.label ?? opt?.text ?? opt?.value ?? opt);
            input.appendChild(o);
          });
        } else if (f.type === 'date') {
          input = document.createElement('input');
          input.type = 'text';
          input.dataset.type = 'date';
          input.dataset.format = f.dateFormat || 'Y-m-d';
        } else if (f.type === 'address') {
          const mountDiv = document.createElement('div');
          mountDiv.className = 'address-field';
          wrap.appendChild(mountDiv);

          const initial =
            typeof values?.[f.id] === 'string'
              ? { formatted: values[f.id] }
              : (values?.[f.id] || null);

          __addressValues[f.id] = initial || null;

          try {
            if (window.AddressAuto && typeof window.AddressAuto.mount === 'function') {
              window.AddressAuto.mount(mountDiv, {
                id: f.id,
                label: f.label || 'Address',
                required: !!f.required,
                value: initial || null,
                onChange: (val) => {
                  __addressValues[f.id] = val;
                  schedulePreviewUpdate();
                }
              });
            } else {
              throw new Error('AddressAuto not available');
            }
          } catch (err) {
            const fallback = document.createElement('input');
            fallback.type = 'text';
            fallback.id = f.id;
            fallback.name = f.id;
            fallback.placeholder = 'Address';
            if (initial?.formatted) fallback.value = initial.formatted;
            fallback.addEventListener('input', () => {
              __addressValues[f.id] = { formatted: fallback.value };
              schedulePreviewUpdate();
            });
            mountDiv.appendChild(fallback);
          }

          form.appendChild(wrap);
          tf.end();
          continue;
        } else {
          input = document.createElement('input');
          input.type = 'text';
        }

        input.id = f.id;
        input.name = f.id;
        if (f.required) input.required = true;
        if (values && values[f.id] != null) input.value = values[f.id];

        input.addEventListener('change', schedulePreviewUpdate);
        input.addEventListener('input', schedulePreviewUpdate);

        wrap.appendChild(input);

        if (f.type === 'date') {
          setTimeout(() => {
            const tt = TRACE('flatpickr:init', { id: input.id, format: input.dataset.format });
            try {
              if (window.flatpickr && typeof window.flatpickr === 'function') {
                window.flatpickr(input, {
                  dateFormat: input.dataset.format || 'Y-m-d',
                  allowInput: true,
                  onChange: schedulePreviewUpdate,
                  onValueUpdate: schedulePreviewUpdate
                });
              }
            } finally {
              tt.end();
            }
          }, 0);
        }

        form.appendChild(wrap);
        tf.end();
      }

      container.appendChild(form);
      tr.end('form built');
    } catch (e) {
      tr.error('buildForm failed', e);
      tr.end();
    }
  }

  // =========================
  // SDT PARSING
  // =========================
  function xmlText(el) {
    let s = '';
    const rec = n => {
      if (!n) return;
      if (n.nodeType === 3) { s += n.nodeValue; return; }
      if (n.nodeType === 1) {
        const ln = n.localName;
        if (ln === 'p' || ln === 'cr' || ln === 'br') s += '\n';
        for (const ch of n.childNodes) rec(ch);
      }
    };
    rec(el);
    return s.replace(/\s+\n/g, '\n').replace(/\n{3,}/g, '\n\n').trim();
  }

  async function parseSDTs_JS(arrayBuffer) {
    const tr = TRACE('parseSDTs_JS', { hasBuffer: !!arrayBuffer, len: arrayBuffer?.byteLength });
    try {
      if (!arrayBuffer) return { sdts: [], scan: [], total: 0 };
      const zip = await JSZip.loadAsync(arrayBuffer);
      const parts = zip.file(/^word\/(?!_rels\/|theme\/|fontTable\.xml|styles\.xml|numbering\.xml|settings\.xml|webSettings\.xml).*\.xml$/i) || [];
      tr.step('parts', parts.map(p => p.name));
      const parser = new DOMParser();
      const sdts = [];
      const scan = [];

      for (const f of parts) {
        const pf = TRACE('parseSDTs_JS:file', f.name);
        const xmlTextContent = await f.async('string');
        let err = null;
        const countBefore = sdts.length;
        try {
          const xml = parser.parseFromString(xmlTextContent, "application/xml");
          const found = Array.from(xml.getElementsByTagNameNS(W_NS, 'sdt'));
          for (const sdt of found) {
            const pr = sdt.getElementsByTagNameNS(W_NS, 'sdtPr')[0];
            const content = sdt.getElementsByTagNameNS(W_NS, 'sdtContent')[0] || sdt;
            let tagVal = '';
            let alias = '';

            if (pr) {
              const tEl = pr.getElementsByTagNameNS(W_NS, 'tag')[0];
              if (tEl) tagVal = tEl.getAttributeNS(W_NS, 'val') || tEl.getAttribute('w:val') || '';
              const aEl = pr.getElementsByTagNameNS(W_NS, 'alias')[0];
              if (aEl) alias = aEl.getAttributeNS(W_NS, 'val') || aEl.getAttribute('w:val') || '';
            }

            sdts.push({
              part: f.name.split('/').pop().replace('.xml', ''),
              tag: tagVal,
              alias,
              text: xmlText(content)
            });
          }
        } catch (e) {
          err = e?.message || String(e);
          pf.warn('xml parse error', e);
        }
        scan.push({
          path: f.name,
          part: f.name.split('/').pop().replace('.xml', ''),
          size: xmlTextContent.length,
          sdt_count: sdts.length - countBefore,
          error: err
        });
        pf.end({ added: sdts.length - countBefore, error: err });
      }

      tr.end({ total: sdts.length, scanned: scan.length });
      return { sdts, scan, total: sdts.length };
    } catch (e) {
      tr.error('parseSDTs_JS failed', e);
      tr.end();
      return { sdts: [], scan: [], total: 0 };
    }
  }

  function renderSDTsView(parsed) {
    const tr = TRACE('renderSDTsView', { total: parsed?.total, rows: parsed?.sdts?.length });
    try {
      tableBody.innerHTML = '';
      const sdts = parsed?.sdts || [];
      if (!sdts.length) {
        const trEl = document.createElement('tr');
        const td = document.createElement('td');
        td.colSpan = 5;
        td.className = 'empty';
        td.textContent = 'No SDTs found in this document.';
        trEl.appendChild(td);
        tableBody.appendChild(trEl);
      } else {
        sdts.forEach((row, i) => {
          const trEl = document.createElement('tr');
          const tdIdx = document.createElement('td');
          tdIdx.textContent = String(i + 1);
          trEl.appendChild(tdIdx);

          const tdPart = document.createElement('td');
          tdPart.textContent = row.part || '';
          trEl.appendChild(tdPart);

          const tdTag = document.createElement('td');
          tdTag.textContent = row.tag || '';
          trEl.appendChild(tdTag);

          const tdAlias = document.createElement('td');
          tdAlias.textContent = row.alias || '';
          trEl.appendChild(tdAlias);

          const tdText = document.createElement('td');
          tdText.textContent = row.text || '';
          trEl.appendChild(tdText);

          tableBody.appendChild(trEl);
        });
      }
    } finally {
      tr.end();
    }
  }

  // =========================
  // HEADINGS PARSING + TREE
  // =========================
  function buildHeadingTree(list) {
    const root = [];
    const stack = [];
    for (const h of (list || [])) {
      const node = {
        level: h.level,
        text: h.text,
        part: h.part || 'document',
        idx: h.idx,
        uid: h.uid,
        paraIndex: h.paraIndex,
        start: h.start,
        end: h.end,
        label: h.label || h.text,
        children: []
      };
      while (stack.length && stack[stack.length - 1].level >= node.level) stack.pop();
      if (!stack.length) {
        root.push(node);
      } else {
        stack[stack.length - 1].children.push(node);
      }
      stack.push(node);
    }
    return root;
  }

  function renderHeadingsTreeView(tree) {
    const tr = TRACE('renderHeadingsTreeView', { nodes: tree?.length || 0 });
    try {
      if (!headersTreeEl) return;
      headersTreeEl.innerHTML = '';

      if (!tree || !tree.length) {
        headersTreeEl.innerHTML = '<div class="empty">No headings found (no paragraphs styled as headings).</div>';
        tr.end('empty');
        return;
      }

      if (typeof window.numberHeadingsTree === 'function') {
        try { window.numberHeadingsTree(tree); } catch (e) { tr.warn('numberHeadingsTree failed', e); }
      }

      const mk = (nodes) => {
        const ul = document.createElement('ul');
        ul.style.margin = '0 0 0 1rem';
        ul.style.padding = '0.1rem 0 0.1rem 0.6rem';
        for (const n of nodes) {
          const li = document.createElement('li');
          li.style.listStyle = 'none';

          const line = document.createElement('div');
          line.style.display = 'flex';
          line.style.gap = '6px';
          line.style.alignItems = 'baseline';

          const num = document.createElement('span');
          num.textContent = n.num || '';
          num.style.minWidth = '4ch';
          num.style.textAlign = 'right';
          num.style.fontVariantNumeric = 'tabular-nums';
          num.style.opacity = '0.9';
          num.style.fontWeight = n.level <= 2 ? '700' : '600';

          const text = document.createElement('span');
          text.textContent = n.text;
          text.title = `${n.part} · H${n.level}`;
          text.style.fontWeight = n.level <= 2 ? '600' : '400';

          const part = document.createElement('span');
          part.textContent = `· ${n.part}`;
          part.className = 'muted';
          part.style.fontSize = '0.75rem';

          line.appendChild(num);
          line.appendChild(text);
          line.appendChild(part);
          li.appendChild(line);

          if (n.children?.length) li.appendChild(mk(n.children));
          ul.appendChild(li);
        }
        return ul;
      };

      headersTreeEl.appendChild(mk(tree));
      tr.end('rendered');
    } catch (e) {
      tr.error('renderHeadingsTreeView failed', e);
      tr.end();
    }
  }

  async function parseHeadings_JS(arrayBuffer) {
    const tr = TRACE('parseHeadings_JS', { hasBuffer: !!arrayBuffer, len: arrayBuffer?.byteLength });
    try {
      if (!arrayBuffer) return { flat: [], tree: [], count: 0 };

      const bytes = (arrayBuffer instanceof Uint8Array) ? arrayBuffer : new Uint8Array(arrayBuffer);

      let plan = { parts: [] };
      try {
        if (typeof window.inspectRemovalPlan === 'function') {
          plan = await window.inspectRemovalPlan(bytes, {}) || { parts: [] };
        } else if (window.docxCore && typeof window.docxCore.inspectRemovalPlan === 'function') {
          plan = await window.docxCore.inspectRemovalPlan(bytes, {}) || { parts: [] };
        } else {
          tr.step('inspectRemovalPlan not available; skipping headings');
          return { flat: [], tree: [], count: 0 };
        }
      } catch (e) {
        tr.warn('inspectRemovalPlan call failed; skipping headings', e);
        return { flat: [], tree: [], count: 0 };
      }

      const parts = Array.isArray(plan.parts) ? plan.parts : [];
      const seen = new Set();
      const flat = [];

      for (const part of parts) {
        const headings = Array.isArray(part.headings) ? part.headings : [];
        for (const heading of headings) {
          const idx = Number(heading.idx);
          if (!Number.isFinite(idx) || seen.has(idx)) continue;
          seen.add(idx);
          const text = String(heading.text || '').trim();
          const lvl = Number(heading.level);
          const entry = {
            idx,
            key: idx,
            id: idx,
            text,
            title: text,
            label: text,
            part: heading.part || part.name || 'document'
          };
          if (Number.isFinite(lvl)) entry.level = lvl;
          const number = heading.number ?? heading.num;
          if (number != null && number !== '') entry.number = String(number);
          flat.push(entry);
        }
      }

      if (!flat.length) {
        tr.end({ count: 0, reason: 'no-headings' });
        return { flat: [], tree: [], count: 0 };
      }

      flat.sort((a, b) => a.idx - b.idx);
      const tree = buildHeadingTree(flat);

      if (typeof window.numberHeadingsTree === 'function') {
        try { window.numberHeadingsTree(tree); } catch (e) { tr.warn('numberHeadingsTree failed', e); }
      }

      const byIdx = new Map(flat.map(h => [Number(h.idx), h]));
      const propagate = (nodes) => {
        if (!Array.isArray(nodes)) return;
        for (const n of nodes) {
          const idx = Number(n.idx);
          const ref = byIdx.get(idx);
          if (ref) {
            if (n.num) {
              ref.number = n.num;
              ref.compositeKey = `${n.num}|${ref.text}`.trim();
            }
          }
          if (Array.isArray(n.children) && n.children.length) propagate(n.children);
        }
      };
      propagate(tree);

      flat.forEach((h) => {
        const num = h.number || h.num;
        const idx = Number(h.idx);
        const prefix = num ? String(num) : (Number.isFinite(idx) ? String(idx + 1) : '');
        if (!h.compositeKey) h.compositeKey = `${prefix}|${h.text}`.trim();
      });

      tr.end({ count: flat.length, rootChildren: tree.length });
      return { flat, tree, count: flat.length };
    } catch (e) {
      tr.error('parseHeadings_JS failed', e);
      tr.end();
      return { flat: [], tree: [], count: 0 };
    }
  }

  // =========================
  // PAYLOAD PREVIEW
  // =========================
  async function updatePreview(values) {
    const tr = TRACE('updatePreview');
    try {
      if (!payloadEl) return;

      const wsState = gDocId ? (await window.formSuitePersist.loadState(gDocId) || {}) : {};

      adoptHeadingBaseline({
        flat: Array.isArray(wsState.headingsFlat)
          ? wsState.headingsFlat
          : Array.isArray(wsState.headings) ? wsState.headings : gHeadingBaseline.flat,
        tree: Array.isArray(wsState.headingsTree)
          ? wsState.headingsTree
          : gHeadingBaseline.tree
      });

      const payloadObj =
        wsState.payload?.CRONOS_PAYLOAD ||
        wsState.CRONOS_PAYLOAD ||
        wsState.cronos_payload ||
        {};

      let mergedRulesRaw = [];
      let mergedFieldRaw = [];
      try {
        if (typeof window.resolveRulesForState === 'function') {
          const resolved = window.resolveRulesForState(wsState, payloadObj);
          mergedRulesRaw = Array.isArray(resolved.rules) ? resolved.rules : [];
          mergedFieldRaw = Array.isArray(resolved.fieldRules) ? resolved.fieldRules : [];
        } else {
          mergedRulesRaw = Array.isArray(payloadObj.rules) ? payloadObj.rules : [];
          mergedFieldRaw = Array.isArray(payloadObj.fieldRules) ? payloadObj.fieldRules : [];
        }
      } catch (e) {
        tr.warn('resolveRulesForState failed in updatePreview; payload-only rules', e);
        mergedRulesRaw = Array.isArray(payloadObj.rules) ? payloadObj.rules : [];
        mergedFieldRaw = Array.isArray(payloadObj.fieldRules) ? payloadObj.fieldRules : [];
      }

      let rules = mergedRulesRaw;
      if (typeof window.normalizeHeadingsRulesForSchema === 'function') {
        try {
          rules = window.normalizeHeadingsRulesForSchema(gSchema, mergedRulesRaw, gHeadingBaseline);
        } catch (e) {
          tr.warn('normalizeHeadingsRulesForSchema failed in updatePreview', e);
          rules = mergedRulesRaw;
        }
      }

      let fieldRules = mergedFieldRaw;
      if (typeof window.normalizeFieldRulesForSchema === 'function') {
        try {
          fieldRules = window.normalizeFieldRulesForSchema(gSchema, mergedFieldRaw);
        } catch (e) {
          tr.warn('normalizeFieldRulesForSchema failed in updatePreview', e);
          fieldRules = mergedFieldRaw;
        }
      }

      const tagMapRaw = wsState.tagMap || payloadObj.tagMap || {};
      const { values: prunedValues, tagMap: prunedTagMap } =
        normalizeForSchema(gSchema, values || {}, tagMapRaw);

      const previewObj = {
        title: gSchema?.title || 'Form',
        fields: gSchema?.fields || [],
        values: prunedValues,
        tagMap: prunedTagMap,
        rules,
        fieldRules
      };

      payloadEl.value = JSON.stringify(previewObj, null, 2);
    } catch (e) {
      tr.error('updatePreview failed', e);
    } finally {
      tr.end();
    }
  }

  // =========================
  // RENDER FROM BYTES
  // =========================
  async function renderFromCurrentBytes(prefix = '') {
    const tr = TRACE('renderFromCurrentBytes', { prefix, docId: gDocId });
    try {
      if (!gArrayBuffer) {
        setStatus('No DOCX loaded.');
        return;
      }

      setStatus((prefix || '') + 'Parsing…');

      // 1) SDTs
      const parsedSDTs = await parseSDTs_JS(gArrayBuffer);
      gSDTs = parsedSDTs.sdts || [];
      renderSDTsView(parsedSDTs);

      // 2) Headings
      let headingsParsed = { flat: [], tree: [], count: 0 };
      try {
        headingsParsed = await parseHeadings_JS(gArrayBuffer);
        renderHeadingsTreeView(headingsParsed.tree);
        adoptHeadingBaseline(headingsParsed);
      } catch (e) {
        console.warn('[Extractor] headings parse failed', e);
        if (headersTreeEl) headersTreeEl.innerHTML = '<div class="empty">No headings.</div>';
        adoptHeadingBaseline({ flat: [], tree: [] });
      }

      // 3) Payload from DOCX
      let payloadJson = null;
      try {
        if (typeof window.readDocVarSettings === 'function') {
          payloadJson = await window.readDocVarSettings(gArrayBuffer, PAYLOAD_KEY);
        }
        if (payloadJson == null && typeof window.readDocVarCustom === 'function') {
          payloadJson = await window.readDocVarCustom(gArrayBuffer, PAYLOAD_KEY);
        }
      } catch (e) {
        tr.warn('readDocVarSettings/readDocVarCustom failed', e);
      }

      let payloadFromDoc = null;
      try { payloadFromDoc = payloadJson ? JSON.parse(payloadJson) : null; }
      catch { payloadFromDoc = null; }

      const wsState = gDocId ? (await window.formSuitePersist.loadState(gDocId) || {}) : {};

      const asTs = (x) => {
        const t = Date.parse(x || '');
        return Number.isFinite(t) ? t : 0;
      };

      const wsSchema  = wsState.schema;
      const wsSchemaTs = asTs(wsState.schemaUpdatedAt);
      const docHasSchema = Array.isArray(payloadFromDoc?.fields) && payloadFromDoc.fields.length > 0;
      const docSchemaTs  = asTs(payloadFromDoc?.updatedAt);

      let chosenSchema;
      if (wsSchema && wsSchemaTs >= docSchemaTs) {
        chosenSchema = wsSchema;
      } else if (docHasSchema) {
        chosenSchema = {
          title: payloadFromDoc.title || 'Form',
          fields: payloadFromDoc.fields
        };
      } else {
        chosenSchema = loadSchemaFromLocalStorage() || { title: 'Form', fields: [] };
      }

      const mergedValues = Object.assign(
        {},
        payloadFromDoc?.values || {},
        wsState.values || {}
      );
      const mergedTagMap = Object.assign(
        {},
        payloadFromDoc?.tagMap || {},
        wsState.tagMap || {}
      );

      let mergedRulesRaw = [];
      let mergedFieldRaw = [];
      try {
        if (typeof window.resolveRulesForState === 'function') {
          const resolved = window.resolveRulesForState(wsState, payloadFromDoc || {});
          mergedRulesRaw = Array.isArray(resolved.rules) ? resolved.rules : [];
          mergedFieldRaw = Array.isArray(resolved.fieldRules) ? resolved.fieldRules : [];
        } else {
          mergedRulesRaw = Array.isArray(payloadFromDoc?.rules) ? payloadFromDoc.rules : [];
          mergedFieldRaw = Array.isArray(payloadFromDoc?.fieldRules) ? payloadFromDoc.fieldRules : [];
        }
      } catch (e) {
        tr.warn('resolveRulesForState failed in renderFromCurrentBytes; payload-only rules', e);
        mergedRulesRaw = Array.isArray(payloadFromDoc?.rules) ? payloadFromDoc.rules : [];
        mergedFieldRaw = Array.isArray(payloadFromDoc?.fieldRules) ? payloadFromDoc.fieldRules : [];
      }

      let rules = mergedRulesRaw;
      if (typeof window.normalizeHeadingsRulesForSchema === 'function') {
        try {
          rules = window.normalizeHeadingsRulesForSchema(chosenSchema, mergedRulesRaw, headingsParsed);
        } catch (e) {
          tr.warn('normalizeHeadingsRulesForSchema failed in renderFromCurrentBytes', e);
          rules = mergedRulesRaw;
        }
      }

      let fieldRules = mergedFieldRaw;
      if (typeof window.normalizeFieldRulesForSchema === 'function') {
        try {
          fieldRules = window.normalizeFieldRulesForSchema(chosenSchema, mergedFieldRaw);
        } catch (e) {
          tr.warn('normalizeFieldRulesForSchema failed in renderFromCurrentBytes', e);
          fieldRules = mergedFieldRaw;
        }
      }

      const { values: prunedValues, tagMap: prunedTagMap } =
        normalizeForSchema(chosenSchema, mergedValues, mergedTagMap);

      gSchema = chosenSchema;
      gValues = prunedValues;

      // Persist canonical view into workspace for other tabs
      if (gDocId) {
        const canonical = {
          title: gSchema.title,
          fields: gSchema.fields,
          values: gValues,
          tagMap: prunedTagMap,
          rules,
          fieldRules,
          headingsFlat: headingsParsed.flat,
          headingsTree: headingsParsed.tree,
          updatedAt: new Date().toISOString()
        };

        await window.formSuitePersist.saveState(gDocId, {
          schema: gSchema,
          values: gValues,
          tagMap: prunedTagMap,
          rules,
          fieldRules,
          payload: { CRONOS_PAYLOAD: canonical },
          CRONOS_PAYLOAD: canonical,
          cronos_payload: canonical,
          headingsFlat: headingsParsed.flat,
          headings: headingsParsed.flat,
          headingsTree: headingsParsed.tree,
          headingsUpdatedAt: new Date().toISOString(),
          schemaUpdatedAt: new Date().toISOString()
        });
      }

      buildForm(formMount, gSchema, gValues);
      await updatePreview(gValues);

      btnSave.disabled = false;
      btnExport.disabled = false;
      if (btnSaveFromPreview) btnSaveFromPreview.disabled = false;

      setStatus('Ready.');
    } catch (e) {
      tr.error('renderFromCurrentBytes failed', e);
      const msg = (e && e.message) ? e.message : String(e ?? 'Unknown error');
      setStatus('Error while parsing: ' + msg);
    } finally {
      tr.end();
    }
  }

  // =========================
  // APPLY PAYLOAD FROM PREVIEW JSON
  // =========================
  async function applyPayloadObject(obj, { broadcast = true, save = true } = {}) {
    const tr = TRACE('applyPayloadObject');
    try {
      if (!obj || typeof obj !== 'object') return;

      const nextSchema = {
        title: obj.title || 'Form',
        fields: Array.isArray(obj.fields) ? obj.fields : []
      };
      const rawValues = (obj.values && typeof obj.values === 'object') ? obj.values : {};
      const rawTagMap = (obj.tagMap && typeof obj.tagMap === 'object') ? obj.tagMap : {};
      const rawRules  = Array.isArray(obj.rules) ? obj.rules : [];
      const rawFieldR = Array.isArray(obj.fieldRules) ? obj.fieldRules : [];

      let rules = rawRules;
      if (typeof window.normalizeHeadingsRulesForSchema === 'function') {
        try {
          rules = window.normalizeHeadingsRulesForSchema(nextSchema, rawRules, gHeadingBaseline);
        } catch (e) {
          tr.warn('normalizeHeadingsRulesForSchema failed in applyPayloadObject', e);
          rules = rawRules;
        }
      }

      let fieldRules = rawFieldR;
      if (typeof window.normalizeFieldRulesForSchema === 'function') {
        try {
          fieldRules = window.normalizeFieldRulesForSchema(nextSchema, rawFieldR);
        } catch (e) {
          tr.warn('normalizeFieldRulesForSchema failed in applyPayloadObject', e);
          fieldRules = rawFieldR;
        }
      }

      const { values: prunedValues, tagMap: prunedTagMap } =
        normalizeForSchema(nextSchema, rawValues, rawTagMap);

      gSchema = nextSchema;
      gValues = prunedValues;

      const payloadObj = {
        title: gSchema.title,
        fields: gSchema.fields,
        values: gValues,
        tagMap: prunedTagMap,
        rules,
        fieldRules,
        updatedAt: new Date().toISOString()
      };

      if (gDocId && save) {
        await window.formSuitePersist.saveState(gDocId, {
          schema: gSchema,
          values: gValues,
          tagMap: prunedTagMap,
          rules,
          fieldRules,
          payload: { CRONOS_PAYLOAD: payloadObj },
          CRONOS_PAYLOAD: payloadObj,
          cronos_payload: payloadObj,
          schemaUpdatedAt: new Date().toISOString()
        });
      } else {
        try {
          localStorage.setItem(STORAGE_KEY, JSON.stringify({ title: gSchema.title, fields: gSchema.fields }));
        } catch {}
      }

      buildForm(formMount, gSchema, gValues);
      await updatePreview(gValues);

      gDirty = true;
      setStatus('Payload applied (from preview). Not yet saved to DOCX.');
      if (previewStatus) {
        previewStatus.textContent = 'Applied';
        setTimeout(() => { previewStatus.textContent = ''; }, 900);
      }

      if (broadcast) {
        try { bcLegacy?.postMessage({ type: 'schema-updated', docId: gDocId, ts: Date.now() }); } catch {}
        try { bcCanon?.postMessage({ type: 'schema-updated',  docId: gDocId, ts: Date.now() }); } catch {}
      }
    } finally {
      tr.end();
    }
  }

  if (payloadEl) {
    let __payloadApplyTimer = null;
    let __payloadEditBusy = false;

    payloadEl.addEventListener('input', () => {
      const tr = TRACE('payloadEl:input');
      try {
        clearTimeout(__payloadApplyTimer);
        __payloadApplyTimer = setTimeout(async () => {
          const tr2 = TRACE('payloadEl:debouncedApply');
          if (__payloadEditBusy) { tr2.end('busy'); return; }
          try {
            const txt = payloadEl.value;
            const obj = JSON.parse(txt);
            __payloadEditBusy = true;
            await applyPayloadObject(obj, { broadcast: true, save: true });
          } catch (e) {
            if (previewStatus) previewStatus.textContent = 'Invalid JSON';
            tr2.warn('invalid JSON', e);
          } finally {
            __payloadEditBusy = false;
            tr2.end();
          }
        }, 350);
      } finally {
        tr.end();
      }
    });
  }

  // =========================
  // FILE OPEN / SAVE / EXPORT
  // =========================
  async function doOpen() {
    const tr = TRACE('doOpen');
    try {
      if (!supportsFS) {
        alert('This browser does not support the File System Access API. Please use the main Form tab to open documents.');
        return;
      }

      clearUiForNewDoc('Opening…');

      const [handle] = await showOpenFilePicker({
        multiple: false,
        excludeAcceptAllOption: true,
        types: [{
          description: 'Word document',
          accept: {
            'application/vnd.openxmlformats-officedocument.wordprocessingml.document': ['.docx', '.docm', '.dotx', '.dotm']
          }
        }]
      });

      const file = await handle.getFile();
      const bytes = new Uint8Array(await file.arrayBuffer());
      const { base, ext } = splitNameAndExt(file.name || 'document.docx');

      gFileHandle = handle;
      gFileName   = base || 'document';
      gFileExt    = ext || 'docx';

      const meta = await window.formSuitePersist.setCurrentDoc({
        bytes,
        handle,
        name: `${gFileName}.${gFileExt}`
      });

      gDocId       = meta.docId;
      gArrayBuffer = bytes.buffer;

      persistActiveMeta(meta);
      try { bcCanon?.postMessage({ type: 'active:set', docId: meta.docId, name: meta.name }); } catch {}
      try { bcLegacy?.postMessage({ type: 'doc-switched', docId: meta.docId, name: meta.name }); } catch {}

      tr.step('opened', { docId: gDocId, name: meta.name, len: bytes.byteLength, sha: await sha256Hex(bytes) });

      await renderFromCurrentBytes();
      await updateWriteAccessBanner({ tryPrompt: true });

    } catch (e) {
      if (e?.name === 'AbortError') {
        tr.step('user canceled');
        setStatus('Idle');
        return;
      }
      tr.error('open failed', e);
      setStatus('Error opening file: ' + (e.message || e));
    } finally {
      tr.end();
    }
  }

  async function doSave() {
    const tr = TRACE('doSave');
    try {
      if (!gArrayBuffer || !gDocId) return;

      const restored = await window.formSuitePersist.loadState(gDocId) || {};

      adoptHeadingBaseline({
        flat: Array.isArray(restored.headingsFlat)
          ? restored.headingsFlat
          : Array.isArray(restored.headings) ? restored.headings : gHeadingBaseline.flat,
        tree: Array.isArray(restored.headingsTree)
          ? restored.headingsTree
          : gHeadingBaseline.tree
      });

      if (restored.schema) gSchema = restored.schema;

      const domVals  = collectFormValues(gSchema);
      const baseVals = restored.values || {};

      const payloadSnapshot =
        restored.payload?.CRONOS_PAYLOAD ||
        restored.CRONOS_PAYLOAD ||
        restored.cronos_payload ||
        {};

      const tagMapRaw = restored.tagMap || payloadSnapshot.tagMap || await getTagMapFor(gDocId);

      let mergedRulesRaw = [];
      let mergedFieldRaw = [];
      try {
        if (typeof window.resolveRulesForState === 'function') {
          const resolved = window.resolveRulesForState(restored, payloadSnapshot);
          mergedRulesRaw = Array.isArray(resolved.rules) ? resolved.rules : [];
          mergedFieldRaw = Array.isArray(resolved.fieldRules) ? resolved.fieldRules : [];
        } else {
          mergedRulesRaw = Array.isArray(payloadSnapshot.rules) ? payloadSnapshot.rules : [];
          mergedFieldRaw = Array.isArray(payloadSnapshot.fieldRules) ? payloadSnapshot.fieldRules : [];
        }
      } catch (e) {
        tr.warn('resolveRulesForState failed in doSave; payload-only rules', e);
        mergedRulesRaw = Array.isArray(payloadSnapshot.rules) ? payloadSnapshot.rules : [];
        mergedFieldRaw = Array.isArray(payloadSnapshot.fieldRules) ? payloadSnapshot.fieldRules : [];
      }

      let rules = mergedRulesRaw;
      if (typeof window.normalizeHeadingsRulesForSchema === 'function') {
        try {
          rules = window.normalizeHeadingsRulesForSchema(gSchema, mergedRulesRaw, gHeadingBaseline);
        } catch (e) {
          tr.warn('normalizeHeadingsRulesForSchema failed in doSave', e);
          rules = mergedRulesRaw;
        }
      }

      let fieldRules = mergedFieldRaw;
      if (typeof window.normalizeFieldRulesForSchema === 'function') {
        try {
          fieldRules = window.normalizeFieldRulesForSchema(gSchema, mergedFieldRaw);
        } catch (e) {
          tr.warn('normalizeFieldRulesForSchema failed in doSave', e);
          fieldRules = mergedFieldRaw;
        }
      }

      const { values: prunedValues, tagMap: prunedTagMap } =
        normalizeForSchema(gSchema, { ...baseVals, ...domVals }, tagMapRaw);

      gValues = prunedValues;
      await updatePreview(gValues);

      const payloadObj = {
        title:  gSchema.title || 'Form',
        fields: gSchema.fields || [],
        values: gValues || {},
        tagMap: prunedTagMap,
        rules,
        fieldRules,
        updatedAt: new Date().toISOString()
      };

      let updatedU8 = null;
      if (typeof window.writeDocVarSettings === 'function') {
        setStatus('Writing payload to DOCX…');
        const updatedBuf = await window.writeDocVarSettings(gArrayBuffer, PAYLOAD_KEY, JSON.stringify(payloadObj));
        updatedU8  = updatedBuf instanceof Uint8Array ? updatedBuf : new Uint8Array(updatedBuf);
      } else {
        tr.warn('writeDocVarSettings not available; workspace-only save');
        updatedU8 = new Uint8Array(gArrayBuffer);
      }

      gArrayBuffer = updatedU8.buffer;

      const stamp = Date.now();
      await window.formSuitePersist.saveState(gDocId, {
        schema: gSchema,
        values: gValues,
        rules,
        fieldRules,
        tagMap: prunedTagMap,
        payload: { CRONOS_PAYLOAD: payloadObj },
        CRONOS_PAYLOAD: payloadObj,
        cronos_payload: payloadObj,
        rulesVersion: stamp,
        schemaUpdatedAt: new Date().toISOString()
      });
      await window.formSuitePersist.putBytes?.(gDocId, updatedU8);

      announceDocUpdated({ docId: gDocId });

      if (supportsFS && gFileHandle && typeof gFileHandle.createWritable === 'function') {
        const p = await updateWriteAccessBanner({ tryPrompt: false });
        if (p === 'granted') {
          try {
            const stream = await gFileHandle.createWritable();
            await stream.write(updatedU8);
            await stream.close();
            setStatus('Saved.');
            gDirty = false;
            return;
          } catch (e) {
            tr.warn('write back to handle failed; falling back to workspace-only', e);
          }
        }
      }

      setStatus('Saved in workspace (file write not available).');
      gDirty = false;
    } catch (e) {
      tr.error('Save failed', e);
      setStatus('Save failed: ' + (e.message || e));
    } finally {
      tr.end();
    }
  }

  async function doExport() {
    const tr = TRACE('doExport');
    try {
      if (!gArrayBuffer) {
        alert('No DOCX loaded.');
        return;
      }
      if (!gSchema) {
        alert('No schema available — parse or hydrate first.');
        return;
      }
      if (!window.fsExportCore || typeof window.fsExportCore.buildDoc !== 'function') {
        alert('Export module (fs-export-core.js) is not available. You can still use Save (payload only).');
        return;
      }

      setStatus('Preparing export…');
      const originalBytes = new Uint8Array(gArrayBuffer);

      const restored = gDocId ? (await window.formSuitePersist.loadState(gDocId) || {}) : {};

      adoptHeadingBaseline({
        flat: Array.isArray(restored.headingsFlat)
          ? restored.headingsFlat
          : Array.isArray(restored.headings) ? restored.headings : gHeadingBaseline.flat,
        tree: Array.isArray(restored.headingsTree)
          ? restored.headingsTree
          : gHeadingBaseline.tree
      });

      if (restored.schema) gSchema = restored.schema;

      const domVals  = collectFormValues(gSchema);
      const baseVals = restored.values || {};

      const payloadSnapshot =
        restored.payload?.CRONOS_PAYLOAD ||
        restored.CRONOS_PAYLOAD ||
        restored.cronos_payload ||
        {};

      const tagMapRaw = restored.tagMap || payloadSnapshot.tagMap || await getTagMapFor(gDocId);

      let mergedRulesRaw = [];
      let mergedFieldRaw = [];
      try {
        if (typeof window.resolveRulesForState === 'function') {
          const resolved = window.resolveRulesForState(restored, payloadSnapshot);
          mergedRulesRaw = Array.isArray(resolved.rules) ? resolved.rules : [];
          mergedFieldRaw = Array.isArray(resolved.fieldRules) ? resolved.fieldRules : [];
        } else {
          mergedRulesRaw = Array.isArray(payloadSnapshot.rules) ? payloadSnapshot.rules : [];
          mergedFieldRaw = Array.isArray(payloadSnapshot.fieldRules) ? payloadSnapshot.fieldRules : [];
        }
      } catch (e) {
        tr.warn('resolveRulesForState failed in doExport; payload-only rules', e);
        mergedRulesRaw = Array.isArray(payloadSnapshot.rules) ? payloadSnapshot.rules : [];
        mergedFieldRaw = Array.isArray(payloadSnapshot.fieldRules) ? payloadSnapshot.fieldRules : [];
      }

      let rules = mergedRulesRaw;
      if (typeof window.normalizeHeadingsRulesForSchema === 'function') {
        try {
          rules = window.normalizeHeadingsRulesForSchema(gSchema, mergedRulesRaw, gHeadingBaseline);
        } catch (e) {
          tr.warn('normalizeHeadingsRulesForSchema failed in doExport', e);
          rules = mergedRulesRaw;
        }
      }

      let fieldRules = mergedFieldRaw;
      if (typeof window.normalizeFieldRulesForSchema === 'function') {
        try {
          fieldRules = window.normalizeFieldRulesForSchema(gSchema, mergedFieldRaw);
        } catch (e) {
          tr.warn('normalizeFieldRulesForSchema failed in doExport', e);
          fieldRules = mergedFieldRaw;
        }
      }

      const { values: prunedValues, tagMap: prunedTagMap } =
        normalizeForSchema(gSchema, { ...baseVals, ...domVals }, tagMapRaw);

      gValues = prunedValues;
      await updatePreview(gValues);

      const baseline = (gHeadingBaseline && (gHeadingBaseline.flat?.length || gHeadingBaseline.tree?.length))
        ? gHeadingBaseline
        : { flat: [], tree: [] };

      setStatus('Writing payload & applying rules…');

      const exportResult = await window.fsExportCore.buildDoc({
        originalBytes,
        schema: gSchema,
        values: gValues,
        tagMap: prunedTagMap,
        rules,
        fieldRules,
        headingBaseline: baseline,
        payloadKey: PAYLOAD_KEY,
        writerKind: 'settings',
        debugLabel: 'extractor.doExport',
        buildHeadingResolver: async () => {
          if (typeof window.buildHeadingTargetIndex === 'function') {
            return window.buildHeadingTargetIndex(baseline);
          }
          return null;
        }
      });

      const updatedU8 = exportResult.updatedBytes instanceof Uint8Array
        ? exportResult.updatedBytes
        : new Uint8Array(exportResult.updatedBytes);

      gArrayBuffer = updatedU8.buffer;

      const payloadObj = exportResult.payload || {
        title: gSchema.title || 'Form',
        fields: gSchema.fields || [],
        values: gValues,
        tagMap: prunedTagMap,
        rules,
        fieldRules,
        updatedAt: new Date().toISOString()
      };

      if (gDocId) {
        const stamp = Date.now();
        await window.formSuitePersist.saveState(gDocId, {
          schema: gSchema,
          values: gValues,
          rules,
          fieldRules,
          tagMap: prunedTagMap,
          payload: { CRONOS_PAYLOAD: payloadObj },
          CRONOS_PAYLOAD: payloadObj,
          cronos_payload: payloadObj,
          rulesVersion: stamp,
          headingsFlat: baseline.flat || [],
          headings: baseline.flat || [],
          headingsTree: baseline.tree || [],
          headingsUpdatedAt: new Date().toISOString(),
          schemaUpdatedAt: new Date().toISOString()
        });
        await window.formSuitePersist.putBytes?.(gDocId, updatedU8);
      }

      announceDocUpdated({ docId: gDocId });

      const outName = (gFileName || 'document').replace(/\.docx$/i, '') + ' (export).docx';

      if (window.showSaveFilePicker && typeof window.showSaveFilePicker === 'function') {
        try {
          const handle = await window.showSaveFilePicker({
            suggestedName: outName,
            types: [{
              description: 'Word Document',
              accept: { 'application/vnd.openxmlformats-officedocument.wordprocessingml.document': ['.docx'] }
            }]
          });
          if (handle && typeof handle.createWritable === 'function') {
            const stream = await handle.createWritable();
            await stream.write(updatedU8);
            await stream.close();
            setStatus('Exported & saved.');
            return;
          }
        } catch (e) {
          tr.warn('SaveFilePicker canceled/failed; falling back to download link.', e);
        }
      }

      const blob = new Blob([updatedU8], {
        type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
      });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = outName;
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        URL.revokeObjectURL(url);
        a.remove();
      }, 4000);

      setStatus('Exported (download started).');
    } catch (e) {
      tr.error('doExport failed', e);
      setStatus('Export failed — see console for details: ' + (e.message || e));
    } finally {
      tr.end();
    }
  }

  // =========================
  // BOOT (auto-restore)
  // =========================
  (async function boot() {
    const tr = TRACE('boot');
    try {
      let meta = (typeof window.readActiveDocSync === 'function') ? window.readActiveDocSync() : null;
      tr.step('readActiveDocSync', meta);
      if (!meta?.docId && window.formSuitePersist && typeof window.formSuitePersist.getCurrentDocMeta === 'function') {
        meta = window.formSuitePersist.getCurrentDocMeta();
        tr.step('getCurrentDocMeta', meta);
      }
      if (!meta?.docId) {
        tr.end('no meta; idle');
        return;
      }

      clearUiForNewDoc('Restoring document…');

      let bytes = await window.formSuitePersist.getBytes?.(meta.docId)
        || await window.formSuitePersist.getCurrentDocBytes?.();

      if (!bytes && supportsFS && window.formSuitePersist && typeof window.formSuitePersist.getHandle === 'function') {
        try {
          const h = await window.formSuitePersist.getHandle(meta.docId);
          if (h && typeof h.getFile === 'function') {
            try { await window.formSuitePersist.ensurePermission?.(h, 'read'); } catch {}
            const f = await h.getFile();
            bytes = new Uint8Array(await f.arrayBuffer());
            gFileHandle = h;
            const { base, ext } = splitNameAndExt(f.name || meta.name || 'document.docx');
            gFileName = base || 'document';
            gFileExt  = ext  || 'docx';
          }
        } catch (e) {
          tr.warn('handle fallback failed', e);
        }
      }

      if (!bytes) {
        await hardResetDocContext('no bytes / no permission');
        tr.end('no bytes');
        return;
      }

      gArrayBuffer = bytes.buffer ?? bytes;

      if (!gFileName) {
        const { base, ext } = splitNameAndExt(meta.name || 'document.docx');
        gFileName = base || 'document';
        gFileExt  = ext || 'docx';
      }
      gDocId = meta.docId;

      tr.step('restored', {
        docId: gDocId,
        name: `${gFileName}.${gFileExt}`,
        len: gArrayBuffer.byteLength,
        sha: await sha256Hex(gArrayBuffer)
      });

      await renderFromCurrentBytes();
      await updateWriteAccessBanner();
    } catch (e) {
      tr.error('boot failed', e);
    } finally {
      tr.end();
    }
  })();

  // =========================
  // EVENT WIRING
  // =========================
  btnOpen.addEventListener('click', doOpen);
  btnSave.addEventListener('click', doSave);
  btnExport.addEventListener('click', doExport);

  if (btnSaveFromPreview) {
    btnSaveFromPreview.addEventListener('click', doSave);
  }

  btnRegrant.addEventListener('click', async () => {
    const tr = TRACE('btnRegrant:click');
    try {
      await updateWriteAccessBanner({ tryPrompt: true });
    } catch (e) {
      tr.error('regrant failed', e);
      permNote.style.display = 'block';
    } finally {
      tr.end();
    }
  });

  window.addEventListener('beforeunload', async () => {
    const tr = TRACE('beforeunload');
    try {
      if (!gDocId) { tr.end('no docId'); return; }
      const vals = collectFormValues(gSchema);
      await window.formSuitePersist.saveState(gDocId, {
        schema: gSchema,
        values: { ...(gValues || {}), ...vals }
      });
      persistActiveMeta({ docId: gDocId, name: gFileName ? `${gFileName}.${gFileExt}` : 'document.docx' });
    } catch (e) {
      tr.warn('beforeunload failed', e);
    } finally {
      tr.end();
    }
  });

  // =========================
  // LOGO NAV (triple-click)
  // =========================
  try {
    if (typeof window.installLogoFocusNav === 'function') {
      window.installLogoFocusNav();
    }
  } catch (e) {
    console.warn('[Extractor] installLogoFocusNav failed', e);
  }
</script>
</body>
</html>
