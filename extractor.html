<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Form Suite â€” Extractor</title>
  <link rel="icon" href="favicon.ico" type="image/gif" sizes="32x32">
  <link rel="shortcut icon" href="favicon.ico" type="image/gif">
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
  <link rel="stylesheet" href="style.css">

  <!-- Persistence layer (provides window.formSuitePersist) -->
  <script src="persistence.js"></script>
  <script src="rules-core.js"></script>
  <script src="docx-core.js"></script>
  <script src="fs-active-doc.js"></script>
  <script src="fs-focus-nav.js"></script>
  <script src="fs-export-core.js"></script>
  <!-- flatpickr JS (date inputs) -->
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <!-- JSZip for JS-based SDT scanning (parity with Tag Matcher) -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <!-- for the autocompletion of the adress-->
  <script src="address-autocomplete.js"></script>
</head>
<body>
  <header>
    <div class="row">
      <span class="brand logo-md">
        <img src="logo.gif" alt="Form Suite logo" class="logo" />
        <strong>Form Suite</strong>
      </span>
      <span class="muted">Â·</span><a href="index.html">Form</a>
      <span class="muted">Â·</span><a href="builder.html" id="openBuilder">Form Builder</a>
      <span class="muted">Â·</span><a href="matcher.html">Tag Matcher</a>
      <span class="muted">Â·</span><a href="rules.html">Rules</a>
      <span class="muted">Â·</span><span class="muted">Extractor</span>
    </div>
  </header>

  <main>
    <section class="panel">
      <h2 style="margin:0 0 10px">Inspect SDTs & store manual form payload in the DOCX</h2>
      <div class="row" style="gap:8px;flex-wrap:wrap">
        <button id="btnOpen">Open DOCXâ€¦</button>
        <button id="btnSave" disabled>Save (payload only)</button>
        <button id="btnExport" disabled>Export (payload + replace tags)</button>
        <span class="muted" id="status" style="margin-left:auto">Idle</span>
      </div>

      <!-- Restored banner -->
      <div id="permNote" class="note warn" style="display:none;margin-top:10px">
        This DOCX was opened via picker but I donâ€™t have write permission to the original file.
        Clicking <em>Save</em> will download a copy instead of writing back.
        <button id="btnRegrant" class="ghost" style="margin-left:8px">Grant write access</button>
      </div>
    </section>

    <div class="grid-3">
      <section class="panel">
        <details>
          <summary><strong>Found SDTs</strong></summary>
          <div style="overflow:auto;">
            <table id="sdt-table">
              <thead>
                <tr>
                  <th>#</th>
                  <th>Part</th>
                  <th>w:tag</th>
                  <th>w:alias</th>
                  <th>Text</th>
                </tr>
              </thead>
              <tbody id="sdt-tbody"></tbody>
            </table>
          </div>
        </details>
      </section>

      <section class="panel">
        <details>
          <summary><strong>CRONOS_PAYLOAD Preview</strong></summary>
          <textarea id="payloadPreview" spellcheck="false" style="min-height:420px"></textarea>
          <div class="row" style="margin-top:6px; gap:8px;">
            <button id="btnSaveFromPreview" class="secondary" disabled>Save</button>
            <span class="muted" id="previewStatus"></span>
          </div>
        </details>
      </section>

      <section class="panel">
        <details>
          <summary><strong>Headers/Subheaders</strong></summary>
          <div id="headersTree" class="tree" style="max-height:420px;overflow:auto;padding:6px 4px;"></div>
        </details>
      </section>

      <section class="panel">
        <details>
          <summary><strong>Live Form (from payload schema)</strong></summary>
          <div id="formMount"></div>
        </details>
      </section>
    </div>
  </main>

  <script>
    // =========================
    // ðŸ”Ž DEBUG / TRACE PRIMITIVES
    // =========================
      const DEBUG = { on: true, seq: 0 };
      const _t = () => new Date().toISOString().slice(11, 23);
      const tag = (name) => `%c[Extractor ${_t()} #${++DEBUG.seq}] ${name}`;
      const tagStyle = 'color:#6b7280;font-weight:600';

      function TRACE(name, details) {
        const label = `${name} :: ${_t()} :: #${DEBUG.seq+1}`;
        let ended = false;
        try {
          console.groupCollapsed(tag(name), tagStyle, details ?? '');
        } catch {}
        try {
          console.time(label);
        } catch {}
        return {
          step: (msg, data) => console.log(tag(`  â†³ ${msg}`), tagStyle, data ?? ''),
          warn: (msg, data) => console.warn(tag(`  âš  ${msg}`), tagStyle, data ?? ''),
          error: (msg, err) => console.error(tag(`  âœ– ${msg}`), tagStyle, err),
          end: (extra) => {
            if (ended) return;
            ended = true;
            if (extra) console.log(tag('done'), tagStyle, extra);
            try { console.timeEnd(label); } catch {}
            try { console.groupEnd(); } catch {}
          }
        };
      }

    window.addEventListener('error', (e) => {
      console.error(tag('window.error'), tagStyle, { message: e.message, filename: e.filename, lineno: e.lineno, colno: e.colno, error: e.error });
    });
    window.addEventListener('unhandledrejection', (e) => {
      console.error(tag('window.unhandledrejection'), tagStyle, e.reason);
    });

    // =========================
    // ðŸ§­ PAYLOAD CHANGE FORENSICS (WHY DID IT WRITE?)
    // =========================
    function __safeLen(x){ return Array.isArray(x) ? x.length : (x && typeof x==='object' ? Object.keys(x).length : 0); }
    function __deepEqual(a,b){ try { return JSON.stringify(a) === JSON.stringify(b); } catch { return false; } }
    function __diffObj(a, b, path = '') {
      const diffs = [];
      const isObj = v => v && typeof v === 'object' && !Array.isArray(v);
      const keys = new Set([...Object.keys(a||{}), ...Object.keys(b||{})]);
      for (const k of keys) {
        const pa = path ? `${path}.${k}` : k;
        const va = a?.[k], vb = b?.[k];
        if (isObj(va) && isObj(vb)) { diffs.push(...__diffObj(va, vb, pa)); continue; }
        if (Array.isArray(va) && Array.isArray(vb)) {
          if (!__deepEqual(va, vb)) diffs.push({ path: pa, type:'array', from: va, to: vb });
          continue;
        }
        if (JSON.stringify(va) !== JSON.stringify(vb)) diffs.push({ path: pa, type:'value', from: va, to: vb });
      }
      return diffs;
    }
    async function __snapshotCanonicalFromState(docId){
      const st = docId ? (await window.formSuitePersist.loadState(docId) || {}) : {};
      const p = st?.payload?.CRONOS_PAYLOAD || st?.CRONOS_PAYLOAD || st?.cronos_payload || {};
      return {
        ws: {
          rules: Array.isArray(st.rules) ? st.rules : [],
          fieldRules: Array.isArray(st.fieldRules) ? st.fieldRules : [],
          rulesVersion: st.rulesVersion,
          schema: st.schema,
          values: st.values,
          tagMap: st.tagMap,
        },
        payload: p
      };
    }
    async function debugLogExtractor(where, reasonFlags, beforeCanon, afterCanon){
      const label = `[Extractor:payload][${where}]`;
      try {
        console.groupCollapsed(label);
        console.log('docId:', gDocId, 'file:', `${gFileName || ''}.${gFileExt || ''}`);
        console.log('reasonFlags:', reasonFlags);
        const pre = beforeCanon || await __snapshotCanonicalFromState(gDocId);
        console.log('BEFORE (workspace.rules, workspace.fieldRules):',
          __safeLen(pre.ws.rules), __safeLen(pre.ws.fieldRules));
        console.log('BEFORE (payload.rules, payload.fieldRules):',
          __safeLen(pre.payload.rules), __safeLen(pre.payload.fieldRules));
        console.log('BEFORE payload.updatedAt:', pre.payload?.updatedAt, 'rulesVersion:', pre.payload?.rulesVersion);
        if (afterCanon) {
          console.log('AFTER payload.rules:', __safeLen(afterCanon.rules), afterCanon.rules);
          console.log('AFTER payload.fieldRules:', __safeLen(afterCanon.fieldRules), afterCanon.fieldRules);
          console.log('AFTER payload.updatedAt:', afterCanon.updatedAt, 'rulesVersion:', afterCanon.rulesVersion);
          const diffs = __diffObj(pre.payload || {}, afterCanon || {});
          if (diffs.length) console.warn('DIFF (payload changes):', diffs);
          else console.log('DIFF: none (payload unchanged)');
        }
      } catch (e) { console.error(label + ' failed', e); }
      finally { console.groupEnd(); }
    }

    // =========================
    // CONSTANTS & STATE
    // =========================
    const STORAGE_KEY  = 'FORM_SCHEMA_V1';
    const PAYLOAD_KEY  = 'CRONOS_PAYLOAD';
    const META_LS_KEY  = 'FS_CURRENT_DOC_META';       // legacy mirror
    const ACTIVE_LS_KEY= 'FS_ACTIVE_DOC_META';        // canonical
    const supportsFS   = 'showOpenFilePicker' in window && 'showSaveFilePicker' in window;

    let gArrayBuffer   = null;
    let gFileName      = null;  // name without .docx
    let gFileHandle    = null;  // FileSystemFileHandle
    let gSchema        = { title: 'Form', fields: [] };
    let gValues        = {};
    let gDocId         = null;
    let gDirty         = false;
    let gSDTs          = [];
    let gLastSchemaPushTs = 0;
    let gPreferDocOnNextLoad = false;   // prefer DOCX payload only right after doOpen()
    let gFileExt = 'docx'; // 'docx' | 'docm' | 'dotx' | 'dotm'
    let gHeadingBaseline = { flat: [], tree: [] };

    // NEW: hold structured address values while editing
    const __addressValues = Object.create(null);

    // UI refs
    const btnOpen   = document.getElementById('btnOpen');
    const btnSave   = document.getElementById('btnSave');
    const btnExport = document.getElementById('btnExport');
    const statusEl  = document.getElementById('status');
    const permNote  = document.getElementById('permNote');
    const payloadEl = document.getElementById('payloadPreview');
    const formMount = document.getElementById('formMount');
    const tableBody = document.getElementById('sdt-tbody');
    const btnRegrant= document.getElementById('btnRegrant');
    const btnSaveFromPreview = document.getElementById('btnSaveFromPreview');
    const previewStatus = document.getElementById('previewStatus');
    const headersTreeEl = document.getElementById('headersTree');

    function splitNameAndExt(fileName) {
      const m = String(fileName).match(/\.(docx|docm|dotx|dotm)$/i);
      return {
        base: String(fileName).replace(/\.(docx|docm|dotx|dotm)$/i, ''),
        ext:  (m ? m[1] : 'docx').toLowerCase()
      };
    }

    function wordMimeFor(ext) {
      switch ((ext || '').toLowerCase()) {
        case 'docm': return 'application/vnd.ms-word.document.macroEnabled.12';
        case 'dotx': return 'application/vnd.openxmlformats-officedocument.wordprocessingml.template';
        case 'dotm': return 'application/vnd.ms-word.template.macroEnabled.12';
        default:     return 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';
      }
    }

    async function sha256Hex(bufOrU8) {
      const tr = TRACE('sha256Hex', { type: (bufOrU8?.constructor?.name), len: bufOrU8?.byteLength || bufOrU8?.length });
      try {
        const ab = (bufOrU8 instanceof ArrayBuffer) ? bufOrU8
                  : (bufOrU8?.buffer instanceof ArrayBuffer) ? bufOrU8.buffer
                  : new Uint8Array(bufOrU8 || []).buffer;
        const d = await crypto.subtle.digest('SHA-256', ab);
        const hex = [...new Uint8Array(d)].map(b => b.toString(16).padStart(2, '0')).join('');
        tr.end({ hex });
        return hex;
      } catch (e) { tr.error('sha failed', e); tr.end(); return '(hash-error)'; }
    }

    const setStatus = (m) => {
      const tr = TRACE('setStatus', { text: m });
      try { statusEl.textContent = m; } finally { tr.end(); }
    };

    // ===== Helpers to normalize/compact Pyodide byte outputs =====
    const toU8 = (x) => (x instanceof Uint8Array ? x : new Uint8Array(x));
    const compactU8 = (u8) => (u8.byteOffset === 0 && u8.byteLength === u8.buffer.byteLength) ? u8 : u8.slice();

    // =========================
    // PERSISTENCE SHIM (if missing)
    // =========================
    (function ensurePersist() {
      const tr = TRACE('ensurePersist');
      try {
        if (window.formSuitePersist) { tr.step('already present'); return; }
        tr.step('installing shim');
        let _meta = null;
        let _state = {};
        window.formSuitePersist = {
          getCurrentDocMeta() { tr.step('shim.getCurrentDocMeta', _meta); return _meta; },
          setCurrentDoc: async ({ bytes, handle, name }) => { tr.step('shim.setCurrentDoc', { bytes: !!bytes, name, handle: !!handle }); _meta = { docId: 'inline-' + Date.now(), name: name || 'document' }; return _meta; },
          setCurrentDocFromBytes: async (bytes, meta) => { tr.step('shim.setCurrentDocFromBytes', { bytes: !!bytes, meta }); _meta = { docId: 'inline-' + Date.now(), name: meta?.name || 'document' }; return _meta; },
          getCurrentDocBytes: async () => { tr.step('shim.getCurrentDocBytes -> null'); return null; },
          getBytes: async (_docId) => { tr.step('shim.getBytes -> null', _docId); return null; },
          getHandle: async (_docId) => { tr.step('shim.getHandle -> null', _docId); return null; },
          saveState: async (_docId, obj) => { tr.step('shim.saveState', { docId:_docId, keys:Object.keys(obj||{}) }); _state = { ..._state, ...(obj||{}) }; },
          loadState: async (_docId) => { tr.step('shim.loadState', { docId:_docId }); return _state; },
          putBytes: async (_docId, _bytes) => { tr.step('shim.putBytes', { docId:_docId, len: _bytes?.byteLength }); },
          ensurePermission: async (_h, _mode) => { tr.step('shim.ensurePermission', { mode:_mode }); return 'granted'; }
        };
      } finally {
        tr.end();
      }
    })();


    // =========================
    // CROSS-TAB + LOCALSTORAGE
    // =========================
    const bcLegacy = ('BroadcastChannel' in window) ? new BroadcastChannel('form-suite-doc') : null;
    const bcCanon  = ('BroadcastChannel' in window) ? new BroadcastChannel('fs-active-doc') : null;

    function clearUiForNewDoc(message = 'Loading new documentâ€¦') {
      try {
        tableBody.innerHTML = '<tr><td colspan="5" class="empty">Loadingâ€¦</td></tr>';
        formMount.innerHTML = '<div class="empty">No schema found.</div>';
        payloadEl.value = '';
        previewStatus.textContent = '';
        if (headersTreeEl) headersTreeEl.innerHTML = '<div class="empty">No headings.</div>';
        btnSave.disabled = true; btnExport.disabled = true; btnSaveFromPreview.disabled = true;
        permNote.style.display = 'none';
        setStatus(message);
      } catch {}
      gSchema = { title: 'Form', fields: [] };
      gValues = {};
      gDirty = false;
      adoptHeadingBaseline({ flat: [], tree: [] });
    }

    async function hardResetDocContext(reason = '') {
      const tr = TRACE('hardResetDocContext:start', { reason, docId: gDocId });
      try {
        if (gDocId) {
          await window.formSuitePersist?.saveState?.(gDocId, {});
          try { await window.formSuitePersist?.putBytes?.(gDocId, new Uint8Array()); } catch (e) { tr.warn('putBytes failed', e); }
        }
      } catch (e) { tr.error('saveState failed', e); }
      gArrayBuffer = null; gFileHandle = null; gFileName = null; gDocId = null; gSDTs = [];
      adoptHeadingBaseline({ flat: [], tree: [] });

      // Centralized active-doc clear (fs-active-doc.js)
      window.clearActiveDocMeta?.();
      try {
        tableBody.innerHTML = '<tr><td colspan="5" class="empty">No document loaded.</td></tr>';
        formMount.innerHTML = '<div class="empty">No schema found.</div>';
        payloadEl.value = '';
        previewStatus.textContent = '';
        btnSave.disabled = true; btnExport.disabled = true; btnSaveFromPreview.disabled = true;
        permNote.style.display = 'none';
        setStatus(reason ? `Cleared: ${reason}` : 'Cleared.');
      } catch (e) { tr.warn('DOM reset failed', e); }
      try { if (headersTreeEl) headersTreeEl.innerHTML = '<div class="empty">No headings.</div>'; } catch {}
      tr.end('reset complete');
    }

    // --- Broadcast listeners (legacy + canonical) ---
    bcLegacy?.addEventListener?.('message', async (ev) => {
      const tr = TRACE('BroadcastChannel(legacy):message', ev?.data);
      try {
        const m = ev.data || {};
        if (m.type === 'doc-switched' && m.docId && m.docId !== gDocId) {
          clearUiForNewDoc('Switching to another documentâ€¦');
          let bytes = await window.formSuitePersist.getBytes?.(m.docId) || await window.formSuitePersist.getCurrentDocBytes?.();
          if (!bytes) { await hardResetDocContext('no bytes / no permission'); return; }
          gArrayBuffer = bytes.buffer ?? bytes;
          gFileName = m.name || gFileName;
          gDocId = m.docId;
          await renderFromCurrentBytes('(switched by other tab) ');
          await updateWriteAccessBanner();
        }
        if (m.type === 'doc-updated' && m.docId && m.docId === gDocId) {
          let bytes = await window.formSuitePersist.getBytes?.(gDocId) || await window.formSuitePersist.getCurrentDocBytes?.();
          if (!bytes) { await hardResetDocContext('no bytes / no permission'); return; }
          gArrayBuffer = bytes.buffer ?? bytes;
          await renderFromCurrentBytes('(updated by other tab) ');
          await updateWriteAccessBanner();
        }
        if (m.type === 'schema-updated' && m.docId && m.docId === gDocId) {
          gLastSchemaPushTs = m.ts || Date.now();
          const st = await window.formSuitePersist.loadState(gDocId);
          adoptHeadingBaseline({
            flat: Array.isArray(st?.headingsFlat) ? st.headingsFlat : Array.isArray(st?.headings) ? st.headings : [],
            tree: Array.isArray(st?.headingsTree) ? st.headingsTree : []
          });
          if (st?.schema) {
            const domVals = collectFormValues(st.schema);
            const wsVals  = st.values || {};
            gSchema = st.schema;
            gValues = { ...wsVals, ...domVals };
            buildForm(formMount, gSchema, gValues);
            await updatePreview(gValues);
            await debugLogExtractor('bc:rules-updated', { function:'BC rules-updated', from: 'rules.html' });
            setStatus('Schema updated from Form Builder.');
          }
        }
        if (m.type === 'doc-cleared') {
          await hardResetDocContext('cleared by another tab');
        }
      } finally { tr.end(); }
    });

    bcCanon?.addEventListener?.('message', async (ev) => {
      const tr = TRACE('BroadcastChannel(canon):message', ev?.data);
      try {
        const m = ev.data || {};
        if (m.type === 'active:set') {
          if (m.docId && m.docId !== gDocId) {
            clearUiForNewDoc('Switching to another documentâ€¦');
            let bytes = await window.formSuitePersist.getBytes?.(m.docId) || await window.formSuitePersist.getCurrentDocBytes?.();
            if (!bytes) { await hardResetDocContext('no bytes / no permission'); return; }
            gArrayBuffer = bytes.buffer ?? bytes;
            gFileName = m.name || gFileName;
            gDocId = m.docId;
            await renderFromCurrentBytes('(switched by other tab) ');
            await updateWriteAccessBanner();
          }
        }
        if (m.type === 'active:updated' && m.docId && m.docId === gDocId) {
          let bytes = await window.formSuitePersist.getBytes?.(gDocId) || await window.formSuitePersist.getCurrentDocBytes?.();
          if (!bytes) return;
          gArrayBuffer = bytes.buffer ?? bytes;
          await renderFromCurrentBytes('(updated by other tab) ');
        }
        if (m.type === 'active:clear') await hardResetDocContext('cleared by another tab');
      } finally { tr.end(); }
    });

    // --- Storage listeners (canonical first, legacy as fallback) ---
    window.addEventListener('storage', async (e) => {
      const tr = TRACE('storage:event', { key:e.key, newValue: !!e.newValue });
      try {
        if ((e.key === ACTIVE_LS_KEY || e.key === META_LS_KEY) && e.newValue) {
          const meta = window.readActiveDocSync?.() || null;
          if (!meta?.docId || meta.docId === gDocId) return;
          clearUiForNewDoc('Switching to another documentâ€¦');
          let bytes = await window.formSuitePersist.getBytes?.(meta.docId) || await window.formSuitePersist.getCurrentDocBytes?.();
          if (!bytes) { await hardResetDocContext('no bytes / no permission'); return; }
          gArrayBuffer = bytes.buffer ?? bytes;
          gFileName = meta.name || gFileName;
          gDocId = meta.docId;
          await renderFromCurrentBytes('(switched by other tab) ');
          await updateWriteAccessBanner();
        }
      } finally { tr.end(); }
    });

    // =========================
    // STABLE FOREGROUND REFRESH
    // =========================
    let __fgRefreshLock = false;
    async function safeGetBytes(docId) {
      const tr = TRACE('safeGetBytes', { docId });
      try {
        let bytes = await window.formSuitePersist.getBytes?.(docId);
        if (bytes) { tr.end({ src:'opfs', len: bytes.byteLength || bytes.length }); return bytes; }

        bytes = await window.formSuitePersist.getCurrentDocBytes?.();
        if (bytes) { tr.end({ src:'currentDocBytes', len: bytes.byteLength || bytes.length }); return bytes; }

        const h = await window.formSuitePersist.getHandle?.(docId);
        if (h?.getFile) {
          try {
            const f = await h.getFile();
            bytes = await f.arrayBuffer();
            tr.end({ src:'handle.getFile', len: bytes.byteLength || bytes.length });
            return bytes;
          } catch (e) { tr.warn('handle.getFile failed', e); }
        }

        tr.end({ src:'none' });
        return null;
      } catch (e) { tr.error('safeGetBytes failed', e); tr.end(); return null; }
    }

    async function rehydrateOnForeground(source) {
      const tr = TRACE('rehydrateOnForeground', { source, docId: gDocId, locked: __fgRefreshLock });
      if (__fgRefreshLock) { tr.step('locked; skip'); tr.end(); return; }
      __fgRefreshLock = true;
      try {
        if (!gDocId) { tr.step('no docId'); return; }

        await new Promise(r => setTimeout(r, 120));

        let bytes = await safeGetBytes(gDocId);
        if (!bytes) {
          await new Promise(r => setTimeout(r, 120));
          bytes = await safeGetBytes(gDocId);
        }

        if (bytes) {
          gArrayBuffer = bytes.buffer ?? bytes;
          await renderFromCurrentBytes(`(${source} refreshed) `);
          await updateWriteAccessBanner();
          tr.end('refreshed');
          return;
        }

        if (gArrayBuffer?.byteLength) {
          setStatus(`Refresh skipped (${source}): no bytes yet; keeping current.`);
          await updateWriteAccessBanner();
          tr.end('kept current buffer');
          return;
        }

        const h = await window.formSuitePersist.getHandle?.(gDocId);
        if (h) {
          setStatus(`Refresh postponed (${source}): handle exists; waiting for bytes.`);
          await updateWriteAccessBanner();
          tr.end('postponed; has handle');
          return;
        }

        await hardResetDocContext('lost access');
        tr.end('hard reset');
      } catch (e) {
        tr.error('rehydrate failed', e);
      } finally {
        __fgRefreshLock = false;
      }
    }

    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible') rehydrateOnForeground('visible');
    });
    window.addEventListener('focus', () => {
      rehydrateOnForeground('focus');
    });

    // =========================
    // âœ… WRITE ACCESS BANNER / PROMPT
    // =========================
    async function updateWriteAccessBanner({ tryPrompt = false } = {}) {
      const tr = TRACE('updateWriteAccessBanner', { tryPrompt, docId: gDocId, supportsFS });
      try {
        if (!supportsFS || !gDocId) { permNote.style.display = 'none'; tr.end('unsupported/no-doc'); return 'unsupported'; }

        let handle = gFileHandle || await window.formSuitePersist.getHandle?.(gDocId);
        if (!handle || !handle.queryPermission) { permNote.style.display = 'none'; tr.end('no-handle'); return 'no-handle'; }

        let p = await handle.queryPermission({ mode: 'readwrite' });
        tr.step('queryPermission', p);

        if (p !== 'granted' && tryPrompt) {
          try {
            const r = await handle.requestPermission({ mode: 'readwrite' });
            p = r || p;
            tr.step('requestPermission', r);
          } catch (e) {
            tr.warn('requestPermission failed', e);
          }
        }

        permNote.style.display = (p === 'granted') ? 'none' : 'block';
        if (p === 'granted') gFileHandle = handle;

        tr.end({ final: p });
        return p || 'denied';
      } catch (e) {
        tr.error('updateWriteAccessBanner failed', e);
        permNote.style.display = 'block';
        return 'error';
      }
    }

    function installRulesUpdatedListener() {
      // attach once
      if (window.__fsRulesBCInstalled) {
        console.log('[Extractor][BC] listener already installed');
        return;
      }
      window.__fsRulesBCInstalled = true;

      console.log('[Extractor][BC] installing listeners', {
        hasCanon: !!bcCanon, hasLegacy: !!bcLegacy, gDocIdAtInstall: gDocId
      });

      const pickActiveMeta = () => {
        try {
          const v = localStorage.getItem('FS_ACTIVE_DOC_META') || localStorage.getItem('FS_CURRENT_DOC_META');
          return v ? JSON.parse(v) : null;
        } catch { return null; }
      };

      const onMsg = async (label, ev) => {
        const m = ev?.data || {};
        if (!m || typeof m !== 'object') return;

        // Always log incoming broadcasts for debugging
        console.log(`[Extractor][BC:${label}]`, m, 'local gDocId=', gDocId);

        if (m.type === 'rules-updated') {
          // Accept the docId from the message if we're not bound yet
          const targetId = m.docId || pickActiveMeta()?.docId || gDocId;
          if (!targetId) { console.warn('[Extractor][BC] rules-updated but no targetId'); return; }

          if (!gDocId) {
            // late-bind this tab to the active doc so we donâ€™t miss future changes
            gDocId = targetId;
            window.setActiveDocMeta?.({
              docId: gDocId,
              name: pickActiveMeta()?.name || gFileName || 'document'
            });
            console.log('[Extractor][BC] late-bound to docId', gDocId);
          }
          if (gDocId !== targetId) {
            console.log('[Extractor][BC] rules-updated for different doc; ignoring', { targetId, gDocId });
            return;
          }

          try {
            await updatePreview(collectFormValues(gSchema));
            await debugLogExtractor('bc:rules-updated', { function:'BC rules-updated', from: 'rules.html' });
            setStatus('Rules updated from Rules tab (BC).');
          } catch (e) {
            console.warn('[Extractor][BC] updatePreview failed after rules-updated', e);
          }
        }

        // (optional) react to generic state signal if your persistence emits it
        if (m.type === 'state-updated') {
          const active = pickActiveMeta();
          if (!active?.docId) return;
          if (!gDocId) gDocId = active.docId;
          if (gDocId !== active.docId) return;
          try {
            await updatePreview(collectFormValues(gSchema));
            await debugLogExtractor('bc:state-updated', { function:'BC state-updated' });
            setStatus('State updated (BC).');
          } catch (e) {
            console.warn('[Extractor][BC] updatePreview failed after state-updated', e);
          }
        }
      };

      bcCanon?.addEventListener?.('message', onMsg.bind(null, 'fs-active-doc'));
      bcLegacy?.addEventListener?.('message', onMsg.bind(null, 'form-suite-doc'));
      console.log('[Extractor][BC] listeners attached');
    }

    (async function setupRulesWatchdog(){
      let lastRV = null;

      async function tick() {
        try {
          if (!gDocId) {
            const meta = window.readActiveDocSync?.();
            if (meta?.docId) {
              gDocId = meta.docId;
              console.log('[Extractor][Watchdog] late-bound gDocId from active meta', gDocId);
            } else {
              return; // still nothing to watch
            }
          }
          const st = await window.formSuitePersist.loadState(gDocId);
          const rv = st?.rulesVersion
            ?? st?.payload?.CRONOS_PAYLOAD?.rulesVersion
            ?? st?.CRONOS_PAYLOAD?.rulesVersion
            ?? st?.cronos_payload?.rulesVersion
            ?? null;

          if (rv !== lastRV) {
            console.log('[Extractor][Watchdog] rulesVersion changed:', { prev: lastRV, next: rv });
            lastRV = rv;
            await updatePreview(collectFormValues(gSchema));
            await debugLogExtractor('watchdog:rulesVersion', { function:'Watchdog', prev: (lastRV ?? null), next: rv });
            setStatus('Rules updated (poll).');
          }
        } catch (e) {
          console.warn('[Extractor][Watchdog] tick failed', e);
        }
      }

      setInterval(tick, 1500);
      console.log('[Extractor][Watchdog] installed');
    })();



    // --- schema indexers / normalizers for rules ---
    function adoptHeadingBaseline(baseline) {
      const flat = baseline?.flat
        ? Array.isArray(baseline.flat) ? baseline.flat.slice() : []
        : Array.isArray(baseline) ? baseline.slice()
        : Array.isArray(baseline?.headings) ? baseline.headings.slice()
        : [];
      const tree = baseline?.tree
        ? (Array.isArray(baseline.tree) ? baseline.tree.slice() : [])
        : Array.isArray(baseline?.headingsTree) ? baseline.headingsTree.slice()
        : [];
      gHeadingBaseline = { flat, tree };
    }

    // Build: fieldId -> { id, label, type, options: [{value,label,slug}] }
    /**
     * Normalize FIELD rules ONLY (preserve option targets). Accepts targets as:
     *  - { id: "<fieldId>", optionValue, optionLabel, label? }
     *  - "fieldId" (parent field target)
     *  - "fieldId__opt__slug"
     *  - "Field Label: Option Label" (the UIâ€™s combined string)
     *  - { id: "fieldId", label: "Field Label: Option Label" } (legacy)
     */

    function normalizeForSchema(schema, values, tagMap) {
      const fieldIds = new Set((schema?.fields || []).map(f => String(f.id)));
      const prunedValues = {};
      for (const [k, v] of Object.entries(values || {})) {
        if (fieldIds.has(String(k))) prunedValues[k] = v;
      }
      const prunedTagMap = {};
      for (const [tag, fieldId] of Object.entries(tagMap || {})) {
        if (fieldIds.has(String(fieldId))) prunedTagMap[tag] = fieldId;
      }
      return { values: prunedValues, tagMap: prunedTagMap };
    }

    async function getTagMapFor(docId) {
      try {
        const state = docId ? (await window.formSuitePersist.loadState(docId)) : null;
        const tagMap = (state?.payload?.CRONOS_PAYLOAD?.tagMap)
                    || (state?.CRONOS_PAYLOAD?.tagMap)
                    || (state?.cronos_payload?.tagMap)
                    || (state?.tagMap)
                    || {};
        return tagMap;
      } catch {
        return {};
      }
    }

    function loadSchemaFromLocalStorage() {
      const tr = TRACE('loadSchemaFromLocalStorage');
      try { const s = JSON.parse(localStorage.getItem(STORAGE_KEY) || 'null'); tr.end({ has:s?.fields?.length }); return s; }
      catch (e) { tr.error('parse fail', e); tr.end(); return null; }
    }

    // Collect values from the live form (address values are structured)
    function collectFormValues(schema) {
      const form = document.getElementById('liveForm');
      const out = {};
      if (!form || !schema) return out;
      for (const f of (schema.fields || [])) {
        if (f.type === 'multichoice') {
          const nodes = form.querySelectorAll(`input[type="checkbox"][name="${CSS.escape(f.id)}"]`);
          out[f.id] = Array.from(nodes).filter(n => n.checked).map(n => n.value);
          continue;
        }
        if (f.type === 'address') {
          out[f.id] = __addressValues[f.id] ?? null;
          continue;
        }
        const el = form.elements[f.id];
        out[f.id] = el ? el.value : null;
      }
      return out;
    }
    // =========================
    // (REPLACE) updatePreview(values)
    // =========================
    async function updatePreview(values) {
      const tr = TRACE('updatePreview');
      try {
        if (!payloadEl) return;

        const wsState = gDocId ? (await window.formSuitePersist.loadState(gDocId)) : null;
        if (wsState) {
          adoptHeadingBaseline({
            flat: Array.isArray(wsState.headingsFlat) ? wsState.headingsFlat : Array.isArray(wsState.headings) ? wsState.headings : [],
            tree: Array.isArray(wsState.headingsTree) ? wsState.headingsTree : gHeadingBaseline.tree
          });
        }
        const payloadObj = wsState?.payload?.CRONOS_PAYLOAD
                        || wsState?.CRONOS_PAYLOAD
                        || wsState?.cronos_payload
                        || {};

        const { rules: mergedRulesRaw, fieldRules: mergedFieldRaw, source: ruleSourceMeta } =
          resolveRulesForState(wsState || {}, payloadObj);

        await debugLogExtractor('updatePreview:merge', {
          function: 'updatePreview',
          chosenRulesSource: ruleSourceMeta.rules,
          chosenFieldRulesSource: ruleSourceMeta.fieldRules,
          contributingRulesSources: ruleSourceMeta.contributingRules,
          contributingFieldRulesSources: ruleSourceMeta.contributingFieldRules,
          wsRules: normalizeRuleCollection(wsState?.rules).length,
          plRules: normalizeRuleCollection(payloadObj?.rules).length,
          wsFieldRules: normalizeRuleCollection(wsState?.fieldRules).length,
          plFieldRules: normalizeRuleCollection(payloadObj?.fieldRules).length
        });

        // Normalize against **current** gSchema (already set by renderFromCurrentBytes)
        const rules      = normalizeHeadingsRulesForSchema(gSchema, mergedRulesRaw, gHeadingBaseline);
        const fieldRules = normalizeFieldRulesForSchema(gSchema, mergedFieldRaw);

        // Instrument target survival for fieldRules
        console.log('[FieldRules][targets]', fieldRules.map(r => ({
          id: r.id, action: r.action, when: r.fieldId, op: r.op, values: r.values,
          targetsCount: Array.isArray(r.targets) ? r.targets.length : 0,
          sampleTarget: Array.isArray(r.targets) ? r.targets[0] : null
        })));

        const tagMapRaw = await getTagMapFor(gDocId);
        const { values: prunedValues, tagMap: prunedTagMap } =
          normalizeForSchema(gSchema, values || {}, tagMapRaw);

        const previewObj = {
          title:  gSchema?.title || 'Form',
          fields: gSchema?.fields || [],
          values: prunedValues,
          tagMap: prunedTagMap,
          rules,
          fieldRules
        };
        payloadEl.value = JSON.stringify(previewObj, null, 2);

        await debugLogExtractor('updatePreview:previewBuilt', {
          function:'updatePreview',
          previewLen: (payloadEl?.value || '').length
        });
      } finally {
        tr.end();
      }
    }


    let previewTimer = null;
    function schedulePreviewUpdate() {
      clearTimeout(previewTimer);
      previewTimer = setTimeout(async () => {
        const vals = collectFormValues(gSchema);
        if (gDocId) await window.formSuitePersist.saveState(gDocId, { schema: gSchema, values: vals });
        await updatePreview(vals);
        gDirty = true;
        setStatus('Unsaved changes â€” press Save to update DOCX.');
      }, 250);
    }

    function buildForm(container, schema, values) {
      const tr = TRACE('buildForm', { fields: schema?.fields?.length || 0 });
      try {
        container.innerHTML = '';
        if (!schema || !Array.isArray(schema.fields) || schema.fields.length === 0) {
          container.innerHTML = '<div class="empty">No manual schema. Create one in the Builder, or load a DOCX that already contains a payload schema.</div>';
          tr.end('empty schema');
          return;
        }

        const form = document.createElement('form');
        form.id = 'liveForm';
        form.noValidate = true;
        form.style.display = 'grid';
        form.style.gap = '12px';

        if (schema.title) {
          const h = document.createElement('h4');
          h.textContent = schema.title;
          h.style.margin = '0 0 6px';
          form.appendChild(h);
        }

        for (const f of schema.fields) {
          const w = TRACE('buildForm:field', f);
          const wrap = document.createElement('div');
          wrap.className = 'field';
          const label = document.createElement('label');
          label.htmlFor = f.id;
          label.textContent = f.label || f.id || '(field)';
          label.style.display = 'flex';
          label.style.justifyContent = 'space-between';
          label.style.alignItems = 'center';
          if (f.required) {
            const star = document.createElement('span');
            star.textContent = 'â€¢'; star.title = 'required'; star.style.fontWeight = '600'; star.style.color = '#ef4444';
            label.appendChild(star);
          }
          wrap.appendChild(label);

          let input;

          if (f.type === 'multichoice') {
            const box = document.createElement('div');
            box.style.display = 'grid'; box.style.gap = '6px';
            (f.options || []).forEach(opt => {
              const id = `${f.id}__${String(opt?.value ?? opt).replace(/\s+/g,'_')}`;
              const row = document.createElement('label');
              row.style.display = 'flex'; row.style.gap = '8px'; row.style.alignItems = 'center';
              const cb = document.createElement('input');
              cb.type = 'checkbox'; cb.name = f.id; cb.id = id; cb.value = String(opt?.value ?? opt);
              if (Array.isArray(values?.[f.id]) && values[f.id].includes(cb.value)) cb.checked = true;
              const span = document.createElement('span'); span.textContent = String(opt?.label ?? opt?.text ?? opt?.value ?? opt);
              row.appendChild(cb); row.appendChild(span); box.appendChild(row);
            });
            wrap.appendChild(box);
            box.addEventListener('change', schedulePreviewUpdate);
            form.appendChild(wrap);
            w.end();
            continue;

          } else if (f.type === 'select') {
            input = document.createElement('select');
            (f.options || []).forEach(opt => {
              const o = document.createElement('option');
              o.value = String(opt?.value ?? opt?.id ?? opt);
              o.textContent = String(opt?.label ?? opt?.text ?? opt?.value ?? opt);
              input.appendChild(o);
            });

          } else if (f.type === 'date') {
            input = document.createElement('input'); input.type = 'text'; input.dataset.type = 'date'; input.dataset.format = f.dateFormat || 'Y-m-d';

          } else if (f.type === 'address') {
            const mountDiv = document.createElement('div');
            mountDiv.className = 'address-field';
            wrap.appendChild(mountDiv);

            const initial =
              typeof values?.[f.id] === 'string'
                ? { formatted: values[f.id] }
                : (values?.[f.id] || null);

            __addressValues[f.id] = initial || null;

            try {
              AddressAuto.mount(mountDiv, {
                id: f.id,
                label: f.label || 'Address',
                required: !!f.required,
                value: initial || null,
                onChange: (val) => { __addressValues[f.id] = val; schedulePreviewUpdate(); }
              });
            } catch (err) {
              const fallback = document.createElement('input');
              fallback.type = 'text';
              fallback.id = f.id;
              fallback.name = f.id;
              fallback.placeholder = 'Address';
              if (initial?.formatted) fallback.value = initial.formatted;
              fallback.addEventListener('input', () => {
                __addressValues[f.id] = { formatted: fallback.value };
                schedulePreviewUpdate();
              });
              mountDiv.appendChild(fallback);
            }

            form.appendChild(wrap);
            w.end();
            continue;

          } else {
            input = document.createElement('input'); input.type = 'text';
          }

          input.id = f.id; input.name = f.id;
          if (f.required) input.required = true;
          if (values && values[f.id] != null) input.value = values[f.id];

          input.addEventListener('change', schedulePreviewUpdate);
          input.addEventListener('input', schedulePreviewUpdate);
          wrap.appendChild(input);

          if (f.type === 'date') {
            setTimeout(() => {
              const tt = TRACE('flatpickr:init', { id: input.id, format: input.dataset.format });
              try {
                if (window.flatpickr) {
                  window.flatpickr(input, {
                    dateFormat: input.dataset.format || 'Y-m-d',
                    allowInput: true,
                    onChange: schedulePreviewUpdate,
                    onValueUpdate: schedulePreviewUpdate
                  });
                }
              } finally { tt.end(); }
            }, 0);
          }

          form.appendChild(wrap);
          w.end();
        }

        container.appendChild(form);
        tr.end('form built');
      } catch (e) { tr.error('failed', e); tr.end(); }
    }

    // =========================
    // SDT PARSING (JS)
    // =========================
    const W_NS = "http://schemas.openxmlformats.org/wordprocessingml/2006/main";
    function xmlText(el) {
      let s = '';
      const rec = n => {
        if (!n) return;
        if (n.nodeType === 3) { s += n.nodeValue; return; }
        if (n.nodeType === 1) {
          const ln = n.localName;
          if (ln === 'p' || ln === 'cr' || ln === 'br') s += '\n';
          for (const ch of n.childNodes) rec(ch);
        }
      };
      rec(el);
      return s.replace(/\s+\n/g,'\n').replace(/\n{3,}/g,'\n\n').trim();
    }

    async function parseSDTs_JS(arrayBuffer) {
      const tr = TRACE('parseSDTs_JS', { hasBuffer: !!arrayBuffer, len: arrayBuffer?.byteLength });
      try {
        if (!arrayBuffer) return { sdts: [], scan: [], total: 0 };
        const zip = await JSZip.loadAsync(arrayBuffer);
        const parts = zip.file(/^word\/(?!_rels\/|theme\/|fontTable\.xml|styles\.xml|numbering\.xml|settings\.xml|webSettings\.xml).*\.xml$/i) || [];
        tr.step('parts', parts.map(p => p.name));
        const parser = new DOMParser();
        const sdts = [];
        const scan = [];
        for (const f of parts) {
          const pf = TRACE('parseSDTs_JS:file', f.name);
          const xmlTextContent = await f.async('string');
          let err = null, countBefore = sdts.length;
          try {
            const xml = parser.parseFromString(xmlTextContent, "application/xml");
            const found = Array.from(xml.getElementsByTagNameNS(W_NS, 'sdt'));
            for (const sdt of found) {
              const pr = sdt.getElementsByTagNameNS(W_NS, 'sdtPr')[0];
              const content = sdt.getElementsByTagNameNS(W_NS, 'sdtContent')[0] || sdt;
              let tag = '', alias = '';
              if (pr) {
                const tEl = pr.getElementsByTagNameNS(W_NS, 'tag')[0];
                if (tEl) tag = tEl.getAttributeNS(W_NS, 'val') || tEl.getAttribute('w:val') || '';
                const aEl = pr.getElementsByTagNameNS(W_NS, 'alias')[0];
                if (aEl) alias = aEl.getAttributeNS(W_NS, 'val') || aEl.getAttribute('w:val') || '';
              }
              sdts.push({ part: f.name.split('/').pop().replace('.xml',''), tag, alias, text: xmlText(content) });
            }
          } catch (e) { err = e?.message || String(e); pf.warn('xml parse error', e); }
          scan.push({ path: f.name, part: f.name.split('/').pop().replace('.xml',''), size: xmlTextContent.length, sdt_count: sdts.length - countBefore, error: err });
          pf.end({ added: sdts.length - countBefore, error: err });
        }
        tr.end({ total: sdts.length, scanned: scan.length });
        return { sdts, scan, total: sdts.length };
      } catch (e) { tr.error('failed', e); tr.end(); return { sdts: [], scan: [], total: 0 }; }
    }

    // =========================
    // PYODIDE (payload/SDT writes)
    // =========================
    // ---------- Helpers: sanitize ----------
    function sanitizeTagMap(tagMap, validIds) {
      const out = {};
      for (const [tag, fid] of Object.entries(tagMap || {})) {
        if (validIds.has(fid)) out[tag] = fid;
      }
      return out;
    }
    // =========================
    // (REPLACE) renderFromCurrentBytes(prefix = '')
    // =========================
    async function renderFromCurrentBytes(prefix = '') {
      const tr = TRACE('renderFromCurrentBytes', { prefix });
      try {
        setStatus((prefix || '') + 'Parsingâ€¦');

        // 1) SDTs
        const parsed = await parseSDTs_JS(gArrayBuffer);
        gSDTs = parsed.sdts || [];
        renderSDTsView(parsed);

        // 2) Headings (best-effort)
        let headingsParsed = { flat: [], tree: [], count: 0 };
        try {
          headingsParsed = await parseHeadings_JS(gArrayBuffer);
          renderHeadingsTreeView(headingsParsed.tree);
          adoptHeadingBaseline(headingsParsed);
        } catch {
          if (headersTreeEl) headersTreeEl.innerHTML = '<div class="empty">No headings.</div>';
          adoptHeadingBaseline({ flat: [], tree: [] });
        }

        // 3) Payload from DOCX (settings/custom)
        let payloadRaw = await readDocVarSettings(gArrayBuffer, PAYLOAD_KEY);
        if (payloadRaw == null) payloadRaw = await readDocVarCustom(gArrayBuffer, PAYLOAD_KEY);
        let payload = null; try { payload = payloadRaw ? JSON.parse(payloadRaw) : null; } catch { payload = null; }

        const wsState = await window.formSuitePersist.loadState(gDocId);

        // Choose schema: newer wins (workspace vs payload)
        const asTs = (x)=> { const t = Date.parse(x || ''); return Number.isFinite(t) ? t : 0; };
        const pHasSchema = Array.isArray(payload?.fields) && payload.fields.length > 0;
        const pUpdatedTs = asTs(payload?.updatedAt);
        const wsSchemaTs = asTs(wsState?.schemaUpdatedAt);

        const chosenSchema =
          (wsState?.schema && (wsSchemaTs >= pUpdatedTs || !pHasSchema)) ? wsState.schema
          : pHasSchema ? { title: payload.title || 'Form', fields: payload.fields }
          : (loadSchemaFromLocalStorage() || { title: 'Form', fields: [] });

        // Merge values/tagMap (workspace overrides payload)
        const mergedValues = Object.assign({}, payload?.values || {}, wsState?.values || {});
        const mergedTagMap = Object.assign({}, payload?.tagMap || {}, wsState?.tagMap || {});

        // ---------- RULES: prefer workspace arrays if they exist; else fall back to payload ----------
        const { rules: mergedRulesRaw, fieldRules: mergedFieldRaw, source: ruleSourceMeta } =
          resolveRulesForState(wsState || {}, payload || {});

        // ðŸ”Ž DEBUG pre-normalization
        console.log('[Rules][pre-normalize]', {
          src: { rules: ruleSourceMeta.rules, fieldRules: ruleSourceMeta.fieldRules },
          counts: { rules: (mergedRulesRaw||[]).length, fieldRules: (mergedFieldRaw||[]).length },
          contributing: ruleSourceMeta
        });

        // âœ… Normalize EVERYTHING against the **chosen** schema (NOT gSchema yet!)
        const rules      = normalizeHeadingsRulesForSchema(chosenSchema, mergedRulesRaw, headingsParsed);
        const fieldRules = normalizeFieldRulesForSchema(chosenSchema, mergedFieldRaw);

        // ðŸ”Ž DEBUG post-normalization
        console.log('[Rules][post-normalize]', {
          rulesCount: rules.length,
          fieldRulesCount: fieldRules.length,
          sampleRule: rules[0],
          sampleFieldRule: fieldRules[0]
        });

        const { values: prunedValues, tagMap: prunedTagMap } =
          normalizeForSchema(chosenSchema, mergedValues, mergedTagMap);

        // Adopt & persist mirrors so Save/Export see the same view
        gSchema = chosenSchema;
        gValues = prunedValues;

        if (gDocId) {
          const canonical = {
            title: gSchema.title,
            fields: gSchema.fields,
            values: gValues,
            tagMap: prunedTagMap,
            rules,
            fieldRules,
            headingsFlat: headingsParsed.flat,
            headingsTree: headingsParsed.tree,
            updatedAt: new Date().toISOString()
          };
          await window.formSuitePersist.saveState(gDocId, {
            schema: gSchema,
            values: gValues,
            tagMap: prunedTagMap,
            rules, fieldRules,
            headingsFlat: headingsParsed.flat,
            headings: headingsParsed.flat,
            headingsTree: headingsParsed.tree,
            headingsUpdatedAt: new Date().toISOString(),
            payload: { CRONOS_PAYLOAD: canonical },
            CRONOS_PAYLOAD: canonical,
            cronos_payload: canonical,
            schemaUpdatedAt: new Date().toISOString()
          });
        }

        buildForm(document.getElementById('formMount'), gSchema, gValues);
        await updatePreview(gValues);
        setStatus('Ready.');
      } catch (e) {
        tr.error('failed', e);
        setStatus('Error while parsing. See console.');
      } finally {
        tr.end();
      }
    }


    function renderSDTsView(parsed) {
      const tr = TRACE('renderSDTsView', { total: parsed?.total, rows: parsed?.sdts?.length });
      try {
        tableBody.innerHTML = '';
        const sdts = parsed?.sdts || [];
        if (!sdts.length) {
          const trEl = document.createElement('tr');
          const td = document.createElement('td');
          td.colSpan = 5;
          td.textContent = 'No SDTs found in this document.';
          trEl.appendChild(td);
          tableBody.appendChild(trEl);
        } else {
          sdts.forEach((row, i) => {
            const trEl = document.createElement('tr');
            const tdIdx = document.createElement('td'); tdIdx.textContent = String(i + 1); trEl.appendChild(tdIdx);
            const tdPart = document.createElement('td'); tdPart.textContent = row.part || ''; trEl.appendChild(tdPart);
            const tdTag = document.createElement('td'); tdTag.textContent = row.tag || ''; trEl.appendChild(tdTag);
            const tdAlias = document.createElement('td'); tdAlias.textContent = row.alias || ''; trEl.appendChild(tdAlias);
            const tdText = document.createElement('td'); tdText.textContent = row.text || ''; trEl.appendChild(tdText);
            tableBody.appendChild(trEl);
          });
        }
      } finally { tr.end(); }
    }

    // =========================
    // BOOT (auto-restore)
    // =========================
    (async function boot() {
      const tr = TRACE('boot');
      try {
        let meta = window.readActiveDocSync?.();
        tr.step('readActiveDocSync', meta);
        if (!meta?.docId) { meta = window.formSuitePersist?.getCurrentDocMeta?.(); tr.step('getCurrentDocMeta', meta); }
        if (!meta?.docId) { tr.end('no meta; idle'); return; }

        clearUiForNewDoc('Restoring documentâ€¦');
        installRulesUpdatedListener();
        let bytes = await window.formSuitePersist.getBytes?.(meta.docId)
                || await window.formSuitePersist.getCurrentDocBytes?.();
        tr.step('persistence bytes', { len: bytes?.byteLength || bytes?.length });

        if (!bytes && supportsFS) {
          try {
            const h = await window.formSuitePersist.getHandle?.(meta.docId);
            tr.step('getHandle (2nd chance)', { has: !!h });
            if (h?.getFile) {
              try { await window.formSuitePersist.ensurePermission?.(h, 'read'); } catch {}
              const f = await h.getFile();
              bytes = new Uint8Array(await f.arrayBuffer());
              gFileHandle = h;
              if (!gFileName) {
                const { base, ext } = splitNameAndExt(f.name || meta.name || 'document.docx');
                gFileName = base || 'document';
                gFileExt  = ext || 'docx';
              }
              tr.step('2nd chance handle.getFile ok', { size: bytes.byteLength });
            }
          } catch (e) {
            tr.warn('2nd chance via handle failed', e);
          }
        }
        if (!bytes && supportsFS) {
          try {
            const h = await window.formSuitePersist.getHandle?.(meta.docId);
            tr.step('getHandle', { has: !!h });
            if (h) {
              try { await window.formSuitePersist.ensurePermission?.(h, 'read'); } catch (e) { tr.warn('ensurePermission failed', e); }
              const f = await h.getFile();
              bytes = new Uint8Array(await f.arrayBuffer());
              gFileHandle = h;
              const { base, ext } = splitNameAndExt(f.name || meta.name || 'document.docx');
              gFileName = base || 'document';
              gFileExt  = ext || 'docx';
              tr.step('handle.getFile ok', { name: `${gFileName}.${gFileExt}`, len: bytes.byteLength });
            }
          } catch (e) { tr.warn('handle path failed', e); }
        }

        if (!bytes) { await hardResetDocContext('no bytes / no permission'); tr.end('no bytes'); return; }

        gArrayBuffer = bytes.buffer ?? bytes;

        if (!gFileName) {
          const { base, ext } = splitNameAndExt(meta.name || 'document.docx');
          gFileName = base || 'document';
          gFileExt  = ext || 'docx';
        }
        gDocId = meta.docId;

        tr.step('restored', { docId: gDocId, name: `${gFileName}.${gFileExt}`, len: gArrayBuffer?.byteLength, sha: await sha256Hex(gArrayBuffer) });

        await renderFromCurrentBytes();
        await updateWriteAccessBanner();

        btnSave.disabled = false; btnExport.disabled = false;
        if (btnSaveFromPreview) btnSaveFromPreview.disabled = false;
      } catch (e) { tr.error('boot failed', e); }
      finally { tr.end(); }
    })();

    // =========================
    // PERSIST WRAPPER
    // =========================
    async function persistCurrentDoc(bytesU8, handle, nameNoExt, ext = 'docx') {
      const tr = TRACE('persistCurrentDoc', { hasBytes: !!bytesU8, handle: !!handle, nameNoExt, ext });
      try {
        if (!bytesU8) throw new Error('persistCurrentDoc requires bytes');
        const safeExt = (ext || 'docx').toLowerCase();
        const name    = `${(nameNoExt || 'document').replace(/\.(docx|docm|dotx|dotm)$/i,'')}.${safeExt}`;

        // Always content-address via persistence.js
        if (window.formSuitePersist?.setCurrentDoc) {
          const meta = await window.formSuitePersist.setCurrentDoc({ bytes: bytesU8, handle, name });
          tr.end(meta); return meta;
        }
        if (window.formSuitePersist?.setCurrentDocFromBytes) {
          const meta = await window.formSuitePersist.setCurrentDocFromBytes(bytesU8, { name, handle });
          tr.end(meta); return meta;
        }

        // Last-ditch fallback (shouldnâ€™t normally hit)
        const meta = { docId: 'inline-' + Date.now(), name };
        tr.end(meta); return meta;
      } catch (e) { tr.error('failed', e); tr.end(); throw e; }
    }


    // ---------- Rules â†’ Visibility map (SHOW supersedes HIDE) ----------
    function loadRulesForDoc(state) {
      return (
        state?.rules ||
        state?.payload?.rules ||
        state?.CRONOS_RULES ||
        state?.cronos_rules ||
        []
      );
    }

    // =========================
    // FILE OPEN / SAVE / EXPORT
    // =========================
    async function doOpen() {
      const tr = TRACE('doOpen');
      try {
        clearUiForNewDoc('Openingâ€¦');

        // 1) Let the user pick a DOCX (File System Access API)
        const [handle] = await showOpenFilePicker({
          multiple: false,
          excludeAcceptAllOption: true,
          types: [{
            description: 'Word document',
            accept: { 'application/vnd.openxmlformats-officedocument.wordprocessingml.document': ['.docx', '.docm'] }
          }]
        });

        // 2) Read bytes and compute content-addressed docId via persistence.js
        const file  = await handle.getFile();
        const bytes = new Uint8Array(await file.arrayBuffer());
        const { base, ext } = splitNameAndExt(file.name || 'document.docx');
        gFileHandle = handle;
        gFileName   = base || 'document';
        gFileExt    = ext  || '.docx';

        // IMPORTANT: this call computes docId = "<basename>#<sha256:12>" from BYTES
        const metaObj = await window.formSuitePersist.setCurrentDoc({
          bytes,
          handle,
          name: `${gFileName}${gFileExt}`
        });

        // 3) Switch local context to the NEW docId (even if filename is identical)
        gDocId       = metaObj.docId;
        gArrayBuffer = bytes.buffer;

        // Centralized active-doc update (fs-active-doc.js)
        window.setActiveDocMeta?.(metaObj);

        // 4) Re-render and refresh permission banner
        await renderFromCurrentBytes();
        await updateWriteAccessBanner({ tryPrompt: true });

        // 5) Enable actions
        btnSave.disabled = false;
        btnExport.disabled = false;
        if (btnSaveFromPreview) btnSaveFromPreview.disabled = false;

        tr.step('opened', { name: `${gFileName}${gFileExt}`, size: bytes.byteLength, docId: gDocId });
      } catch (e) {
        if (e?.name === 'AbortError') { tr.step('user canceled'); return; }
        tr.error('open failed', e);
        setStatus(`Error opening file: ${e.message || e}`);
      } finally { tr.end(); }
    }


    async function ensureWritePermission(handle) {
      const tr = TRACE('ensureWritePermission', { haveHandle: !!handle });
      try {
        if (!handle?.requestPermission) return 'denied';
        let p = await handle.queryPermission?.({ mode: 'readwrite' });
        tr.step('queryPermission', p);
        if (p === 'granted') return 'granted';
        const r = await handle.requestPermission?.({ mode: 'readwrite' });
        tr.end({ requestPermission: r });
        return r || 'denied';
      } catch (e) { tr.error('perm failed', e); tr.end(); return 'denied'; }
    }

    async function doSave() {
      const tr = TRACE('doSave');
      try {
        if (!gArrayBuffer) return;

        const restored = gDocId ? (await window.formSuitePersist.loadState(gDocId)) : null;
        if (restored) {
          adoptHeadingBaseline({
            flat: Array.isArray(restored.headingsFlat) ? restored.headingsFlat : Array.isArray(restored.headings) ? restored.headings : [],
            tree: Array.isArray(restored.headingsTree) ? restored.headingsTree : gHeadingBaseline.tree
          });
        }
        if (restored?.schema) gSchema = restored.schema;

        const domVals  = collectFormValues(gSchema);
        const baseVals = (restored && restored.values) ? restored.values : {};
        const tagMapRaw = restored?.tagMap || await getTagMapFor(gDocId);

        const payloadSnapshot = restored?.payload?.CRONOS_PAYLOAD
                              || restored?.CRONOS_PAYLOAD
                              || restored?.cronos_payload
                              || {};

        const { rules: mergedRulesRaw, fieldRules: mergedFieldRaw, source: ruleSourceMeta } =
          resolveRulesForState(restored || {}, payloadSnapshot);

        const rules      = normalizeHeadingsRulesForSchema(gSchema, mergedRulesRaw, gHeadingBaseline);
        const fieldRules = normalizeFieldRulesForSchema(gSchema, mergedFieldRaw);

        console.log('[doSave][rulesSource]', {
          source: ruleSourceMeta,
          wsRules: normalizeRuleCollection(restored?.rules).length,
          plRules: normalizeRuleCollection(payloadSnapshot?.rules).length
        });

        console.log('[doSave][normalized]', {
          rules: rules.length,
          fieldRules: fieldRules.length,
          source: ruleSourceMeta,
          wsRules: normalizeRuleCollection(restored?.rules).length,
          plRules: normalizeRuleCollection(payloadSnapshot?.rules).length
        });

        const { values: prunedValues, tagMap: prunedTagMap } =
          normalizeForSchema(gSchema, { ...baseVals, ...domVals }, tagMapRaw);

        gValues = prunedValues;
        await updatePreview(gValues);

        const payloadObj = {
          title:  gSchema.title || 'Form',
          fields: gSchema.fields || [],
          values: gValues || {},
          tagMap: prunedTagMap,
          rules,
          fieldRules,
          updatedAt: new Date().toISOString()
        };

        setStatus('Writing payload to DOCXâ€¦');
        const updated = await writeDocVarSettings(gArrayBuffer, PAYLOAD_KEY, JSON.stringify(payloadObj));
        const updatedU8 = (updated instanceof Uint8Array) ? updated : new Uint8Array(updated);
        gArrayBuffer = updatedU8.slice().buffer;

        if (gDocId) {
          const stamp = Date.now();
          await window.formSuitePersist.saveState(gDocId, {
            schema: gSchema,
            values: gValues,
            rules,
            fieldRules,
            tagMap: prunedTagMap,
            payload: { CRONOS_PAYLOAD: payloadObj },
            CRONOS_PAYLOAD: payloadObj,
            cronos_payload: payloadObj,
            rulesVersion: stamp,
            schemaUpdatedAt: new Date().toISOString()
          });
          await window.formSuitePersist.putBytes(gDocId, updatedU8);
        }

        const metaObj = await persistCurrentDoc(updatedU8, gFileHandle, gFileName, gFileExt);
        gDocId = metaObj.docId;

        // keep active-doc meta in sync across tabs
        window.setActiveDocMeta?.(metaObj);
        window.notifyActiveDocUpdated?.(metaObj);

        if (window.showSaveFilePicker && gFileHandle) {
          const p = await ensureWritePermission(gFileHandle, 'readwrite');
          if (p === 'granted') {
            const stream = await gFileHandle.createWritable();
            await stream.write(updatedU8);
            await stream.close();
            setStatus('Saved.');
            gDirty = false;
            return;
          }
        }
        setStatus('Saved in workspace (file write not available).');
        gDirty = false;
      } catch (e) {
        tr.error('failed', e);
        setStatus('Save failed.');
      } finally {
        tr.end();
      }
    }

    async function doExport() {
      const tr = TRACE('doExport');
      try {
        if (!gArrayBuffer) {
          alert('No DOCX loaded.');
          return;
        }
        if (!gSchema) {
          alert('No schema available â€” parse or hydrate first.');
          return;
        }

        setStatus('Preparing exportâ€¦');
        const PAYLOAD_KEY = 'CRONOS_PAYLOAD';
        const originalBytes = new Uint8Array(gArrayBuffer);

        const restored = gDocId ? (await window.formSuitePersist.loadState(gDocId)) : null;

        // Make sure we have the latest headings baseline and schema
        if (restored) {
          adoptHeadingBaseline({
            flat: Array.isArray(restored.headingsFlat)
              ? restored.headingsFlat
              : Array.isArray(restored.headings)
                ? restored.headings
                : [],
            tree: Array.isArray(restored.headingsTree)
              ? restored.headingsTree
              : gHeadingBaseline.tree
          });
        }
        if (restored?.schema) {
          gSchema = restored.schema;
        }

        const domVals  = collectFormValues(gSchema);
        const baseVals = (restored && restored.values) ? restored.values : {};
        const tagMapRaw = restored?.tagMap || await getTagMapFor(gDocId);

        const payloadSnapshot = restored?.payload?.CRONOS_PAYLOAD
                              || restored?.CRONOS_PAYLOAD
                              || restored?.cronos_payload
                              || {};

        const { rules: mergedRulesRaw, fieldRules: mergedFieldRaw, source: ruleSourceMeta } =
          resolveRulesForState(restored || {}, payloadSnapshot);

        const rules      = normalizeHeadingsRulesForSchema(gSchema, mergedRulesRaw, gHeadingBaseline);
        const fieldRules = normalizeFieldRulesForSchema(gSchema, mergedFieldRaw);

        console.log('[doExport][rulesSource]', {
          source: ruleSourceMeta,
          wsRules: normalizeRuleCollection(restored?.rules).length,
          plRules: normalizeRuleCollection(payloadSnapshot?.rules).length
        });

        console.log('[doExport][normalized]', {
          rules: rules.length,
          fieldRules: fieldRules.length,
          source: ruleSourceMeta
        });

        const { values: prunedValues, tagMap: prunedTagMap } =
          normalizeForSchema(gSchema, { baseVals, domVals }, tagMapRaw);

        gValues = prunedValues;
        await updatePreview(gValues);

        const baseline = gHeadingBaseline && (gHeadingBaseline.flat || gHeadingBaseline.tree)
          ? gHeadingBaseline
          : { flat: [], tree: [] };

        setStatus('Writing payload & applying rulesâ€¦');

        const { updatedBytes, payload, visibilityMap } =
          await window.fsExportCore.buildDoc({
            originalBytes,
            schema: gSchema,
            values: gValues,
            tagMap: prunedTagMap,
            rules,
            fieldRules,
            headingBaseline: baseline,
            payloadKey: PAYLOAD_KEY,
            writerKind: 'settings',               // extractor previously wrote into settings
            debugLabel: 'extractor.doExport',
            buildHeadingResolver: async () => {
              // extractor: we rely on the baseline-driven index
              return buildHeadingTargetIndex(baseline);
            }
          });

        const updatedU8 = updatedBytes;
        gArrayBuffer = updatedU8.slice().buffer;

        // Persist canonical state back into workspace
        if (gDocId) {
          const stamp = Date.now();
          await window.formSuitePersist.saveState(gDocId, {
            schema: gSchema,
            values: gValues,
            rules,
            fieldRules,
            tagMap: prunedTagMap,
            payload: { CRONOS_PAYLOAD: payload },
            CRONOS_PAYLOAD: payload,
            cronos_payload: payload,
            rulesVersion: stamp,
            headingsFlat: baseline.flat || [],
            headings: baseline.flat || [],
            headingsTree: baseline.tree || [],
            headingsUpdatedAt: new Date().toISOString(),
            schemaUpdatedAt: new Date().toISOString()
          });
          await window.formSuitePersist.putBytes(gDocId, updatedU8);
        }

        // Persist to the underlying file handle (if we have one)
        const metaObj = await persistCurrentDoc(updatedU8, gFileHandle, gFileName, gFileExt);
        gDocId = metaObj.docId;
        persistActiveMeta(metaObj);
        announceDocUpdate();

        // Offer final export as separate file (same behavior as before)
        const outName = (gFileName || 'document').replace(/\.docx$/i, '') + ' (export).docx';

        if (window.showSaveFilePicker) {
          try {
            const handle = await window.showSaveFilePicker({
              suggestedName: outName,
              types: [{
                description: 'Word Document',
                accept: { 'application/vnd.openxmlformats-officedocument.wordprocessingml.document': ['.docx'] }
              }]
            });
            const stream = await handle.createWritable();
            await stream.write(updatedU8);
            await stream.close();
            setStatus('Exported & saved.');
            return;
          } catch (e) {
            console.warn('SaveFilePicker canceled/failed; falling back to download link.', e);
          }
        }

        // Fallback: classic download
        const blob = new Blob([updatedU8], {
          type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = outName;
        document.body.appendChild(a);
        a.click();
        setTimeout(() => {
          URL.revokeObjectURL(url);
          a.remove();
        }, 5000);

        setStatus('Exported (download started).');
      } catch (e) {
        tr.error('failed', e);
        console.error(e);
        setStatus('Export failed â€” see console for details.');
      } finally {
        tr.end();
      }
    }


    // =========================
    // PAYLOAD PREVIEW (editable)
    // =========================
    let __payloadApplyTimer = null;
    let __payloadEditBusy = false;

    async function applyPayloadObject(obj, { broadcast = true, save = true } = {}) {
      const tr = TRACE('applyPayloadObject');
      try {
        if (!obj || typeof obj !== 'object') return;

        const nextSchema = { title: obj.title || 'Form', fields: Array.isArray(obj.fields) ? obj.fields : [] };
        const rawValues  = (obj.values && typeof obj.values === 'object') ? obj.values : {};
        const rawTagMap  = (obj.tagMap && typeof obj.tagMap === 'object') ? obj.tagMap : {};

        const rawRules   = Array.isArray(obj.rules) ? obj.rules : [];
        const rawFieldR  = Array.isArray(obj.fieldRules) ? obj.fieldRules : [];

        const rules      = normalizeHeadingsRulesForSchema(nextSchema, rawRules, gHeadingBaseline);
        const fieldRules = normalizeFieldRulesForSchema(nextSchema, rawFieldR);

        console.log('[applyPayloadObject][normalized]', {
          rules: rules.length,
          fieldRules: fieldRules.length,
          sampleFR: fieldRules[0]
        });

        const { values: prunedValues, tagMap: prunedTagMap } =
          normalizeForSchema(nextSchema, rawValues, rawTagMap);

        gSchema = nextSchema;
        gValues = prunedValues;

        const payloadObj = {
          title: gSchema.title,
          fields: gSchema.fields,
          values: gValues,
          tagMap: prunedTagMap,
          rules,
          fieldRules,
          updatedAt: new Date().toISOString()
        };

        if (gDocId && save) {
          await window.formSuitePersist.saveState(gDocId, {
            schema: gSchema,
            values: gValues,
            tagMap: prunedTagMap,
            rules, fieldRules,
            payload: { CRONOS_PAYLOAD: payloadObj },
            CRONOS_PAYLOAD: payloadObj,
            cronos_payload: payloadObj,
            schemaUpdatedAt: new Date().toISOString()
          });
        } else {
          try { localStorage.setItem(STORAGE_KEY, JSON.stringify({ title: gSchema.title, fields: gSchema.fields })); } catch {}
        }

        buildForm(document.getElementById('formMount'), gSchema, gValues);
        await updatePreview(gValues);

        if (broadcast) {
          try { bcLegacy?.postMessage({ type: 'schema-updated', docId: gDocId, ts: Date.now() }); } catch {}
          try { bcCanon?.postMessage({ type: 'schema-updated',  docId: gDocId, ts: Date.now() }); } catch {}
        }

        gDirty = true;
        setStatus('Payload applied (normalized). Not yet saved to DOCX.');
        if (previewStatus) { previewStatus.textContent = 'Applied'; setTimeout(()=> previewStatus.textContent='', 900); }
      } finally {
        tr.end();
      }
    }


    if (payloadEl) {
      payloadEl.addEventListener('input', () => {
        const tr = TRACE('payloadEl:input');
        try {
          clearTimeout(__payloadApplyTimer);
          __payloadApplyTimer = setTimeout(async () => {
            const tr2 = TRACE('payloadEl:debouncedApply');
            if (__payloadEditBusy) { tr2.step('busy skip'); tr2.end(); return; }
            try {
              const txt = payloadEl.value;
              const obj = JSON.parse(txt);
              __payloadEditBusy = true;
              await applyPayloadObject(obj);
            } catch (e) {
              if (previewStatus) previewStatus.textContent = 'Invalid JSON';
              tr2.warn('invalid JSON', e);
            } finally {
              __payloadEditBusy = false;
              tr2.end();
            }
          }, 350);
        } finally { tr.end(); }
      });
    }

    // =========================
    // WIRE UP UI
    // =========================
    btnOpen.addEventListener('click', doOpen);
    btnSave.addEventListener('click', doSave);
    btnExport.addEventListener('click', doExport);
    btnSaveFromPreview?.addEventListener('click', doSave);

    btnRegrant.addEventListener('click', async () => {
      const tr = TRACE('btnRegrant:click');
      try { await updateWriteAccessBanner({ tryPrompt: true }); }
      catch (e) { tr.error('regrant failed', e); permNote.style.display='block'; }
      finally { tr.end(); }
    });

    window.addEventListener('beforeunload', async () => {
      const tr = TRACE('beforeunload');
      try {
        if (!gDocId) { tr.end('no docId'); return; }
        const vals = collectFormValues(gSchema);
        await window.formSuitePersist.saveState(gDocId, {
          schema: gSchema,
          values: { ...(gValues || {}), ...vals }
        });
        window.setActiveDocMeta?.({ docId: gDocId, name: gFileName });
      } catch (e) {
        tr.warn('beforeunload failed', e);
      } finally {
        tr.end();
      }
    });


    // =========================
    // TRIPLE-CLICK FOCUS NAV
    // =========================
    installLogoFocusNav();

    // =========================
    // HEADINGS (H1..H9) PARSING & TREE
    // =========================

    async function parseHeadings_JS(arrayBuffer) {
      const tr = TRACE('parseHeadings_JS', { hasBuffer: !!arrayBuffer, len: arrayBuffer?.byteLength });
      try {
        if (!arrayBuffer) return { flat: [], tree: [], count: 0 };

        const bytes = (arrayBuffer instanceof Uint8Array) ? arrayBuffer : new Uint8Array(arrayBuffer);
        const plan = await inspectRemovalPlan(bytes, {});
        const parts = Array.isArray(plan?.parts) ? plan.parts : [];

        const seen = new Set();
        const flat = [];

        for (const part of parts) {
          const headings = Array.isArray(part?.headings) ? part.headings : [];
          for (const heading of headings) {
            const idx = Number(heading?.idx);
            if (!Number.isFinite(idx) || seen.has(idx)) continue;
            seen.add(idx);
            const text = String(heading?.text || '').trim();
            const lvl = Number(heading?.level);
            const entry = {
              idx,
              key: idx,
              id: idx,
              text,
              title: text,
              label: text,
              part: heading?.part || part?.name || 'document'
            };
            if (Number.isFinite(lvl)) entry.level = lvl;
            const number = heading?.number ?? heading?.num;
            if (number != null && number !== '') entry.number = String(number);
            flat.push(entry);
          }
        }

        if (!flat.length) { tr.end({ count: 0, reason: 'no-headings' }); return { flat: [], tree: [], count: 0 }; }

        flat.sort((a, b) => a.idx - b.idx);

        const tree = buildHeadingTree(flat);
        numberHeadingsTree(tree);

        const byIdx = new Map(flat.map(h => [Number(h.idx), h]));
        const propagate = (nodes) => {
          if (!Array.isArray(nodes)) return;
          for (const n of nodes) {
            if (byIdx.has(Number(n.idx))) {
              const ref = byIdx.get(Number(n.idx));
              if (n.num) {
                ref.number = n.num;
                ref.compositeKey = `${n.num}|${ref.text}`.trim();
              }
            }
            if (Array.isArray(n.children) && n.children.length) propagate(n.children);
          }
        };
        propagate(tree);

        flat.forEach((h) => {
          const num = h.number || h.num;
          const idx = Number(h.idx);
          const prefix = num ? String(num) : Number.isFinite(idx) ? String(idx + 1) : '';
          if (!h.compositeKey) h.compositeKey = `${prefix}|${h.text}`.trim();
        });

        tr.end({ count: flat.length, rootChildren: tree.length });
        return { flat, tree, count: flat.length };
      } catch (e) {
        tr.error('failed', e); tr.end();
        return { flat: [], tree: [], count: 0 };
      }
    }

    function buildHeadingTree(list) {
      const root = [];
      const stack = [];
      for (const h of (list || [])) {
        const node = {
          level: h.level,
          text: h.text,
          part: h.part || 'document',
          idx: h.idx,
          uid: h.uid,
          paraIndex: h.paraIndex,
          start: h.start,
          end: h.end,
          label: h.label || h.text,
          children: []
        };
        while (stack.length && stack[stack.length - 1].level >= node.level) stack.pop();
        if (!stack.length) {
          root.push(node);
        } else {
          stack[stack.length - 1].children.push(node);
        }
        stack.push(node);
      }
      return root;
    }

    function renderHeadingsTreeView(tree) {
      const tr = TRACE('renderHeadingsTreeView', { nodes: tree?.length || 0 });
      try {
        if (!headersTreeEl) return;
        headersTreeEl.innerHTML = '';
        if (!tree || !tree.length) {
          headersTreeEl.innerHTML = '<div class="empty">No headings found (no paragraphs styled as headings).</div>';
          tr.end('empty'); return;
        }

        numberHeadingsTree(tree);

        const mk = (nodes) => {
          const ul = document.createElement('ul');
          ul.style.margin = '0 0 0 1rem';
          ul.style.padding = '0.1rem 0 0.1rem 0.6rem';
          for (const n of nodes) {
            const li = document.createElement('li');
            li.style.listStyle = 'none';

            const line = document.createElement('div');
            line.style.display = 'flex';
            line.style.gap = '6px';
            line.style.alignItems = 'baseline';

            const num = document.createElement('span');
            num.textContent = n.num;
            num.style.minWidth = '4ch';
            num.style.textAlign = 'right';
            num.style.fontVariantNumeric = 'tabular-nums';
            num.style.opacity = '0.9';
            num.style.fontWeight = n.level <= 2 ? '700' : '600';

            const text = document.createElement('span');
            text.textContent = n.text;
            text.title = `${n.part} â€¢ H${n.level}`;
            text.style.fontWeight = n.level <= 2 ? '600' : '400';

            const part = document.createElement('span');
            part.textContent = `Â· ${n.part}`;
            part.className = 'muted';
            part.style.fontSize = '0.75rem';

            line.appendChild(num);
            line.appendChild(text);
            line.appendChild(part);
            li.appendChild(line);

            if (n.children?.length) li.appendChild(mk(n.children));
            ul.appendChild(li);
          }
          return ul;
        };

        headersTreeEl.appendChild(mk(tree));
        tr.end('rendered');
      } catch (e) { tr.error('failed', e); tr.end(); }
    }

  </script>
</body>
</html>
