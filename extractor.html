<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Form Suite — Extractor</title>
  <link rel="icon" href="favicon.ico" type="image/gif" sizes="32x32">
  <link rel="shortcut icon" href="favicon.ico" type="image/gif">
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
  <link rel="stylesheet" href="style.css">
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

  <!-- JSZip for SDT scanning -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

  <!-- Core app plumbing -->
  <script src="persistence.js"></script>
  <script src="rules-core.js"></script>
  <script src="docx-core.js"></script>
  <script src="fs-active-doc.js"></script>
  <script src="fs-focus-nav.js"></script>

  <!-- Address autocomplete widget -->
  <script src="address-autocomplete.js"></script>
</head>
<body>
<header>
  <div class="row">
    <span class="brand logo-md">
      <img src="logo.gif" alt="Form Suite logo" class="logo" />
      <strong>Form Suite</strong>
    </span>
    <span class="muted">·</span><a href="index.html">Form</a>
    <span class="muted">·</span><a href="builder.html" id="openBuilder">Form Builder</a>
    <span class="muted">·</span><a href="matcher.html">Tag Matcher</a>
    <span class="muted">·</span><a href="rules.html">Rules</a>
    <span class="muted">·</span><span class="muted">Extractor</span>
  </div>
</header>

<main>
  <section class="panel">
    <h2 style="margin:0 0 10px">Inspect SDTs & store manual form payload in the DOCX</h2>
    <div class="row" style="gap:8px;flex-wrap:wrap">
      <button id="btnOpen">Open DOCX…</button>
      <button id="btnSave" disabled>Save (payload only)</button>
      <span class="muted" id="status" style="margin-left:auto">Idle</span>
    </div>

    <div id="permNote" class="note warn" style="display:none;margin-top:10px">
      This DOCX was opened via picker but I don’t have write permission to the original file.
      Clicking <em>Save</em> will write to a copy instead of the original.
      <button id="btnRegrant" class="ghost" style="margin-left:8px">Grant write access</button>
    </div>
  </section>

  <div class="grid-3">
    <section class="panel">
      <details open>
        <summary><strong>Found SDTs</strong></summary>
        <div style="overflow:auto;">
          <table id="sdt-table">
            <thead>
            <tr>
              <th>#</th>
              <th>Part</th>
              <th>w:tag</th>
              <th>w:alias</th>
              <th>Text</th>
            </tr>
            </thead>
            <tbody id="sdt-tbody"></tbody>
          </table>
        </div>
      </details>
    </section>

    <section class="panel">
      <details open>
        <summary><strong>CRONOS_PAYLOAD Preview</strong></summary>
        <textarea id="payloadPreview" spellcheck="false" style="min-height:420px"></textarea>
        <div class="row" style="margin-top:6px; gap:8px;">
          <button id="btnSaveFromPreview" class="secondary" disabled>Apply JSON & Save</button>
          <span class="muted" id="previewStatus"></span>
        </div>
      </details>
    </section>

    <section class="panel">
      <details>
        <summary><strong>Headers/Subheaders</strong></summary>
        <div id="headersTree" class="tree" style="max-height:420px;overflow:auto;padding:6px 4px;"></div>
      </details>
    </section>

    <section class="panel">
      <details open>
        <summary><strong>Live Form (from payload schema)</strong></summary>
        <div id="formMount"></div>
      </details>
    </section>
  </div>
</main>

<script>
'use strict';

/* ============================================================
   TRACE (exactly one tracing primitive; used everywhere)
   ============================================================ */
(function ensureTrace() {
  if (typeof window.TRACE === 'function') return;

  const DEBUG = { on: true, seq: 0 };
  const ts = () => new Date().toISOString().slice(11, 23);

  window.TRACE = function TRACE(name, details) {
    const id = ++DEBUG.seq;
    const prefix = `[Extractor ${ts()} #${id}] ${name}`;
    if (DEBUG.on) console.log(prefix, details ?? '');
    const t0 = (typeof performance !== 'undefined' ? performance.now() : Date.now());

    return {
      step(msg, data) { if (DEBUG.on) console.log(`${prefix}  ↳ ${msg}`, data ?? ''); },
      warn(msg, data) { if (DEBUG.on) console.warn(`${prefix}  ⚠ ${msg}`, data ?? ''); },
      error(msg, err) { if (DEBUG.on) console.error(`${prefix}  ✖ ${msg}`, err); },
      end(extra) {
        if (!DEBUG.on) return;
        const t1 = (typeof performance !== 'undefined' ? performance.now() : Date.now());
        const ms = Math.round((t1 - t0) * 1000) / 1000;
        console.log(`${prefix} done (${ms}ms)`, extra ?? '');
      }
    };
  };
})();

window.addEventListener('error', (e) => {
  console.error('[Extractor window.error]', {
    message: e.message,
    filename: e.filename,
    lineno: e.lineno,
    colno: e.colno,
    error: e.error
  });
});
window.addEventListener('unhandledrejection', (e) => {
  console.error('[Extractor window.unhandledrejection]', e.reason);
});

/* ============================================================
   Single coordination layer: fs-active-doc + formSuitePersist
   Single broadcast: BroadcastChannel("fs-active-doc")
   Single payload mirror: workspace state payload.CRONOS_PAYLOAD
   ============================================================ */

const PAYLOAD_KEY = 'CRONOS_PAYLOAD';
const supportsFS  = ('showOpenFilePicker' in window) && ('showSaveFilePicker' in window);

const els = {
  btnOpen: document.getElementById('btnOpen'),
  btnSave: document.getElementById('btnSave'),
  status: document.getElementById('status'),
  permNote: document.getElementById('permNote'),
  btnRegrant: document.getElementById('btnRegrant'),
  payloadPreview: document.getElementById('payloadPreview'),
  btnSaveFromPreview: document.getElementById('btnSaveFromPreview'),
  previewStatus: document.getElementById('previewStatus'),
  formMount: document.getElementById('formMount'),
  tableBody: document.getElementById('sdt-tbody'),
  headersTree: document.getElementById('headersTree'),
};

const bc = ('BroadcastChannel' in window) ? new BroadcastChannel('fs-active-doc') : null;

function setStatus(text) {
  const tr = TRACE('setStatus', { text });
  try { els.status.textContent = String(text || ''); }
  finally { tr.end(); }
}

function assertDeps() {
  const tr = TRACE('assertDeps');
  try {
    const miss = [];
    if (!window.formSuitePersist) miss.push('window.formSuitePersist (persistence.js)');
    if (typeof window.readActiveDocSync !== 'function') miss.push('readActiveDocSync (fs-active-doc.js)');
    if (typeof window.installActiveDocListener !== 'function') miss.push('installActiveDocListener (fs-active-doc.js)');
    if (miss.length) {
      console.error('[Extractor] Missing deps:', miss);
      setStatus('Error: missing core dependencies (see console).');
      return false;
    }
    return true;
  } finally {
    tr.end();
  }
}

function splitNameAndExt(fileName) {
  const m = String(fileName || '').match(/\.(docx|docm|dotx|dotm)$/i);
  return {
    base: String(fileName || 'document.docx').replace(/\.(docx|docm|dotx|dotm)$/i, ''),
    ext:  (m ? m[1] : 'docx').toLowerCase()
  };
}

async function sha256Hex(bufOrU8) {
  const tr = TRACE('sha256Hex', { type: bufOrU8?.constructor?.name, len: bufOrU8?.byteLength || bufOrU8?.length });
  try {
    const ab = (bufOrU8 instanceof ArrayBuffer)
      ? bufOrU8
      : (bufOrU8?.buffer instanceof ArrayBuffer)
        ? bufOrU8.buffer
        : new Uint8Array(bufOrU8 || []).buffer;
    const d = await crypto.subtle.digest('SHA-256', ab);
    const hex = [...new Uint8Array(d)].map(b => b.toString(16).padStart(2, '0')).join('');
    tr.end({ hex: hex.slice(0, 12) });
    return hex;
  } catch (e) {
    tr.error('sha failed', e);
    tr.end();
    return '(hash-error)';
  }
}

/* ============================================================
   In-memory state (Extractor)
   ============================================================ */
let currentDoc = null;           // {docId, name}
let currentHandle = null;        // FileSystemFileHandle (best-effort cache)
let currentBytesU8 = null;       // Uint8Array (best-effort cache)

let schema = { title: 'Form', fields: [] };
let values = {};
let tagMap = {};
let headingsBaseline = { flat: [], tree: [] };
let lastParsedHeadings = { flat: [], tree: [] };

let __hydrating = false;
let __fgRefreshLock = false;

// Address widget store
const __addressValues = Object.create(null);

/* ============================================================
   Canonical byte access workflow (one function)
   ============================================================ */
async function getWorkingDocBytesU8() {
  const tr = TRACE('getWorkingDocBytesU8', { docId: currentDoc?.docId, hasHandle: !!currentHandle });
  try {
    // 1) Prefer persistence "current bytes" (already includes in-memory writes)
    try {
      const b0 = await window.formSuitePersist.getCurrentDocBytes?.();
      if (b0 && (b0.byteLength || b0.length)) {
        const u8 = (b0 instanceof Uint8Array) ? b0 : new Uint8Array(b0);
        tr.end({ mode: 'persist.getCurrentDocBytes', len: u8.byteLength });
        return u8;
      }
    } catch (e) { tr.warn('getCurrentDocBytes failed', e); }

    // 2) Per-doc cache
    try {
      if (currentDoc?.docId) {
        const b1 = await window.formSuitePersist.getBytes?.(currentDoc.docId);
        if (b1 && (b1.byteLength || b1.length)) {
          const u8 = (b1 instanceof Uint8Array) ? b1 : new Uint8Array(b1);
          tr.end({ mode: 'persist.getBytes', len: u8.byteLength });
          return u8;
        }
      }
    } catch (e) { tr.warn('getBytes failed', e); }

    // 3) Handle fallback
    try {
      const h = currentHandle || (currentDoc?.docId ? await window.formSuitePersist.getHandle?.(currentDoc.docId) : null);
      if (h?.getFile) {
        const p = await window.formSuitePersist.ensurePermission?.(h, 'read') || 'granted';
        if (p === 'granted') {
          const f = await h.getFile();
          const u8 = new Uint8Array(await f.arrayBuffer());
          currentHandle = h;
          tr.end({ mode: 'handle.getFile', len: u8.byteLength });
          return u8;
        }
      }
    } catch (e) { tr.warn('handle.getFile failed', e); }

    tr.end({ mode: 'none' });
    return null;
  } catch (e) {
    tr.error('getWorkingDocBytesU8 failed', e);
    tr.end();
    return null;
  }
}

/* ============================================================
   Single write access banner workflow
   ============================================================ */
async function updateWriteAccessBanner({ tryPrompt = false } = {}) {
  const tr = TRACE('updateWriteAccessBanner', { tryPrompt, docId: currentDoc?.docId, supportsFS });
  try {
    if (!supportsFS || !currentDoc?.docId) { els.permNote.style.display = 'none'; return 'unsupported'; }

    const h = currentHandle || await window.formSuitePersist.getHandle?.(currentDoc.docId);
    if (!h?.queryPermission) { els.permNote.style.display = 'none'; return 'no-handle'; }

    let p = await h.queryPermission({ mode: 'readwrite' });
    tr.step('queryPermission', p);

    if (p !== 'granted' && tryPrompt && h.requestPermission) {
      try { p = await h.requestPermission({ mode: 'readwrite' }) || p; }
      catch (e) { tr.warn('requestPermission failed', e); }
    }

    els.permNote.style.display = (p === 'granted') ? 'none' : 'block';
    if (p === 'granted') currentHandle = h;
    tr.end({ final: p });
    return p || 'denied';
  } catch (e) {
    tr.error('updateWriteAccessBanner failed', e);
    els.permNote.style.display = 'block';
    return 'error';
  }
}

/* ============================================================
   UI reset
   ============================================================ */
function clearUi(message = 'Idle') {
  const tr = TRACE('clearUi', { message });
  try {
    els.tableBody.innerHTML = '<tr><td colspan="5" class="empty">No document loaded.</td></tr>';
    els.formMount.innerHTML = '<div class="empty">No schema found.</div>';
    els.payloadPreview.value = '';
    els.previewStatus.textContent = '';
    if (els.headersTree) els.headersTree.innerHTML = '<div class="empty">No headings.</div>';
    els.btnSave.disabled = true;
    els.btnSaveFromPreview.disabled = true;
    els.permNote.style.display = 'none';
    setStatus(message);
  } finally { tr.end(); }
}

/* ============================================================
   DOCX reads/writes (payload only) — docx-core.js is canonical
   ============================================================ */
async function readPayloadFromDocx(bytesU8) {
  const tr = TRACE('readPayloadFromDocx', { len: bytesU8?.byteLength });
  try {
    if (!bytesU8?.byteLength) return null;

    let raw = null;
    try {
      if (typeof window.readDocVarSettings === 'function') {
        raw = await window.readDocVarSettings(bytesU8, PAYLOAD_KEY);
      }
    } catch (e) { tr.warn('readDocVarSettings failed', e); }

    if (raw == null) {
      try {
        if (typeof window.readDocVarCustom === 'function') {
          raw = await window.readDocVarCustom(bytesU8, PAYLOAD_KEY);
        }
      } catch (e) { tr.warn('readDocVarCustom failed', e); }
    }

    tr.end({ has: !!raw, len: raw ? String(raw).length : 0 });
    return raw;
  } catch (e) {
    tr.error('readPayloadFromDocx failed', e);
    tr.end();
    return null;
  }
}

async function writePayloadToDocx(bytesU8, payloadObj) {
  const tr = TRACE('writePayloadToDocx', { inLen: bytesU8?.byteLength });
  try {
    if (!bytesU8?.byteLength) throw new Error('No bytes to write');
    const json = JSON.stringify(payloadObj || {}, null, 0);

    let out = null;
    try {
      if (typeof window.writeDocVarSettings === 'function') {
        out = await window.writeDocVarSettings(bytesU8, PAYLOAD_KEY, json);
      }
    } catch (e) { tr.warn('writeDocVarSettings failed', e); }

    if (!out) {
      try {
        if (typeof window.writeDocVarCustom === 'function') {
          out = await window.writeDocVarCustom(bytesU8, PAYLOAD_KEY, json);
        }
      } catch (e) { tr.warn('writeDocVarCustom failed', e); }
    }

    if (!out) throw new Error('No docx writer available (writeDocVarSettings/writeDocVarCustom missing).');

    const outU8 = (out instanceof Uint8Array) ? out : new Uint8Array(out);
    tr.end({ outLen: outU8.byteLength });
    return outU8;
  } catch (e) {
    tr.error('writePayloadToDocx failed', e);
    tr.end();
    throw e;
  }
}

/* ============================================================
   Rules + payload normalization (single workflow via deriveNormalizedRulesForDoc)
   ============================================================ */
function makeBaselineFromParsed(parsed) {
  return {
    flat: Array.isArray(parsed?.flat) ? parsed.flat : [],
    tree: Array.isArray(parsed?.tree) ? parsed.tree : []
  };
}

function normalizeAllForDoc(wsState, nextSchema, baseline) {
  const tr = TRACE('normalizeAllForDoc', {
    hasSchema: !!nextSchema,
    fields: nextSchema?.fields?.length || 0,
    baselineFlat: baseline?.flat?.length || 0
  });
  try {
    const normalized = (typeof window.deriveNormalizedRulesForDoc === 'function')
      ? window.deriveNormalizedRulesForDoc(wsState || {}, nextSchema || null, baseline || { flat: [], tree: [] })
      : { headingRules: (wsState?.rules || []), fieldRules: (wsState?.fieldRules || []) };

    const headingRules = Array.isArray(normalized?.headingRules) ? normalized.headingRules : (Array.isArray(wsState?.rules) ? wsState.rules : []);
    const fieldRules   = Array.isArray(normalized?.fieldRules) ? normalized.fieldRules : (Array.isArray(wsState?.fieldRules) ? wsState.fieldRules : []);

    tr.end({ headingRules: headingRules.length, fieldRules: fieldRules.length });
    return { headingRules, fieldRules };
  } catch (e) {
    tr.error('normalizeAllForDoc failed', e);
    tr.end();
    return { headingRules: Array.isArray(wsState?.rules) ? wsState.rules : [], fieldRules: Array.isArray(wsState?.fieldRules) ? wsState.fieldRules : [] };
  }
}

function pruneBySchema(nextSchema, nextValues, nextTagMap) {
  const fieldIds = new Set((nextSchema?.fields || []).map(f => String(f.id)));
  const prunedValues = {};
  for (const [k, v] of Object.entries(nextValues || {})) {
    if (fieldIds.has(String(k))) prunedValues[k] = v;
  }
  const prunedTagMap = {};
  for (const [tag, fid] of Object.entries(nextTagMap || {})) {
    if (fieldIds.has(String(fid))) prunedTagMap[tag] = fid;
  }
  return { values: prunedValues, tagMap: prunedTagMap };
}

async function saveWorkspaceMirror(docId, payloadObj, { baseline } = {}) {
  const tr = TRACE('saveWorkspaceMirror', { docId, fields: payloadObj?.fields?.length || 0 });
  try {
    if (!docId) return;

    // Single mirror location: payload.CRONOS_PAYLOAD
    const patch = {
      schema: { title: payloadObj.title || 'Form', fields: Array.isArray(payloadObj.fields) ? payloadObj.fields : [] },
      values: payloadObj.values || {},
      tagMap: payloadObj.tagMap || {},
      rules: Array.isArray(payloadObj.rules) ? payloadObj.rules : [],
      fieldRules: Array.isArray(payloadObj.fieldRules) ? payloadObj.fieldRules : [],
      payload: { CRONOS_PAYLOAD: payloadObj },
      schemaUpdatedAt: new Date().toISOString(),
      headingsUpdatedAt: new Date().toISOString(),
    };

    if (baseline?.flat) patch.headingsFlat = baseline.flat;
    if (baseline?.tree) patch.headingsTree = baseline.tree;

    await window.formSuitePersist.saveState(docId, patch);
    tr.end({ ok: true });
  } catch (e) {
    tr.error('saveWorkspaceMirror failed', e);
    tr.end();
  }
}

/* ============================================================
   SDT parsing
   ============================================================ */
const DOCX_NS = window.DOCX_W_NS || window.W_NS || "http://schemas.openxmlformats.org/wordprocessingml/2006/main";

function xmlText(el) {
  let s = '';
  const rec = n => {
    if (!n) return;
    if (n.nodeType === 3) { s += n.nodeValue; return; }
    if (n.nodeType === 1) {
      const ln = n.localName;
      if (ln === 'p' || ln === 'cr' || ln === 'br') s += '\n';
      for (const ch of n.childNodes) rec(ch);
    }
  };
  rec(el);
  return s.replace(/\s+\n/g, '\n').replace(/\n{3,}/g, '\n\n').trim();
}

async function parseSDTs_JS(arrayBuffer) {
  const tr = TRACE('parseSDTs_JS', { hasBuffer: !!arrayBuffer, len: arrayBuffer?.byteLength });
  try {
    if (!arrayBuffer) return { sdts: [], total: 0 };
    const zip = await JSZip.loadAsync(arrayBuffer);
    const parts = zip.file(/^word\/(?!_rels\/|theme\/|fontTable\.xml|styles\.xml|numbering\.xml|settings\.xml|webSettings\.xml).*\.xml$/i) || [];
    const parser = new DOMParser();
    const sdts = [];

    for (const f of parts) {
      const pf = TRACE('parseSDTs_JS:file', { name: f.name });
      try {
        const xmlTextContent = await f.async('string');
        const xml = parser.parseFromString(xmlTextContent, "application/xml");
        const found = Array.from(xml.getElementsByTagNameNS(DOCX_NS, 'sdt'));
        for (const sdt of found) {
          const pr = sdt.getElementsByTagNameNS(DOCX_NS, 'sdtPr')[0];
          const content = sdt.getElementsByTagNameNS(DOCX_NS, 'sdtContent')[0] || sdt;
          let tagVal = '';
          let alias = '';

          if (pr) {
            const tEl = pr.getElementsByTagNameNS(DOCX_NS, 'tag')[0];
            if (tEl) tagVal = tEl.getAttributeNS(DOCX_NS, 'val') || tEl.getAttribute('w:val') || '';
            const aEl = pr.getElementsByTagNameNS(DOCX_NS, 'alias')[0];
            if (aEl) alias = aEl.getAttributeNS(DOCX_NS, 'val') || aEl.getAttribute('w:val') || '';
          }

          sdts.push({
            part: f.name.split('/').pop().replace('.xml', ''),
            tag: tagVal,
            alias,
            text: xmlText(content)
          });
        }
        pf.end({ added: found.length });
      } catch (e) {
        pf.warn('xml parse failed', e);
        pf.end({ error: true });
      }
    }

    tr.end({ total: sdts.length });
    return { sdts, total: sdts.length };
  } catch (e) {
    tr.error('parseSDTs_JS failed', e);
    tr.end();
    return { sdts: [], total: 0 };
  }
}

function renderSDTsView(parsed) {
  const tr = TRACE('renderSDTsView', { total: parsed?.total });
  try {
    els.tableBody.innerHTML = '';
    const sdts = parsed?.sdts || [];
    if (!sdts.length) {
      const trEl = document.createElement('tr');
      const td = document.createElement('td');
      td.colSpan = 5;
      td.className = 'empty';
      td.textContent = 'No SDTs found in this document.';
      trEl.appendChild(td);
      els.tableBody.appendChild(trEl);
      return;
    }

    sdts.forEach((row, i) => {
      const trEl = document.createElement('tr');

      const tdIdx = document.createElement('td'); tdIdx.textContent = String(i + 1);
      const tdPart = document.createElement('td'); tdPart.textContent = row.part || '';
      const tdTag = document.createElement('td'); tdTag.textContent = row.tag || '';
      const tdAlias = document.createElement('td'); tdAlias.textContent = row.alias || '';
      const tdText = document.createElement('td'); tdText.textContent = row.text || '';

      trEl.appendChild(tdIdx);
      trEl.appendChild(tdPart);
      trEl.appendChild(tdTag);
      trEl.appendChild(tdAlias);
      trEl.appendChild(tdText);

      els.tableBody.appendChild(trEl);
    });
  } finally {
    tr.end();
  }
}

/* ============================================================
   Headings: keep using your existing implementation if present.
   If none exists, we degrade gracefully to "no headings".
   ============================================================ */
async function parseHeadings_JS(arrayBuffer) {
  const tr = TRACE('parseHeadings_JS', { len: arrayBuffer?.byteLength });
  try {
    // If your docx-core already provides a parser, prefer it:
    if (typeof window.parseHeadings_JS === 'function' && window.parseHeadings_JS !== parseHeadings_JS) {
      const out = await window.parseHeadings_JS(arrayBuffer);
      tr.end({ mode: 'window.parseHeadings_JS', flat: out?.flat?.length || 0 });
      return out;
    }
    // Otherwise: no-op (stable)
    const out = { flat: [], tree: [], count: 0 };
    tr.end({ mode: 'noop', flat: 0 });
    return out;
  } catch (e) {
    tr.error('parseHeadings_JS failed', e);
    tr.end();
    return { flat: [], tree: [], count: 0 };
  }
}

function buildHeadingTree(list) {
  const root = [];
  const stack = [];
  for (const h of (list || [])) {
    const node = {
      level: h.level,
      text: h.text,
      part: h.part || 'document',
      idx: h.idx,
      uid: h.uid,
      paraIndex: h.paraIndex,
      start: h.start,
      end: h.end,
      label: h.label || h.text,
      children: []
    };
    while (stack.length && stack[stack.length - 1].level >= node.level) stack.pop();
    if (!stack.length) root.push(node);
    else stack[stack.length - 1].children.push(node);
    stack.push(node);
  }
  return root;
}

function renderHeadingsTreeView(tree) {
  const tr = TRACE('renderHeadingsTreeView', { nodes: tree?.length || 0 });
  try {
    if (!els.headersTree) return;
    els.headersTree.innerHTML = '';

    if (!tree || !tree.length) {
      els.headersTree.innerHTML = '<div class="empty">No headings found (no paragraphs styled as headings).</div>';
      tr.end('empty');
      return;
    }

    if (typeof window.numberHeadingsTree === 'function') {
      try { window.numberHeadingsTree(tree); } catch (e) { tr.warn('numberHeadingsTree failed', e); }
    }

    const mk = (nodes) => {
      const ul = document.createElement('ul');
      ul.style.margin = '0 0 0 1rem';
      ul.style.padding = '0.1rem 0 0.1rem 0.6rem';
      for (const n of nodes) {
        const li = document.createElement('li');
        li.style.listStyle = 'none';

        const line = document.createElement('div');
        line.style.display = 'flex';
        line.style.gap = '6px';
        line.style.alignItems = 'baseline';

        const num = document.createElement('span');
        num.textContent = n.num || '';
        num.style.minWidth = '4ch';
        num.style.textAlign = 'right';
        num.style.fontVariantNumeric = 'tabular-nums';
        num.style.opacity = '0.9';
        num.style.fontWeight = n.level <= 2 ? '700' : '600';

        const text = document.createElement('span');
        text.textContent = n.text;
        text.title = `${n.part} · H${n.level}`;
        text.style.fontWeight = n.level <= 2 ? '600' : '400';

        const part = document.createElement('span');
        part.textContent = `· ${n.part}`;
        part.className = 'muted';
        part.style.fontSize = '0.75rem';

        line.appendChild(num);
        line.appendChild(text);
        line.appendChild(part);
        li.appendChild(line);

        if (n.children?.length) li.appendChild(mk(n.children));
        ul.appendChild(li);
      }
      return ul;
    };

    els.headersTree.appendChild(mk(tree));
    tr.end('rendered');
  } catch (e) {
    tr.error('renderHeadingsTreeView failed', e);
    tr.end();
  }
}

/* ============================================================
   Preview + form rendering (Extractor live form)
   ============================================================ */
function collectFormValues(schema) {
  const form = document.getElementById('liveForm');
  const out = {};
  if (!form || !schema) return out;

  for (const f of (schema.fields || [])) {
    if (f.type === 'multichoice') {
      const nodes = form.querySelectorAll(`input[type="checkbox"][name="${CSS.escape(f.id)}"]`);
      out[f.id] = Array.from(nodes).filter(n => n.checked).map(n => n.value);
      continue;
    }
    if (f.type === 'address') {
      out[f.id] = __addressValues[f.id] ?? null;
      continue;
    }
    const el = form.elements[f.id];
    out[f.id] = el ? el.value : null;
  }
  return out;
}

let previewTimer = null;
function schedulePreviewUpdate() {
  clearTimeout(previewTimer);
  previewTimer = setTimeout(async () => {
    const tr = TRACE('schedulePreviewUpdate:tick');
    try {
      const vals = collectFormValues(schema);
      values = { ...(values || {}), ...(vals || {}) };

      if (currentDoc?.docId) {
        await window.formSuitePersist.saveState(currentDoc.docId, { schema, values });
        bc?.postMessage({ type: 'state:changed', docId: currentDoc.docId, ts: Date.now() });
      }

      await updatePreview();
      setStatus('Unsaved changes — press Save to update DOCX.');
    } catch (e) {
      tr.error('preview tick failed', e);
    } finally {
      tr.end();
    }
  }, 250);
}

function buildForm(container, schema, values) {
  const tr = TRACE('buildForm', { fields: schema?.fields?.length || 0 });
  try {
    container.innerHTML = '';
    if (!schema || !Array.isArray(schema.fields) || schema.fields.length === 0) {
      container.innerHTML = '<div class="empty">No manual schema. Create one in the Builder, or load a DOCX that already contains a payload schema.</div>';
      tr.end('empty schema');
      return;
    }

    const form = document.createElement('form');
    form.id = 'liveForm';
    form.noValidate = true;
    form.style.display = 'grid';
    form.style.gap = '12px';

    if (schema.title) {
      const h = document.createElement('h4');
      h.textContent = schema.title;
      h.style.margin = '0 0 6px';
      form.appendChild(h);
    }

    for (const f of schema.fields) {
      const tf = TRACE('buildForm:field', { id: f.id, type: f.type });
      const wrap = document.createElement('div');
      wrap.className = 'field';

      const label = document.createElement('label');
      label.htmlFor = f.id;
      label.style.display = 'flex';
      label.style.justifyContent = 'space-between';
      label.style.alignItems = 'center';

      const labelText = document.createElement('span');
      labelText.textContent = f.label || f.id || '(field)';
      label.appendChild(labelText);

      if (f.required) {
        const star = document.createElement('span');
        star.textContent = '•';
        star.title = 'Required';
        star.style.fontWeight = '600';
        star.style.color = '#ef4444';
        label.appendChild(star);
      }

      wrap.appendChild(label);

      let input;

      if (f.type === 'multichoice') {
        const box = document.createElement('div');
        box.style.display = 'grid';
        box.style.gap = '6px';

        (f.options || []).forEach(opt => {
          const v = String(opt?.value ?? opt);
          const id = `${f.id}__${v.replace(/\s+/g, '_')}`;
          const row = document.createElement('label');
          row.style.display = 'flex';
          row.style.gap = '8px';
          row.style.alignItems = 'center';

          const cb = document.createElement('input');
          cb.type = 'checkbox';
          cb.name = f.id;
          cb.id = id;
          cb.value = v;

          if (Array.isArray(values?.[f.id]) && values[f.id].map(String).includes(v)) cb.checked = true;

          const span = document.createElement('span');
          span.textContent = String(opt?.label ?? opt?.text ?? opt?.value ?? opt);

          row.appendChild(cb);
          row.appendChild(span);
          box.appendChild(row);
        });

        wrap.appendChild(box);
        box.addEventListener('change', schedulePreviewUpdate);
        form.appendChild(wrap);
        tf.end();
        continue;
      }

      if (f.type === 'select') {
        input = document.createElement('select');
        (f.options || []).forEach(opt => {
          const o = document.createElement('option');
          o.value = String(opt?.value ?? opt?.id ?? opt);
          o.textContent = String(opt?.label ?? opt?.text ?? opt?.value ?? opt);
          input.appendChild(o);
        });
      } else if (f.type === 'date') {
        input = document.createElement('input');
        input.type = 'text';
        input.dataset.type = 'date';
        input.dataset.format = f.dateFormat || 'Y-m-d';
      } else if (f.type === 'address') {
        const mountDiv = document.createElement('div');
        mountDiv.className = 'address-field';
        wrap.appendChild(mountDiv);

        const initial =
          typeof values?.[f.id] === 'string'
            ? { formatted: values[f.id] }
            : (values?.[f.id] || null);

        __addressValues[f.id] = initial || null;

        try {
          if (window.AddressAuto && typeof window.AddressAuto.mount === 'function') {
            window.AddressAuto.mount(mountDiv, {
              id: f.id,
              label: f.label || 'Address',
              required: !!f.required,
              value: initial || null,
              onChange: (val) => { __addressValues[f.id] = val; schedulePreviewUpdate(); }
            });
          } else {
            throw new Error('AddressAuto not available');
          }
        } catch (err) {
          const fallback = document.createElement('input');
          fallback.type = 'text';
          fallback.id = f.id;
          fallback.name = f.id;
          fallback.placeholder = 'Address';
          if (initial?.formatted) fallback.value = initial.formatted;
          fallback.addEventListener('input', () => {
            __addressValues[f.id] = { formatted: fallback.value };
            schedulePreviewUpdate();
          });
          mountDiv.appendChild(fallback);
        }

        form.appendChild(wrap);
        tf.end();
        continue;
      } else {
        input = document.createElement('input');
        input.type = 'text';
      }

      input.id = f.id;
      input.name = f.id;
      if (f.required) input.required = true;
      if (values && values[f.id] != null) input.value = values[f.id];

      input.addEventListener('change', schedulePreviewUpdate);
      input.addEventListener('input', schedulePreviewUpdate);

      wrap.appendChild(input);

      if (f.type === 'date') {
        setTimeout(() => {
          const tt = TRACE('flatpickr:init', { id: input.id, format: input.dataset.format });
          try {
            if (window.flatpickr && typeof window.flatpickr === 'function') {
              window.flatpickr(input, {
                dateFormat: input.dataset.format || 'Y-m-d',
                allowInput: true,
                onChange: schedulePreviewUpdate,
                onValueUpdate: schedulePreviewUpdate
              });
            }
          } finally { tt.end(); }
        }, 0);
      }

      form.appendChild(wrap);
      tf.end();
    }

    container.appendChild(form);
    tr.end('form built');
  } catch (e) {
    tr.error('buildForm failed', e);
    tr.end();
  }
}

async function updatePreview() {
  const tr = TRACE('updatePreview', { docId: currentDoc?.docId });
  try {
    if (!els.payloadPreview) return;

    const docId = currentDoc?.docId;
    const st = docId ? (await window.formSuitePersist.loadState(docId) || {}) : {};

    // Adopt best-known headings baseline for normalization
    const baseline = {
      flat: Array.isArray(st.headingsFlat) ? st.headingsFlat : (Array.isArray(lastParsedHeadings.flat) ? lastParsedHeadings.flat : []),
      tree: Array.isArray(st.headingsTree) ? st.headingsTree : (Array.isArray(lastParsedHeadings.tree) ? lastParsedHeadings.tree : []),
    };
    headingsBaseline = baseline;

    // Single mirror is payload.CRONOS_PAYLOAD; fall back to raw state fields
    const payload = st.payload?.CRONOS_PAYLOAD || null;

    const effectiveSchema = payload?.fields?.length
      ? { title: payload.title || 'Form', fields: payload.fields }
      : (st.schema?.fields?.length ? st.schema : schema);

    const effectiveValues = payload?.values ? payload.values : (st.values || values || {});
    const effectiveTagMap = payload?.tagMap ? payload.tagMap : (st.tagMap || tagMap || {});

    const { headingRules, fieldRules } = normalizeAllForDoc(st, effectiveSchema, baseline);

    const pruned = pruneBySchema(effectiveSchema, effectiveValues, effectiveTagMap);

    const previewObj = {
      title: effectiveSchema?.title || 'Form',
      fields: effectiveSchema?.fields || [],
      values: pruned.values,
      tagMap: pruned.tagMap,
      rules: headingRules,
      fieldRules: fieldRules,
      updatedAt: new Date().toISOString()
    };

    els.payloadPreview.value = JSON.stringify(previewObj, null, 2);
    tr.end({ fields: previewObj.fields.length, rules: previewObj.rules.length, fieldRules: previewObj.fieldRules.length });
  } catch (e) {
    tr.error('updatePreview failed', e);
    tr.end();
  }
}

/* ============================================================
   Render pipeline: bytes -> SDTs/headings/payload -> workspace mirror
   ============================================================ */
async function renderFromBytes(bytesU8, { prefix = '' } = {}) {
  const tr = TRACE('renderFromBytes', { prefix, len: bytesU8?.byteLength, docId: currentDoc?.docId });
  try {
    if (!bytesU8?.byteLength) { setStatus('No DOCX loaded.'); return; }

    setStatus((prefix || '') + 'Parsing…');

    // SDTs
    const parsedSDTs = await parseSDTs_JS(bytesU8.buffer);
    renderSDTsView(parsedSDTs);

    // Headings (best effort)
    const headingsParsed = await parseHeadings_JS(bytesU8.buffer);
    lastParsedHeadings = {
      flat: Array.isArray(headingsParsed?.flat) ? headingsParsed.flat : [],
      tree: Array.isArray(headingsParsed?.tree) ? headingsParsed.tree : []
    };

    const tree = (Array.isArray(headingsParsed?.tree) && headingsParsed.tree.length)
      ? headingsParsed.tree
      : buildHeadingTree(lastParsedHeadings.flat);

    renderHeadingsTreeView(tree);

    // Payload from DOCX (optional)
    const payloadRaw = await readPayloadFromDocx(bytesU8);
    let payloadFromDoc = null;
    try { payloadFromDoc = payloadRaw ? JSON.parse(payloadRaw) : null; } catch { payloadFromDoc = null; }

    // Workspace state
    const docId = currentDoc?.docId;
    const st = docId ? (await window.formSuitePersist.loadState(docId) || {}) : {};

    // Choose schema:
    // - Prefer workspace schema if present (it represents your "working set")
    // - Otherwise use doc payload schema if present
    // - Otherwise empty schema
    const wsSchema = st.schema;
    const docSchema = (Array.isArray(payloadFromDoc?.fields) && payloadFromDoc.fields.length)
      ? { title: payloadFromDoc.title || 'Form', fields: payloadFromDoc.fields }
      : null;

    const chosenSchema = (wsSchema?.fields?.length ? wsSchema : (docSchema || { title: 'Form', fields: [] }));

    // Values/tagMap: workspace overrides doc (working set wins)
    const mergedValues = Object.assign({}, payloadFromDoc?.values || {}, st.values || {});
    const mergedTagMap = Object.assign({}, payloadFromDoc?.tagMap || {}, st.tagMap || {});

    const baseline = makeBaselineFromParsed({ flat: lastParsedHeadings.flat, tree });
    const normalized = normalizeAllForDoc(st, chosenSchema, baseline);

    const pruned = pruneBySchema(chosenSchema, mergedValues, mergedTagMap);

    // Update in-memory
    schema = chosenSchema;
    values = pruned.values;
    tagMap = pruned.tagMap;
    headingsBaseline = baseline;

    // Build canonical payload mirror and write into workspace ONLY (no duplication)
    const payloadObj = {
      title: schema.title || 'Form',
      fields: schema.fields || [],
      values,
      tagMap,
      rules: normalized.headingRules,
      fieldRules: normalized.fieldRules,
      updatedAt: new Date().toISOString()
    };

    if (docId) await saveWorkspaceMirror(docId, payloadObj, { baseline });

    buildForm(els.formMount, schema, values);
    await updatePreview();

    els.btnSave.disabled = !docId;
    els.btnSaveFromPreview.disabled = !docId;

    setStatus('Ready.');
    tr.end({ fields: schema?.fields?.length || 0 });
  } catch (e) {
    tr.error('renderFromBytes failed', e);
    setStatus('Error while parsing (see console).');
    tr.end();
  }
}

/* ============================================================
   Hydrate / refresh from workspace (override-safe)
   - ONLY re-renders UI from latest bytes/state
   - DOES NOT overwrite state unless we successfully parsed bytes
   ============================================================ */
async function rehydrateOnForeground(source) {
  const tr = TRACE('rehydrateOnForeground', { source, locked: __fgRefreshLock, docId: currentDoc?.docId });
  if (__fgRefreshLock) { tr.end('locked'); return; }
  __fgRefreshLock = true;
  try {
    if (!currentDoc?.docId) { tr.end('no doc'); return; }

    // small debounce to allow other tabs to finish writing
    await new Promise(r => setTimeout(r, 120));

    const bytes = await getWorkingDocBytesU8();
    if (!bytes) { tr.end('no bytes'); return; }

    currentBytesU8 = bytes;
    await renderFromBytes(bytes, { prefix: `(${source} refreshed) ` });
    await updateWriteAccessBanner();
    tr.end('refreshed');
  } catch (e) {
    tr.error('rehydrateOnForeground failed', e);
    tr.end();
  } finally {
    __fgRefreshLock = false;
  }
}

document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'visible') rehydrateOnForeground('visible');
});
window.addEventListener('focus', () => rehydrateOnForeground('focus'));

/* ============================================================
   Apply payload JSON from preview (single normalization + mirror update)
   ============================================================ */
async function applyPayloadObject(obj) {
  const tr = TRACE('applyPayloadObject', { hasObj: !!obj });
  try {
    if (!obj || typeof obj !== 'object') return false;

    const nextSchema = { title: obj.title || 'Form', fields: Array.isArray(obj.fields) ? obj.fields : [] };
    const rawValues  = (obj.values && typeof obj.values === 'object') ? obj.values : {};
    const rawTagMap  = (obj.tagMap && typeof obj.tagMap === 'object') ? obj.tagMap : {};
    const rawRules   = Array.isArray(obj.rules) ? obj.rules : [];
    const rawFieldR  = Array.isArray(obj.fieldRules) ? obj.fieldRules : [];

    // Normalize using deriveNormalizedRulesForDoc by building a temp wsState shape
    const tmpState = { rules: rawRules, fieldRules: rawFieldR };
    const baseline = headingsBaseline || { flat: [], tree: [] };
    const normalized = normalizeAllForDoc(tmpState, nextSchema, baseline);

    const pruned = pruneBySchema(nextSchema, rawValues, rawTagMap);

    schema = nextSchema;
    values = pruned.values;
    tagMap = pruned.tagMap;

    const payloadObj = {
      title: schema.title || 'Form',
      fields: schema.fields || [],
      values,
      tagMap,
      rules: normalized.headingRules,
      fieldRules: normalized.fieldRules,
      updatedAt: new Date().toISOString()
    };

    if (currentDoc?.docId) {
      await saveWorkspaceMirror(currentDoc.docId, payloadObj, { baseline });
      bc?.postMessage({ type: 'state:changed', docId: currentDoc.docId, ts: Date.now() });
    }

    buildForm(els.formMount, schema, values);
    await updatePreview();

    if (els.previewStatus) {
      els.previewStatus.textContent = 'Applied';
      setTimeout(() => { els.previewStatus.textContent = ''; }, 900);
    }

    tr.end({ ok: true, fields: schema.fields.length });
    return true;
  } catch (e) {
    tr.error('applyPayloadObject failed', e);
    if (els.previewStatus) els.previewStatus.textContent = 'Apply failed (see console)';
    tr.end({ ok: false });
    return false;
  }
}

/* ============================================================
   Save: payload-only write into DOCX, then update workspace + broadcast
   ============================================================ */
async function doSave() {
  const tr = TRACE('doSave', { docId: currentDoc?.docId });
  try {
    if (!currentDoc?.docId) { setStatus('No active document.'); return; }

    const docId = currentDoc.docId;
    const st = await window.formSuitePersist.loadState(docId) || {};
    const baseline = {
      flat: Array.isArray(st.headingsFlat) ? st.headingsFlat : (lastParsedHeadings.flat || []),
      tree: Array.isArray(st.headingsTree) ? st.headingsTree : (lastParsedHeadings.tree || [])
    };

    // Ensure current UI values are included
    const liveVals = collectFormValues(schema);
    values = { ...(values || {}), ...(liveVals || {}) };

    // Normalize rules one time, and build canonical payload object
    const normalized = normalizeAllForDoc(st, schema, baseline);
    const pruned = pruneBySchema(schema, values, tagMap);

    const payloadObj = {
      title: schema.title || 'Form',
      fields: schema.fields || [],
      values: pruned.values,
      tagMap: pruned.tagMap,
      rules: normalized.headingRules,
      fieldRules: normalized.fieldRules,
      updatedAt: new Date().toISOString()
    };

    // Get bytes and write payload
    const inBytes = await getWorkingDocBytesU8();
    if (!inBytes) {
      setStatus('No bytes / no permission (cannot save).');
      tr.end('no-bytes');
      return;
    }

    const outBytes = await writePayloadToDocx(inBytes, payloadObj);

    // Write back:
    // 1) If we have write permission on original handle -> overwrite original
    // 2) Else -> Save As copy, and switch active doc to new handle/meta
    let wroteToOriginal = false;

    const h = currentHandle || await window.formSuitePersist.getHandle?.(docId);
    const p = h?.queryPermission ? await h.queryPermission({ mode: 'readwrite' }) : 'denied';

    if (h?.createWritable && p === 'granted') {
      const wt = TRACE('doSave:writeOriginal');
      try {
        const w = await h.createWritable();
        await w.write(outBytes);
        await w.close();
        currentHandle = h;
        wroteToOriginal = true;
        wt.end({ ok: true, len: outBytes.byteLength, sha: (await sha256Hex(outBytes)).slice(0, 12) });
      } catch (e) {
        wt.error('writeOriginal failed', e);
        wt.end({ ok: false });
        wroteToOriginal = false;
      }
    }

    if (!wroteToOriginal) {
      const wt = TRACE('doSave:saveAsCopy');
      try {
        if (!supportsFS) throw new Error('File System Access API not supported');

        const suggested = (currentDoc?.name ? splitNameAndExt(currentDoc.name).base : 'document') + '.docx';

        const saveHandle = await showSaveFilePicker({
          suggestedName: suggested,
          excludeAcceptAllOption: true,
          types: [{
            description: 'Word document',
            accept: { 'application/vnd.openxmlformats-officedocument.wordprocessingml.document': ['.docx'] }
          }]
        });

        const w = await saveHandle.createWritable();
        await w.write(outBytes);
        await w.close();

        // Switch the active doc to the copy (future-proof: treat it as new doc)
        const file = await saveHandle.getFile();
        const bytes = new Uint8Array(await file.arrayBuffer());
        const meta = await window.formSuitePersist.setCurrentDoc({
          bytes,
          handle: saveHandle,
          name: file.name || 'document.docx'
        });

        currentDoc = meta;
        currentHandle = saveHandle;
        currentBytesU8 = bytes;

        try { if (typeof window.setActiveDocMeta === 'function') window.setActiveDocMeta({ docId: meta.docId, name: meta.name }); } catch {}
        bc?.postMessage({ type: 'active:set', docId: meta.docId, name: meta.name, ts: Date.now() });

        wt.end({ ok: true, newDocId: meta.docId, name: meta.name });
      } catch (e) {
        wt.error('saveAsCopy failed', e);
        setStatus('Save failed (no permission). See console.');
        wt.end({ ok: false });
        return;
      }
    }

    // Update workspace mirror (single) and broadcast update
    await saveWorkspaceMirror(currentDoc.docId, payloadObj, { baseline });
    bc?.postMessage({ type: 'active:updated', docId: currentDoc.docId, ts: Date.now() });

    await updateWriteAccessBanner();
    await updatePreview();

    setStatus('Saved payload to DOCX.');
    tr.end({ ok: true });
  } catch (e) {
    tr.error('doSave failed', e);
    setStatus('Save failed (see console).');
    tr.end({ ok: false });
  }
}

/* ============================================================
   Open / switch document
   ============================================================ */
async function doOpen() {
  const tr = TRACE('doOpen');
  try {
    if (!supportsFS) {
      alert('This browser does not support the File System Access API.');
      tr.end('unsupported');
      return;
    }

    clearUi('Opening…');

    const [handle] = await showOpenFilePicker({
      multiple: false,
      excludeAcceptAllOption: true,
      types: [{
        description: 'Word document',
        accept: {
          'application/vnd.openxmlformats-officedocument.wordprocessingml.document': ['.docx', '.docm', '.dotx', '.dotm']
        }
      }]
    });

    const file = await handle.getFile();
    const bytes = new Uint8Array(await file.arrayBuffer());

    const meta = await window.formSuitePersist.setCurrentDoc({
      bytes,
      handle,
      name: file.name || 'document.docx'
    });

    currentDoc = meta;
    currentHandle = handle;
    currentBytesU8 = bytes;

    try { if (typeof window.setActiveDocMeta === 'function') window.setActiveDocMeta({ docId: meta.docId, name: meta.name }); } catch {}
    bc?.postMessage({ type: 'active:set', docId: meta.docId, name: meta.name, ts: Date.now() });

    tr.step('opened', { docId: meta.docId, name: meta.name, len: bytes.byteLength, sha: (await sha256Hex(bytes)).slice(0, 12) });

    await renderFromBytes(bytes, { prefix: '' });
    await updateWriteAccessBanner({ tryPrompt: true });

    els.btnSave.disabled = false;
    els.btnSaveFromPreview.disabled = false;

    tr.end({ ok: true });
  } catch (e) {
    if (e?.name === 'AbortError') { setStatus('Idle'); tr.end('canceled'); return; }
    tr.error('doOpen failed', e);
    setStatus('Error opening file (see console).');
    tr.end({ ok: false });
  }
}

async function switchToDoc(meta) {
  const tr = TRACE('switchToDoc', meta);
  try {
    if (!meta?.docId) return;
    if (currentDoc?.docId === meta.docId && currentBytesU8?.byteLength) { tr.end('already active'); return; }

    clearUi('Switching document…');

    currentDoc = meta;
    currentHandle = null;
    currentBytesU8 = null;

    const bytes = await getWorkingDocBytesU8();
    if (!bytes) {
      clearUi('No bytes / no permission.');
      tr.end('no-bytes');
      return;
    }

    currentBytesU8 = bytes;
    await renderFromBytes(bytes, { prefix: '(switched) ' });
    await updateWriteAccessBanner();
    els.btnSave.disabled = false;
    els.btnSaveFromPreview.disabled = false;

    tr.end({ ok: true });
  } catch (e) {
    tr.error('switchToDoc failed', e);
    setStatus('Switch failed (see console).');
    tr.end({ ok: false });
  }
}

/* ============================================================
   One broadcast handler (only fs-active-doc)
   ============================================================ */
bc?.addEventListener('message', async (ev) => {
  const tr = TRACE('BroadcastChannel:message', ev?.data);
  try {
    const m = ev.data || {};
    if (!m || typeof m !== 'object') return;

    if (m.type === 'active:set') {
      if (m.docId && m.docId !== currentDoc?.docId) {
        await switchToDoc({ docId: m.docId, name: m.name || 'document.docx' });
      }
      return;
    }

    if (m.type === 'active:updated') {
      if (m.docId && m.docId === currentDoc?.docId) {
        await rehydrateOnForeground('active:updated');
      }
      return;
    }

    if (m.type === 'active:clear') {
      currentDoc = null;
      currentHandle = null;
      currentBytesU8 = null;
      schema = { title: 'Form', fields: [] };
      values = {};
      tagMap = {};
      clearUi('Cleared.');
      return;
    }

    if (m.type === 'state:changed') {
      if (!m.docId || m.docId === currentDoc?.docId) {
        // override-safe: re-render only from workspace state/bytes
        await updatePreview();
      }
      return;
    }
  } catch (e) {
    tr.error('BC handler failed', e);
  } finally {
    tr.end();
  }
});

/* ============================================================
   Active-doc listener (single coordination layer)
   ============================================================ */
installActiveDocListener(async (meta) => {
  const tr = TRACE('installActiveDocListener:cb', meta);
  try {
    if (!meta?.docId) {
      currentDoc = null;
      clearUi('No active document. Open one.');
      tr.end('cleared');
      return;
    }
    currentDoc = meta;
    await switchToDoc(meta);
  } catch (e) {
    tr.error('active doc listener failed', e);
  } finally {
    tr.end();
  }
});

/* ============================================================
   Preview textarea: validate + apply (manual apply via button)
   - We do NOT auto-save on every keystroke into DOCX.
   - Button "Apply JSON & Save" applies to workspace + triggers doSave().
   ============================================================ */
function tryParseJSON(txt) { try { return JSON.parse(txt); } catch { return null; } }

let __previewDirty = false;
els.payloadPreview?.addEventListener('input', () => {
  __previewDirty = true;
  if (!els.previewStatus) return;
  const obj = tryParseJSON(els.payloadPreview.value);
  els.previewStatus.textContent = obj ? 'JSON ok' : 'Invalid JSON';
});

els.btnSaveFromPreview?.addEventListener('click', async () => {
  const tr = TRACE('btnSaveFromPreview:click', { dirty: __previewDirty });
  try {
    const obj = tryParseJSON(els.payloadPreview.value);
    if (!obj) {
      if (els.previewStatus) els.previewStatus.textContent = 'Invalid JSON';
      tr.end('invalid-json');
      return;
    }
    await applyPayloadObject(obj);
    await doSave();
    __previewDirty = false;
  } catch (e) {
    tr.error('Apply+Save failed', e);
  } finally {
    tr.end();
  }
});

/* ============================================================
   Wiring
   ============================================================ */
els.btnOpen.addEventListener('click', doOpen);
els.btnSave.addEventListener('click', doSave);

els.btnRegrant?.addEventListener('click', async () => {
  const tr = TRACE('btnRegrant:click');
  try {
    await updateWriteAccessBanner({ tryPrompt: true });
  } catch (e) {
    tr.error('regrant failed', e);
    els.permNote.style.display = 'block';
  } finally {
    tr.end();
  }
});

window.addEventListener('beforeunload', async () => {
  const tr = TRACE('beforeunload');
  try {
    if (!currentDoc?.docId) { tr.end('no doc'); return; }
    const vals = collectFormValues(schema);
    await window.formSuitePersist.saveState(currentDoc.docId, {
      schema,
      values: { ...(values || {}), ...(vals || {}) }
    });
    try { if (typeof window.setActiveDocMeta === 'function') window.setActiveDocMeta({ docId: currentDoc.docId, name: currentDoc.name }); } catch {}
  } catch (e) {
    tr.warn('beforeunload failed', e);
  } finally {
    tr.end();
  }
});

/* ============================================================
   Boot
   ============================================================ */
(async function boot() {
  const tr = TRACE('boot');
  try {
    if (!assertDeps()) { tr.end('deps-missing'); return; }

    const meta = (typeof window.readActiveDocSync === 'function') ? window.readActiveDocSync() : null;
    tr.step('readActiveDocSync', meta);

    if (!meta?.docId) {
      clearUi('Idle');
      tr.end('no-meta');
      return;
    }

    currentDoc = meta;
    clearUi('Restoring document…');

    const bytes = await getWorkingDocBytesU8();
    if (!bytes) {
      clearUi('No bytes / no permission.');
      tr.end('no-bytes');
      return;
    }

    currentBytesU8 = bytes;

    tr.step('restored', {
      docId: meta.docId,
      name: meta.name,
      len: bytes.byteLength,
      sha: (await sha256Hex(bytes)).slice(0, 12)
    });

    await renderFromBytes(bytes, { prefix: '(restored) ' });
    await updateWriteAccessBanner();

    els.btnSave.disabled = false;
    els.btnSaveFromPreview.disabled = false;

    tr.end('ok');
  } catch (e) {
    tr.error('boot failed', e);
    clearUi('Boot failed (see console).');
    tr.end('fail');
  }
})();

/* ============================================================
   Logo nav (triple-click)
   ============================================================ */
try { window.installLogoFocusNav?.(); } catch (e) { console.warn('[Extractor] installLogoFocusNav failed', e); }

</script>
</body>
</html>
