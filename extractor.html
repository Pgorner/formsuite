<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Form Suite — Extractor</title>
  <link rel="icon" href="favicon.ico" type="image/gif" sizes="32x32">
  <link rel="shortcut icon" href="favicon.ico" type="image/gif">
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
  <link rel="stylesheet" href="style.css">

  <!-- Persistence layer (provides window.formSuitePersist) -->
  <script src="persistence.js"></script>
  <!-- flatpickr JS (date inputs) -->
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <!-- JSZip for JS-based SDT scanning (parity with Tag Matcher) -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <!-- for the autocompletion of the adress-->
  <script src="address-autocomplete.js"></script>
</head>
<body>
  <header>
    <div class="row">
      <span class="brand logo-md">
        <img src="logo.gif" alt="Form Suite logo" class="logo" />
        <strong>Form Suite</strong>
      </span>
      <span class="muted">·</span><a href="index.html">Form</a>
      <span class="muted">·</span><a href="builder.html" id="openBuilder">Form Builder</a>
      <span class="muted">·</span><a href="matcher.html">Tag Matcher</a>
      <span class="muted">·</span><a href="rules.html">Rules</a>
      <span class="muted">·</span><span class="muted">Extractor</span>
    </div>
  </header>

  <main>
    <section class="panel">
      <h2 style="margin:0 0 10px">Inspect SDTs & store manual form payload in the DOCX</h2>
      <div class="row" style="gap:8px;flex-wrap:wrap">
        <button id="btnOpen">Open DOCX…</button>
        <button id="btnSave" disabled>Save (payload only)</button>
        <button id="btnExport" disabled>Export (payload + replace tags)</button>
        <span class="muted" id="status" style="margin-left:auto">Idle</span>
      </div>

      <!-- Restored banner -->
      <div id="permNote" class="note warn" style="display:none;margin-top:10px">
        This DOCX was opened via picker but I don’t have write permission to the original file.
        Clicking <em>Save</em> will download a copy instead of writing back.
        <button id="btnRegrant" class="ghost" style="margin-left:8px">Grant write access</button>
      </div>
    </section>

    <div class="grid-3">
      <section class="panel">
        <details>
          <summary><strong>Found SDTs</strong></summary>
          <div style="overflow:auto;">
            <table id="sdt-table">
              <thead>
                <tr>
                  <th>#</th>
                  <th>Part</th>
                  <th>w:tag</th>
                  <th>w:alias</th>
                  <th>Text</th>
                </tr>
              </thead>
              <tbody id="sdt-tbody"></tbody>
            </table>
          </div>
        </details>
      </section>

      <section class="panel">
        <details>
          <summary><strong>CRONOS_PAYLOAD Preview</strong></summary>
          <textarea id="payloadPreview" spellcheck="false" style="min-height:420px"></textarea>
          <div class="row" style="margin-top:6px; gap:8px;">
            <button id="btnSaveFromPreview" class="secondary" disabled>Save</button>
            <span class="muted" id="previewStatus"></span>
          </div>
        </details>
      </section>

      <section class="panel">
        <details>
          <summary><strong>Headers/Subheaders</strong></summary>
          <div id="headersTree" class="tree" style="max-height:420px;overflow:auto;padding:6px 4px;"></div>
        </details>
      </section>

      <section class="panel">
        <details>
          <summary><strong>Live Form (from payload schema)</strong></summary>
          <div id="formMount"></div>
        </details>
      </section>
    </div>
  </main>

  <script>
    // =========================
    // 🔎 DEBUG / TRACE PRIMITIVES
    // =========================
    const DEBUG = { on: true, seq: 0 };
    const _t = () => new Date().toISOString().slice(11, 23);
    const tag = (name) => `%c[Extractor ${_t()} #${++DEBUG.seq}] ${name}`;
    const tagStyle = 'color:#6b7280;font-weight:600';

    function TRACE(name, details) {
      const label = `${name} :: ${_t()} :: #${DEBUG.seq+1}`;
      console.groupCollapsed(tag(name), tagStyle, details ?? '');
      console.time(label);
      return {
        step: (msg, data) => console.log(tag(`  ↳ ${msg}`), tagStyle, data ?? ''),
        warn: (msg, data) => console.warn(tag(`  ⚠ ${msg}`), tagStyle, data ?? ''),
        error: (msg, err) => console.error(tag(`  ✖ ${msg}`), tagStyle, err),
        end: (extra) => { if (extra) console.log(tag('done'), tagStyle, extra); console.timeEnd(label); console.groupEnd(); }
      };
    }

    window.addEventListener('error', (e) => {
      console.error(tag('window.error'), tagStyle, { message: e.message, filename: e.filename, lineno: e.lineno, colno: e.colno, error: e.error });
    });
    window.addEventListener('unhandledrejection', (e) => {
      console.error(tag('window.unhandledrejection'), tagStyle, e.reason);
    });

    // =========================
    // CONSTANTS & STATE
    // =========================
    const STORAGE_KEY  = 'FORM_SCHEMA_V1';
    const PAYLOAD_KEY  = 'CRONOS_PAYLOAD';
    const META_LS_KEY  = 'FS_CURRENT_DOC_META';       // legacy mirror
    const ACTIVE_LS_KEY= 'FS_ACTIVE_DOC_META';        // canonical
    const supportsFS   = 'showOpenFilePicker' in window && 'showSaveFilePicker' in window;

    let gArrayBuffer   = null;
    let gFileName      = null;  // name without .docx
    let gFileHandle    = null;  // FileSystemFileHandle
    let gSchema        = { title: 'Form', fields: [] };
    let gValues        = {};
    let gDocId         = null;
    let gDirty         = false;
    let gSDTs          = [];
    let gLastSchemaPushTs = 0;
    let gPreferDocOnNextLoad = false;   // prefer DOCX payload only right after doOpen()
    let gFileExt = 'docx'; // 'docx' | 'docm' | 'dotx' | 'dotm'

    // NEW: hold structured address values while editing
    const __addressValues = Object.create(null);

    // UI refs
    const btnOpen   = document.getElementById('btnOpen');
    const btnSave   = document.getElementById('btnSave');
    const btnExport = document.getElementById('btnExport');
    const statusEl  = document.getElementById('status');
    const permNote  = document.getElementById('permNote');
    const payloadEl = document.getElementById('payloadPreview');
    const formMount = document.getElementById('formMount');
    const tableBody = document.getElementById('sdt-tbody');
    const btnRegrant= document.getElementById('btnRegrant');
    const btnSaveFromPreview = document.getElementById('btnSaveFromPreview');
    const previewStatus = document.getElementById('previewStatus');
    const headersTreeEl = document.getElementById('headersTree');

    function splitNameAndExt(fileName) {
      const m = String(fileName).match(/\.(docx|docm|dotx|dotm)$/i);
      return {
        base: String(fileName).replace(/\.(docx|docm|dotx|dotm)$/i, ''),
        ext:  (m ? m[1] : 'docx').toLowerCase()
      };
    }

    function wordMimeFor(ext) {
      switch ((ext || '').toLowerCase()) {
        case 'docm': return 'application/vnd.ms-word.document.macroEnabled.12';
        case 'dotx': return 'application/vnd.openxmlformats-officedocument.wordprocessingml.template';
        case 'dotm': return 'application/vnd.ms-word.template.macroEnabled.12';
        default:     return 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';
      }
    }

    async function sha256Hex(bufOrU8) {
      const tr = TRACE('sha256Hex', { type: (bufOrU8?.constructor?.name), len: bufOrU8?.byteLength || bufOrU8?.length });
      try {
        const ab = (bufOrU8 instanceof ArrayBuffer) ? bufOrU8
                  : (bufOrU8?.buffer instanceof ArrayBuffer) ? bufOrU8.buffer
                  : new Uint8Array(bufOrU8 || []).buffer;
        const d = await crypto.subtle.digest('SHA-256', ab);
        const hex = [...new Uint8Array(d)].map(b => b.toString(16).padStart(2, '0')).join('');
        tr.end({ hex });
        return hex;
      } catch (e) { tr.error('sha failed', e); tr.end(); return '(hash-error)'; }
    }

    const setStatus = (m) => {
      const tr = TRACE('setStatus', { text: m });
      try { statusEl.textContent = m; } finally { tr.end(); }
    };

    // ===== Helpers to normalize/compact Pyodide byte outputs =====
    const toU8 = (x) => (x instanceof Uint8Array ? x : new Uint8Array(x));
    const compactU8 = (u8) => (u8.byteOffset === 0 && u8.byteLength === u8.buffer.byteLength) ? u8 : u8.slice();

    // =========================
    // PERSISTENCE SHIM (if missing)
    // =========================
    (function ensurePersist() {
      const tr = TRACE('ensurePersist');
      try {
        if (window.formSuitePersist) { tr.step('already present'); tr.end(); return; }
        tr.step('installing shim');
        let _meta = null;
        let _state = {};
        window.formSuitePersist = {
          getCurrentDocMeta() { tr.step('shim.getCurrentDocMeta', _meta); return _meta; },
          setCurrentDoc: async ({ bytes, handle, name }) => { tr.step('shim.setCurrentDoc', { bytes: !!bytes, name, handle: !!handle }); _meta = { docId: 'inline-' + Date.now(), name: name || 'document' }; return _meta; },
          setCurrentDocFromBytes: async (bytes, meta) => { tr.step('shim.setCurrentDocFromBytes', { bytes: !!bytes, meta }); _meta = { docId: 'inline-' + Date.now(), name: meta?.name || 'document' }; return _meta; },
          getCurrentDocBytes: async () => { tr.step('shim.getCurrentDocBytes -> null'); return null; },
          getBytes: async (_docId) => { tr.step('shim.getBytes -> null', _docId); return null; },
          getHandle: async (_docId) => { tr.step('shim.getHandle -> null', _docId); return null; },
          saveState: async (_docId, obj) => { tr.step('shim.saveState', { docId:_docId, keys:Object.keys(obj||{}) }); _state = { ..._state, ...(obj||{}) }; },
          loadState: async (_docId) => { tr.step('shim.loadState', { docId:_docId }); return _state; },
          putBytes: async (_docId, _bytes) => { tr.step('shim.putBytes', { docId:_docId, len: _bytes?.byteLength }); },
          ensurePermission: async (_h, _mode) => { tr.step('shim.ensurePermission', { mode:_mode }); return 'granted'; }
        };
      } finally { tr.end(); }
    })();

    // =========================
    // CROSS-TAB + LOCALSTORAGE
    // =========================
    const bcLegacy = ('BroadcastChannel' in window) ? new BroadcastChannel('form-suite-doc') : null;
    const bcCanon  = ('BroadcastChannel' in window) ? new BroadcastChannel('fs-active-doc') : null;

    function persistActiveMeta(meta) {
      try { localStorage.setItem(ACTIVE_LS_KEY, JSON.stringify({ docId: meta?.docId, name: meta?.name })); } catch {}
      try { localStorage.setItem(META_LS_KEY,   JSON.stringify({ docId: meta?.docId, name: meta?.name })); } catch {}
      try { bcCanon?.postMessage({ type: 'active:set', docId: meta?.docId, name: meta?.name, ts: Date.now() }); } catch {}
      try { bcLegacy?.postMessage({ type: 'doc-switched', docId: meta?.docId, name: meta?.name, ts: Date.now() }); } catch {}
    }
    function readActiveMeta() {
      try {
        const v = localStorage.getItem(ACTIVE_LS_KEY) || localStorage.getItem(META_LS_KEY);
        return v ? JSON.parse(v) : null;
      } catch { return null; }
    }
    function announceDocSwitch() {
      persistActiveMeta({ docId: gDocId, name: gFileName });
    }
    function announceDocUpdate() {
      try { bcLegacy?.postMessage({ type: 'doc-updated', docId: gDocId, name: gFileName, ts: Date.now() }); } catch {}
      try { bcCanon?.postMessage({ type: 'active:updated', docId: gDocId, name: gFileName, ts: Date.now() }); } catch {}
    }
    function clearActiveMeta() {
      try { localStorage.removeItem(ACTIVE_LS_KEY); } catch {}
      try { localStorage.removeItem(META_LS_KEY); } catch {}
      try { bcCanon?.postMessage({ type: 'active:clear', ts: Date.now() }); } catch {}
      try { bcLegacy?.postMessage({ type: 'doc-cleared', ts: Date.now() }); } catch {}
    }

    function clearUiForNewDoc(message = 'Loading new document…') {
      try {
        tableBody.innerHTML = '<tr><td colspan="5" class="empty">Loading…</td></tr>';
        formMount.innerHTML = '<div class="empty">No schema found.</div>';
        payloadEl.value = '';
        previewStatus.textContent = '';
        if (headersTreeEl) headersTreeEl.innerHTML = '<div class="empty">No headings.</div>';
        btnSave.disabled = true; btnExport.disabled = true; btnSaveFromPreview.disabled = true;
        permNote.style.display = 'none';
        setStatus(message);
      } catch {}
      gSchema = { title: 'Form', fields: [] };
      gValues = {};
      gDirty = false;
    }

    async function hardResetDocContext(reason = '') {
      const tr = TRACE('hardResetDocContext:start', { reason, docId: gDocId });
      try {
        if (gDocId) {
          await window.formSuitePersist?.saveState?.(gDocId, {});
          try { await window.formSuitePersist?.putBytes?.(gDocId, new Uint8Array()); } catch (e) { tr.warn('putBytes failed', e); }
        }
      } catch (e) { tr.error('saveState failed', e); }
      gArrayBuffer = null; gFileHandle = null; gFileName = null; gDocId = null; gSDTs = [];
      clearActiveMeta();
      try {
        tableBody.innerHTML = '<tr><td colspan="5" class="empty">No document loaded.</td></tr>';
        formMount.innerHTML = '<div class="empty">No schema found.</div>';
        payloadEl.value = '';
        previewStatus.textContent = '';
        btnSave.disabled = true; btnExport.disabled = true; btnSaveFromPreview.disabled = true;
        permNote.style.display = 'none';
        setStatus(reason ? `Cleared: ${reason}` : 'Cleared.');
      } catch (e) { tr.warn('DOM reset failed', e); }
      try { if (headersTreeEl) headersTreeEl.innerHTML = '<div class="empty">No headings.</div>'; } catch {}
      tr.end('reset complete');
    }

    // --- Broadcast listeners (legacy + canonical) ---
    bcLegacy?.addEventListener?.('message', async (ev) => {
      const tr = TRACE('BroadcastChannel(legacy):message', ev?.data);
      try {
        const m = ev.data || {};
        if (m.type === 'doc-switched' && m.docId && m.docId !== gDocId) {
          clearUiForNewDoc('Switching to another document…');
          let bytes = await window.formSuitePersist.getBytes?.(m.docId) || await window.formSuitePersist.getCurrentDocBytes?.();
          if (!bytes) { await hardResetDocContext('no bytes / no permission'); return; }
          gArrayBuffer = bytes.buffer ?? bytes;
          gFileName = m.name || gFileName;
          gDocId = m.docId;
          await renderFromCurrentBytes('(switched by other tab) ');
          await updateWriteAccessBanner();
        }
        if (m.type === 'doc-updated' && m.docId && m.docId === gDocId) {
          let bytes = await window.formSuitePersist.getBytes?.(gDocId) || await window.formSuitePersist.getCurrentDocBytes?.();
          if (!bytes) { await hardResetDocContext('no bytes / no permission'); return; }
          gArrayBuffer = bytes.buffer ?? bytes;
          await renderFromCurrentBytes('(updated by other tab) ');
          await updateWriteAccessBanner();
        }
        if (m.type === 'schema-updated' && m.docId && m.docId === gDocId) {
          gLastSchemaPushTs = m.ts || Date.now();
          const st = await window.formSuitePersist.loadState(gDocId);
          if (st?.schema) {
            const domVals = collectFormValues(st.schema);
            const wsVals  = st.values || {};
            gSchema = st.schema;
            gValues = { ...wsVals, ...domVals };
            buildForm(formMount, gSchema, gValues);
            await updatePreview(gValues);
            setStatus('Schema updated from Form Builder.');
          }
        }
        if (m.type === 'doc-cleared') {
          await hardResetDocContext('cleared by another tab');
        }
      } finally { tr.end(); }
    });

    bcCanon?.addEventListener?.('message', async (ev) => {
      const tr = TRACE('BroadcastChannel(canon):message', ev?.data);
      try {
        const m = ev.data || {};
        if (m.type === 'active:set') {
          if (m.docId && m.docId !== gDocId) {
            clearUiForNewDoc('Switching to another document…');
            let bytes = await window.formSuitePersist.getBytes?.(m.docId) || await window.formSuitePersist.getCurrentDocBytes?.();
            if (!bytes) { await hardResetDocContext('no bytes / no permission'); return; }
            gArrayBuffer = bytes.buffer ?? bytes;
            gFileName = m.name || gFileName;
            gDocId = m.docId;
            await renderFromCurrentBytes('(switched by other tab) ');
            await updateWriteAccessBanner();
          }
        }
        if (m.type === 'active:updated' && m.docId && m.docId === gDocId) {
          let bytes = await window.formSuitePersist.getBytes?.(gDocId) || await window.formSuitePersist.getCurrentDocBytes?.();
          if (!bytes) return;
          gArrayBuffer = bytes.buffer ?? bytes;
          await renderFromCurrentBytes('(updated by other tab) ');
        }
        if (m.type === 'active:clear') await hardResetDocContext('cleared by another tab');
      } finally { tr.end(); }
    });

    // --- Storage listeners (canonical first, legacy as fallback) ---
    window.addEventListener('storage', async (e) => {
      const tr = TRACE('storage:event', { key:e.key, newValue: !!e.newValue });
      try {
        if ((e.key === ACTIVE_LS_KEY || e.key === META_LS_KEY) && e.newValue) {
          const meta = JSON.parse(e.newValue || 'null');
          if (!meta?.docId || meta.docId === gDocId) return;
          clearUiForNewDoc('Switching to another document…');
          let bytes = await window.formSuitePersist.getBytes?.(meta.docId) || await window.formSuitePersist.getCurrentDocBytes?.();
          if (!bytes) { await hardResetDocContext('no bytes / no permission'); return; }
          gArrayBuffer = bytes.buffer ?? bytes;
          gFileName = meta.name || gFileName;
          gDocId = meta.docId;
          await renderFromCurrentBytes('(switched by other tab) ');
          await updateWriteAccessBanner();
        }
      } finally { tr.end(); }
    });

    // =========================
    // STABLE FOREGROUND REFRESH
    // =========================
    let __fgRefreshLock = false;
    async function safeGetBytes(docId) {
      const tr = TRACE('safeGetBytes', { docId });
      try {
        let bytes = await window.formSuitePersist.getBytes?.(docId);
        if (bytes) { tr.end({ src:'opfs', len: bytes.byteLength || bytes.length }); return bytes; }

        bytes = await window.formSuitePersist.getCurrentDocBytes?.();
        if (bytes) { tr.end({ src:'currentDocBytes', len: bytes.byteLength || bytes.length }); return bytes; }

        const h = await window.formSuitePersist.getHandle?.(docId);
        if (h?.getFile) {
          try {
            const f = await h.getFile();
            bytes = await f.arrayBuffer();
            tr.end({ src:'handle.getFile', len: bytes.byteLength || bytes.length });
            return bytes;
          } catch (e) { tr.warn('handle.getFile failed', e); }
        }

        tr.end({ src:'none' });
        return null;
      } catch (e) { tr.error('safeGetBytes failed', e); tr.end(); return null; }
    }

    async function rehydrateOnForeground(source) {
      const tr = TRACE('rehydrateOnForeground', { source, docId: gDocId, locked: __fgRefreshLock });
      if (__fgRefreshLock) { tr.step('locked; skip'); tr.end(); return; }
      __fgRefreshLock = true;
      try {
        if (!gDocId) { tr.step('no docId'); return; }

        await new Promise(r => setTimeout(r, 120));

        let bytes = await safeGetBytes(gDocId);
        if (!bytes) {
          await new Promise(r => setTimeout(r, 120));
          bytes = await safeGetBytes(gDocId);
        }

        if (bytes) {
          gArrayBuffer = bytes.buffer ?? bytes;
          await renderFromCurrentBytes(`(${source} refreshed) `);
          await updateWriteAccessBanner();
          tr.end('refreshed');
          return;
        }

        if (gArrayBuffer?.byteLength) {
          setStatus(`Refresh skipped (${source}): no bytes yet; keeping current.`);
          await updateWriteAccessBanner();
          tr.end('kept current buffer');
          return;
        }

        const h = await window.formSuitePersist.getHandle?.(gDocId);
        if (h) {
          setStatus(`Refresh postponed (${source}): handle exists; waiting for bytes.`);
          await updateWriteAccessBanner();
          tr.end('postponed; has handle');
          return;
        }

        await hardResetDocContext('lost access');
        tr.end('hard reset');
      } catch (e) {
        tr.error('rehydrate failed', e);
      } finally {
        __fgRefreshLock = false;
      }
    }

    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible') rehydrateOnForeground('visible');
    });
    window.addEventListener('focus', () => {
      rehydrateOnForeground('focus');
    });

    // =========================
    // ✅ WRITE ACCESS BANNER / PROMPT
    // =========================
    async function updateWriteAccessBanner({ tryPrompt = false } = {}) {
      const tr = TRACE('updateWriteAccessBanner', { tryPrompt, docId: gDocId, supportsFS });
      try {
        if (!supportsFS || !gDocId) { permNote.style.display = 'none'; tr.end('unsupported/no-doc'); return 'unsupported'; }

        let handle = gFileHandle || await window.formSuitePersist.getHandle?.(gDocId);
        if (!handle || !handle.queryPermission) { permNote.style.display = 'none'; tr.end('no-handle'); return 'no-handle'; }

        let p = await handle.queryPermission({ mode: 'readwrite' });
        tr.step('queryPermission', p);

        if (p !== 'granted' && tryPrompt) {
          try {
            const r = await handle.requestPermission({ mode: 'readwrite' });
            p = r || p;
            tr.step('requestPermission', r);
          } catch (e) {
            tr.warn('requestPermission failed', e);
          }
        }

        permNote.style.display = (p === 'granted') ? 'none' : 'block';
        if (p === 'granted') gFileHandle = handle;

        tr.end({ final: p });
        return p || 'denied';
      } catch (e) {
        tr.error('updateWriteAccessBanner failed', e);
        permNote.style.display = 'block';
        return 'error';
      }
    }

    // =========================
    // TAG MAP / PREVIEW HELPERS
    // =========================

    // ---------- Rules pruning against schema (NEW) ----------
    function getValidFieldIdSet(schema) {
      return new Set((schema?.fields || []).map(f => String(f.id)));
    }

    /**
     * Keep only rules whose `fieldId` exists in the schema.
     * Also prune condition references to non-existing fields.
     * Targets (heading indices) are kept if they look numeric.
     */
    function normalizeRulesForSchema(schema, rulesIn) {
      const rules = Array.isArray(rulesIn) ? rulesIn : [];
      const valid = getValidFieldIdSet(schema);
      const out = [];

      for (const r of rules) {
        if (!r) continue;
        const fieldId = String(r.fieldId ?? r.field ?? r.whenField ?? '');
               if (!fieldId || !valid.has(fieldId)) continue; // drop whole rule

        const rr = JSON.parse(JSON.stringify(r)); // safe clone

        if (Array.isArray(rr.conditions)) {
          rr.conditions = rr.conditions.filter(c => {
            if (!c) return false;
            const ref = c.fieldId ?? c.leftFieldId ?? c.rightFieldId;
            return !ref || valid.has(String(ref));
          });
        }

        // Keep only numeric-like targets (heading indices)
        if (Array.isArray(rr.targets)) {
          rr.targets = rr.targets.filter(t => {
            const key = t?.key ?? t?.idx ?? t?.id;
            if (key == null) return false;
            const n = Number(key);
            return Number.isFinite(n) && n > 0;
          });
        }

        out.push(rr);
      }
      return out;
    }

    function normalizeRules(rules){
      return Array.isArray(rules) ? rules : [];
    }

    function normalizeForSchema(schema, values, tagMap) {
      const fieldIds = new Set((schema?.fields || []).map(f => String(f.id)));
      const prunedValues = {};
      for (const [k, v] of Object.entries(values || {})) {
        if (fieldIds.has(String(k))) prunedValues[k] = v;
      }
      // Optional: keep tagMap only if it points to an existing field id
      const prunedTagMap = {};
      for (const [tag, fieldId] of Object.entries(tagMap || {})) {
        if (fieldIds.has(String(fieldId))) prunedTagMap[tag] = fieldId;
      }
      return { values: prunedValues, tagMap: prunedTagMap };
    }

    async function getTagMapFor(docId) {
      const tr = TRACE('getTagMapFor', { docId });
      try {
        const state = docId ? (await window.formSuitePersist.loadState(docId)) : null;
        const tagMap = (state?.payload?.CRONOS_PAYLOAD?.tagMap)
                    || (state?.cronos_payload?.tagMap)
                    || (state?.CRONOS_PAYLOAD?.tagMap)
                    || (state?.tagMap)
                    || {};
        tr.end({ tagCount: Object.keys(tagMap).length });
        return tagMap;
      } catch (e) { tr.error('failed', e); tr.end(); return {}; }
    }

    function loadSchemaFromLocalStorage() {
      const tr = TRACE('loadSchemaFromLocalStorage');
      try { const s = JSON.parse(localStorage.getItem(STORAGE_KEY) || 'null'); tr.end({ has:s?.fields?.length }); return s; }
      catch (e) { tr.error('parse fail', e); tr.end(); return null; }
    }

    // Collect values from the live form.
    // NEW: returns structured address objects from __addressValues.
    function collectFormValues(schema) {
      const tr = TRACE('collectFormValues', { fieldCount: schema?.fields?.length || 0 });
      try {
        const form = document.getElementById('liveForm');
        const out = {};
        if (!form || !schema) { tr.end('no form/schema'); return out; }
        for (const f of schema.fields) {
          if (f.type === 'multichoice') {
            const nodes = form.querySelectorAll(`input[type="checkbox"][name="${CSS.escape(f.id)}"]`);
            out[f.id] = Array.from(nodes).filter(n => n.checked).map(n => n.value);
            continue;
          }
          if (f.type === 'address') {
            out[f.id] = __addressValues[f.id] ?? null;
            continue;
          }
          const el = form.elements[f.id];
          out[f.id] = el ? el.value : null;
        }
        tr.end({ keys: Object.keys(out).length });
        return out;
      } catch (e) { tr.error('failed', e); tr.end(); return {}; }
    }

    async function updatePreview(values) {
      const tr = TRACE('updatePreview', { valueKeys: Object.keys(values||{}).length });
      try {
        if (!payloadEl) { tr.end('no payloadEl'); return; }

        const tagMapRaw = await getTagMapFor(gDocId);
        const wsState   = gDocId ? (await window.formSuitePersist.loadState(gDocId)) : null;

        // Workspace arrays
        const wsRules    = normalizeRules(wsState?.rules);
        const wsFieldR   = normalizeRules(wsState?.fieldRules);

        // Payload fallbacks (accept multiple common keys)
        const pl = wsState?.payload?.CRONOS_PAYLOAD
                || wsState?.CRONOS_PAYLOAD
                || wsState?.cronos_payload
                || {};
        const plRules    = normalizeRules(pl.rules);
        const plFieldR   = normalizeRules(pl.fieldRules);

        // Merge: prefer workspace if present, else payload
        const mergedRules  = wsRules.length  ? wsRules  : plRules;
        const mergedFieldR = wsFieldR.length ? wsFieldR : plFieldR;

        // Prune against current schema
        const rules      = normalizeRulesForSchema(gSchema, mergedRules);
        const fieldRules = normalizeRulesForSchema(gSchema, mergedFieldR);

        const { values: prunedValues, tagMap: prunedTagMap } =
          normalizeForSchema(gSchema, values || {}, tagMapRaw);

        payloadEl.value = JSON.stringify({
          title:  gSchema?.title || 'Form',
          fields: gSchema?.fields || [],
          values: prunedValues,
          tagMap: prunedTagMap,
          rules,
          fieldRules
        }, null, 2);

        tr.end({ ok:true });
      } catch (e) { tr.error('failed', e); tr.end(); }
    }


    let previewTimer = null;
    function schedulePreviewUpdate() {
      const tr = TRACE('schedulePreviewUpdate');
      try {
        clearTimeout(previewTimer);
        previewTimer = setTimeout(async () => {
          const tr2 = TRACE('previewUpdate:tick');
          try {
            const vals = collectFormValues(gSchema);
            if (gDocId) await window.formSuitePersist.saveState(gDocId, { schema: gSchema, values: vals });
            await updatePreview(vals);
            gDirty = true;
            setStatus('Unsaved changes — press Save to update DOCX.');
          } catch (e) { tr2.error('tick failed', e); }
          finally { tr2.end(); }
        }, 250);
      } finally { tr.end(); }
    }

    function buildForm(container, schema, values) {
      const tr = TRACE('buildForm', { fields: schema?.fields?.length || 0 });
      try {
        container.innerHTML = '';
        if (!schema || !Array.isArray(schema.fields) || schema.fields.length === 0) {
          container.innerHTML = '<div class="empty">No manual schema. Create one in the Builder, or load a DOCX that already contains a payload schema.</div>';
          tr.end('empty schema');
          return;
        }

        const form = document.createElement('form');
        form.id = 'liveForm';
        form.noValidate = true;
        form.style.display = 'grid';
        form.style.gap = '12px';

        if (schema.title) {
          const h = document.createElement('h4');
          h.textContent = schema.title;
          h.style.margin = '0 0 6px';
          form.appendChild(h);
        }

        for (const f of schema.fields) {
          const w = TRACE('buildForm:field', f);
          const wrap = document.createElement('div');
          wrap.className = 'field';
          const label = document.createElement('label');
          label.htmlFor = f.id;
          label.textContent = f.label || f.id || '(field)';
          label.style.display = 'flex';
          label.style.justifyContent = 'space-between';
          label.style.alignItems = 'center';
          if (f.required) {
            const star = document.createElement('span');
            star.textContent = '•'; star.title = 'required'; star.style.fontWeight = '600'; star.style.color = '#ef4444';
            label.appendChild(star);
          }
          wrap.appendChild(label);

          let input;

          if (f.type === 'multichoice') {
            const box = document.createElement('div');
            box.style.display = 'grid'; box.style.gap = '6px';
            (f.options || []).forEach(opt => {
              const id = `${f.id}__${String(opt?.value ?? opt).replace(/\s+/g,'_')}`;
              const row = document.createElement('label');
              row.style.display = 'flex'; row.style.gap = '8px'; row.style.alignItems = 'center';
              const cb = document.createElement('input');
              cb.type = 'checkbox'; cb.name = f.id; cb.id = id; cb.value = String(opt?.value ?? opt);
              if (Array.isArray(values?.[f.id]) && values[f.id].includes(cb.value)) cb.checked = true;
              const span = document.createElement('span'); span.textContent = String(opt?.label ?? opt?.text ?? opt?.value ?? opt);
              row.appendChild(cb); row.appendChild(span); box.appendChild(row);
            });
            wrap.appendChild(box);
            box.addEventListener('change', schedulePreviewUpdate);
            form.appendChild(wrap);
            w.end();
            continue;

          } else if (f.type === 'select') {
            input = document.createElement('select');
            (f.options || []).forEach(opt => {
              const o = document.createElement('option');
              o.value = String(opt?.value ?? opt?.id ?? opt);
              o.textContent = String(opt?.label ?? opt?.text ?? opt?.value ?? opt);
              input.appendChild(o);
            });

          } else if (f.type === 'date') {
            input = document.createElement('input'); input.type = 'text'; input.dataset.type = 'date'; input.dataset.format = f.dateFormat || 'Y-m-d';

          // NEW: Address field mounts AddressAuto and stores structured value in __addressValues
          } else if (f.type === 'address') {
            const mountDiv = document.createElement('div');
            mountDiv.className = 'address-field';
            wrap.appendChild(mountDiv);

            // Initial structured value (or upgrade from legacy string)
            const initial =
              typeof values?.[f.id] === 'string'
                ? { formatted: values[f.id] }
                : (values?.[f.id] || null);

            // seed local state for collectFormValues()
            __addressValues[f.id] = initial || null;

            try {
              AddressAuto.mount(mountDiv, {
                id: f.id,
                label: f.label || 'Address',
                required: !!f.required,
                value: initial || null,
                onChange: (val) => {
                  __addressValues[f.id] = val;     // keep full object
                  schedulePreviewUpdate();          // reflect in preview + persistence
                }
              });
            } catch (err) {
              // Fallback: plain text input if AddressAuto is unavailable
              const fallback = document.createElement('input');
              fallback.type = 'text';
              fallback.id = f.id;
              fallback.name = f.id;
              fallback.placeholder = 'Address';
              if (initial?.formatted) fallback.value = initial.formatted;
              fallback.addEventListener('input', () => {
                __addressValues[f.id] = { formatted: fallback.value };
                schedulePreviewUpdate();
              });
              mountDiv.appendChild(fallback);
            }

            form.appendChild(wrap);
            w.end();
            continue;

          } else {
            input = document.createElement('input'); input.type = 'text';
          }

          input.id = f.id; input.name = f.id;
          if (f.required) input.required = true;
          if (values && values[f.id] != null) input.value = values[f.id];

          input.addEventListener('change', schedulePreviewUpdate);
          input.addEventListener('input', schedulePreviewUpdate);
          wrap.appendChild(input);

          if (f.type === 'date') {
            setTimeout(() => {
              const tt = TRACE('flatpickr:init', { id: input.id, format: input.dataset.format });
              try {
                if (window.flatpickr) {
                  window.flatpickr(input, {
                    dateFormat: input.dataset.format || 'Y-m-d',
                    allowInput: true,
                    onChange: schedulePreviewUpdate,
                    onValueUpdate: schedulePreviewUpdate
                  });
                }
              } finally { tt.end(); }
            }, 0);
          }

          form.appendChild(wrap);
          w.end();
        }

        container.appendChild(form);
        tr.end('form built');
      } catch (e) { tr.error('failed', e); tr.end(); }
    }

    // =========================
    // SDT PARSING (JS)
    // =========================
    const W_NS = "http://schemas.openxmlformats.org/wordprocessingml/2006/main";
    function xmlText(el) {
      let s = '';
      const rec = n => {
        if (!n) return;
        if (n.nodeType === 3) { s += n.nodeValue; return; }
        if (n.nodeType === 1) {
          const ln = n.localName;
          if (ln === 'p' || ln === 'cr' || ln === 'br') s += '\n';
          for (const ch of n.childNodes) rec(ch);
        }
      };
      rec(el);
      return s.replace(/\s+\n/g,'\n').replace(/\n{3,}/g,'\n\n').trim();
    }

    async function parseSDTs_JS(arrayBuffer) {
      const tr = TRACE('parseSDTs_JS', { hasBuffer: !!arrayBuffer, len: arrayBuffer?.byteLength });
      try {
        if (!arrayBuffer) return { sdts: [], scan: [], total: 0 };
        const zip = await JSZip.loadAsync(arrayBuffer);
        const parts = zip.file(/^word\/(?!_rels\/|theme\/|fontTable\.xml|styles\.xml|numbering\.xml|settings\.xml|webSettings\.xml).*\.xml$/i) || [];
        tr.step('parts', parts.map(p => p.name));
        const parser = new DOMParser();
        const sdts = [];
        const scan = [];
        for (const f of parts) {
          const pf = TRACE('parseSDTs_JS:file', f.name);
          const xmlTextContent = await f.async('string');
          let err = null, countBefore = sdts.length;
          try {
            const xml = parser.parseFromString(xmlTextContent, "application/xml");
            const found = Array.from(xml.getElementsByTagNameNS(W_NS, 'sdt'));
            for (const sdt of found) {
              const pr = sdt.getElementsByTagNameNS(W_NS, 'sdtPr')[0];
              const content = sdt.getElementsByTagNameNS(W_NS, 'sdtContent')[0] || sdt;
              let tag = '', alias = '';
              if (pr) {
                const tEl = pr.getElementsByTagNameNS(W_NS, 'tag')[0];
                if (tEl) tag = tEl.getAttributeNS(W_NS, 'val') || tEl.getAttribute('w:val') || '';
                const aEl = pr.getElementsByTagNameNS(W_NS, 'alias')[0];
                if (aEl) alias = aEl.getAttributeNS(W_NS, 'val') || aEl.getAttribute('w:val') || '';
              }
              sdts.push({ part: f.name.split('/').pop().replace('.xml',''), tag, alias, text: xmlText(content) });
            }
          } catch (e) { err = e?.message || String(e); pf.warn('xml parse error', e); }
          scan.push({ path: f.name, part: f.name.split('/').pop().replace('.xml',''), size: xmlTextContent.length, sdt_count: sdts.length - countBefore, error: err });
          pf.end({ added: sdts.length - countBefore, error: err });
        }
        tr.end({ total: sdts.length, scanned: scan.length });
        return { sdts, scan, total: sdts.length };
      } catch (e) { tr.error('failed', e); tr.end(); return { sdts: [], scan: [], total: 0 }; }
    }

    // =========================
    // PYODIDE (payload/SDT writes)
    // =========================
    let pyodideReady = (async () => {
      const tr = TRACE('pyodide:bootstrap');
      try {
        const s = document.createElement('script');
        s.src = "https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js";
        document.head.appendChild(s);
        await new Promise(r => s.onload = r);
        const py = await loadPyodide({ indexURL: "https://cdn.jsdelivr.net/pyodide/v0.24.1/full/" });
        tr.step('pyodide loaded');
        await py.runPythonAsync(`
    import io, zipfile, json
    import xml.etree.ElementTree as ET
    _W_NS = "http://schemas.openxmlformats.org/wordprocessingml/2006/main"
    NS = {"w": _W_NS}
    def _q(local): return f"{{{_W_NS}}}{local}"

    def read_docvar_settings(doc_bytes: bytes, name: str) -> str | None:
        f = io.BytesIO(doc_bytes)
        with zipfile.ZipFile(f) as z:
            try: data = z.read("word/settings.xml")
            except KeyError: return None
        try: root = ET.fromstring(data)
        except ET.ParseError: return None
        docVars = root.find("w:docVars", NS)
        if docVars is None: return None
        for dv in docVars.findall("w:docVar", NS):
            if dv.attrib.get(_q("name")) == name:
                return dv.attrib.get(_q("val"), "") or ""
        return None

    def write_docvar_settings(doc_bytes: bytes, name: str, value: str) -> bytes:
        f_in = io.BytesIO(doc_bytes); out = io.BytesIO()
        with zipfile.ZipFile(f_in) as zin, zipfile.ZipFile(out, "w", zipfile.ZIP_DEFLATED) as zout:
            try: settings_xml = zin.read("word/settings.xml")
            except KeyError:
                settings_xml = b'<?xml version="1.0" encoding="UTF-8" standalone="yes"?><w:settings xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main"/>'
            for item in zin.infolist():
                if item.filename != "word/settings.xml":
                    zout.writestr(item, zin.read(item.filename))
            root = ET.fromstring(settings_xml)
            docVars = root.find("w:docVars", NS)
            if docVars is None: 
                docVars = ET.SubElement(root, _q("docVars"))
            target = None
            for dv in docVars.findall("w:docVar", NS):
                if dv.attrib.get(_q("name")) == name: 
                    target = dv; break
            if target is None:
                ET.SubElement(docVars, _q("docVar"), {_q("name"): name, _q("val"): value or ""})
            else:
                target.set(_q("val"), value or "")
            data = ET.tostring(root, encoding="utf-8", xml_declaration=True)
            zout.writestr("word/settings.xml", data)
        return out.getvalue()

    def read_docvar_custom(doc_bytes: bytes, name: str) -> str | None:
        f = io.BytesIO(doc_bytes)
        with zipfile.ZipFile(f) as z:
            try: docprops = z.read("docProps/custom.xml")
            except KeyError: return None
        try: root = ET.fromstring(docprops)
        except ET.ParseError: return None
        for v in root:
            if v.tag.endswith("property") and v.attrib.get("name") == name:
                for c in v: return c.text or ""
        return None

    def _set_sdt_text(content_el, value):
        texts = content_el.findall(".//w:t", {"w": _W_NS})
        if texts:
            first = True
            for t in texts:
                if first:
                    t.text = value
                    first = False
                else:
                    t.text = ""
            return
        has_block = (content_el.find(".//w:p", {"w": _W_NS}) is not None) or (content_el.find(".//w:tbl", {"w": _W_NS}) is not None)
        for ch in list(content_el): content_el.remove(ch)
        if has_block:
            p = ET.SubElement(content_el, _q("p")); r = ET.SubElement(p, _q("r"))
        else:
            r = ET.SubElement(content_el, _q("r"))
        t = ET.SubElement(r, _q("t")); t.text = value
        if (value.strip() != value) or ("\\n" in value) or ("  " in value):
            t.set("{http://www.w3.org/XML/1998/namespace}space", "preserve")

    def write_sdts_by_tag(doc_bytes: bytes, mapping_json: str) -> bytes:
        try: mapping = json.loads(mapping_json or "{}")
        except Exception: mapping = {}
        f_in = io.BytesIO(doc_bytes); out = io.BytesIO()
        with zipfile.ZipFile(f_in) as zin, zipfile.ZipFile(out, "w", zipfile.ZIP_DEFLATED) as zout:
            def is_target(name):
                if not (name.startswith("word/") and name.endswith(".xml")): return False
                skip = {"word/styles.xml","word/numbering.xml","word/theme/theme1.xml","word/fontTable.xml","word/settings.xml","word/webSettings.xml"}
                return name not in skip and not name.startswith("word/_rels/")
            for item in zin.infolist():
                name = item.filename
                data = zin.read(name)
                if not is_target(name):
                    zout.writestr(name, data); continue
                try:
                    root = ET.fromstring(data)
                except ET.ParseError:
                    zout.writestr(name, data); continue
                changed = False
                for sdt in root.findall(".//w:sdt", {"w": _W_NS}):
                    pr = sdt.find("w:sdtPr", {"w": _W_NS})
                    if pr is None: continue
                    tag_el = pr.find("w:tag", {"w": _W_NS})
                    tag_val = (tag_el.get(_q("val")) if tag_el is not None else "") or ""
                    if tag_val and tag_val in mapping:
                        val = mapping.get(tag_val, "")
                        if not isinstance(val, str):
                            try: import json as _json; val = _json.dumps(val, ensure_ascii=False)
                            except Exception: val = str(val)
                        content_el = sdt.find("w:sdtContent", {"w": _W_NS}) or sdt
                        _set_sdt_text(content_el, val)
                        changed = True
                zout.writestr(name, ET.tostring(root, encoding="utf-8", xml_declaration=True) if changed else data)
        return out.getvalue()

    # ---------------------- NEW: visibility tooling ----------------------
    def _ensure_fsHidden_style(zfin, names):
        if "word/styles.xml" in names:
            try:
                root = ET.fromstring(zfin.read("word/styles.xml"))
            except ET.ParseError:
                root = ET.Element(_q("styles"))
        else:
            root = ET.Element(_q("styles"))

        have = False
        for st in root.findall(_q("style")):
            if st.get(_q("type")) == "character" and st.get(_q("styleId")) == "fsHidden":
                have = True
                break

        if not have:
            st = ET.Element(_q("style"), {_q("type"): "character", _q("styleId"): "fsHidden"})
            ET.SubElement(st, _q("name"), {_q("val"): "fsHidden"})
            rpr = ET.SubElement(st, _q("rPr"))
            ET.SubElement(rpr, _q("vanish"))
            root.append(st)

        return ET.tostring(root, encoding="utf-8", xml_declaration=True)



    def _heading_level(p_el):
        ppr = p_el.find(_q("pPr"))
        if ppr is not None:
            ol = ppr.find(_q("outlineLvl"))
            if ol is not None and ol.get(_q("val")) is not None:
                try: return int(ol.get(_q("val"))) + 1
                except: pass
            ps = ppr.find(_q("pStyle"))
            if ps is not None and ps.get(_q("val")):
                v = ps.get(_q("val")).lower()
                if v.startswith("heading"):
                    try: return int(v.replace("heading","").strip())
                    except: return None
        return None

    def _apply_rStyle_hidden_to_runs(el):
        for r in el.findall(".//w:r", {"w": _W_NS}):
            rpr = r.find(_q("rPr"))
            if rpr is None:
                rpr = ET.SubElement(r, _q("rPr"))
            has = False
            for rs in rpr.findall(_q("rStyle")):
                if rs.get(_q("val")) == "fsHidden":
                    has = True; break
            if not has:
                ET.SubElement(rpr, _q("rStyle"), {_q("val"): "fsHidden"})

    def _clear_table_hidden_markers(tbl_el):
        tbl_pr = tbl_el.find(_q("tblPr"))
        if tbl_pr is not None:
            for node in list(tbl_pr.findall(_q("hidden"))):
                tbl_pr.remove(node)
        for tr in tbl_el.findall(".//w:tr", {"w": _W_NS}):
            tr_pr = tr.find(_q("trPr"))
            if tr_pr is None:
                continue
            for node in list(tr_pr.findall(_q("hidden"))):
                tr_pr.remove(node)

    def _mark_table_hidden(tbl_el):
        tbl_pr = tbl_el.find(_q("tblPr"))
        if tbl_pr is None:
            tbl_pr = ET.SubElement(tbl_el, _q("tblPr"))
        hidden = tbl_pr.find(_q("hidden"))
        if hidden is None:
            ET.SubElement(tbl_pr, _q("hidden"), {_q("val"): "true"})
        else:
            hidden.set(_q("val"), "true")
        for tr in tbl_el.findall(".//w:tr", {"w": _W_NS}):
            tr_pr = tr.find(_q("trPr"))
            if tr_pr is None:
                tr_pr = ET.SubElement(tr, _q("trPr"))
            hidden = tr_pr.find(_q("hidden"))
            if hidden is None:
                ET.SubElement(tr_pr, _q("hidden"), {_q("val"): "true"})
            else:
                hidden.set(_q("val"), "true")

    def _iter_blocks_within(container, top_level):
        for node in list(container):
            if node.tag == _q("sdt"):
                inner = node.find(_q("sdtContent"))
                if inner is not None:
                    yield from _iter_blocks_within(inner, top_level)
                else:
                    yield {"element": node, "type": "other", "level": None, "top": top_level}
            elif node.tag == _q("p"):
                yield {"element": node, "type": "p", "level": _heading_level(node), "top": top_level}
            elif node.tag == _q("tbl"):
                yield {"element": node, "type": "tbl", "level": None, "top": top_level}
            else:
                yield {"element": node, "type": "other", "level": None, "top": top_level}

    def _collect_body_blocks(body_el):
        blocks = []
        for child in list(body_el):
            if child.tag == _q("sdt"):
                content = child.find(_q("sdtContent"))
                if content is not None:
                    blocks.extend(_iter_blocks_within(content, child))
                else:
                    blocks.append({"element": child, "type": "other", "level": None, "top": child})
            elif child.tag == _q("p"):
                blocks.append({"element": child, "type": "p", "level": _heading_level(child), "top": child})
            elif child.tag == _q("tbl"):
                blocks.append({"element": child, "type": "tbl", "level": None, "top": child})
            else:
                blocks.append({"element": child, "type": "other", "level": None, "top": child})
        return blocks

    def _mark_block_hidden(el):
        if el is None:
            return
        _apply_rStyle_hidden_to_runs(el)
        if el.tag == _q("tbl"):
            _mark_table_hidden(el)
        for tbl in el.findall(".//w:tbl", {"w": _W_NS}):
            _apply_rStyle_hidden_to_runs(tbl)
            _mark_table_hidden(tbl)

    def apply_visibility(u8, idx_to_action_json):
        try: idx_to_action = {int(k): v for (k,v) in json.loads(idx_to_action_json).items()}
        except Exception: idx_to_action = {}
        data = bytes(u8)
        outbuf = io.BytesIO()
        with zipfile.ZipFile(io.BytesIO(data), "r") as zfin, zipfile.ZipFile(outbuf, "w", compression=zipfile.ZIP_DEFLATED) as zfout:
            names = zfin.namelist()
            for n in names:
                if n == "word/styles.xml": continue
                zfout.writestr(n, zfin.read(n))
            styles_bytes = _ensure_fsHidden_style(zfin, set(names))
            zfout.writestr("word/styles.xml", styles_bytes)
            def is_doc_part(n):
                if not (n.startswith("word/") and n.endswith(".xml")): return False
                skip = {"word/styles.xml","word/numbering.xml","word/theme/theme1.xml","word/fontTable.xml","word/settings.xml","word/webSettings.xml"}
                return n not in skip and not n.startswith("word/_rels/")
            parts_roots = {}
            for n in names:
                if not is_doc_part(n): continue
                try: root = ET.fromstring(zfin.read(n))
                except ET.ParseError:
                    parts_roots[n] = None
                    continue
                for r in root.findall(".//w:r", {"w": _W_NS}):
                    rpr = r.find(_q("rPr"))
                    if rpr is None: continue
                    for rs in list(rpr.findall(_q("rStyle"))):
                        if rs.get(_q("val")) == "fsHidden":
                            rpr.remove(rs)
                for tbl in root.findall(".//w:tbl", {"w": _W_NS}):
                    _clear_table_hidden_markers(tbl)
                parts_roots[n] = root
            global_idx = 0
            for n in names:
                if not is_doc_part(n): continue
                root = parts_roots.get(n)
                if root is None: continue
                body = root.find(_q("body"))
                if body is None:
                    zfout.writestr(n, ET.tostring(root, encoding="utf-8", xml_declaration=True)); continue
                elems = _collect_body_blocks(body)
                heading_positions = []
                for i, blk in enumerate(elems):
                    if blk.get("type") == "p" and blk.get("level") is not None:
                        global_idx += 1
                        heading_positions.append((i, blk.get("level"), global_idx))
                for h_i, (pos, lvl, idx) in enumerate(heading_positions):
                    if idx_to_action.get(idx) != "HIDE":
                        continue
                    if h_i + 1 < len(heading_positions):
                        end = len(elems)
                        for j in range(h_i+1, len(heading_positions)):
                            np, nl, _ = heading_positions[j]
                            if nl <= lvl:
                                end = np
                                break
                    else:
                        end = len(elems)
                    seen = set()
                    for j in range(pos, end):
                        blk = elems[j]
                        top = blk.get("top")
                        if top is None:
                            continue
                        key = id(top)
                        if key in seen:
                            continue
                        seen.add(key)
                        if top.tag in {_q("p"), _q("tbl"), _q("sdt")}:
                            _mark_block_hidden(top)
                zfout.writestr(n, ET.tostring(root, encoding="utf-8", xml_declaration=True))
        return outbuf.getvalue()
        `);
        tr.end('pyodide ready');
        return py;
      } catch (e) { tr.error('bootstrap failed', e); tr.end(); throw e; }
    })();

    async function readDocVarSettings(arrayBufferOrBytes, name) {
      const tr = TRACE('readDocVarSettings', { name });
      try {
        const py = await pyodideReady;
        const u8in = arrayBufferOrBytes instanceof Uint8Array ? arrayBufferOrBytes : new Uint8Array(arrayBufferOrBytes);
        const fn = py.globals.get('read_docvar_settings');
        const pyBytes = py.toPy(u8in);
        let pyOut;
        try { pyOut = fn(pyBytes, name); }
        finally { try{fn.destroy();}catch{} try{pyBytes.destroy();}catch{} }
        let txt = null;
        if (pyOut?.toJs) txt = pyOut.toJs({ create_proxies:false });
        else txt = pyOut ?? null;
        try { pyOut.destroy?.(); } catch {}
        tr.end({ found: !!txt, len: txt?.length });
        return txt;
      } catch (e) { tr.error('failed', e); tr.end(); return null; }
    }

    async function readDocVarCustom(arrayBufferOrBytes, name) {
      const tr = TRACE('readDocVarCustom', { name });
      try {
        const py = await pyodideReady;
        const u8in = arrayBufferOrBytes instanceof Uint8Array ? arrayBufferOrBytes : new Uint8Array(arrayBufferOrBytes);
        const fn = py.globals.get('read_docvar_custom');
        const pyBytes = py.toPy(u8in);
        let pyOut;
        try { pyOut = fn(pyBytes, name); }
        finally { try{fn.destroy();}catch{} try{pyBytes.destroy();}catch{} }
        let txt = null;
        if (pyOut?.toJs) txt = pyOut.toJs({ create_proxies:false });
        else txt = pyOut ?? null;
        try { pyOut.destroy?.(); } catch {}
        tr.end({ found: !!txt, len: txt?.length });
        return txt;
      } catch (e) { tr.error('failed', e); tr.end(); return null; }
    }

    async function writeDocVarSettings(arrayBufferOrBytes, name, value) {
      const tr = TRACE('writeDocVarSettings', { name, valueLen: (value||'').length });
      try {
        const py = await pyodideReady;
        const u8in = arrayBufferOrBytes instanceof Uint8Array ? arrayBufferOrBytes : new Uint8Array(arrayBufferOrBytes);
        const fn = py.globals.get('write_docvar_settings');
        const pyBytes = py.toPy(u8in);
        let pyOut;
        try { pyOut = fn(pyBytes, name, String(value ?? "")); }
        finally { try{fn.destroy();}catch{} try{pyBytes.destroy();}catch{} }
        let u8;
        if (pyOut?.toJs) u8 = pyOut.toJs({ create_proxies:false });
        else if (pyOut?.getBuffer) u8 = new Uint8Array(pyOut.getBuffer());
        else u8 = new Uint8Array([]);
        try { pyOut.destroy?.(); } catch {}
        tr.end({ outLen: u8?.byteLength });
        return u8;
      } catch (e) { tr.error('failed', e); tr.end(); throw e; }
    }

    async function writeSDTs(arrayBufferOrBytes, tagToTextObj) {
      const tr = TRACE('writeSDTs', { tagCount: Object.keys(tagToTextObj||{}).length });
      try {
        const py = await pyodideReady;
        const u8in = arrayBufferOrBytes instanceof Uint8Array ? arrayBufferOrBytes : new Uint8Array(arrayBufferOrBytes);
        const fn = py.globals.get('write_sdts_by_tag');
        const pyBytes   = py.toPy(u8in);
        const pyMap     = py.toPy(JSON.stringify(tagToTextObj || {}));
        let pyOut;
        try { pyOut = fn(pyBytes, pyMap); }
        finally { try{fn.destroy();}catch{} try{pyBytes.destroy();}catch{} try{pyMap.destroy();}catch{} }
        let u8;
        if (pyOut?.toJs) u8 = pyOut.toJs({ create_proxies:false });
        else if (pyOut?.getBuffer) u8 = new Uint8Array(pyOut.getBuffer());
        else u8 = new Uint8Array([]);
        try { pyOut.destroy?.(); } catch {}
        tr.end({ outLen: u8?.byteLength });
        return u8;
      } catch (e) { tr.error('failed', e); tr.end(); throw e; }
    }

    // =========================
    // RENDER FROM CURRENT BYTES
    // =========================
    async function renderFromCurrentBytes(prefix = '') {
      const tr = TRACE('renderFromCurrentBytes', { prefix, hasBuf: !!gArrayBuffer, len: gArrayBuffer?.byteLength });
      try {
        tr.step('buffer sha', await sha256Hex(gArrayBuffer));

        // 1) SDTs
        const parsed = await parseSDTs_JS(gArrayBuffer);
        gSDTs = parsed.sdts || [];
        renderSDTsView(parsed);

        // 2) Headings (best-effort)
        let headingsParsed = { flat: [], tree: [], count: 0 };
        try {
          headingsParsed = await parseHeadings_JS(gArrayBuffer);
          renderHeadingsTreeView(headingsParsed.tree);
        } catch (e) {
          tr.warn('headings parse/render failed', e);
          try { if (headersTreeEl) headersTreeEl.innerHTML = '<div class="empty">No headings.</div>'; } catch {}
        }

        // 3) Payload (schema/values/tagMap/rules/fieldRules)
        let payloadRaw = await readDocVarSettings(gArrayBuffer, PAYLOAD_KEY);
        if (payloadRaw == null) payloadRaw = await readDocVarCustom(gArrayBuffer, PAYLOAD_KEY);

        let payload = null;
        try { payload = payloadRaw ? JSON.parse(payloadRaw) : null; } catch { payload = null; }

        const wsState    = await window.formSuitePersist.loadState(gDocId);
        const wsSchema   = wsState?.schema || null;
        const wsValues   = wsState?.values || {};
        const wsRules    = normalizeRules(wsState?.rules);
        const wsFieldR   = normalizeRules(wsState?.fieldRules);
        const wsTagMap   = wsState?.tagMap || {};

        const asTs = (x)=> { const t = Date.parse(x || ''); return Number.isFinite(t) ? t : 0; };
        const pHasSchema = Array.isArray(payload?.fields) && payload.fields.length > 0;
        const pUpdatedTs = asTs(payload?.updatedAt);
        const wsSchemaTs = asTs(wsState?.schemaUpdatedAt);

        let chosenSchema, statusSource;
        if (wsSchema && (wsSchemaTs >= pUpdatedTs || !pHasSchema)) {
          chosenSchema = wsSchema; statusSource = 'Using newer schema from Builder/workspace.';
        } else if (pHasSchema) {
          chosenSchema = { title: payload.title || 'Form', fields: payload.fields };
          statusSource = 'Loaded schema from DOCX payload.';
        } else {
          chosenSchema = loadSchemaFromLocalStorage() || { title: 'Form', fields: [] };
          statusSource = 'Fallback schema (local storage or empty).';
        }

        const mergedValues = Object.assign({}, payload?.values || {}, wsValues || {});
        const mergedTagMap = Object.assign({}, payload?.tagMap || {}, wsTagMap || {});

        const payloadRules  = normalizeRules(payload?.rules);
        const payloadFieldR = normalizeRules(payload?.fieldRules);

        const mergedRules   = wsRules.length    ? wsRules    : payloadRules;
        const mergedFieldR  = wsFieldR.length   ? wsFieldR   : payloadFieldR;

        const prunedRules   = normalizeRulesForSchema(chosenSchema, mergedRules);
        const prunedFieldR  = normalizeRulesForSchema(chosenSchema, mergedFieldR);

        const { values: prunedValues, tagMap: prunedTagMap } =
          normalizeForSchema(chosenSchema, mergedValues, mergedTagMap);

        gSchema = chosenSchema;
        gValues = prunedValues;

        // Persist both arrays so they remain available for export/save
        if (gDocId) {
          const patch = {
            schema: gSchema,
            values: gValues,
            tagMap: prunedTagMap,
            headings: headingsParsed.flat,
            headingsTree: headingsParsed.tree,
            headingsUpdatedAt: new Date().toISOString()
          };
          if (Array.isArray(prunedRules) && prunedRules.length)     patch.rules = prunedRules;
          if (Array.isArray(prunedFieldR) && prunedFieldR.length)   patch.fieldRules = prunedFieldR;
          await window.formSuitePersist.saveState(gDocId, patch);
        }

        buildForm(document.getElementById('formMount'), gSchema, gValues);
        await updatePreview(gValues);
        setStatus(statusSource);
        tr.end({ statusSource });
      } catch (e) { tr.error('failed', e); tr.end(); }
    }

    function renderSDTsView(parsed) {
      const tr = TRACE('renderSDTsView', { total: parsed?.total, rows: parsed?.sdts?.length });
      try {
        tableBody.innerHTML = '';
        const sdts = parsed?.sdts || [];
        if (!sdts.length) {
          const trEl = document.createElement('tr');
          const td = document.createElement('td');
          td.colSpan = 5;
          td.textContent = 'No SDTs found in this document.';
          trEl.appendChild(td);
          tableBody.appendChild(trEl);
        } else {
          sdts.forEach((row, i) => {
            const trEl = document.createElement('tr');
            const tdIdx = document.createElement('td'); tdIdx.textContent = String(i + 1); trEl.appendChild(tdIdx);
            const tdPart = document.createElement('td'); tdPart.textContent = row.part || ''; trEl.appendChild(tdPart);
            const tdTag = document.createElement('td'); tdTag.textContent = row.tag || ''; trEl.appendChild(tdTag);
            const tdAlias = document.createElement('td'); tdAlias.textContent = row.alias || ''; trEl.appendChild(tdAlias);
            const tdText = document.createElement('td'); tdText.textContent = row.text || ''; trEl.appendChild(tdText);
            tableBody.appendChild(trEl);
          });
        }
      } finally { tr.end(); }
    }

    // =========================
    // BOOT (auto-restore)
    // =========================
    (async function boot() {
      const tr = TRACE('boot');
      try {
        let meta = readActiveMeta();
        tr.step('readActiveMeta', meta);
        if (!meta?.docId) { meta = window.formSuitePersist?.getCurrentDocMeta?.(); tr.step('getCurrentDocMeta', meta); }
        if (!meta?.docId) { tr.end('no meta; idle'); return; }

        clearUiForNewDoc('Restoring document…');

        let bytes = await window.formSuitePersist.getBytes?.(meta.docId)
                || await window.formSuitePersist.getCurrentDocBytes?.();
        tr.step('persistence bytes', { len: bytes?.byteLength || bytes?.length });

        if (!bytes && supportsFS) {
          try {
            const h = await window.formSuitePersist.getHandle?.(meta.docId);
            tr.step('getHandle (2nd chance)', { has: !!h });
            if (h?.getFile) {
              try { await window.formSuitePersist.ensurePermission?.(h, 'read'); } catch {}
              const f = await h.getFile();
              bytes = new Uint8Array(await f.arrayBuffer());
              gFileHandle = h;
              if (!gFileName) {
                const { base, ext } = splitNameAndExt(f.name || meta.name || 'document.docx');
                gFileName = base || 'document';
                gFileExt  = ext || 'docx';
              }
              tr.step('2nd chance handle.getFile ok', { size: bytes.byteLength });
            }
          } catch (e) {
            tr.warn('2nd chance via handle failed', e);
          }
        }
        if (!bytes && supportsFS) {
          try {
            const h = await window.formSuitePersist.getHandle?.(meta.docId);
            tr.step('getHandle', { has: !!h });
            if (h) {
              try { await window.formSuitePersist.ensurePermission?.(h, 'read'); } catch (e) { tr.warn('ensurePermission failed', e); }
              const f = await h.getFile();
              bytes = new Uint8Array(await f.arrayBuffer());
              gFileHandle = h;
              const { base, ext } = splitNameAndExt(f.name || meta.name || 'document.docx');
              gFileName = base || 'document';
              gFileExt  = ext || 'docx';
              tr.step('handle.getFile ok', { name: `${gFileName}.${gFileExt}`, len: bytes.byteLength });
            }
          } catch (e) { tr.warn('handle path failed', e); }
        }

        if (!bytes) { await hardResetDocContext('no bytes / no permission'); tr.end('no bytes'); return; }

        gArrayBuffer = bytes.buffer ?? bytes;

        if (!gFileName) {
          const { base, ext } = splitNameAndExt(meta.name || 'document.docx');
          gFileName = base || 'document';
          gFileExt  = ext || 'docx';
        }
        gDocId = meta.docId;

        tr.step('restored', { docId: gDocId, name: `${gFileName}.${gFileExt}`, len: gArrayBuffer?.byteLength, sha: await sha256Hex(gArrayBuffer) });

        await renderFromCurrentBytes();
        await updateWriteAccessBanner();

        btnSave.disabled = false; btnExport.disabled = false;
        if (btnSaveFromPreview) btnSaveFromPreview.disabled = false;
      } catch (e) { tr.error('boot failed', e); }
      finally { tr.end(); }
    })();

    // =========================
    // PERSIST WRAPPER
    // =========================
    async function persistCurrentDoc(bytesU8, handle, nameNoExt, ext = 'docx') {
      const tr = TRACE('persistCurrentDoc', { hasBytes: !!bytesU8, handle: !!handle, nameNoExt, ext });
      try {
        const safeExt = (ext || 'docx').toLowerCase();
        const name = `${(nameNoExt || 'document').replace(/\.(docx|docm|dotx|dotm)$/i,'')}.${safeExt}`;
        tr.step('computed name', name);
        tr.step('hash', await sha256Hex(bytesU8));
        if (window.formSuitePersist?.setCurrentDoc) {
          const meta = await window.formSuitePersist.setCurrentDoc({ bytes: bytesU8, handle, name });
          tr.end(meta); return meta;
        }
        if (window.formSuitePersist?.setCurrentDocFromBytes) {
          const meta = await window.formSuitePersist.setCurrentDocFromBytes(bytesU8, { name, handle });
          tr.end(meta); return meta;
        }
        const meta = { docId: 'inline-' + Date.now(), name };
        tr.end(meta);
        return meta;
      } catch (e) { tr.error('failed', e); tr.end(); throw e; }
    }

    // ---------- Rules → Visibility map (SHOW supersedes HIDE) ----------
    function loadRulesForDoc(state) {
      return (
        state?.rules ||
        state?.payload?.rules ||
        state?.CRONOS_RULES ||
        state?.cronos_rules ||
        []
      );
    }

    function ruleMatchesValue(op, expected, actual) {
      const a = actual;
      if (op === 'equals')    return String(a) === String(expected);
      if (op === 'notEquals') return String(a) !== String(expected);
      if (op === 'anyOf') {
        const arr = Array.isArray(expected) ? expected.map(String) : [String(expected)];
        if (Array.isArray(a)) return a.map(String).some(v => arr.includes(v));
        return arr.includes(String(a));
      }
      if (op === 'allOf') {
        const arr = Array.isArray(expected) ? expected.map(String) : [String(expected)];
        if (!Array.isArray(a)) return false;
        const aset = new Set(a.map(String));
        return arr.every(v => aset.has(v));
      }
      if (op === 'contains')  return String(a ?? '').toLowerCase().includes(String(expected ?? '').toLowerCase());
      return false;
    }

    function evaluateRulesToVisibility(schema, values, rules) {
      const out = Object.create(null);
      if (!Array.isArray(rules) || !rules.length) return out;

      const cleanVals = values || {};
      const getVal = (fid) => cleanVals[fid];

      for (const r of rules) {
        if (!r) continue;
        const action = (String(r.action || '').toUpperCase() === 'SHOW') ? 'SHOW'
                    : (String(r.action || '').toUpperCase() === 'HIDE') ? 'HIDE'
                    : null;
        if (!action) continue;

        const fieldId = r.fieldId || r.field || r.whenField;
        const op      = r.op || r.operator || 'equals';
               const exp     = r.values ?? r.value ?? r.expected;
        const targets = Array.isArray(r.targets) ? r.targets : [];

        const actual  = getVal(fieldId);
        if (!ruleMatchesValue(op, exp, actual)) continue;

        for (const t of targets) {
          const key = t?.key ?? t?.idx ?? t?.id;
          if (key == null) continue;
          const idx = Number(key);
          if (!Number.isFinite(idx)) continue;
          const prev = out[idx];
          if (action === 'SHOW') out[idx] = 'SHOW';
          else if (action === 'HIDE' && prev !== 'SHOW') out[idx] = 'HIDE';
        }
      }
      return out;
    }

    // ---------- Bridge to Python: apply visibility using fsHidden ----------
    async function applyVisibilityByRules(bytesU8, visibilityMap) {
      if (!visibilityMap || !Object.keys(visibilityMap).length) return bytesU8;
      const py = await pyodideReady;
      const fn = py.globals.get('apply_visibility');
      const pyBytes = py.toPy(bytesU8 instanceof Uint8Array ? bytesU8 : new Uint8Array(bytesU8));
      const pyMap   = py.toPy(JSON.stringify(visibilityMap));
      let pyOut;
      try { pyOut = fn(pyBytes, pyMap); }
      finally { try{fn.destroy();}catch{} try{pyBytes.destroy();}catch{} try{pyMap.destroy();}catch{} }
      let u8;
      if (pyOut?.toJs) u8 = pyOut.toJs({ create_proxies:false });
      else if (pyOut?.getBuffer) u8 = new Uint8Array(pyOut.getBuffer());
      else u8 = new Uint8Array([]);
      try { pyOut.destroy?.(); } catch {}
      return u8;
    }

    // =========================
    // FILE OPEN / SAVE / EXPORT
    // =========================
    async function doOpen() {
      const tr = TRACE('doOpen');
      try {
        clearUiForNewDoc('Opening…');

        const [handle] = await showOpenFilePicker({
          multiple: false,
          types: [{
            description: 'Word document',
            accept: {
              'application/vnd.openxmlformats-officedocument.wordprocessingml.document': ['.docx'],
              'application/vnd.ms-word.document.macroEnabled.12': ['.docm'],
              'application/vnd.openxmlformats-officedocument.wordprocessingml.template': ['.dotx'],
              'application/vnd.ms-word.template.macroEnabled.12': ['.dotm']
            }
          }]
        });

        gFileHandle = handle;
        const file = await handle.getFile();
        const { base, ext } = splitNameAndExt(file.name || 'document.docx');
        gFileName = base || 'document';
        gFileExt  = ext;

        const bytes = new Uint8Array(await file.arrayBuffer());
        gArrayBuffer = bytes.buffer;

        tr.step('opened', { name: `${gFileName}.${gFileExt}`, size: bytes.byteLength, sha: await sha256Hex(bytes) });

        const metaObj = await persistCurrentDoc(bytes, gFileHandle, gFileName, gFileExt);
        gDocId = metaObj.docId;
        persistActiveMeta(metaObj);
        announceDocSwitch();
        gPreferDocOnNextLoad = true;
        await renderFromCurrentBytes();

        await updateWriteAccessBanner({ tryPrompt: true });

        btnSave.disabled = false; btnExport.disabled = false;
        if (btnSaveFromPreview) btnSaveFromPreview.disabled = false;
      } catch (e) {
        if (e?.name === 'AbortError') { tr.step('user canceled'); return; }
        tr.error('open failed', e);
        setStatus(`Error opening file: ${e.message || e}`);
      } finally { tr.end(); }
    }

    async function ensureWritePermission(handle) {
      const tr = TRACE('ensureWritePermission', { haveHandle: !!handle });
      try {
        if (!handle?.requestPermission) return 'denied';
        let p = await handle.queryPermission?.({ mode: 'readwrite' });
        tr.step('queryPermission', p);
        if (p === 'granted') return 'granted';
        const r = await handle.requestPermission?.({ mode: 'readwrite' });
        tr.end({ requestPermission: r });
        return r || 'denied';
      } catch (e) { tr.error('perm failed', e); tr.end(); return 'denied'; }
    }

    async function doSave() {
      const tr = TRACE('doSave', { hasBuf: !!gArrayBuffer, docId: gDocId });
      try {
        if (!gArrayBuffer) { tr.warn('no buffer'); return; }

        const restored = gDocId ? (await window.formSuitePersist.loadState(gDocId)) : null;
        if (restored?.schema) gSchema = restored.schema;

        // --- values ---
        const domVals  = collectFormValues(gSchema);
        const baseVals = (restored && restored.values) ? restored.values : {};

        // --- tag map ---
        const tagMapRaw = restored?.tagMap || await getTagMapFor(gDocId);

        // --- RULE SOURCING: prefer workspace, fall back to payload mirrors (like Preview) ---
        const pl = restored?.payload?.CRONOS_PAYLOAD
                || restored?.CRONOS_PAYLOAD
                || restored?.cronos_payload
                || {};

        const wsRules    = Array.isArray(restored?.rules)      ? restored.rules      : [];
        const wsFieldR   = Array.isArray(restored?.fieldRules) ? restored.fieldRules : [];
        const plRules    = Array.isArray(pl.rules)             ? pl.rules            : [];
        const plFieldR   = Array.isArray(pl.fieldRules)        ? pl.fieldRules       : [];

        const mergedRules  = wsRules.length  ? wsRules  : plRules;
        const mergedFieldR = wsFieldR.length ? wsFieldR : plFieldR;

        // --- Normalize / prune against current schema ---
        const rules      = normalizeRulesForSchema(gSchema, mergedRules);
        const fieldRules = normalizeRulesForSchema(gSchema, mergedFieldR);

        const { values: prunedValues, tagMap: prunedTagMap } =
          normalizeForSchema(gSchema, { ...baseVals, ...domVals }, tagMapRaw);

        gValues = prunedValues;
        await updatePreview(gValues);

        setStatus('Writing payload to DOCX (settings.xml)…');

        // --- Build payload (always include arrays for symmetry) ---
        const payloadObj = {
          title:     gSchema.title || 'Form',
          fields:    gSchema.fields || [],
          values:    gValues || {},
          tagMap:    prunedTagMap,
          rules,          // always present
          fieldRules,     // always present
          updatedAt: new Date().toISOString()
        };
        const payload = JSON.stringify(payloadObj);

        // Write into DOCX settings
        const updated = await writeDocVarSettings(gArrayBuffer, PAYLOAD_KEY, payload);
        const updatedU8 = compactU8(toU8(updated));
        gArrayBuffer = updatedU8.slice().buffer;

        // Persist workspace snapshot
        if (gDocId) await window.formSuitePersist.saveState(gDocId, {
          schema: gSchema, values: gValues, rules, fieldRules, tagMap: prunedTagMap
        });
        if (gDocId) await window.formSuitePersist.putBytes(gDocId, updatedU8);
        const metaObj = await persistCurrentDoc(updatedU8, gFileHandle, gFileName, gFileExt);
        gDocId = metaObj.docId;
        persistActiveMeta(metaObj);
        announceDocUpdate();

        if (supportsFS) {
          const handle = gFileHandle || await window.formSuitePersist.getHandle?.(gDocId);
          if (handle) {
            const p = await ensurePermission(handle, 'readwrite');
            tr.step('ensurePermission', p);
            if (p === 'granted') {
              const stream = await handle.createWritable();
              await stream.write(updatedU8);
              await stream.close();
              setStatus('Saved.');
              gDirty = false;
              return;
            }
          }
        }

        setStatus('Saved in workspace (file system write not available).');
        gDirty = false;
      } catch (e) {
        tr.error('save failed', e);
        setStatus(`Error saving: ${e.message || e}`);
      } finally { tr.end(); }
    }

    async function doExport() {
      const tr = TRACE('doExport', { hasBuf: !!gArrayBuffer, docId: gDocId });
      try {
        if (!gArrayBuffer) { tr.warn('no buffer'); return; }

        const restored = gDocId ? (await window.formSuitePersist.loadState(gDocId)) : null;
        if (restored?.schema) gSchema = restored.schema;

        // --- values ---
        const domVals  = collectFormValues(gSchema);
        const baseVals = (restored && restored.values) ? restored.values : {};

        // --- tag map ---
        const tagMapRaw = restored?.tagMap || await getTagMapFor(gDocId);

        // --- RULE SOURCING (same logic as doSave/Preview) ---
        const pl = restored?.payload?.CRONOS_PAYLOAD
                || restored?.CRONOS_PAYLOAD
                || restored?.cronos_payload
                || {};

        const wsRules    = Array.isArray(restored?.rules)      ? restored.rules      : [];
        const wsFieldR   = Array.isArray(restored?.fieldRules) ? restored.fieldRules : [];
        const plRules    = Array.isArray(pl.rules)             ? pl.rules            : [];
        const plFieldR   = Array.isArray(pl.fieldRules)        ? pl.fieldRules       : [];

        const mergedRules  = wsRules.length  ? wsRules  : plRules;
        const mergedFieldR = wsFieldR.length ? wsFieldR : plFieldR;

        // --- Normalize / prune against current schema ---
        const rules      = normalizeRulesForSchema(gSchema, mergedRules);
        const fieldRules = normalizeRulesForSchema(gSchema, mergedFieldR);

        const { values: prunedValues, tagMap: prunedTagMap } =
          normalizeForSchema(gSchema, { ...baseVals, ...domVals }, tagMapRaw);

        gValues = prunedValues;
        setStatus('Preparing export…');

        // 1) write CRONOS_PAYLOAD into the in-memory DOCX
        const payload = JSON.stringify({
          title:     gSchema.title || 'Form',
          fields:    gSchema.fields || [],
          values:    gValues || {},
          tagMap:    prunedTagMap,
          rules,          // always present
          fieldRules,     // always present
          updatedAt: new Date().toISOString()
        });
        const updated = await writeDocVarSettings(gArrayBuffer, PAYLOAD_KEY, payload);
        const updatedU8 = compactU8(toU8(updated));

        // 2) save the updated bytes to the chosen file
        const suggested = (gFileName?.replace(/\.docx$/i,'') || 'document') + '_export.' + gFileExt;
        if (window.showSaveFilePicker) {
          try {
            const handle = await window.showSaveFilePicker({
              suggestedName: suggested,
              types: [{ description: 'Word document', accept: { [wordMimeFor(gFileExt)]: [`.${gFileExt}`] } }]
            });
            const stream = await handle.createWritable();
            await stream.write(updatedU8);
            await stream.close();
            setStatus(`Exported as “${handle.name || suggested}”.`);
            gDirty = false;
            return;
          } catch (e) {
            if (e?.name === 'AbortError') { setStatus('Export canceled.'); return; }
            tr.warn('showSaveFilePicker failed, falling back', e);
          }
        }

        const mime = wordMimeFor(gFileExt);
        const blob = new Blob([updatedU8], { type: mime });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = suggested; a.click();
        URL.revokeObjectURL(url);
        setStatus(`Exported as “${suggested}”.`);
        gDirty = false;
      } catch (e) {
        tr.error('export failed', e);
        setStatus(`Error exporting: ${e.message || e}`);
      } finally { tr.end(); }
    }

    // =========================
    // PAYLOAD PREVIEW (editable)
    // =========================
    let __payloadApplyTimer = null;
    let __payloadEditBusy = false;

    async function applyPayloadObject(obj, { broadcast = true, save = true } = {}) {
      const tr = TRACE('applyPayloadObject', { broadcast, save, keys: Object.keys(obj||{}).length });
      try {
        if (!obj || typeof obj !== 'object') { tr.warn('no object'); return; }

        const nextSchema = { title: obj.title || 'Form', fields: Array.isArray(obj.fields) ? obj.fields : [] };
        const nextValues = (obj.values && typeof obj.values === 'object') ? obj.values : {};
        const nextTagMap = (obj.tagMap && typeof obj.tagMap === 'object') ? obj.tagMap : {};

        const rawRules    = normalizeRules(obj.rules);
        const nextRules   = normalizeRulesForSchema(nextSchema, rawRules);
        const rawField    = normalizeRules(obj.fieldRules);
        const nextFieldsR = normalizeRulesForSchema(nextSchema, rawField);

        const nowIso = new Date().toISOString();

        const { values: prunedValues, tagMap: prunedTagMap } =
          normalizeForSchema(nextSchema, nextValues, nextTagMap);

        gSchema = nextSchema;
        gValues = prunedValues;

        if (gDocId && save) {
          await window.formSuitePersist.saveState(gDocId, {
            schema: gSchema,
            values: gValues,
            tagMap: prunedTagMap,
            rules:  nextRules,
            fieldRules: nextFieldsR,
            payload: { CRONOS_PAYLOAD: {
              title: gSchema.title,
              fields: gSchema.fields,
              values: gValues,
              tagMap: prunedTagMap,
              rules: nextRules,
              fieldRules: nextFieldsR
            }},
            schemaUpdatedAt: nowIso
          });
        } else {
          try { localStorage.setItem(STORAGE_KEY, JSON.stringify({ title: gSchema.title, fields: gSchema.fields })); } catch {}
        }

        buildForm(document.getElementById('formMount'), gSchema, gValues);
        await updatePreview(gValues);

        if (broadcast) {
          try { bcLegacy?.postMessage({ type: 'schema-updated', docId: gDocId, ts: Date.now() }); } catch {}
          try { bcCanon?.postMessage({ type: 'schema-updated', docId: gDocId, ts: Date.now() }); } catch {}
        }

        gDirty = true;
        setStatus('Payload applied (normalized). Not yet saved to DOCX.');
        if (previewStatus) { previewStatus.textContent = 'Applied'; setTimeout(()=> previewStatus.textContent='', 1200); }
        tr.end('applied');
      } catch (e) { tr.error('failed', e); tr.end(); }
    }

    if (payloadEl) {
      payloadEl.addEventListener('input', () => {
        const tr = TRACE('payloadEl:input');
        try {
          clearTimeout(__payloadApplyTimer);
          __payloadApplyTimer = setTimeout(async () => {
            const tr2 = TRACE('payloadEl:debouncedApply');
            if (__payloadEditBusy) { tr2.step('busy skip'); tr2.end(); return; }
            try {
              const txt = payloadEl.value;
              const obj = JSON.parse(txt);
              __payloadEditBusy = true;
              await applyPayloadObject(obj);
            } catch (e) {
              if (previewStatus) previewStatus.textContent = 'Invalid JSON';
              tr2.warn('invalid JSON', e);
            } finally {
              __payloadEditBusy = false;
              tr2.end();
            }
          }, 350);
        } finally { tr.end(); }
      });
    }

    // =========================
    // WIRE UP UI
    // =========================
    btnOpen.addEventListener('click', doOpen);
    btnSave.addEventListener('click', doSave);
    btnExport.addEventListener('click', doExport);
    btnSaveFromPreview?.addEventListener('click', doSave);

    btnRegrant.addEventListener('click', async () => {
      const tr = TRACE('btnRegrant:click');
      try { await updateWriteAccessBanner({ tryPrompt: true }); }
      catch (e) { tr.error('regrant failed', e); permNote.style.display='block'; }
      finally { tr.end(); }
    });

    window.addEventListener('beforeunload', async () => {
      const tr = TRACE('beforeunload');
      try {
        if (!gDocId) { tr.end('no docId'); return; }
        const vals = collectFormValues(gSchema);
        await window.formSuitePersist.saveState(gDocId, { schema: gSchema, values: { ...(gValues||{}), ...vals } });
        persistActiveMeta({ docId: gDocId, name: gFileName });
      } catch (e) { tr.warn('beforeunload failed', e); }
      finally { tr.end(); }
    });

    // =========================
    // TRIPLE-CLICK FOCUS NAV
    // =========================
    (function() {
      const logo = document.querySelector('header .logo');
      const header = document.querySelector('header .row');
      if (!logo || !header) return;

      let clickCount = 0;
      let clickTimer = null;
      let focusMode = false;

      logo.addEventListener('click', () => {
        clickCount++;
        clearTimeout(clickTimer);
        clickTimer = setTimeout(() => { clickCount = 0; }, 600);

        if (clickCount === 3) {
          clickCount = 0;
          focusMode = !focusMode;

          if (focusMode) {
            header.querySelectorAll('a, span.muted').forEach(el => {
              if (!el.closest('.brand')) el.style.display = 'none';
            });
            if (!location.pathname.endsWith('index.html')) location.href = 'index.html';
          } else {
            header.querySelectorAll('a, span.muted').forEach(el => { el.style.display = ''; });
          }
        }
      });
    })();

    // =========================
    // HEADINGS (H1..H9) PARSING & TREE
    // =========================
    function levelFromStyleHint(str) {
      if (!str) return 0;
      const s = String(str).trim().toLowerCase();
      const patterns = [
        /heading\s*([1-9])/,
        /überschrift\s*([1-9])/,
        /titre\s*([1-9])/,
        /t[ií]tulo\s*([1-9])/,
        /encabezado\s*([1-9])/,
        /rubrik\s*([1-9])/,
        /zagolovok\s*([1-9])/,
        /заголовок\s*([1-9])/,
      ];
      for (const re of patterns) {
        const m = s.match(re);
        if (m) return parseInt(m[1], 10);
      }
      const m2 = s.match(/^heading([1-9])$/i);
      if (m2) return parseInt(m2[1], 10);
      return 0;
    }

    async function buildStyleOutlineMap(arrayBuffer) {
      const tr = TRACE('buildStyleOutlineMap');
      try {
        const zip = await JSZip.loadAsync(arrayBuffer);
        const stylesFile = zip.file('word/styles.xml');
        if (!stylesFile) { tr.end('no styles.xml'); return {}; }

        const xmlTextContent = await stylesFile.async('string');
        const parser = new DOMParser();
        const xml = parser.parseFromString(xmlTextContent, "application/xml");

        const byId = {};
        const styles = xml.getElementsByTagNameNS(W_NS, 'style');
        for (let i = 0; i < styles.length; i++) {
          const st = styles[i];
          if ((st.getAttributeNS(W_NS, 'type') || st.getAttribute('w:type')) !== 'paragraph') continue;

          const id = st.getAttributeNS(W_NS, 'styleId') || st.getAttribute('w:styleId') || '';
          if (!id) continue;

          const nameEl = st.getElementsByTagNameNS(W_NS, 'name')[0];
          const name = nameEl ? (nameEl.getAttributeNS(W_NS, 'val') || nameEl.getAttribute('w:val') || '') : '';

          const basedEl = st.getElementsByTagNameNS(W_NS, 'basedOn')[0];
          const basedOn = basedEl ? (basedEl.getAttributeNS(W_NS, 'val') || basedEl.getAttribute('w:val') || '') : '';

          let rawLevel = 0;
          const pPr = st.getElementsByTagNameNS(W_NS, 'pPr')[0];
          if (pPr) {
            const outline = pPr.getElementsByTagNameNS(W_NS, 'outlineLvl')[0];
            if (outline) {
              const v = outline.getAttributeNS(W_NS, 'val') || outline.getAttribute('w:val') || null;
              if (v != null && v !== '') {
                const n = parseInt(v, 10);
                if (Number.isFinite(n)) rawLevel = Math.min(Math.max(n + 1, 1), 9);
              }
            }
          }
          if (!rawLevel) {
            rawLevel = levelFromStyleHint(id) || levelFromStyleHint(name) || 0;
          }
          byId[id] = { id, name, basedOn, rawLevel };
        }

        const resolved = {};
        const resolveLevel = (id, depth = 0) => {
          if (!id || !byId[id] || depth > 12) return 0;
          if (resolved[id] != null) return resolved[id];
          const info = byId[id];
          if (info.rawLevel) { resolved[id] = info.rawLevel; return info.rawLevel; }
          const parent = info.basedOn;
          const lvl = resolveLevel(parent, depth + 1);
          resolved[id] = lvl || 0;
          return resolved[id];
        };
        Object.keys(byId).forEach(id => resolveLevel(id));

        tr.end({ styles: Object.keys(byId).length, mapped: Object.keys(resolved).length });
        return resolved;
      } catch (e) {
        tr.error('buildStyleOutlineMap failed', e); tr.end();
        return {};
      }
    }

    function paraText(pEl) {
      const ts = pEl.getElementsByTagNameNS(W_NS, 't');
      let s = '';
      for (let i = 0; i < ts.length; i++) s += ts[i].textContent;
      return s.trim();
    }

    function detectHeadingLevel(pEl, styleMap) {
      const pPr = pEl.getElementsByTagNameNS(W_NS, 'pPr')[0];
      if (pPr) {
        const outline = pPr.getElementsByTagNameNS(W_NS, 'outlineLvl')[0];
        if (outline) {
          const v = outline.getAttributeNS(W_NS, 'val') || outline.getAttribute('w:val') || null;
          if (v != null && v !== '') {
            const n = parseInt(v, 10);
            if (Number.isFinite(n)) return Math.min(Math.max(n + 1, 1), 9);
          }
        }
        const pStyle = pPr.getElementsByTagNameNS(W_NS, 'pStyle')[0];
        if (pStyle) {
          const styleId = pStyle.getAttributeNS(W_NS, 'val') || pStyle.getAttribute('w:val') || '';
          const lvl = styleMap?.[styleId];
          if (lvl && Number.isFinite(lvl)) return lvl;
        }
      }
      return 0;
    }

    function numberHeadingsTree(tree) {
      const walk = (nodes, prefix=[]) => {
        for (let i = 0; i < nodes.length; i++) {
          const n = nodes[i];
          const current = [...prefix, i + 1];
          n.num = current.join('.');
          if (Array.isArray(n.children) && n.children.length) {
            walk(n.children, current);
          }
        }
      };
      walk(tree, []);
      return tree;
    }

    async function parseHeadings_JS(arrayBuffer) {
      const tr = TRACE('parseHeadings_JS', { hasBuffer: !!arrayBuffer, len: arrayBuffer?.byteLength });
      try {
        if (!arrayBuffer) return { flat: [], tree: [], count: 0 };

        const styleMap = await buildStyleOutlineMap(arrayBuffer);
        tr.step('styleMap', { entries: Object.keys(styleMap || {}).length });

        const zip = await JSZip.loadAsync(arrayBuffer);
        const parts = zip.file(/^word\/(?!_rels\/|theme\/|fontTable\.xml|styles\.xml|numbering\.xml|settings\.xml|webSettings\.xml).*\.xml$/i) || [];
        const parser = new DOMParser();
        const out = [];
        let idx = 0;

        for (const f of parts) {
          const pf = TRACE('parseHeadings_JS:file', f.name);
          const xmlTextContent = await f.async('string');
          try {
            const xml = parser.parseFromString(xmlTextContent, "application/xml");
            const paras = xml.getElementsByTagNameNS(W_NS, 'p');
            for (let i = 0; i < paras.length; i++) {
              const p = paras[i];
              const lvl = detectHeadingLevel(p, styleMap);
              if (!lvl) continue;
              const text = paraText(p);
              if (!text) continue;
              out.push({
                idx: ++idx,
                level: lvl,
                text,
                part: f.name.split('/').pop().replace('.xml','')
              });
            }
            pf.end({ added: idx });
          } catch (e) {
            pf.warn('xml parse error', e);
            pf.end({ added: 0, error: String(e?.message || e) });
          }
        }

        const tree = buildHeadingTree(out);
        tr.end({ count: out.length, rootChildren: tree.length });
        return { flat: out, tree, count: out.length };
      } catch (e) {
        tr.error('failed', e); tr.end();
        return { flat: [], tree: [], count: 0 };
      }
    }

    function buildHeadingTree(list) {
      const root = [];
      const stack = [];
      for (const h of list) {
        const node = { level: h.level, text: h.text, part: h.part, idx: h.idx, children: [] };
        while (stack.length && stack[stack.length - 1].level >= node.level) stack.pop();
        if (!stack.length) {
          root.push(node);
        } else {
          stack[stack.length - 1].children.push(node);
        }
        stack.push(node);
      }
      return root;
    }

    function renderHeadingsTreeView(tree) {
      const tr = TRACE('renderHeadingsTreeView', { nodes: tree?.length || 0 });
      try {
        if (!headersTreeEl) return;
        headersTreeEl.innerHTML = '';
        if (!tree || !tree.length) {
          headersTreeEl.innerHTML = '<div class="empty">No headings found (no paragraphs styled as headings).</div>';
          tr.end('empty'); return;
        }

        numberHeadingsTree(tree);

        const mk = (nodes) => {
          const ul = document.createElement('ul');
          ul.style.margin = '0 0 0 1rem';
          ul.style.padding = '0.1rem 0 0.1rem 0.6rem';
          for (const n of nodes) {
            const li = document.createElement('li');
            li.style.listStyle = 'none';

            const line = document.createElement('div');
            line.style.display = 'flex';
            line.style.gap = '6px';
            line.style.alignItems = 'baseline';

            const num = document.createElement('span');
            num.textContent = n.num;
            num.style.minWidth = '4ch';
            num.style.textAlign = 'right';
            num.style.fontVariantNumeric = 'tabular-nums';
            num.style.opacity = '0.9';
            num.style.fontWeight = n.level <= 2 ? '700' : '600';

            const text = document.createElement('span');
            text.textContent = n.text;
            text.title = `${n.part} • H${n.level}`;
            text.style.fontWeight = n.level <= 2 ? '600' : '400';

            const part = document.createElement('span');
            part.textContent = `· ${n.part}`;
            part.className = 'muted';
            part.style.fontSize = '0.75rem';

            line.appendChild(num);
            line.appendChild(text);
            line.appendChild(part);
            li.appendChild(line);

            if (n.children?.length) li.appendChild(mk(n.children));
            ul.appendChild(li);
          }
          return ul;
        };

        headersTreeEl.appendChild(mk(tree));
        tr.end('rendered');
      } catch (e) { tr.error('failed', e); tr.end(); }
    }

  </script>
</body>
</html>
