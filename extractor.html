<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Form Suite — Extractor</title>
  <link rel="icon" href="favicon.ico" type="image/gif" sizes="32x32">
  <link rel="shortcut icon" href="favicon.ico" type="image/gif">
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
  <link rel="stylesheet" href="style.css">
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

  <!-- JSZip for SDT scanning -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

  <!-- Core app plumbing -->
  <script src="persistence.js"></script>
  <script src="rules-core.js"></script>
  <script src="docx-core.js"></script>
  <script src="fs-active-doc.js"></script>
  <script src="fs-focus-nav.js"></script>

  <!-- Address autocomplete widget -->
  <script src="address-autocomplete.js"></script>

<style id="fs-multi-style">
/* Multi-select dropdown (checkbox-style) */
.fs-multi { position: relative; width: 100%; }
.fs-multi-btn {
  width: 100%;
  text-align: left;
  padding: 8px 10px;
  border: 1px solid rgba(0,0,0,.25);
  border-radius: 6px;
  background: #fff;
  cursor: pointer;
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  align-items: center;
  min-height: 38px;
}
.fs-multi-placeholder { color: rgba(0,0,0,.55); }
.fs-multi-chip {
  display: inline-flex;
  align-items: center;
  padding: 2px 8px;
  border: 1px solid rgba(0,0,0,.18);
  border-radius: 999px;
  background: rgba(0,0,0,.03);
  font-size: 12px;
  line-height: 1.3;
}
.fs-multi-menu {
  position: absolute;
  left: 0; right: 0;
  margin-top: 6px;
  border: 1px solid rgba(0,0,0,.25);
  border-radius: 6px;
  background: #fff;
  max-height: 240px;
  overflow: auto;
  display: none;
  z-index: 2000;
}
.fs-multi-menu.open { display: block; }
.fs-multi-opt {
  display: flex;
  gap: 10px;
  align-items: center;
  padding: 8px 10px;
  cursor: pointer;
  user-select: none;
}
.fs-multi-opt.selected { background: rgba(0,0,0,.06); }
.fs-multi-opt:hover { background: rgba(0,0,0,.04); }
.fs-multi-opt input[type="checkbox"] { pointer-events: none; }
</style>

</head>
<body>
<header>
  <div class="row">
    <span class="brand logo-md">
      <img src="logo.gif" alt="Form Suite logo" class="logo" />
      <strong>Form Suite</strong>
    </span>
    <span class="muted">·</span><a href="index.html">Form</a>
    <span class="muted">·</span><a href="builder.html" id="openBuilder">Form Builder</a>
    <span class="muted">·</span><a href="matcher.html">Tag Matcher</a>
    <span class="muted">·</span><a href="rules.html">Rules</a>
    <span class="muted">·</span><span class="muted">Extractor</span>
  </div>
</header>

<main>
  <section class="panel">
    <h2 style="margin:0 0 10px">Inspect SDTs & store manual form payload in the DOCX</h2>
    <div class="row" style="gap:8px;flex-wrap:wrap">
      <button id="btnOpen">Open DOCX…</button>
      <button id="btnSave" disabled>Save (payload only)</button>
      <span class="muted" id="status" style="margin-left:auto">Idle</span>
    </div>

    <div id="permNote" class="note warn" style="display:none;margin-top:10px">
      This DOCX was opened via picker but I don’t have write permission to the original file.
      Clicking <em>Save</em> will write to a copy instead of the original.
      <button id="btnRegrant" class="ghost" style="margin-left:8px">Grant write access</button>
    </div>

    <!-- DEBUG PANEL -->
    <details class="panel" style="margin-top:12px;">
      <summary><strong>Debug (Bytes/Handle/Persistence)</strong></summary>
      <div class="row" style="gap:8px; flex-wrap:wrap; margin-top:10px;">
        <button id="btnDbgSnap" class="secondary">Snapshot now</button>
        <button id="btnDbgClear" class="ghost">Clear debug log</button>
        <label class="row" style="gap:6px; align-items:center;">
          <input type="checkbox" id="dbgVerbose" checked />
          <span class="muted">Verbose</span>
        </label>
      </div>
      <textarea id="dbgLog" spellcheck="false" style="width:100%; min-height:220px; margin-top:10px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;"></textarea>
      <div class="muted" style="margin-top:8px; font-size:0.85rem;">
        Tip: reproduce the issue, then copy/paste this log. Look for “diagPersist” and “getWorkingDocBytesU8” fallbacks.
      </div>
    </details>
  </section>

  <div class="grid-3">
    <section class="panel">
      <details open>
        <summary><strong>Found SDTs</strong></summary>
        <div style="overflow:auto;">
          <table id="sdt-table">
            <thead>
            <tr>
              <th>#</th>
              <th>Part</th>
              <th>w:tag</th>
              <th>w:alias</th>
              <th>Text</th>
            </tr>
            </thead>
            <tbody id="sdt-tbody"></tbody>
          </table>
        </div>
      </details>
    </section>

    <section class="panel">
      <details open>
        <summary><strong>CRONOS_PAYLOAD Preview</strong></summary>
        <textarea id="payloadPreview" spellcheck="false" style="min-height:420px"></textarea>
        <div class="row" style="margin-top:6px; gap:8px;">
          <button id="btnSaveFromPreview" class="secondary" disabled>Apply JSON & Save</button>
          <span class="muted" id="previewStatus"></span>
        </div>
      </details>
    </section>

    <section class="panel">
      <details>
        <summary><strong>Headers/Subheaders</strong></summary>
        <div id="headersTree" class="tree" style="max-height:420px;overflow:auto;padding:6px 4px;"></div>
      </details>
    </section>

    <section class="panel">
      <details open>
        <summary><strong>Live Form (from payload schema)</strong></summary>
        <div id="formMount"></div>
      </details>
    </section>
  </div>
</main>

<script>
'use strict';

/* ============================================================
   TRACE (one primitive) + DEBUG LOG SINK
   ============================================================ */
(function ensureTrace() {
  if (typeof window.TRACE === 'function') return;

  const DEBUG = { on: true, seq: 0 };
  const ts = () => new Date().toISOString().slice(11, 23);

  function safeJson(x) {
    try {
      return JSON.stringify(x, (k, v) => {
        if (v instanceof ArrayBuffer) return { __type: 'ArrayBuffer', byteLength: v.byteLength };
        if (v instanceof Uint8Array) return { __type: 'Uint8Array', byteLength: v.byteLength };
        if (v && typeof v === 'object' && v.kind && v.name && typeof v.getFile === 'function') {
          return { __type: 'FileSystemHandle', kind: v.kind, name: v.name };
        }
        if (typeof v === 'function') return { __type: 'function', name: v.name || '(anon)' };
        return v;
      }, 2);
    } catch {
      try { return String(x); } catch { return '(unprintable)'; }
    }
  }

  window.__DBG = {
    verbose: true,
    buf: [],
    max: 2000,
    write(line) {
      this.buf.push(line);
      if (this.buf.length > this.max) this.buf.splice(0, this.buf.length - this.max);
      const el = document.getElementById('dbgLog');
      if (el) el.value = this.buf.join('\n');
    },
    log(name, payload) {
      const line = `[${ts()}] ${name} ${payload !== undefined ? safeJson(payload) : ''}`;
      this.write(line);
    }
  };

  window.TRACE = function TRACE(name, details) {
    const id = ++DEBUG.seq;
    const prefix = `[Extractor ${ts()} #${id}] ${name}`;
    const t0 = (typeof performance !== 'undefined' ? performance.now() : Date.now());

    if (DEBUG.on) console.log(prefix, details ?? '');
    try { window.__DBG?.log(prefix, details ?? ''); } catch {}

    return {
      step(msg, data) {
        if (DEBUG.on) console.log(`${prefix}  ↳ ${msg}`, data ?? '');
        if (window.__DBG?.verbose) window.__DBG.log(`${prefix}  ↳ ${msg}`, data ?? '');
      },
      warn(msg, data) {
        if (DEBUG.on) console.warn(`${prefix}  ⚠ ${msg}`, data ?? '');
        window.__DBG?.log(`${prefix}  ⚠ ${msg}`, data ?? '');
      },
      error(msg, err) {
        if (DEBUG.on) console.error(`${prefix}  ✖ ${msg}`, err);
        window.__DBG?.log(`${prefix}  ✖ ${msg}`, { message: err?.message, name: err?.name, stack: err?.stack });
      },
      end(extra) {
        const t1 = (typeof performance !== 'undefined' ? performance.now() : Date.now());
        const ms = Math.round((t1 - t0) * 1000) / 1000;
        if (DEBUG.on) console.log(`${prefix} done (${ms}ms)`, extra ?? '');
        window.__DBG?.log(`${prefix} done (${ms}ms)`, extra ?? '');
      }
    };
  };
})();

window.addEventListener('error', (e) => {
  console.error('[Extractor window.error]', {
    message: e.message,
    filename: e.filename,
    lineno: e.lineno,
    colno: e.colno,
    error: e.error
  });
  try { window.__DBG?.log('[window.error]', { message: e.message, filename: e.filename, lineno: e.lineno, colno: e.colno }); } catch {}
});
window.addEventListener('unhandledrejection', (e) => {
  console.error('[Extractor window.unhandledrejection]', e.reason);
  try { window.__DBG?.log('[unhandledrejection]', { reason: String(e.reason?.message || e.reason) }); } catch {}
});

window.addEventListener('pageshow', (e) => {
  // If BFCache is in play you want to know; it can change unload/restore behavior.
  window.__DBG?.log('[pageshow]', { persisted: !!e.persisted });
});
window.addEventListener('pagehide', (e) => {
  window.__DBG?.log('[pagehide]', { persisted: !!e.persisted });
});

/* ============================================================
   Single coordination layer: fs-active-doc + formSuitePersist
   ============================================================ */

const PAYLOAD_KEY = 'CRONOS_PAYLOAD';
const supportsFS  = ('showOpenFilePicker' in window) && ('showSaveFilePicker' in window);

const els = {
  btnOpen: document.getElementById('btnOpen'),
  btnSave: document.getElementById('btnSave'),
  status: document.getElementById('status'),
  permNote: document.getElementById('permNote'),
  btnRegrant: document.getElementById('btnRegrant'),
  payloadPreview: document.getElementById('payloadPreview'),
  btnSaveFromPreview: document.getElementById('btnSaveFromPreview'),
  previewStatus: document.getElementById('previewStatus'),
  formMount: document.getElementById('formMount'),
  tableBody: document.getElementById('sdt-tbody'),
  headersTree: document.getElementById('headersTree'),
  dbgLog: document.getElementById('dbgLog'),
  btnDbgSnap: document.getElementById('btnDbgSnap'),
  btnDbgClear: document.getElementById('btnDbgClear'),
  dbgVerbose: document.getElementById('dbgVerbose'),
};

if (els.dbgVerbose) {
  els.dbgVerbose.addEventListener('change', () => {
    window.__DBG.verbose = !!els.dbgVerbose.checked;
    window.__DBG.log('[dbgVerbose]', { verbose: window.__DBG.verbose });
  });
}
if (els.btnDbgClear) {
  els.btnDbgClear.addEventListener('click', () => {
    window.__DBG.buf = [];
    if (els.dbgLog) els.dbgLog.value = '';
  });
}

const bc = ('BroadcastChannel' in window) ? new BroadcastChannel('fs-active-doc') : null;
window.__DBG?.log('[init]', { supportsFS, hasBC: !!bc, ua: navigator.userAgent });

function setStatus(text) {
  const tr = TRACE('setStatus', { text });
  try { els.status.textContent = String(text || ''); }
  finally { tr.end(); }
}

function assertDeps() {
  const tr = TRACE('assertDeps');
  try {
    const miss = [];
    if (!window.formSuitePersist) miss.push('window.formSuitePersist (persistence.js)');
    if (typeof window.readActiveDocSync !== 'function') miss.push('readActiveDocSync (fs-active-doc.js)');
    if (typeof window.installActiveDocListener !== 'function') miss.push('installActiveDocListener (fs-active-doc.js)');

    // Introspect persist surface area
    if (window.formSuitePersist) {
      const keys = Object.keys(window.formSuitePersist).sort();
      tr.step('formSuitePersist.keys', keys);
    }

    if (miss.length) {
      console.error('[Extractor] Missing deps:', miss);
      setStatus('Error: missing core dependencies (see console).');
      tr.end({ ok: false, miss });
      return false;
    }
    tr.end({ ok: true });
    return true;
  } finally {
    tr.end();
  }
}

function splitNameAndExt(fileName) {
  const m = String(fileName || '').match(/\.(docx|docm|dotx|dotm)$/i);
  return {
    base: String(fileName || 'document.docx').replace(/\.(docx|docm|dotx|dotm)$/i, ''),
    ext:  (m ? m[1] : 'docx').toLowerCase()
  };
}

async function sha256Hex(bufOrU8) {
  const tr = TRACE('sha256Hex', { type: bufOrU8?.constructor?.name, len: bufOrU8?.byteLength || bufOrU8?.length });
  try {
    const ab = (bufOrU8 instanceof ArrayBuffer)
      ? bufOrU8
      : (bufOrU8?.buffer instanceof ArrayBuffer)
        ? bufOrU8.buffer
        : new Uint8Array(bufOrU8 || []).buffer;
    const d = await crypto.subtle.digest('SHA-256', ab);
    const hex = [...new Uint8Array(d)].map(b => b.toString(16).padStart(2, '0')).join('');
    tr.end({ hex: hex.slice(0, 12) });
    return hex;
  } catch (e) {
    tr.error('sha failed', e);
    tr.end();
    return '(hash-error)';
  }
}

/* ============================================================
   In-memory state
   ============================================================ */
let currentDoc = null;           // {docId, name}
let currentHandle = null;        // FileSystemFileHandle (best-effort cache)
let currentBytesU8 = null;       // Uint8Array (best-effort cache)

let schema = { title: 'Form', fields: [] };
let values = {};
let tagMap = {};
let headingsBaseline = { flat: [], tree: [] };
let lastParsedHeadings = { flat: [], tree: [] };

let __hydrating = false;
let __fgRefreshLock = false;

// Address widget store
const __addressValues = Object.create(null);

/* ============================================================
   PERSIST DIAGNOSTICS (critical for this bug)
   ============================================================ */
function describeHandle(h) {
  if (!h) return null;
  return {
    kind: h.kind,
    name: h.name,
    hasGetFile: typeof h.getFile === 'function',
    hasCreateWritable: typeof h.createWritable === 'function',
    hasQueryPermission: typeof h.queryPermission === 'function',
    hasRequestPermission: typeof h.requestPermission === 'function',
  };
}

async function diagPersist(docId, note) {
  const tr = TRACE('diagPersist', { note, docId, mem: { hasBytes: !!currentBytesU8, hasHandle: !!currentHandle } });
  try {
    const out = { note, docId, supportsFS, mem: {}, persist: {}, handle: {} };

    out.mem.bytesLen = currentBytesU8?.byteLength || 0;
    out.mem.handle = describeHandle(currentHandle);

    // Persist: current bytes
    try {
      const b0 = await window.formSuitePersist.getCurrentDocBytes?.();
      out.persist.currentBytes = !!(b0 && (b0.byteLength || b0.length));
      out.persist.currentBytesLen = b0?.byteLength || b0?.length || 0;
    } catch (e) {
      out.persist.currentBytesErr = { name: e?.name, message: e?.message };
    }

    // Persist: per-doc bytes
    try {
      const b1 = docId ? await window.formSuitePersist.getBytes?.(docId) : null;
      out.persist.docBytes = !!(b1 && (b1.byteLength || b1.length));
      out.persist.docBytesLen = b1?.byteLength || b1?.length || 0;
    } catch (e) {
      out.persist.docBytesErr = { name: e?.name, message: e?.message };
    }

    // Persist: handle
    try {
      const h = docId ? await window.formSuitePersist.getHandle?.(docId) : null;
      out.persist.handle = describeHandle(h);
      if (h?.queryPermission) {
        try { out.persist.permRead = await h.queryPermission({ mode: 'read' }); } catch (e) { out.persist.permReadErr = e?.message; }
        try { out.persist.permRW = await h.queryPermission({ mode: 'readwrite' }); } catch (e) { out.persist.permRWErr = e?.message; }
      }
    } catch (e) {
      out.persist.handleErr = { name: e?.name, message: e?.message };
    }

    // Active meta
    try {
      const meta = (typeof window.readActiveDocSync === 'function') ? window.readActiveDocSync() : null;
      out.activeMeta = meta || null;
    } catch (e) {
      out.activeMetaErr = { name: e?.name, message: e?.message };
    }

    tr.end(out);
    return out;
  } catch (e) {
    tr.error('diagPersist failed', e);
    tr.end();
    return null;
  }
}

/* ============================================================
   Canonical byte access workflow (one function) + EXTRA TRACE
   ============================================================ */
async function getWorkingDocBytesU8() {
  const tr = TRACE('getWorkingDocBytesU8', { docId: currentDoc?.docId, hasHandle: !!currentHandle, memBytes: currentBytesU8?.byteLength || 0 });
  try {
    // 0) In-memory cache (if still present)
    if (currentBytesU8?.byteLength) {
      tr.step('use mem cache', { len: currentBytesU8.byteLength });
      tr.end({ mode: 'mem', len: currentBytesU8.byteLength });
      return currentBytesU8;
    }

    // 1) Prefer persistence "current bytes" (already includes in-memory writes)
    try {
      const b0 = await window.formSuitePersist.getCurrentDocBytes?.();
      tr.step('persist.getCurrentDocBytes', { ok: !!b0, len: b0?.byteLength || b0?.length || 0, type: b0?.constructor?.name });
      if (b0 && (b0.byteLength || b0.length)) {
        const u8 = (b0 instanceof Uint8Array) ? b0 : new Uint8Array(b0);
        tr.end({ mode: 'persist.getCurrentDocBytes', len: u8.byteLength });
        return u8;
      }
    } catch (e) { tr.warn('getCurrentDocBytes failed', e); }

    // 2) Per-doc cache
    try {
      if (currentDoc?.docId) {
        const b1 = await window.formSuitePersist.getBytes?.(currentDoc.docId);
        tr.step('persist.getBytes', { ok: !!b1, len: b1?.byteLength || b1?.length || 0, type: b1?.constructor?.name });
        if (b1 && (b1.byteLength || b1.length)) {
          const u8 = (b1 instanceof Uint8Array) ? b1 : new Uint8Array(b1);
          tr.end({ mode: 'persist.getBytes', len: u8.byteLength });
          return u8;
        }
      }
    } catch (e) { tr.warn('getBytes failed', e); }

    // 3) Handle fallback
    try {
      const h = currentHandle || (currentDoc?.docId ? await window.formSuitePersist.getHandle?.(currentDoc.docId) : null);
      tr.step('handle candidate', { memHandle: !!currentHandle, persistHandle: !!(!currentHandle && !!h), h: describeHandle(h) });
      if (h?.getFile) {
        const p = await window.formSuitePersist.ensurePermission?.(h, 'read') || 'granted';
        tr.step('ensurePermission(read)', p);
        if (p === 'granted') {
          const f = await h.getFile();
          tr.step('handle.getFile', { name: f?.name, size: f?.size, type: f?.type });
          const u8 = new Uint8Array(await f.arrayBuffer());
          currentHandle = h;
          tr.end({ mode: 'handle.getFile', len: u8.byteLength });
          return u8;
        }
      }
    } catch (e) { tr.warn('handle.getFile failed', e); }

    // As a last resort, print a persist snapshot right here
    await diagPersist(currentDoc?.docId, 'getWorkingDocBytesU8:miss');

    tr.end({ mode: 'none' });
    return null;
  } catch (e) {
    tr.error('getWorkingDocBytesU8 failed', e);
    tr.end();
    return null;
  }
}

/* ============================================================
   Single write access banner workflow (unchanged except extra trace)
   ============================================================ */
async function updateWriteAccessBanner({ tryPrompt = false } = {}) {
  const tr = TRACE('updateWriteAccessBanner', { tryPrompt, docId: currentDoc?.docId, supportsFS });
  try {
    if (!supportsFS || !currentDoc?.docId) { els.permNote.style.display = 'none'; tr.end('unsupported/no-doc'); return 'unsupported'; }

    const h = currentHandle || await window.formSuitePersist.getHandle?.(currentDoc.docId);
    tr.step('handle', describeHandle(h));
    if (!h?.queryPermission) { els.permNote.style.display = 'none'; tr.end('no-handle'); return 'no-handle'; }

    let p = await h.queryPermission({ mode: 'readwrite' });
    tr.step('queryPermission(readwrite)', p);

    if (p !== 'granted' && tryPrompt && h.requestPermission) {
      try { p = await h.requestPermission({ mode: 'readwrite' }) || p; }
      catch (e) { tr.warn('requestPermission failed', e); }
    }

    els.permNote.style.display = (p === 'granted') ? 'none' : 'block';
    if (p === 'granted') currentHandle = h;
    tr.end({ final: p });
    return p || 'denied';
  } catch (e) {
    tr.error('updateWriteAccessBanner failed', e);
    els.permNote.style.display = 'block';
    tr.end('error');
    return 'error';
  }
}

/* ============================================================
   UI reset
   ============================================================ */
function clearUi(message = 'Idle') {
  const tr = TRACE('clearUi', { message });
  try {
    els.tableBody.innerHTML = '<tr><td colspan="5" class="empty">No document loaded.</td></tr>';
    els.formMount.innerHTML = '<div class="empty">No schema found.</div>';
    els.payloadPreview.value = '';
    els.previewStatus.textContent = '';
    if (els.headersTree) els.headersTree.innerHTML = '<div class="empty">No headings.</div>';
    els.btnSave.disabled = true;
    els.btnSaveFromPreview.disabled = true;
    els.permNote.style.display = 'none';
    setStatus(message);
  } finally { tr.end(); }
}

/* ============================================================
   DOCX reads/writes (payload only)
   ============================================================ */
async function readPayloadFromDocx(bytesU8) {
  const tr = TRACE('readPayloadFromDocx', { len: bytesU8?.byteLength });
  try {
    if (!bytesU8?.byteLength) return null;

    let raw = null;
    try {
      if (typeof window.readDocVarSettings === 'function') {
        raw = await window.readDocVarSettings(bytesU8, PAYLOAD_KEY);
      }
    } catch (e) { tr.warn('readDocVarSettings failed', e); }

    if (raw == null) {
      try {
        if (typeof window.readDocVarCustom === 'function') {
          raw = await window.readDocVarCustom(bytesU8, PAYLOAD_KEY);
        }
      } catch (e) { tr.warn('readDocVarCustom failed', e); }
    }

    tr.end({ has: !!raw, len: raw ? String(raw).length : 0 });
    return raw;
  } catch (e) {
    tr.error('readPayloadFromDocx failed', e);
    tr.end();
    return null;
  }
}

async function writePayloadToDocx(bytesU8, payloadObj) {
  const tr = TRACE('writePayloadToDocx', { inLen: bytesU8?.byteLength, fields: payloadObj?.fields?.length || 0 });
  try {
    if (!bytesU8?.byteLength) throw new Error('No bytes to write');
    const json = JSON.stringify(payloadObj || {}, null, 0);

    let out = null;
    try {
      if (typeof window.writeDocVarSettings === 'function') {
        out = await window.writeDocVarSettings(bytesU8, PAYLOAD_KEY, json);
      }
    } catch (e) { tr.warn('writeDocVarSettings failed', e); }

    if (!out) {
      try {
        if (typeof window.writeDocVarCustom === 'function') {
          out = await window.writeDocVarCustom(bytesU8, PAYLOAD_KEY, json);
        }
      } catch (e) { tr.warn('writeDocVarCustom failed', e); }
    }

    if (!out) throw new Error('No docx writer available (writeDocVarSettings/writeDocVarCustom missing).');

    const outU8 = (out instanceof Uint8Array) ? out : new Uint8Array(out);
    tr.end({ outLen: outU8.byteLength, outSha: (await sha256Hex(outU8)).slice(0, 12) });
    return outU8;
  } catch (e) {
    tr.error('writePayloadToDocx failed', e);
    tr.end();
    throw e;
  }
}

/* ============================================================
   Rules + payload normalization (same as yours)
   ============================================================ */
function makeBaselineFromParsed(parsed) {
  return {
    flat: Array.isArray(parsed?.flat) ? parsed.flat : [],
    tree: Array.isArray(parsed?.tree) ? parsed.tree : []
  };
}

function normalizeAllForDoc(wsState, nextSchema, baseline) {
  const tr = TRACE('normalizeAllForDoc', {
    hasSchema: !!nextSchema,
    fields: nextSchema?.fields?.length || 0,
    baselineFlat: baseline?.flat?.length || 0
  });
  try {
    const normalized = (typeof window.deriveNormalizedRulesForDoc === 'function')
      ? window.deriveNormalizedRulesForDoc(wsState || {}, nextSchema || null, baseline || { flat: [], tree: [] })
      : { headingRules: (wsState?.rules || []), fieldRules: (wsState?.fieldRules || []) };

    const headingRules = Array.isArray(normalized?.headingRules) ? normalized.headingRules : (Array.isArray(wsState?.rules) ? wsState.rules : []);
    const fieldRules   = Array.isArray(normalized?.fieldRules) ? normalized.fieldRules : (Array.isArray(wsState?.fieldRules) ? wsState.fieldRules : []);

    tr.end({ headingRules: headingRules.length, fieldRules: fieldRules.length });
    return { headingRules, fieldRules };
  } catch (e) {
    tr.error('normalizeAllForDoc failed', e);
    tr.end();
    return { headingRules: Array.isArray(wsState?.rules) ? wsState.rules : [], fieldRules: Array.isArray(wsState?.fieldRules) ? wsState.fieldRules : [] };
  }
}

function pruneBySchema(nextSchema, nextValues, nextTagMap) {
  const fieldIds = new Set((nextSchema?.fields || []).map(f => String(f.id)));
  const prunedValues = {};
  for (const [k, v] of Object.entries(nextValues || {})) {
    if (fieldIds.has(String(k))) prunedValues[k] = v;
  }
  const prunedTagMap = {};
  for (const [tag, fid] of Object.entries(nextTagMap || {})) {
    if (fieldIds.has(String(fid))) prunedTagMap[tag] = fid;
  }
  return { values: prunedValues, tagMap: prunedTagMap };
}

async function saveWorkspaceMirror(docId, payloadObj, { baseline } = {}) {
  const tr = TRACE('saveWorkspaceMirror', { docId, fields: payloadObj?.fields?.length || 0 });
  try {
    if (!docId) return;

    const patch = {
      schema: { title: payloadObj.title || 'Form', fields: Array.isArray(payloadObj.fields) ? payloadObj.fields : [] },
      values: payloadObj.values || {},
      tagMap: payloadObj.tagMap || {},
      rules: Array.isArray(payloadObj.rules) ? payloadObj.rules : [],
      fieldRules: Array.isArray(payloadObj.fieldRules) ? payloadObj.fieldRules : [],
      payload: { CRONOS_PAYLOAD: payloadObj },
      schemaUpdatedAt: new Date().toISOString(),
      headingsUpdatedAt: new Date().toISOString(),
    };

    if (baseline?.flat) patch.headingsFlat = baseline.flat;
    if (baseline?.tree) patch.headingsTree = baseline.tree;

    await window.formSuitePersist.saveState(docId, patch);
    tr.end({ ok: true });
  } catch (e) {
    tr.error('saveWorkspaceMirror failed', e);
    tr.end();
  }
}

/* ============================================================
   SDT parsing (unchanged)
   ============================================================ */
const DOCX_NS = window.DOCX_W_NS || window.W_NS || "http://schemas.openxmlformats.org/wordprocessingml/2006/main";

function xmlText(el) {
  let s = '';
  const rec = n => {
    if (!n) return;
    if (n.nodeType === 3) { s += n.nodeValue; return; }
    if (n.nodeType === 1) {
      const ln = n.localName;
      if (ln === 'p' || ln === 'cr' || ln === 'br') s += '\n';
      for (const ch of n.childNodes) rec(ch);
    }
  };
  rec(el);
  return s.replace(/\s+\n/g, '\n').replace(/\n{3,}/g, '\n\n').trim();
}

async function parseSDTs_JS(arrayBuffer) {
  const tr = TRACE('parseSDTs_JS', { hasBuffer: !!arrayBuffer, len: arrayBuffer?.byteLength });
  try {
    if (!arrayBuffer) return { sdts: [], total: 0 };
    const zip = await JSZip.loadAsync(arrayBuffer);
    const parts = zip.file(/^word\/(?!_rels\/|theme\/|fontTable\.xml|styles\.xml|numbering\.xml|settings\.xml|webSettings\.xml).*\.xml$/i) || [];
    const parser = new DOMParser();
    const sdts = [];

    for (const f of parts) {
      const pf = TRACE('parseSDTs_JS:file', { name: f.name });
      try {
        const xmlTextContent = await f.async('string');
        const xml = parser.parseFromString(xmlTextContent, "application/xml");
        const found = Array.from(xml.getElementsByTagNameNS(DOCX_NS, 'sdt'));
        for (const sdt of found) {
          const pr = sdt.getElementsByTagNameNS(DOCX_NS, 'sdtPr')[0];
          const content = sdt.getElementsByTagNameNS(DOCX_NS, 'sdtContent')[0] || sdt;
          let tagVal = '';
          let alias = '';

          if (pr) {
            const tEl = pr.getElementsByTagNameNS(DOCX_NS, 'tag')[0];
            if (tEl) tagVal = tEl.getAttributeNS(DOCX_NS, 'val') || tEl.getAttribute('w:val') || '';
            const aEl = pr.getElementsByTagNameNS(DOCX_NS, 'alias')[0];
            if (aEl) alias = aEl.getAttributeNS(DOCX_NS, 'val') || aEl.getAttribute('w:val') || '';
          }

          sdts.push({
            part: f.name.split('/').pop().replace('.xml', ''),
            tag: tagVal,
            alias,
            text: xmlText(content)
          });
        }
        pf.end({ added: found.length });
      } catch (e) {
        pf.warn('xml parse failed', e);
        pf.end({ error: true });
      }
    }

    tr.end({ total: sdts.length });
    return { sdts, total: sdts.length };
  } catch (e) {
    tr.error('parseSDTs_JS failed', e);
    tr.end();
    return { sdts: [], total: 0 };
  }
}

function renderSDTsView(parsed) {
  const tr = TRACE('renderSDTsView', { total: parsed?.total });
  try {
    els.tableBody.innerHTML = '';
    const sdts = parsed?.sdts || [];
    if (!sdts.length) {
      const trEl = document.createElement('tr');
      const td = document.createElement('td');
      td.colSpan = 5;
      td.className = 'empty';
      td.textContent = 'No SDTs found in this document.';
      trEl.appendChild(td);
      els.tableBody.appendChild(trEl);
      return;
    }

    sdts.forEach((row, i) => {
      const trEl = document.createElement('tr');

      const tdIdx = document.createElement('td'); tdIdx.textContent = String(i + 1);
      const tdPart = document.createElement('td'); tdPart.textContent = row.part || '';
      const tdTag = document.createElement('td'); tdTag.textContent = row.tag || '';
      const tdAlias = document.createElement('td'); tdAlias.textContent = row.alias || '';
      const tdText = document.createElement('td'); tdText.textContent = row.text || '';

      trEl.appendChild(tdIdx);
      trEl.appendChild(tdPart);
      trEl.appendChild(tdTag);
      trEl.appendChild(tdAlias);
      trEl.appendChild(tdText);

      els.tableBody.appendChild(trEl);
    });
  } finally {
    tr.end();
  }
}

/* ============================================================
   Headings: degrade gracefully
   ============================================================ */
async function parseHeadings_JS(arrayBuffer) {
  const tr = TRACE('parseHeadings_JS', { len: arrayBuffer?.byteLength });
  try {
    if (typeof window.parseHeadings_JS === 'function' && window.parseHeadings_JS !== parseHeadings_JS) {
      const out = await window.parseHeadings_JS(arrayBuffer);
      tr.end({ mode: 'window.parseHeadings_JS', flat: out?.flat?.length || 0 });
      return out;
    }
    const out = { flat: [], tree: [], count: 0 };
    tr.end({ mode: 'noop', flat: 0 });
    return out;
  } catch (e) {
    tr.error('parseHeadings_JS failed', e);
    tr.end();
    return { flat: [], tree: [], count: 0 };
  }
}

function buildHeadingTree(list) {
  const root = [];
  const stack = [];
  for (const h of (list || [])) {
    const node = {
      level: h.level,
      text: h.text,
      part: h.part || 'document',
      idx: h.idx,
      uid: h.uid,
      paraIndex: h.paraIndex,
      start: h.start,
      end: h.end,
      label: h.label || h.text,
      children: []
    };
    while (stack.length && stack[stack.length - 1].level >= node.level) stack.pop();
    if (!stack.length) root.push(node);
    else stack[stack.length - 1].children.push(node);
    stack.push(node);
  }
  return root;
}

function renderHeadingsTreeView(tree) {
  const tr = TRACE('renderHeadingsTreeView', { nodes: tree?.length || 0 });
  try {
    if (!els.headersTree) return;
    els.headersTree.innerHTML = '';

    if (!tree || !tree.length) {
      els.headersTree.innerHTML = '<div class="empty">No headings found (no paragraphs styled as headings).</div>';
      tr.end('empty');
      return;
    }

    if (typeof window.numberHeadingsTree === 'function') {
      try { window.numberHeadingsTree(tree); } catch (e) { tr.warn('numberHeadingsTree failed', e); }
    }

    const mk = (nodes) => {
      const ul = document.createElement('ul');
      ul.style.margin = '0 0 0 1rem';
      ul.style.padding = '0.1rem 0 0.1rem 0.6rem';
      for (const n of nodes) {
        const li = document.createElement('li');
        li.style.listStyle = 'none';

        const line = document.createElement('div');
        line.style.display = 'flex';
        line.style.gap = '6px';
        line.style.alignItems = 'baseline';

        const num = document.createElement('span');
        num.textContent = n.num || '';
        num.style.minWidth = '4ch';
        num.style.textAlign = 'right';
        num.style.fontVariantNumeric = 'tabular-nums';
        num.style.opacity = '0.9';
        num.style.fontWeight = n.level <= 2 ? '700' : '600';

        const text = document.createElement('span');
        text.textContent = n.text;
        text.title = `${n.part} · H${n.level}`;
        text.style.fontWeight = n.level <= 2 ? '600' : '400';

        const part = document.createElement('span');
        part.textContent = `· ${n.part}`;
        part.className = 'muted';
        part.style.fontSize = '0.75rem';

        line.appendChild(num);
        line.appendChild(text);
        line.appendChild(part);
        li.appendChild(line);

        if (n.children?.length) li.appendChild(mk(n.children));
        ul.appendChild(li);
      }
      return ul;
    };

    els.headersTree.appendChild(mk(tree));
    tr.end('rendered');
  } catch (e) {
    tr.error('renderHeadingsTreeView failed', e);
    tr.end();
  }
}

/* ============================================================
   Preview + form rendering (unchanged)
   ============================================================ */
function collectFormValues(schema) {
  const form = document.getElementById('liveForm');
  const out = {};
  if (!form || !schema) return out;

  for (const f of (schema.fields || [])) {
    const fid = String(f.id || '');
    if (!fid) continue;

    // Tables are edited in the Form page (index) and persisted in workspace state.
    // Extractor does not render native controls for tables; never overwrite them.
    if (f.type === 'table') continue;

    if (f.type === 'multichoice') {
      const nodes = form.querySelectorAll(`input[type="checkbox"][name="${CSS.escape(fid)}"]`);
      // If there are no checkboxes rendered (e.g., hidden/disabled/not in this form), do not overwrite.
      if (!nodes || nodes.length === 0) continue;
      out[fid] = Array.from(nodes).filter(n => n.checked).map(n => n.value);
      continue;
    }

    if (f.type === 'address') {
      // If address component isn't mounted/changed, do not overwrite.
      if (!(fid in __addressValues)) continue;
      out[fid] = __addressValues[fid] ?? null;
      continue;
    }

    const el = form.elements[fid];
    // If this field has no native element (e.g., hidden/removed/custom UI), do not overwrite.
    if (!el) continue;

    // Multiple select: custom UI stores JSON in a hidden input.
if (f.type === 'select' && !!f.multiple) {
  // If the hidden input isn't rendered (e.g., field hidden), do not overwrite.
  if (!el) continue;
  try {
    const v = String(el.value || '[]');
    const parsed = JSON.parse(v);
    out[fid] = Array.isArray(parsed) ? parsed.map(String) : [];
  } catch {
    // Fallback: treat as comma-separated list.
    out[fid] = String(el.value || '').split(',').map(s => s.trim()).filter(Boolean);
  }
  continue;
}

    out[fid] = el.value;
  }

  return out;
}


let previewTimer = null;
function schedulePreviewUpdate() {
  clearTimeout(previewTimer);
  previewTimer = setTimeout(async () => {
    const tr = TRACE('schedulePreviewUpdate:tick');
    try {
      const vals = collectFormValues(schema);
      values = { ...(values || {}), ...(vals || {}) };

      if (currentDoc?.docId) {
        await window.formSuitePersist.saveState(currentDoc.docId, { schema, values });
        bc?.postMessage({ type: 'state:changed', docId: currentDoc.docId, ts: Date.now() });
      }

      await updatePreview();
      setStatus('Unsaved changes — press Save to update DOCX.');
    } catch (e) {
      tr.error('preview tick failed', e);
    } finally {
      tr.end();
    }
  }, 250);
}

function buildForm(container, schema, values) {
  const tr = TRACE('buildForm', { fields: schema?.fields?.length || 0 });
  try {
    container.innerHTML = '';
    if (!schema || !Array.isArray(schema.fields) || schema.fields.length === 0) {
      container.innerHTML = '<div class="empty">No manual schema. Create one in the Builder, or load a DOCX that already contains a payload schema.</div>';
      tr.end('empty schema');
      return;
    }

    const form = document.createElement('form');
    form.id = 'liveForm';
    form.noValidate = true;
    form.style.display = 'grid';
    form.style.gap = '12px';

    if (schema.title) {
      const h = document.createElement('h4');
      h.textContent = schema.title;
      h.style.margin = '0 0 6px';
      form.appendChild(h);
    }

    for (const f of schema.fields) {
      const tf = TRACE('buildForm:field', { id: f.id, type: f.type });
      const wrap = document.createElement('div');
      wrap.className = 'field';

      const label = document.createElement('label');
      label.htmlFor = f.id;
      label.style.display = 'flex';
      label.style.justifyContent = 'space-between';
      label.style.alignItems = 'center';

      const labelText = document.createElement('span');
      labelText.textContent = f.label || f.id || '(field)';
      label.appendChild(labelText);

      if (f.required) {
        const star = document.createElement('span');
        star.textContent = '•';
        star.title = 'Required';
        star.style.fontWeight = '600';
        star.style.color = '#ef4444';
        label.appendChild(star);
      }

      wrap.appendChild(label);

      let input;
      let customMount = null;

      if (f.type === 'multichoice') {
        const box = document.createElement('div');
        box.style.display = 'grid';
        box.style.gap = '6px';

        (f.options || []).forEach(opt => {
          const v = String(opt?.value ?? opt);
          const id = `${f.id}__${v.replace(/\s+/g, '_')}`;
          const row = document.createElement('label');
          row.style.display = 'flex';
          row.style.gap = '8px';
          row.style.alignItems = 'center';

          const cb = document.createElement('input');
          cb.type = 'checkbox';
          cb.name = f.id;
          cb.id = id;
          cb.value = v;

          if (Array.isArray(values?.[f.id]) && values[f.id].map(String).includes(v)) cb.checked = true;

          const span = document.createElement('span');
          span.textContent = String(opt?.label ?? opt?.text ?? opt?.value ?? opt);

          row.appendChild(cb);
          row.appendChild(span);
          box.appendChild(row);
        });

        wrap.appendChild(box);
        box.addEventListener('change', schedulePreviewUpdate);
        form.appendChild(wrap);
        tf.end();
        continue;
      }

      if (f.type === 'select') {
        const isMulti = !!f.multiple;

        if (!isMulti) {
          input = document.createElement('select');

          (f.options || []).forEach(opt => {
            const o = document.createElement('option');
            o.value = String(opt?.value ?? opt?.id ?? opt);
            o.textContent = String(opt?.label ?? opt?.text ?? opt?.value ?? opt);
            input.appendChild(o);
          });

          // hydrate value
          const cur = values?.[f.id];
          if (cur != null) input.value = String(cur);
        }

        // Custom multi-select with checkmarks (no Ctrl/⌘ required)
        else {
          const opts = (f.options || []).map(opt => ({
            value: String(opt?.value ?? opt?.id ?? opt),
            label: String(opt?.label ?? opt?.text ?? opt?.value ?? opt)
          }));

          const root = document.createElement('div');
          root.className = 'fs-multi';
          root.dataset.fid = String(f.id);

          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'fs-multi-btn';
          btn.setAttribute('aria-haspopup', 'listbox');
          btn.setAttribute('aria-expanded', 'false');

          const menu = document.createElement('div');
          menu.className = 'fs-multi-menu';
          menu.setAttribute('role', 'listbox');

          const hidden = document.createElement('input');
          hidden.type = 'hidden';
          // NOTE: id/name will be set by the shared code below.

          const cur = values?.[f.id];
          let selected = Array.isArray(cur)
            ? cur.map(String)
            : (cur != null && cur !== '' ? [String(cur)] : []);

          const labelByValue = new Map(opts.map(o => [String(o.value), String(o.label)]));
          const normalizeSelected = () => {
            const ok = new Set(opts.map(o => String(o.value)));
            selected = selected.map(String).filter(v => ok.has(v));
          };

          const updateBtnText = () => {
      normalizeSelected();
      btn.innerHTML = '';
      if (!selected.length) {
        const ph = document.createElement('span');
        ph.className = 'fs-multi-placeholder';
        ph.textContent = '-- select --';
        btn.appendChild(ph);
      } else {
        const labels = selected.map(v => labelByValue.get(String(v)) ?? String(v));
        labels.forEach(l => {
          const chip = document.createElement('span');
          chip.className = 'fs-multi-chip';
          chip.textContent = String(l);
          btn.appendChild(chip);
        });
      }
    };

          const commit = () => {
            normalizeSelected();
            hidden.value = JSON.stringify(selected);
            schedulePreviewUpdate();
          };

          const syncMenu = () => {
            const nodes = menu.querySelectorAll('.fs-multi-opt');
            nodes.forEach(n => {
              const v = String(n.dataset.value || '');
              const isSel = selected.includes(v);
              n.classList.toggle('selected', isSel);
              const cb = n.querySelector('input[type="checkbox"]');
              if (cb) cb.checked = isSel;
            });
          };

          opts.forEach(({value,label}) => {
            const v = String(value);

            const row = document.createElement('div');
            row.className = 'fs-multi-opt';
            row.dataset.value = v;

            const cb = document.createElement('input');
            cb.type = 'checkbox';
            cb.tabIndex = -1;

            const lab = document.createElement('span');
            lab.textContent = String(label);

            row.appendChild(cb);
            row.appendChild(lab);

            const toggle = (evt) => {
              evt.preventDefault();
              evt.stopPropagation();

              const idx = selected.indexOf(v);
              if (idx >= 0) selected.splice(idx, 1);
              else selected.push(v);

              updateBtnText();
              syncMenu();
              commit();
            };

            row.addEventListener('click', toggle);
            cb.addEventListener('click', toggle);

            menu.appendChild(row);
          });

          const openMenu = () => {
            menu.classList.add('open');
            btn.setAttribute('aria-expanded', 'true');
            syncMenu();
          };
          const closeMenu = () => {
            menu.classList.remove('open');
            btn.setAttribute('aria-expanded', 'false');
          };
          const toggleMenu = () => {
            if (menu.classList.contains('open')) closeMenu();
            else openMenu();
          };

          btn.addEventListener('click', (e) => { e.preventDefault(); toggleMenu(); });

          const onDocClick = (e) => { if (!root.contains(e.target)) closeMenu(); };
          const onKeyDown = (e) => { if (e.key === 'Escape') closeMenu(); };
          document.addEventListener('click', onDocClick);
          document.addEventListener('keydown', onKeyDown);

          updateBtnText();
          syncMenu();
          hidden.value = JSON.stringify(selected);

          root.appendChild(btn);
          root.appendChild(menu);
          root.appendChild(hidden);

          customMount = root;
          input = hidden;
        }

      } else if (f.type === 'date')  {
        input = document.createElement('input');
        input.type = 'text';
        input.dataset.type = 'date';
        input.dataset.format = f.dateFormat || 'Y-m-d';
      } else if (f.type === 'address') {
        const mountDiv = document.createElement('div');
        mountDiv.className = 'address-field';
        wrap.appendChild(mountDiv);

        const initial =
          typeof values?.[f.id] === 'string'
            ? { formatted: values[f.id] }
            : (values?.[f.id] || null);

        __addressValues[f.id] = initial || null;

        try {
          if (window.AddressAuto && typeof window.AddressAuto.mount === 'function') {
            window.AddressAuto.mount(mountDiv, {
              id: f.id,
              label: f.label || 'Address',
              required: !!f.required,
              value: initial || null,
              onChange: (val) => { __addressValues[f.id] = val; schedulePreviewUpdate(); }
            });
          } else {
            throw new Error('AddressAuto not available');
          }
        } catch (err) {
          const fallback = document.createElement('input');
          fallback.type = 'text';
          fallback.id = f.id;
          fallback.name = f.id;
          fallback.placeholder = 'Address';
          if (initial?.formatted) fallback.value = initial.formatted;
          fallback.addEventListener('input', () => {
            __addressValues[f.id] = { formatted: fallback.value };
            schedulePreviewUpdate();
          });
          mountDiv.appendChild(fallback);
        }

        form.appendChild(wrap);
        tf.end();
        continue;
      } else {
        input = document.createElement('input');
        input.type = 'text';
      }

      input.id = f.id;
      input.name = f.id;
      if (f.required) input.required = true;
      if (values && values[f.id] != null) {
        // Multi-select was already hydrated above.
        if (!(f.type === 'select' && !!f.multiple)) {
          input.value = values[f.id];
        }
      }

      input.addEventListener('change', schedulePreviewUpdate);
      input.addEventListener('input', schedulePreviewUpdate);

      wrap.appendChild(customMount || input);

      if (f.type === 'date') {
        setTimeout(() => {
          const tt = TRACE('flatpickr:init', { id: input.id, format: input.dataset.format });
          try {
            if (window.flatpickr && typeof window.flatpickr === 'function') {
              window.flatpickr(input, {
                dateFormat: input.dataset.format || 'Y-m-d',
                allowInput: true,
                onChange: schedulePreviewUpdate,
                onValueUpdate: schedulePreviewUpdate
              });
            }
          } finally { tt.end(); }
        }, 0);
      }

      form.appendChild(wrap);
      tf.end();
    }

    container.appendChild(form);
    tr.end('form built');
  } catch (e) {
    tr.error('buildForm failed', e);
    tr.end();
  }
}

async function updatePreview() {
  const tr = TRACE('updatePreview', { docId: currentDoc?.docId });
  try {
    if (!els.payloadPreview) return;

    const docId = currentDoc?.docId;
    const st = docId ? (await window.formSuitePersist.loadState(docId) || {}) : {};

    const baseline = {
      flat: Array.isArray(st.headingsFlat) ? st.headingsFlat : (Array.isArray(lastParsedHeadings.flat) ? lastParsedHeadings.flat : []),
      tree: Array.isArray(st.headingsTree) ? st.headingsTree : (Array.isArray(lastParsedHeadings.tree) ? lastParsedHeadings.tree : []),
    };
    headingsBaseline = baseline;

    const payload = st.payload?.CRONOS_PAYLOAD || null;

    const effectiveSchema = payload?.fields?.length
      ? { title: payload.title || 'Form', fields: payload.fields }
      : (st.schema?.fields?.length ? st.schema : schema);

    const effectiveValues = payload?.values ? payload.values : (st.values || values || {});
    const effectiveTagMap = payload?.tagMap ? payload.tagMap : (st.tagMap || tagMap || {});

    const { headingRules, fieldRules } = normalizeAllForDoc(st, effectiveSchema, baseline);
    const pruned = pruneBySchema(effectiveSchema, effectiveValues, effectiveTagMap);

    const previewObj = {
      title: effectiveSchema?.title || 'Form',
      fields: effectiveSchema?.fields || [],
      values: pruned.values,
      tagMap: pruned.tagMap,
      rules: headingRules,
      fieldRules: fieldRules,
      updatedAt: new Date().toISOString()
    };

    els.payloadPreview.value = JSON.stringify(previewObj, null, 2);
    tr.end({ fields: previewObj.fields.length, rules: previewObj.rules.length, fieldRules: previewObj.fieldRules.length });
  } catch (e) {
    tr.error('updatePreview failed', e);
    tr.end();
  }
}

/* ============================================================
   Render pipeline (unchanged except trace additions)
   ============================================================ */
async function renderFromBytes(bytesU8, { prefix = '' } = {}) {
  const tr = TRACE('renderFromBytes', { prefix, len: bytesU8?.byteLength, docId: currentDoc?.docId });
  try {
    if (!bytesU8?.byteLength) { setStatus('No DOCX loaded.'); return; }

    setStatus((prefix || '') + 'Parsing…');

    const parsedSDTs = await parseSDTs_JS(bytesU8.buffer);
    renderSDTsView(parsedSDTs);

    const headingsParsed = await parseHeadings_JS(bytesU8.buffer);
    lastParsedHeadings = {
      flat: Array.isArray(headingsParsed?.flat) ? headingsParsed.flat : [],
      tree: Array.isArray(headingsParsed?.tree) ? headingsParsed.tree : []
    };

    const tree = (Array.isArray(headingsParsed?.tree) && headingsParsed.tree.length)
      ? headingsParsed.tree
      : buildHeadingTree(lastParsedHeadings.flat);

    renderHeadingsTreeView(tree);

    const payloadRaw = await readPayloadFromDocx(bytesU8);
    let payloadFromDoc = null;
    try { payloadFromDoc = payloadRaw ? JSON.parse(payloadRaw) : null; } catch { payloadFromDoc = null; }

    const docId = currentDoc?.docId;
    const st = docId ? (await window.formSuitePersist.loadState(docId) || {}) : {};

    const wsSchema = st.schema;
    const docSchema = (Array.isArray(payloadFromDoc?.fields) && payloadFromDoc.fields.length)
      ? { title: payloadFromDoc.title || 'Form', fields: payloadFromDoc.fields }
      : null;

    const chosenSchema = (wsSchema?.fields?.length ? wsSchema : (docSchema || { title: 'Form', fields: [] }));

    const mergedValues = Object.assign({}, payloadFromDoc?.values || {}, st.values || {});
    const mergedTagMap = Object.assign({}, payloadFromDoc?.tagMap || {}, st.tagMap || {});

    const baseline = makeBaselineFromParsed({ flat: lastParsedHeadings.flat, tree });
    const normalized = normalizeAllForDoc(st, chosenSchema, baseline);

    const pruned = pruneBySchema(chosenSchema, mergedValues, mergedTagMap);

    schema = chosenSchema;
    values = pruned.values;
    tagMap = pruned.tagMap;
    headingsBaseline = baseline;

    const payloadObj = {
      title: schema.title || 'Form',
      fields: schema.fields || [],
      values,
      tagMap,
      rules: normalized.headingRules,
      fieldRules: normalized.fieldRules,
      updatedAt: new Date().toISOString()
    };

    if (docId) await saveWorkspaceMirror(docId, payloadObj, { baseline });

    buildForm(els.formMount, schema, values);
    await updatePreview();

    els.btnSave.disabled = !docId;
    els.btnSaveFromPreview.disabled = !docId;

    setStatus('Ready.');
    tr.end({ fields: schema?.fields?.length || 0 });
  } catch (e) {
    tr.error('renderFromBytes failed', e);
    setStatus('Error while parsing (see console).');
    tr.end();
  }
}

/* ============================================================
   Hydrate / refresh on foreground (extra trace)
   ============================================================ */
async function rehydrateOnForeground(source) {
  const tr = TRACE('rehydrateOnForeground', { source, locked: __fgRefreshLock, docId: currentDoc?.docId });
  if (__fgRefreshLock) { tr.end('locked'); return; }
  __fgRefreshLock = true;
  try {
    if (!currentDoc?.docId) { tr.end('no doc'); return; }

    await new Promise(r => setTimeout(r, 120));

    await diagPersist(currentDoc?.docId, `rehydrateOnForeground:${source}:pre`);

    const bytes = await getWorkingDocBytesU8();
    if (!bytes) { tr.end('no bytes'); return; }

    currentBytesU8 = bytes;
    await renderFromBytes(bytes, { prefix: `(${source} refreshed) ` });
    await updateWriteAccessBanner();

    await diagPersist(currentDoc?.docId, `rehydrateOnForeground:${source}:post`);
    tr.end('refreshed');
  } catch (e) {
    tr.error('rehydrateOnForeground failed', e);
    tr.end();
  } finally {
    __fgRefreshLock = false;
  }
}

document.addEventListener('visibilitychange', () => {
  window.__DBG?.log('[visibilitychange]', { state: document.visibilityState });
  if (document.visibilityState === 'visible') rehydrateOnForeground('visible');
});
window.addEventListener('focus', () => rehydrateOnForeground('focus'));

/* ============================================================
   Apply payload JSON from preview (unchanged)
   ============================================================ */
async function applyPayloadObject(obj) {
  const tr = TRACE('applyPayloadObject', { hasObj: !!obj });
  try {
    if (!obj || typeof obj !== 'object') return false;

    const nextSchema = { title: obj.title || 'Form', fields: Array.isArray(obj.fields) ? obj.fields : [] };
    const rawValues  = (obj.values && typeof obj.values === 'object') ? obj.values : {};
    const rawTagMap  = (obj.tagMap && typeof obj.tagMap === 'object') ? obj.tagMap : {};
    const rawRules   = Array.isArray(obj.rules) ? obj.rules : [];
    const rawFieldR  = Array.isArray(obj.fieldRules) ? obj.fieldRules : [];

    const tmpState = { rules: rawRules, fieldRules: rawFieldR };
    const baseline = headingsBaseline || { flat: [], tree: [] };
    const normalized = normalizeAllForDoc(tmpState, nextSchema, baseline);

    const pruned = pruneBySchema(nextSchema, rawValues, rawTagMap);

    schema = nextSchema;
    values = pruned.values;
    tagMap = pruned.tagMap;

    const payloadObj = {
      title: schema.title || 'Form',
      fields: schema.fields || [],
      values,
      tagMap,
      rules: normalized.headingRules,
      fieldRules: normalized.fieldRules,
      updatedAt: new Date().toISOString()
    };

    if (currentDoc?.docId) {
      await saveWorkspaceMirror(currentDoc.docId, payloadObj, { baseline });
      bc?.postMessage({ type: 'state:changed', docId: currentDoc.docId, ts: Date.now() });
    }

    buildForm(els.formMount, schema, values);
    await updatePreview();

    if (els.previewStatus) {
      els.previewStatus.textContent = 'Applied';
      setTimeout(() => { els.previewStatus.textContent = ''; }, 900);
    }

    tr.end({ ok: true, fields: schema.fields.length });
    return true;
  } catch (e) {
    tr.error('applyPayloadObject failed', e);
    if (els.previewStatus) els.previewStatus.textContent = 'Apply failed (see console)';
    tr.end({ ok: false });
    return false;
  }
}

/* ============================================================
   Save: payload-only write into DOCX (extra trace + diag)
   ============================================================ */
async function doSave() {
  const tr = TRACE('doSave', { docId: currentDoc?.docId });
  try {
    if (!currentDoc?.docId) { setStatus('No active document.'); return; }

    const docId = currentDoc.docId;

    await diagPersist(docId, 'doSave:pre');

    const st = await window.formSuitePersist.loadState(docId) || {};
    const baseline = {
      flat: Array.isArray(st.headingsFlat) ? st.headingsFlat : (lastParsedHeadings.flat || []),
      tree: Array.isArray(st.headingsTree) ? st.headingsTree : (lastParsedHeadings.tree || [])
    };

    // IMPORTANT (tables + structured fields):
    // collectFormValues(schema) only sees native input/select/textarea controls.
    // Table fields are edited through custom UI and are persisted in workspace
    // (st.values) but typically have no native inputs to collect here.
    // If we do not merge st.values into the outgoing payload, table values will
    // never be written into CRONOS_PAYLOAD even though they are present in the
    // workspace state.
    const cloneSafe = (o) => {
      try {
        if (typeof structuredClone === 'function') return structuredClone(o);
        return JSON.parse(JSON.stringify(o));
      } catch {
        return o;
      }
    };

    const wsValues = (st?.values && typeof st.values === 'object') ? st.values : {};
    const wsTagMap = (st?.tagMap && typeof st.tagMap === 'object') ? st.tagMap : {};

    const liveVals = collectFormValues(schema);

    // Merge precedence: workspace -> in-memory -> live DOM
    // (DOM should win for scalar fields; tables live in workspace/in-memory)
    values = { ...cloneSafe(wsValues), ...(values || {}), ...(liveVals || {}) };
    tagMap = { ...cloneSafe(wsTagMap), ...(tagMap || {}) };

    const normalized = normalizeAllForDoc(st, schema, baseline);
    const pruned = pruneBySchema(schema, values, tagMap);

    const payloadObj = {
      title: schema.title || 'Form',
      fields: schema.fields || [],
      values: pruned.values,
      tagMap: pruned.tagMap,
      rules: normalized.headingRules,
      fieldRules: normalized.fieldRules,
      updatedAt: new Date().toISOString()
    };

    // Keep workspace mirror aligned with what we're about to persist into the DOCX.
    // This is especially important for non-DOM collected values (e.g., tables).
    try {
      await window.formSuitePersist.saveState(docId, {
        values: pruned.values,
        tagMap: pruned.tagMap,
        rules: normalized.headingRules,
        fieldRules: normalized.fieldRules,
        payload: { CRONOS_PAYLOAD: payloadObj },
        updatedAt: payloadObj.updatedAt
      });
    } catch (e) {
      // Non-fatal: the DOCX write below is still the source of truth for the payload.
      tr.step('workspace mirror save failed (non-fatal)', String(e && e.message ? e.message : e));
    }

    const inBytes = await getWorkingDocBytesU8();
    if (!inBytes) {
      setStatus('No bytes / no permission (cannot save).');
      tr.end('no-bytes');
      return;
    }

    const outBytes = await writePayloadToDocx(inBytes, payloadObj);

    let wroteToOriginal = false;

    const h = currentHandle || await window.formSuitePersist.getHandle?.(docId);
    const p = h?.queryPermission ? await h.queryPermission({ mode: 'readwrite' }) : 'denied';
    tr.step('write target', { h: describeHandle(h), permRW: p });

    if (h?.createWritable && p === 'granted') {
      const wt = TRACE('doSave:writeOriginal');
      try {
        const w = await h.createWritable();
        await w.write(outBytes);
        await w.close();
        currentHandle = h;
        currentBytesU8 = outBytes; // keep mem current
        wroteToOriginal = true;
        wt.end({ ok: true, len: outBytes.byteLength, sha: (await sha256Hex(outBytes)).slice(0, 12) });
      } catch (e) {
        wt.error('writeOriginal failed', e);
        wt.end({ ok: false });
        wroteToOriginal = false;
      }
    }

    if (!wroteToOriginal) {
      const wt = TRACE('doSave:saveAsCopy');
      try {
        if (!supportsFS) throw new Error('File System Access API not supported');

        const suggested = (currentDoc?.name ? splitNameAndExt(currentDoc.name).base : 'document') + '.docx';

        const saveHandle = await showSaveFilePicker({
          suggestedName: suggested,
          excludeAcceptAllOption: true,
          types: [{
            description: 'Word document',
            accept: { 'application/vnd.openxmlformats-officedocument.wordprocessingml.document': ['.docx'] }
          }]
        });

        const w = await saveHandle.createWritable();
        await w.write(outBytes);
        await w.close();

        const file = await saveHandle.getFile();
        const bytes = new Uint8Array(await file.arrayBuffer());
        const meta = await window.formSuitePersist.setCurrentDoc({
          bytes,
          handle: saveHandle,
          name: file.name || 'document.docx'
        });

        currentDoc = meta;
        currentHandle = saveHandle;
        currentBytesU8 = bytes;

        try { if (typeof window.setActiveDocMeta === 'function') window.setActiveDocMeta({ docId: meta.docId, name: meta.name }); } catch {}
        bc?.postMessage({ type: 'active:set', docId: meta.docId, name: meta.name, ts: Date.now() });

        wt.end({ ok: true, newDocId: meta.docId, name: meta.name });
      } catch (e) {
        wt.error('saveAsCopy failed', e);
        setStatus('Save failed (no permission). See console.');
        wt.end({ ok: false });
        return;
      }
    }

    await saveWorkspaceMirror(currentDoc.docId, payloadObj, { baseline });

    bc?.postMessage({ type: 'active:updated', docId: currentDoc.docId, ts: Date.now() });

    await updateWriteAccessBanner();
    await updatePreview();

    await diagPersist(currentDoc.docId, 'doSave:post');

    setStatus('Saved payload to DOCX.');
    tr.end({ ok: true });
  } catch (e) {
    tr.error('doSave failed', e);
    setStatus('Save failed (see console).');
    tr.end({ ok: false });
  }
}

/* ============================================================
   Open / switch document (extra diag)
   ============================================================ */
async function doOpen() {
  const tr = TRACE('doOpen');
  try {
    if (!supportsFS) {
      alert('This browser does not support the File System Access API.');
      tr.end('unsupported');
      return;
    }

    clearUi('Opening…');

    const [handle] = await showOpenFilePicker({
      multiple: false,
      excludeAcceptAllOption: true,
      types: [{
        description: 'Word document',
        accept: {
          'application/vnd.openxmlformats-officedocument.wordprocessingml.document': ['.docx', '.docm', '.dotx', '.dotm']
        }
      }]
    });

    const file = await handle.getFile();
    const bytes = new Uint8Array(await file.arrayBuffer());

    tr.step('picked file', { name: file.name, size: file.size, handle: describeHandle(handle), sha: (await sha256Hex(bytes)).slice(0, 12) });

    const meta = await window.formSuitePersist.setCurrentDoc({
      bytes,
      handle,
      name: file.name || 'document.docx'
    });

    currentDoc = meta;
    currentHandle = handle;
    currentBytesU8 = bytes;

    try { if (typeof window.setActiveDocMeta === 'function') window.setActiveDocMeta({ docId: meta.docId, name: meta.name }); } catch {}
    bc?.postMessage({ type: 'active:set', docId: meta.docId, name: meta.name, ts: Date.now() });

    tr.step('opened meta', meta);

    await diagPersist(meta.docId, 'doOpen:after-setCurrentDoc');

    await renderFromBytes(bytes, { prefix: '' });
    await updateWriteAccessBanner({ tryPrompt: true });

    els.btnSave.disabled = false;
    els.btnSaveFromPreview.disabled = false;

    tr.end({ ok: true });
  } catch (e) {
    if (e?.name === 'AbortError') { setStatus('Idle'); tr.end('canceled'); return; }
    tr.error('doOpen failed', e);
    setStatus('Error opening file (see console).');
    tr.end({ ok: false });
  }
}

async function switchToDoc(meta) {
  const tr = TRACE('switchToDoc', meta);
  try {
    if (!meta?.docId) return;

    await diagPersist(meta.docId, 'switchToDoc:entry');

    if (currentDoc?.docId === meta.docId && currentBytesU8?.byteLength) { tr.end('already active'); return; }

    clearUi('Switching document…');

    // NOTE: do NOT immediately discard mem cache before we know we can hydrate.
    const prev = { doc: currentDoc, handle: currentHandle, bytesLen: currentBytesU8?.byteLength || 0 };

    currentDoc = meta;

    // attempt hydrate without nuking caches first
    const bytes = await getWorkingDocBytesU8();
    if (!bytes) {
      window.__DBG?.log('[switchToDoc] hydrate failed, keeping previous in-memory cache', prev);
      clearUi('No bytes / no permission.');
      await diagPersist(meta.docId, 'switchToDoc:no-bytes');
      tr.end('no-bytes');
      return;
    }

    // now swap
    currentHandle = null;        // will be rederived by getWorkingDocBytesU8 if needed
    currentBytesU8 = bytes;

    await renderFromBytes(bytes, { prefix: '(switched) ' });
    await updateWriteAccessBanner();
    els.btnSave.disabled = false;
    els.btnSaveFromPreview.disabled = false;

    await diagPersist(meta.docId, 'switchToDoc:ok');
    tr.end({ ok: true });
  } catch (e) {
    tr.error('switchToDoc failed', e);
    setStatus('Switch failed (see console).');
    tr.end({ ok: false });
  }
}

/* ============================================================
   One broadcast handler (extra trace)
   ============================================================ */
bc?.addEventListener('message', async (ev) => {
  const tr = TRACE('BroadcastChannel:message', ev?.data);
  try {
    const m = ev.data || {};
    if (!m || typeof m !== 'object') return;

    if (m.type === 'active:set') {
      tr.step('active:set received', { docId: m.docId, name: m.name });
      if (m.docId && m.docId !== currentDoc?.docId) {
        await switchToDoc({ docId: m.docId, name: m.name || 'document.docx' });
      }
      return;
    }

    if (m.type === 'active:updated') {
      tr.step('active:updated received', { docId: m.docId });
      if (m.docId && m.docId === currentDoc?.docId) {
        await rehydrateOnForeground('active:updated');
      }
      return;
    }

    if (m.type === 'active:clear') {
      tr.step('active:clear received');
      currentDoc = null;
      currentHandle = null;
      currentBytesU8 = null;
      schema = { title: 'Form', fields: [] };
      values = {};
      tagMap = {};
      clearUi('Cleared.');
      return;
    }

    if (m.type === 'state:changed') {
      tr.step('state:changed received', { docId: m.docId });
      if (!m.docId || m.docId === currentDoc?.docId) {
        await updatePreview();
      }
      return;
    }
  } catch (e) {
    tr.error('BC handler failed', e);
  } finally {
    tr.end();
  }
});

/* ============================================================
   Active-doc listener
   ============================================================ */
installActiveDocListener(async (meta) => {
  const tr = TRACE('installActiveDocListener:cb', meta);
  try {
    if (!meta?.docId) {
      currentDoc = null;
      clearUi('No active document. Open one.');
      tr.end('cleared');
      return;
    }
    currentDoc = meta;
    await switchToDoc(meta);
  } catch (e) {
    tr.error('active doc listener failed', e);
  } finally {
    tr.end();
  }
});

/* ============================================================
   Preview textarea wiring (unchanged)
   ============================================================ */
function tryParseJSON(txt) { try { return JSON.parse(txt); } catch { return null; } }

let __previewDirty = false;
els.payloadPreview?.addEventListener('input', () => {
  __previewDirty = true;
  if (!els.previewStatus) return;
  const obj = tryParseJSON(els.payloadPreview.value);
  els.previewStatus.textContent = obj ? 'JSON ok' : 'Invalid JSON';
});

els.btnSaveFromPreview?.addEventListener('click', async () => {
  const tr = TRACE('btnSaveFromPreview:click', { dirty: __previewDirty });
  try {
    const obj = tryParseJSON(els.payloadPreview.value);
    if (!obj) {
      if (els.previewStatus) els.previewStatus.textContent = 'Invalid JSON';
      tr.end('invalid-json');
      return;
    }
    await applyPayloadObject(obj);
    await doSave();
    __previewDirty = false;
  } catch (e) {
    tr.error('Apply+Save failed', e);
  } finally {
    tr.end();
  }
});

/* ============================================================
   Wiring
   ============================================================ */
els.btnOpen.addEventListener('click', doOpen);
els.btnSave.addEventListener('click', doSave);

els.btnRegrant?.addEventListener('click', async () => {
  const tr = TRACE('btnRegrant:click');
  try {
    await updateWriteAccessBanner({ tryPrompt: true });
    await diagPersist(currentDoc?.docId, 'btnRegrant:post');
  } catch (e) {
    tr.error('regrant failed', e);
    els.permNote.style.display = 'block';
  } finally {
    tr.end();
  }
});

els.btnDbgSnap?.addEventListener('click', async () => {
  const docId = currentDoc?.docId || null;
  await diagPersist(docId, 'manual snapshot');
});

window.addEventListener('beforeunload', async () => {
  const tr = TRACE('beforeunload');
  try {
    window.__DBG?.log('[beforeunload]', { docId: currentDoc?.docId, memBytes: currentBytesU8?.byteLength || 0, memHandle: describeHandle(currentHandle) });

    if (!currentDoc?.docId) { tr.end('no doc'); return; }

    const vals = collectFormValues(schema);
    await window.formSuitePersist.saveState(currentDoc.docId, {
      schema,
      values: { ...(values || {}), ...(vals || {}) }
    });

    // We do NOT change behavior here yet (just observe).
    // Once we confirm missing persistence APIs, we will patch persistence.js.

    try { if (typeof window.setActiveDocMeta === 'function') window.setActiveDocMeta({ docId: currentDoc.docId, name: currentDoc.name }); } catch {}

    await diagPersist(currentDoc.docId, 'beforeunload:post-saveState');
  } catch (e) {
    tr.warn('beforeunload failed', e);
  } finally {
    tr.end();
  }
});

/* ============================================================
   Boot (extra diag)
   ============================================================ */
(async function boot() {
  const tr = TRACE('boot');
  try {
    if (!assertDeps()) { tr.end('deps-missing'); return; }

    const meta = (typeof window.readActiveDocSync === 'function') ? window.readActiveDocSync() : null;
    tr.step('readActiveDocSync', meta);

    await diagPersist(meta?.docId || null, 'boot:after-readActiveDocSync');

    if (!meta?.docId) {
      clearUi('Idle');
      tr.end('no-meta');
      return;
    }

    currentDoc = meta;
    clearUi('Restoring document…');

    const bytes = await getWorkingDocBytesU8();
    if (!bytes) {
      clearUi('No bytes / no permission.');
      await diagPersist(meta.docId, 'boot:no-bytes');
      tr.end('no-bytes');
      return;
    }

    currentBytesU8 = bytes;

    tr.step('restored', {
      docId: meta.docId,
      name: meta.name,
      len: bytes.byteLength,
      sha: (await sha256Hex(bytes)).slice(0, 12)
    });

    await renderFromBytes(bytes, { prefix: '(restored) ' });
    await updateWriteAccessBanner();

    els.btnSave.disabled = false;
    els.btnSaveFromPreview.disabled = false;

    await diagPersist(meta.docId, 'boot:ok');

    tr.end('ok');
  } catch (e) {
    tr.error('boot failed', e);
    clearUi('Boot failed (see console).');
    tr.end('fail');
  }
})();

/* ============================================================
   Logo nav (triple-click)
   ============================================================ */
try { window.installLogoFocusNav?.(); } catch (e) { console.warn('[Extractor] installLogoFocusNav failed', e); }

</script>
</body>
</html>
