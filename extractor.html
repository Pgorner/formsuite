<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Form Suite â€” Extractor (DEBUG)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
  <link rel="stylesheet" href="style.css">

  <!-- Persistence layer (provides window.formSuitePersist) -->
  <script src="persistence.js"></script>
  <!-- flatpickr JS (date inputs) -->
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <!-- JSZip for JS-based SDT scanning (parity with Tag Matcher) -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
</head>
<body>
  <header>
    <div class="row">
      <span class="brand logo-md">
        <img src="logo.gif" alt="Form Suite logo" class="logo" />
        <strong>Form Suite</strong>
      </span>
      <span class="muted">Â·</span><a href="index.html">Open Form</a>
      <span class="muted">Â·</span><a href="builder.html" id="openBuilder">Form Builder</a>
      <span class="muted">Â·</span><a href="matcher.html">Tag Matcher</a>
      <span class="muted">Â·</span><span class="muted">Extractor</span>
    </div>
  </header>

  <main>
    <section class="panel">
      <h2 style="margin:0 0 10px">Inspect SDTs & store manual form payload in the DOCX</h2>
      <div class="row" style="gap:8px;flex-wrap:wrap">
        <button id="btnOpen">Open DOCXâ€¦</button>
        <button id="btnSave" disabled>Save (payload only)</button>
        <button id="btnExport" disabled>Export (payload + replace tags)</button>
        <span class="muted" id="status" style="margin-left:auto">Idle</span>
      </div>

      <!-- Banner restored: will show whenever write not granted -->
      <div id="permNote" class="note warn" style="display:none;margin-top:10px">
        This DOCX was opened via picker but I donâ€™t have write permission to the original file.
        Clicking <em>Save</em> will download a copy instead of writing back.
        <button id="btnRegrant" class="ghost" style="margin-left:8px">Grant write access</button>
      </div>
    </section>

    <div class="grid-3">
      <section class="panel">
        <details open>
          <summary><strong>Found SDTs</strong></summary>
          <div style="overflow:auto;">
            <table id="sdt-table">
              <thead>
                <tr>
                  <th>#</th>
                  <th>Part</th>
                  <th>w:tag</th>
                  <th>w:alias</th>
                  <th>Text</th>
                </tr>
              </thead>
              <tbody id="sdt-tbody"></tbody>
            </table>
          </div>
        </details>
      </section>

      <section class="panel">
        <details open>
          <summary><strong>CRONOS_PAYLOAD Preview</strong></summary>
          <textarea id="payloadPreview" spellcheck="false" style="min-height:420px"></textarea>
          <div class="row" style="margin-top:6px; gap:8px;">
            <button id="btnSaveFromPreview" class="secondary" disabled>Save</button>
            <span class="muted" id="previewStatus"></span>
          </div>
        </details>
      </section>

      <section class="panel">
        <details open>
          <summary><strong>Live Form (from payload schema)</strong></summary>
          <div id="formMount"></div>
        </details>
      </section>
    </div>
  </main>

  <script>
    // =========================
    // ðŸ”Ž DEBUG / TRACE PRIMITIVES
    // =========================
    const DEBUG = { on: true, seq: 0 };
    const _t = () => new Date().toISOString().slice(11, 23);
    const tag = (name) => `%c[Extractor ${_t()} #${++DEBUG.seq}] ${name}`;
    const tagStyle = 'color:#6b7280;font-weight:600';

    function TRACE(name, details) {
      const label = `${name} :: ${_t()} :: #${DEBUG.seq+1}`;
      console.groupCollapsed(tag(name), tagStyle, details ?? '');
      console.time(label);
      return {
        step: (msg, data) => console.log(tag(`  â†³ ${msg}`), tagStyle, data ?? ''),
        warn: (msg, data) => console.warn(tag(`  âš  ${msg}`), tagStyle, data ?? ''),
        error: (msg, err) => console.error(tag(`  âœ– ${msg}`), tagStyle, err),
        end: (extra) => { if (extra) console.log(tag('done'), tagStyle, extra); console.timeEnd(label); console.groupEnd(); }
      };
    }

    window.addEventListener('error', (e) => {
      console.error(tag('window.error'), tagStyle, { message: e.message, filename: e.filename, lineno: e.lineno, colno: e.colno, error: e.error });
    });
    window.addEventListener('unhandledrejection', (e) => {
      console.error(tag('window.unhandledrejection'), tagStyle, e.reason);
    });

    // =========================
    // CONSTANTS & STATE
    // =========================
    const STORAGE_KEY  = 'FORM_SCHEMA_V1';
    const PAYLOAD_KEY  = 'CRONOS_PAYLOAD';
    const META_LS_KEY  = 'FS_CURRENT_DOC_META';
    const supportsFS   = 'showOpenFilePicker' in window && 'showSaveFilePicker' in window;

    let gArrayBuffer   = null;
    let gFileName      = null;  // name without .docx
    let gFileHandle    = null;  // FileSystemFileHandle
    let gSchema        = { title: 'Form', fields: [] };
    let gValues        = {};
    let gDocId         = null;
    let gDirty         = false;
    let gSDTs          = [];
    let gLastSchemaPushTs = 0;

    // UI refs
    const btnOpen   = document.getElementById('btnOpen');
    const btnSave   = document.getElementById('btnSave');
    const btnExport = document.getElementById('btnExport');
    const statusEl  = document.getElementById('status');
    const permNote  = document.getElementById('permNote');
    const payloadEl = document.getElementById('payloadPreview');
    const formMount = document.getElementById('formMount');
    const tableBody = document.getElementById('sdt-tbody');
    const btnRegrant= document.getElementById('btnRegrant');
    const btnSaveFromPreview = document.getElementById('btnSaveFromPreview');
    const previewStatus = document.getElementById('previewStatus');

    async function sha256Hex(bufOrU8) {
      const tr = TRACE('sha256Hex', { type: (bufOrU8?.constructor?.name), len: bufOrU8?.byteLength || bufOrU8?.length });
      try {
        const ab = (bufOrU8 instanceof ArrayBuffer) ? bufOrU8
                  : (bufOrU8?.buffer instanceof ArrayBuffer) ? bufOrU8.buffer
                  : new Uint8Array(bufOrU8 || []).buffer;
        const d = await crypto.subtle.digest('SHA-256', ab);
        const hex = [...new Uint8Array(d)].map(b => b.toString(16).padStart(2, '0')).join('');
        tr.end({ hex });
        return hex;
      } catch (e) { tr.error('sha failed', e); tr.end(); return '(hash-error)'; }
    }

    const setStatus = (m) => {
      const tr = TRACE('setStatus', { text: m });
      try { statusEl.textContent = m; } finally { tr.end(); }
    };

    // =========================
    // PERSISTENCE SHIM (if missing)
    // =========================
    (function ensurePersist() {
      const tr = TRACE('ensurePersist');
      try {
        if (window.formSuitePersist) { tr.step('already present'); tr.end(); return; }
        tr.step('installing shim');
        let _meta = null;
        let _state = {};
        window.formSuitePersist = {
          getCurrentDocMeta() { tr.step('shim.getCurrentDocMeta', _meta); return _meta; },
          setCurrentDoc: async ({ bytes, handle, name }) => { tr.step('shim.setCurrentDoc', { bytes: !!bytes, name, handle: !!handle }); _meta = { docId: 'inline-' + Date.now(), name: name || 'document' }; return _meta; },
          setCurrentDocFromBytes: async (bytes, meta) => { tr.step('shim.setCurrentDocFromBytes', { bytes: !!bytes, meta }); _meta = { docId: 'inline-' + Date.now(), name: meta?.name || 'document' }; return _meta; },
          getCurrentDocBytes: async () => { tr.step('shim.getCurrentDocBytes -> null'); return null; },
          getBytes: async (_docId) => { tr.step('shim.getBytes -> null', _docId); return null; },
          getHandle: async (_docId) => { tr.step('shim.getHandle -> null', _docId); return null; },
          saveState: async (_docId, obj) => { tr.step('shim.saveState', { docId:_docId, keys:Object.keys(obj||{}) }); _state = { ..._state, ...(obj||{}) }; },
          loadState: async (_docId) => { tr.step('shim.loadState', { docId:_docId }); return _state; },
          putBytes: async (_docId, _bytes) => { tr.step('shim.putBytes', { docId:_docId, len: _bytes?.byteLength }); },
          ensurePermission: async (_h, _mode) => { tr.step('shim.ensurePermission', { mode:_mode }); return 'granted'; }
        };
      } finally { tr.end(); }
    })();

    // =========================
    // CROSS-TAB + LOCALSTORAGE
    // =========================
    const bc = ('BroadcastChannel' in window) ? new BroadcastChannel('form-suite-doc') : null;
    function persistDocMeta(meta) {
      const tr = TRACE('persistDocMeta', meta);
      try { localStorage.setItem(META_LS_KEY, JSON.stringify({ docId: meta?.docId, name: meta?.name })); }
      finally { tr.end(); }
    }
    function readDocMeta() {
      const tr = TRACE('readDocMeta');
      try { const v = JSON.parse(localStorage.getItem(META_LS_KEY) || 'null'); tr.end(v); return v; }
      catch (e){ tr.error('parse fail', e); tr.end(); return null; }
    }
    function announceDocSwitch() { const tr = TRACE('announceDocSwitch', { docId:gDocId, name:gFileName }); try { bc?.postMessage({ type:'doc-switched', docId:gDocId, name:gFileName }); persistDocMeta({ docId:gDocId, name:gFileName }); } finally { tr.end(); } }
    function announceDocUpdate() { const tr = TRACE('announceDocUpdate', { docId:gDocId, name:gFileName }); try { bc?.postMessage({ type:'doc-updated', docId:gDocId, name:gFileName, ts:Date.now() }); } finally { tr.end(); } }

    function clearMetaLS() {
      const tr = TRACE('clearMetaLS');
      try { localStorage.removeItem(META_LS_KEY); } finally { tr.end(); }
    }

    async function hardResetDocContext(reason = '') {
      const tr = TRACE('hardResetDocContext:start', { reason, docId: gDocId });
      try {
        if (gDocId) {
          await window.formSuitePersist?.saveState?.(gDocId, {});
          try { await window.formSuitePersist?.putBytes?.(gDocId, new Uint8Array()); } catch (e) { tr.warn('putBytes failed', e); }
        }
      } catch (e) { tr.error('saveState failed', e); }
      gArrayBuffer = null; gFileHandle = null; gFileName = null; gDocId = null; gSDTs = [];
      clearMetaLS();
      try {
        tableBody.innerHTML = '<tr><td colspan="5" class="empty">No document loaded.</td></tr>';
        formMount.innerHTML = '<div class="empty">No schema found.</div>';
        payloadEl.value = '';
        previewStatus.textContent = '';
        btnSave.disabled = true; btnExport.disabled = true; btnSaveFromPreview.disabled = true;
        permNote.style.display = 'none';
        setStatus(reason ? `Cleared: ${reason}` : 'Cleared.');
      } catch (e) { tr.warn('DOM reset failed', e); }
      try { bc?.postMessage?.({ type: 'doc-cleared', ts: Date.now() }); } catch (e) { tr.warn('broadcast failed', e); }
      tr.end('reset complete');
    }

    bc?.addEventListener?.('message', async (ev) => {
      const tr = TRACE('BroadcastChannel:message', ev?.data);
      try {
        const m = ev.data || {};
        if (m.type === 'doc-switched' && m.docId && m.docId !== gDocId) {
          tr.step('doc-switched -> fetch bytes');
          let bytes = await window.formSuitePersist.getBytes?.(m.docId) || await window.formSuitePersist.getCurrentDocBytes?.();
          tr.step('bytes from persistence', { len: bytes?.byteLength || bytes?.length });
          if (!bytes) { await hardResetDocContext('no bytes / no permission'); return; }
          gArrayBuffer = bytes.buffer ?? bytes;
          gFileName = m.name || gFileName;
          gDocId = m.docId;
          await renderFromCurrentBytes('(switched by other tab) ');
          await updateWriteAccessBanner(); // reflect state
        }
        if (m.type === 'doc-updated' && m.docId && m.docId === gDocId) {
          tr.step('doc-updated -> reload bytes for current doc');
          let bytes = await window.formSuitePersist.getBytes?.(gDocId) || await window.formSuitePersist.getCurrentDocBytes?.();
          tr.step('bytes from persistence', { len: bytes?.byteLength || bytes?.length });
          if (!bytes) { await hardResetDocContext('no bytes / no permission'); return; }
          gArrayBuffer = bytes.buffer ?? bytes;
          await renderFromCurrentBytes('(updated by other tab) ');
          await updateWriteAccessBanner();
        }
        if (m.type === 'schema-updated' && m.docId && m.docId === gDocId) {
          tr.step('schema-updated');
          gLastSchemaPushTs = m.ts || Date.now();
          const st = await window.formSuitePersist.loadState(gDocId);
          tr.step('workspace state', { hasSchema: !!st?.schema, hasValues: !!st?.values });
          if (st?.schema) {
            const domVals = collectFormValues(st.schema);
            const wsVals  = st.values || {};
            gSchema = st.schema;
            gValues = { ...wsVals, ...domVals };
            buildForm(formMount, gSchema, gValues);
            await updatePreview(gValues);
            setStatus('Schema updated from Form Builder.');
          }
        }
        if (m.type === 'doc-cleared') {
          await hardResetDocContext('cleared by another tab');
        }
      } finally { tr.end(); }
    });

    window.addEventListener('storage', async (e) => {
      const tr = TRACE('storage:event', { key:e.key, newValue: !!e.newValue });
      try {
        if (e.key !== META_LS_KEY || !e.newValue) return;
        const meta = JSON.parse(e.newValue || 'null');
        tr.step('parsed meta', meta);
        if (!meta?.docId || meta.docId === gDocId) return;
        let bytes = await window.formSuitePersist.getBytes?.(meta.docId) || await window.formSuitePersist.getCurrentDocBytes?.();
        tr.step('bytes from persistence', { len: bytes?.byteLength || bytes?.length });
        if (!bytes) { await hardResetDocContext('no bytes / no permission'); return; }
        gArrayBuffer = bytes.buffer ?? bytes;
        gFileName = meta.name || gFileName;
        gDocId = meta.docId;
        await renderFromCurrentBytes('(switched by other tab) ');
        await updateWriteAccessBanner();
      } finally { tr.end(); }
    });

    // =========================
    // STABLE FOREGROUND REFRESH (fixes Alt+Tab clears)
    // =========================
    let __fgRefreshLock = false;
    async function safeGetBytes(docId) {
      const tr = TRACE('safeGetBytes', { docId });
      try {
        let bytes = await window.formSuitePersist.getBytes?.(docId);
        if (bytes) { tr.end({ src:'opfs', len: bytes.byteLength || bytes.length }); return bytes; }

        bytes = await window.formSuitePersist.getCurrentDocBytes?.();
        if (bytes) { tr.end({ src:'currentDocBytes', len: bytes.byteLength || bytes.length }); return bytes; }

        const h = await window.formSuitePersist.getHandle?.(docId);
        if (h?.getFile) {
          try {
            const f = await h.getFile();
            bytes = await f.arrayBuffer();
            tr.end({ src:'handle.getFile', len: bytes.byteLength || bytes.length });
            return bytes;
          } catch (e) { tr.warn('handle.getFile failed', e); }
        }

        tr.end({ src:'none' });
        return null;
      } catch (e) { tr.error('safeGetBytes failed', e); tr.end(); return null; }
    }

    async function rehydrateOnForeground(source) {
      const tr = TRACE('rehydrateOnForeground', { source, docId: gDocId, locked: __fgRefreshLock });
      if (__fgRefreshLock) { tr.step('locked; skip'); tr.end(); return; }
      __fgRefreshLock = true;
      try {
        if (!gDocId) { tr.step('no docId'); return; }

        await new Promise(r => setTimeout(r, 120));

        let bytes = await safeGetBytes(gDocId);

        if (!bytes) {
          await new Promise(r => setTimeout(r, 120)); // brief retry
          bytes = await safeGetBytes(gDocId);
        }

        if (bytes) {
          gArrayBuffer = bytes.buffer ?? bytes;
          await renderFromCurrentBytes(`(${source} refreshed) `);
          await updateWriteAccessBanner();
          tr.end('refreshed');
          return;
        }

        if (gArrayBuffer?.byteLength) {
          setStatus(`Refresh skipped (${source}): no bytes yet; keeping current.`);
          await updateWriteAccessBanner();
          tr.end('kept current buffer');
          return;
        }

        const h = await window.formSuitePersist.getHandle?.(gDocId);
        if (h) {
          setStatus(`Refresh postponed (${source}): handle exists; waiting for bytes.`);
          await updateWriteAccessBanner();
          tr.end('postponed; has handle');
          return;
        }

        await hardResetDocContext('lost access');
        tr.end('hard reset');
      } catch (e) {
        tr.error('rehydrate failed', e);
      } finally {
        __fgRefreshLock = false;
      }
    }

    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible') rehydrateOnForeground('visible');
    });

    window.addEventListener('focus', () => {
      rehydrateOnForeground('focus');
    });

    // =========================
    // WRITE ACCESS BANNER / PROMPT
    // =========================
    async function updateWriteAccessBanner(opts = {}) {
      const { tryPrompt = false } = opts;
      const tr = TRACE('updateWriteAccessBanner', { tryPrompt, docId: gDocId, supportsFS });
      try {
        if (!supportsFS || !gDocId) { permNote.style.display = 'none'; tr.end('unsupported or no doc'); return 'unsupported'; }

        let handle = gFileHandle || await window.formSuitePersist.getHandle?.(gDocId);
        if (!handle || !handle.queryPermission) { permNote.style.display = 'none'; tr.end('no handle'); return 'no-handle'; }

        let p = await handle.queryPermission({ mode: 'readwrite' });
        tr.step('queryPermission', p);

        if (p !== 'granted' && tryPrompt) {
          try {
            const r = await handle.requestPermission({ mode: 'readwrite' });
            p = r || p;
            tr.step('requestPermission', r);
          } catch (e) {
            tr.warn('requestPermission failed', e);
          }
        }

        permNote.style.display = (p === 'granted') ? 'none' : 'block';
        if (p === 'granted') gFileHandle = handle;

        tr.end({ final: p });
        return p || 'denied';
      } catch (e) {
        tr.error('updateWriteAccessBanner failed', e);
        permNote.style.display = 'block';
        return 'error';
      }
    }

    // =========================
    // TAG MAP / PREVIEW HELPERS
    // =========================
    async function getTagMapFor(docId) {
      const tr = TRACE('getTagMapFor', { docId });
      try {
        const state = docId ? (await window.formSuitePersist.loadState(docId)) : null;
        const tagMap = (state?.payload?.CRONOS_PAYLOAD?.tagMap)
                    || (state?.cronos_payload?.tagMap)
                    || (state?.CRONOS_PAYLOAD?.tagMap)
                    || (state?.tagMap)
                    || {};
        tr.end({ tagCount: Object.keys(tagMap).length });
        return tagMap;
      } catch (e) { tr.error('failed', e); tr.end(); return {}; }
    }

    function loadSchemaFromLocalStorage() {
      const tr = TRACE('loadSchemaFromLocalStorage');
      try { const s = JSON.parse(localStorage.getItem(STORAGE_KEY) || 'null'); tr.end({ has:s?.fields?.length }); return s; }
      catch (e) { tr.error('parse fail', e); tr.end(); return null; }
    }

    function collectFormValues(schema) {
      const tr = TRACE('collectFormValues', { fieldCount: schema?.fields?.length || 0 });
      try {
        const form = document.getElementById('liveForm');
        const out = {};
        if (!form || !schema) { tr.end('no form/schema'); return out; }
        for (const f of schema.fields) {
          if (f.type === 'multichoice') {
            const nodes = form.querySelectorAll(`input[type="checkbox"][name="${CSS.escape(f.id)}"]`);
            out[f.id] = Array.from(nodes).filter(n => n.checked).map(n => n.value);
            continue;
          }
          const el = form.elements[f.id];
          out[f.id] = el ? el.value : null;
        }
        tr.end({ keys: Object.keys(out).length });
        return out;
      } catch (e) { tr.error('failed', e); tr.end(); return {}; }
    }

    async function updatePreview(values) {
      const tr = TRACE('updatePreview', { valueKeys: Object.keys(values||{}).length });
      try {
        if (!payloadEl) { tr.end('no payloadEl'); return; }
        const tagMap = await getTagMapFor(gDocId);
        const obj = { title: gSchema?.title || 'Form', fields: gSchema?.fields || [], values: values || {}, tagMap };
        payloadEl.value = JSON.stringify(obj, null, 2);
        tr.end({ ok:true });
      } catch (e) { tr.error('failed', e); tr.end(); }
    }

    let previewTimer = null;
    function schedulePreviewUpdate() {
      const tr = TRACE('schedulePreviewUpdate');
      try {
        clearTimeout(previewTimer);
        previewTimer = setTimeout(async () => {
          const tr2 = TRACE('previewUpdate:tick');
          try {
            const vals = collectFormValues(gSchema);
            if (gDocId) await window.formSuitePersist.saveState(gDocId, { schema: gSchema, values: vals });
            await updatePreview(vals);
            gDirty = true;
            setStatus('Unsaved changes â€” press Save to update DOCX.');
          } catch (e) { tr2.error('tick failed', e); }
          finally { tr2.end(); }
        }, 250);
      } finally { tr.end(); }
    }

    function buildForm(container, schema, values) {
      const tr = TRACE('buildForm', { fields: schema?.fields?.length || 0 });
      try {
        container.innerHTML = '';
        if (!schema || !Array.isArray(schema.fields) || schema.fields.length === 0) {
          container.innerHTML = '<div class="empty">No manual schema. Create one in the Builder, or load a DOCX that already contains a payload schema.</div>';
          tr.end('empty schema');
          return;
        }

        const form = document.createElement('form');
        form.id = 'liveForm';
        form.noValidate = true;
        form.style.display = 'grid';
        form.style.gap = '12px';

        if (schema.title) {
          const h = document.createElement('h4');
          h.textContent = schema.title;
          h.style.margin = '0 0 6px';
          form.appendChild(h);
        }

        for (const f of schema.fields) {
          const w = TRACE('buildForm:field', f);
          const wrap = document.createElement('div');
          wrap.className = 'field';
          const label = document.createElement('label');
          label.htmlFor = f.id;
          label.textContent = f.label || f.id || '(field)';
          label.style.display = 'flex';
          label.style.justifyContent = 'space-between';
          label.style.alignItems = 'center';
          if (f.required) {
            const star = document.createElement('span');
            star.textContent = 'â€¢'; star.title = 'required'; star.style.fontWeight = '600'; star.style.color = '#ef4444';
            label.appendChild(star);
          }
          wrap.appendChild(label);

          let input;
          if (f.type === 'date') {
            input = document.createElement('input'); input.type = 'text'; input.dataset.type = 'date'; input.dataset.format = f.dateFormat || 'Y-m-d';
          } else if (f.type === 'select') {
            input = document.createElement('select');
            (f.options || []).forEach(opt => {
              const o = document.createElement('option');
              o.value = String(opt?.value ?? opt?.id ?? opt);
              o.textContent = String(opt?.label ?? opt?.text ?? opt?.value ?? opt);
              input.appendChild(o);
            });
          } else if (f.type === 'multichoice') {
            const box = document.createElement('div');
            box.style.display = 'grid'; box.style.gap = '6px';
            (f.options || []).forEach(opt => {
              const id = `${f.id}__${String(opt?.value ?? opt).replace(/\s+/g,'_')}`;
              const row = document.createElement('label');
              row.style.display = 'flex'; row.style.gap = '8px'; row.style.alignItems = 'center';
              const cb = document.createElement('input');
              cb.type = 'checkbox'; cb.name = f.id; cb.id = id; cb.value = String(opt?.value ?? opt);
              if (Array.isArray(values?.[f.id]) && values[f.id].includes(cb.value)) cb.checked = true;
              const span = document.createElement('span'); span.textContent = String(opt?.label ?? opt?.text ?? opt?.value ?? opt);
              row.appendChild(cb); row.appendChild(span); box.appendChild(row);
            });
            wrap.appendChild(box);
            box.addEventListener('change', schedulePreviewUpdate);
            form.appendChild(wrap);
            w.end();
            continue;
          } else {
            input = document.createElement('input'); input.type = 'text';
          }

          input.id = f.id; input.name = f.id;
          if (f.required) input.required = true;
          if (values && values[f.id] != null) input.value = values[f.id];

          input.addEventListener('change', schedulePreviewUpdate);
          input.addEventListener('input', schedulePreviewUpdate);
          wrap.appendChild(input);

          if (f.type === 'date') {
            setTimeout(() => {
              const tt = TRACE('flatpickr:init', { id: input.id, format: input.dataset.format });
              try {
                if (window.flatpickr) {
                  window.flatpickr(input, {
                    dateFormat: input.dataset.format || 'Y-m-d',
                    allowInput: true,
                    onChange: schedulePreviewUpdate,
                    onValueUpdate: schedulePreviewUpdate
                  });
                }
              } finally { tt.end(); }
            }, 0);
          }

          form.appendChild(wrap);
          w.end();
        }

        container.appendChild(form);
        tr.end('form built');
      } catch (e) { tr.error('failed', e); tr.end(); }
    }

    // =========================
    // SDT PARSING (JS)
    // =========================
    const W_NS = "http://schemas.openxmlformats.org/wordprocessingml/2006/main";
    function xmlText(elem) {
      let out = '';
      const ts = elem.getElementsByTagNameNS(W_NS, 't');
      for (let i = 0; i < ts.length; i++) out += ts[i].textContent || '';
      return out;
    }
    async function parseSDTs_JS(arrayBuffer) {
      const tr = TRACE('parseSDTs_JS', { hasBuffer: !!arrayBuffer, len: arrayBuffer?.byteLength });
      try {
        if (!arrayBuffer) return { sdts: [], scan: [], total: 0 };
        const zip = await JSZip.loadAsync(arrayBuffer);
        const parts = zip.file(/^word\/.*\.xml$/i) || [];
        tr.step('parts', parts.map(p => p.name));
        const parser = new DOMParser();
        const sdts = [];
        const scan = [];
        for (const f of parts) {
          const pf = TRACE('parseSDTs_JS:file', f.name);
          const xmlTextContent = await f.async('string');
          let err = null, countBefore = sdts.length;
          try {
            const xml = parser.parseFromString(xmlTextContent, "application/xml");
            const found = Array.from(xml.getElementsByTagNameNS(W_NS, 'sdt'));
            for (const sdt of found) {
              const pr = sdt.getElementsByTagNameNS(W_NS, 'sdtPr')[0];
              const content = sdt.getElementsByTagNameNS(W_NS, 'sdtContent')[0] || sdt;
              let tag = '', alias = '';
              if (pr) {
                const tEl = pr.getElementsByTagNameNS(W_NS, 'tag')[0];
                if (tEl) tag = tEl.getAttributeNS(W_NS, 'val') || tEl.getAttribute('w:val') || '';
                const aEl = pr.getElementsByTagNameNS(W_NS, 'alias')[0];
                if (aEl) alias = aEl.getAttributeNS(W_NS, 'val') || aEl.getAttribute('w:val') || '';
              }
              sdts.push({ part: f.name.split('/').pop().replace('.xml',''), tag, alias, text: xmlText(content) });
            }
          } catch (e) { err = e?.message || String(e); pf.warn('xml parse error', e); }
          scan.push({ path: f.name, part: f.name.split('/').pop().replace('.xml',''), size: xmlTextContent.length, sdt_count: sdts.length - countBefore, error: err });
          pf.end({ added: sdts.length - countBefore, error: err });
        }
        tr.end({ total: sdts.length, scanned: scan.length });
        return { sdts, scan, total: sdts.length };
      } catch (e) { tr.error('failed', e); tr.end(); return { sdts: [], scan: [], total: 0 }; }
    }

    // =========================
    // PYODIDE (payload/SDT writes)
    // =========================
    let pyodideReady = (async () => {
      const tr = TRACE('pyodide:bootstrap');
      try {
        const s = document.createElement('script');
        s.src = "https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js";
        document.head.appendChild(s);
        await new Promise(r => s.onload = r);
        const py = await loadPyodide({ indexURL: "https://cdn.jsdelivr.net/pyodide/v0.24.1/full/" });
        tr.step('pyodide loaded');
        await py.runPythonAsync(`
import io, zipfile, json
import xml.etree.ElementTree as ET
_W_NS = "http://schemas.openxmlformats.org/wordprocessingml/2006/main"
NS = {"w": _W_NS}
def _q(local): return f"{{{_W_NS}}}{local}"
def read_docvar_settings(doc_bytes: bytes, name: str) -> str | None:
    f = io.BytesIO(doc_bytes)
    with zipfile.ZipFile(f) as z:
        try: data = z.read("word/settings.xml")
        except KeyError: return None
    try: root = ET.fromstring(data)
    except ET.ParseError: return None
    docVars = root.find("w:docVars", NS)
    if docVars is None: return None
    for dv in docVars.findall("w:docVar", NS):
        if dv.attrib.get(_q("name")) == name:
            return dv.attrib.get(_q("val"), "") or ""
    return None
def write_docvar_settings(doc_bytes: bytes, name: str, value: str) -> bytes:
    f_in = io.BytesIO(doc_bytes); out = io.BytesIO()
    with zipfile.ZipFile(f_in) as zin, zipfile.ZipFile(out, "w", zipfile.ZIP_DEFLATED) as zout:
        try: settings_xml = zin.read("word/settings.xml")
        except KeyError:
            settings_xml = b'<?xml version="1.0" encoding="UTF-8" standalone="yes"?><w:settings xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main"/>'
        for item in zin.infolist():
            if item.filename != "word/settings.xml":
                zout.writestr(item, zin.read(item.filename))
        root = ET.fromstring(settings_xml)
        docVars = root.find("w:docVars", NS)
        if docVars is None: 
            docVars = ET.SubElement(root, _q("docVars"))
        target = None
        for dv in docVars.findall("w:docVar", NS):
            if dv.attrib.get(_q("name")) == name: 
                target = dv; break
        if target is None:
            ET.SubElement(docVars, _q("docVar"), {_q("name"): name, _q("val"): value or ""})
        else:
            target.set(_q("val"), value or "")
        data = ET.tostring(root, encoding="utf-8", xml_declaration=True)
        zout.writestr("word/settings.xml", data)
    return out.getvalue()
def read_docvar_custom(doc_bytes: bytes, name: str) -> str | None:
    f = io.BytesIO(doc_bytes)
    with zipfile.ZipFile(f) as z:
        try: docprops = z.read("docProps/custom.xml")
        except KeyError: return None
    try: root = ET.fromstring(docprops)
    except ET.ParseError: return None
    for v in root:
        if v.tag.endswith("property") and v.attrib.get("name") == name:
            for c in v: return c.text or ""
    return None
def write_sdts_by_tag(doc_bytes: bytes, mapping_json: str) -> bytes:
    import json as _json
    mapping = _json.loads(mapping_json or "{}")
    f_in = io.BytesIO(doc_bytes); out = io.BytesIO()
    with zipfile.ZipFile(f_in) as zin, zipfile.ZipFile(out, "w", zipfile.ZIP_DEFLATED) as zout:
        for item in zin.infolist():
            data = zin.read(item.filename)
            if item.filename.startswith("word/") and item.filename.endswith(".xml"):
                try:
                    root = ET.fromstring(data)
                    for sdt in root.findall(".//w:sdt", NS):
                        props = sdt.find("w:sdtPr", NS); tag = None
                        if props is not None:
                            t = props.find("w:tag", NS)
                            if t is not None: tag = t.attrib.get(_q("val"))
                        if tag and tag in mapping:
                            for tnode in sdt.findall(".//w:t", NS): tnode.text = ""
                            body = sdt.find(".//w:r/w:t", NS)
                            if body is not None: body.text = str(mapping[tag])
                    data = ET.tostring(root, encoding="utf-8", xml_declaration=True)
                except ET.ParseError:
                    pass
            zout.writestr(item, data)
    return out.getvalue()
        `);
        tr.end('pyodide ready');
        return py;
      } catch (e) { tr.error('bootstrap failed', e); tr.end(); throw e; }
    })();

    async function readDocVarSettings(arrayBufferOrBytes, name) {
      const tr = TRACE('readDocVarSettings', { name });
      try {
        const py = await pyodideReady;
        const u8in = arrayBufferOrBytes instanceof Uint8Array ? arrayBufferOrBytes : new Uint8Array(arrayBufferOrBytes);
        const fn = py.globals.get('read_docvar_settings');
        const pyBytes = py.toPy(u8in);
        let pyOut;
        try { pyOut = fn(pyBytes, name); }
        finally { try{fn.destroy();}catch{} try{pyBytes.destroy();}catch{} }
        let txt = null;
        if (pyOut?.toJs) txt = pyOut.toJs({ create_proxies:false });
        else txt = pyOut ?? null;
        try { pyOut.destroy?.(); } catch {}
        tr.end({ found: !!txt, len: txt?.length });
        return txt;
      } catch (e) { tr.error('failed', e); tr.end(); return null; }
    }

    async function readDocVarCustom(arrayBufferOrBytes, name) {
      const tr = TRACE('readDocVarCustom', { name });
      try {
        const py = await pyodideReady;
        const u8in = arrayBufferOrBytes instanceof Uint8Array ? arrayBufferOrBytes : new Uint8Array(arrayBufferOrBytes);
        const fn = py.globals.get('read_docvar_custom');
        const pyBytes = py.toPy(u8in);
        let pyOut;
        try { pyOut = fn(pyBytes, name); }
        finally { try{fn.destroy();}catch{} try{pyBytes.destroy();}catch{} }
        let txt = null;
        if (pyOut?.toJs) txt = pyOut.toJs({ create_proxies:false });
        else txt = pyOut ?? null;
        try { pyOut.destroy?.(); } catch {}
        tr.end({ found: !!txt, len: txt?.length });
        return txt;
      } catch (e) { tr.error('failed', e); tr.end(); return null; }
    }

    async function writeDocVarSettings(arrayBufferOrBytes, name, value) {
      const tr = TRACE('writeDocVarSettings', { name, valueLen: (value||'').length });
      try {
        const py = await pyodideReady;
        const u8in = arrayBufferOrBytes instanceof Uint8Array ? arrayBufferOrBytes : new Uint8Array(arrayBufferOrBytes);
        const fn = py.globals.get('write_docvar_settings');
        const pyBytes = py.toPy(u8in);
        let pyOut;
        try { pyOut = fn(pyBytes, name, String(value ?? "")); }
        finally { try{fn.destroy();}catch{} try{pyBytes.destroy();}catch{} }
        let u8;
        if (pyOut?.toJs) u8 = pyOut.toJs({ create_proxies:false });
        else if (pyOut?.getBuffer) u8 = new Uint8Array(pyOut.getBuffer());
        else u8 = new Uint8Array([]);
        try { pyOut.destroy?.(); } catch {}
        tr.end({ outLen: u8?.byteLength });
        return u8;
      } catch (e) { tr.error('failed', e); tr.end(); throw e; }
    }

    async function writeSDTs(arrayBufferOrBytes, tagToTextObj) {
      const tr = TRACE('writeSDTs', { tagCount: Object.keys(tagToTextObj||{}).length });
      try {
        const py = await pyodideReady;
        const u8in = arrayBufferOrBytes instanceof Uint8Array ? arrayBufferOrBytes : new Uint8Array(arrayBufferOrBytes);
        const fn = py.globals.get('write_sdts_by_tag');
        const pyBytes   = py.toPy(u8in);
        const pyMap     = py.toPy(JSON.stringify(tagToTextObj || {}));
        let pyOut;
        try { pyOut = fn(pyBytes, pyMap); }
        finally { try{fn.destroy();}catch{} try{pyBytes.destroy();}catch{} try{pyMap.destroy();}catch{} }
        let u8;
        if (pyOut?.toJs) u8 = pyOut.toJs({ create_proxies:false });
        else if (pyOut?.getBuffer) u8 = new Uint8Array(pyOut.getBuffer());
        else u8 = new Uint8Array([]);
        try { pyOut.destroy?.(); } catch {}
        tr.end({ outLen: u8?.byteLength });
        return u8;
      } catch (e) { tr.error('failed', e); tr.end(); throw e; }
    }

    // =========================
    // RENDER FROM CURRENT BYTES
    // =========================
    async function renderFromCurrentBytes(prefix = '') {
      const tr = TRACE('renderFromCurrentBytes', { prefix, hasBuf: !!gArrayBuffer, len: gArrayBuffer?.byteLength });
      try {
        tr.step('buffer sha', await sha256Hex(gArrayBuffer));
        const parsed = await parseSDTs_JS(gArrayBuffer);
        gSDTs = parsed.sdts || [];
        renderSDTsView(parsed);

        let payloadRaw = await readDocVarSettings(gArrayBuffer, PAYLOAD_KEY);
        if (payloadRaw == null) payloadRaw = await readDocVarCustom(gArrayBuffer, PAYLOAD_KEY);

        let payload = null;
        try { payload = payloadRaw ? JSON.parse(payloadRaw) : null; } catch { payload = null; }

        const wsState  = await window.formSuitePersist.loadState(gDocId);
        const wsSchema = wsState?.schema || null;
        const wsValues = wsState?.values || {};
        const lsSchema = loadSchemaFromLocalStorage();

        function asTs(x){ const t = Date.parse(x || ''); return Number.isFinite(t) ? t : 0; }
        const pHasSchema = Array.isArray(payload?.fields) && payload.fields.length > 0;
        const pUpdatedTs = asTs(payload?.updatedAt);
        const wsSchemaTs = asTs(wsState?.schemaUpdatedAt);

        let chosenSchema, statusSource;
        if (wsSchema && (wsSchemaTs >= pUpdatedTs || !pHasSchema)) {
          chosenSchema = wsSchema; statusSource = 'Using newer schema from Builder/workspace.';
        } else if (pHasSchema) {
          chosenSchema = { title: payload.title || 'Form', fields: payload.fields };
          statusSource = 'Loaded schema from DOCX payload.';
        } else if (lsSchema && Array.isArray(lsSchema.fields)) {
          chosenSchema = lsSchema; statusSource = 'No schema in DOCX. Using Builder (local) schema.';
        } else {
          chosenSchema = { title: 'Form', fields: [] }; statusSource = 'No schema found.';
        }

        const mergedValues = { ...(payload?.values || {}), ...(wsValues || {}) };

        gSchema = chosenSchema;
        gValues = mergedValues;

        await window.formSuitePersist.saveState(gDocId, { schema: gSchema, values: gValues });

        buildForm(formMount, gSchema, gValues);
        await updatePreview(gValues);
        gDirty = false;

        btnSave.disabled = false;
        btnExport.disabled = false;
        btnSaveFromPreview.disabled = false;

        setStatus(`${prefix}${statusSource} SDTs: ${gSDTs.length}. Fields: ${gSchema.fields.length}.`);
        tr.end({ sdtCount: gSDTs.length, fieldCount: gSchema.fields.length, statusSource });
      } catch (e) { tr.error('failed', e); tr.end(); throw e; }
    }

    function renderSDTsView(parsed) {
      const tr = TRACE('renderSDTsView', { total: parsed?.total, rows: parsed?.sdts?.length });
      try {
        tableBody.innerHTML = '';
        const sdts = parsed?.sdts || [];
        if (!sdts.length) {
          const trEl = document.createElement('tr');
          const td = document.createElement('td');
          td.colSpan = 5;
          td.textContent = 'No SDTs found in this document.';
          trEl.appendChild(td);
          tableBody.appendChild(trEl);
        } else {
          sdts.forEach((row, i) => {
            const trEl = document.createElement('tr');
            const tdIdx = document.createElement('td'); tdIdx.textContent = String(i + 1); trEl.appendChild(tdIdx);
            const tdPart = document.createElement('td'); tdPart.textContent = row.part || ''; trEl.appendChild(tdPart);
            const tdTag = document.createElement('td'); tdTag.textContent = row.tag || ''; trEl.appendChild(tdTag);
            const tdAlias = document.createElement('td'); tdAlias.textContent = row.alias || ''; trEl.appendChild(tdAlias);
            const tdText = document.createElement('td'); tdText.textContent = row.text || ''; trEl.appendChild(tdText);
            tableBody.appendChild(trEl);
          });
        }
      } finally { tr.end(); }
    }

    // =========================
    // BOOT (auto-restore)
    // =========================
    (async function boot() {
      const tr = TRACE('boot');
      try {
        let meta = window.formSuitePersist?.getCurrentDocMeta?.();
        tr.step('getCurrentDocMeta', meta);
        if (!meta?.docId) { meta = readDocMeta(); tr.step('readDocMeta', meta); }
        if (!meta?.docId) { tr.end('no meta; idle'); return; }

        let bytes = await window.formSuitePersist.getBytes?.(meta.docId)
                 || await window.formSuitePersist.getCurrentDocBytes?.();
        tr.step('persistence bytes', { len: bytes?.byteLength || bytes?.length });

        if (!bytes && supportsFS) {
          try {
            const h = await window.formSuitePersist.getHandle?.(meta.docId);
            tr.step('getHandle', { has: !!h });
            if (h) {
              try { await window.formSuitePersist.ensurePermission?.(h, 'read'); } catch (e) { tr.warn('ensurePermission failed', e); }
              const f = await h.getFile();
              bytes = new Uint8Array(await f.arrayBuffer());
              gFileHandle = h;
              gFileName = f.name?.replace(/\.docx$/i,'') || meta.name || 'document';
              tr.step('handle.getFile ok', { name: gFileName, len: bytes.byteLength });
            }
          } catch (e) { tr.warn('handle path failed', e); }
        }

        if (!bytes) { await hardResetDocContext('no bytes / no permission'); tr.end('no bytes'); return; }

        gArrayBuffer = bytes.buffer ?? bytes;
        gFileName = gFileName || meta.name || 'document';
        gDocId = meta.docId;

        tr.step('restored', { docId: gDocId, name: gFileName, len: gArrayBuffer?.byteLength, sha: await sha256Hex(gArrayBuffer) });

        await renderFromCurrentBytes();
        await updateWriteAccessBanner(); // reflect current permission without prompting

        btnSave.disabled = false; btnExport.disabled = false;
        if (btnSaveFromPreview) btnSaveFromPreview.disabled = false;
      } catch (e) { tr.error('boot failed', e); }
      finally { tr.end(); }
    })();

    // =========================
    // PERSIST WRAPPER
    // =========================
    async function persistCurrentDoc(bytesU8, handle, nameNoExt) {
      const tr = TRACE('persistCurrentDoc', { hasBytes: !!bytesU8, handle: !!handle, nameNoExt });
      try {
        const name = (nameNoExt || 'document').replace(/\.docx$/i,'') + '.docx';
        tr.step('computed name', name);
        tr.step('hash', await sha256Hex(bytesU8));
        if (window.formSuitePersist?.setCurrentDoc) {
          const meta = await window.formSuitePersist.setCurrentDoc({ bytes: bytesU8, handle, name });
          tr.end(meta); return meta;
        }
        if (window.formSuitePersist?.setCurrentDocFromBytes) {
          const meta = await window.formSuitePersist.setCurrentDocFromBytes(bytesU8, { name, handle });
          tr.end(meta); return meta;
        }
        const meta = { docId: 'inline-' + Date.now(), name };
        tr.end(meta);
        return meta;
      } catch (e) { tr.error('failed', e); tr.end(); throw e; }
    }

    // =========================
    // FILE OPEN / SAVE / EXPORT
    // =========================
    async function doOpen() {
      const tr = TRACE('doOpen');
      try {
        const [handle] = await showOpenFilePicker({
          multiple: false,
          types: [{ description: 'Word document', accept: { 'application/vnd.openxmlformats-officedocument.wordprocessingml.document': ['.docx'] } }]
        });
        gFileHandle = handle;
        const file = await handle.getFile();
        gFileName = file.name.replace(/\.docx$/i,'') || 'document';
        const bytes = new Uint8Array(await file.arrayBuffer());
        gArrayBuffer = bytes.buffer;

        tr.step('opened', { name: gFileName, size: bytes.byteLength, sha: await sha256Hex(bytes) });

        const metaObj = await persistCurrentDoc(bytes, gFileHandle, gFileName);
        gDocId = metaObj.docId;
        persistDocMeta(metaObj);
        announceDocSwitch();

        await renderFromCurrentBytes();

        // ðŸ‘‡ Prompt immediately (still within user gesture) to grant write
        await updateWriteAccessBanner({ tryPrompt: true });

        btnSave.disabled = false; btnExport.disabled = false;
        if (btnSaveFromPreview) btnSaveFromPreview.disabled = false;
      } catch (e) {
        if (e?.name === 'AbortError') { tr.step('user canceled'); return; }
        tr.error('open failed', e);
        setStatus(`Error opening file: ${e.message || e}`);
      } finally { tr.end(); }
    }

    async function ensureWritePermission(handle) {
      const tr = TRACE('ensureWritePermission', { haveHandle: !!handle });
      try {
        if (!handle?.requestPermission) return 'denied';
        let p = await handle.queryPermission?.({ mode: 'readwrite' });
        tr.step('queryPermission', p);
        if (p === 'granted') return 'granted';
        const r = await handle.requestPermission?.({ mode: 'readwrite' });
        tr.end({ requestPermission: r });
        return r || 'denied';
      } catch (e) { tr.error('perm failed', e); tr.end(); return 'denied'; }
    }

    async function doSave() {
      const tr = TRACE('doSave', { hasBuf: !!gArrayBuffer, docId: gDocId });
      try {
        if (!gArrayBuffer) { tr.warn('no buffer'); return; }
        const restored = gDocId ? (await window.formSuitePersist.loadState(gDocId)) : null;
        tr.step('restored state', { hasSchema: !!restored?.schema, hasValues: !!restored?.values });
        if (restored?.schema) gSchema = restored.schema;

        const __domVals = collectFormValues(gSchema);
        const __baseVals = (restored && restored.values) ? restored.values : {};
        gValues = Object.assign({}, __baseVals, __domVals);

        const tagMap = await getTagMapFor(gDocId);

        const payload = JSON.stringify({ title: gSchema.title || 'Form', fields: gSchema.fields || [], values: gValues || {}, tagMap, updatedAt: new Date().toISOString() });

        await updatePreview(gValues);
        setStatus('Writing payload to DOCX (settings.xml)â€¦');

        const updated = await writeDocVarSettings(gArrayBuffer, PAYLOAD_KEY, payload);
        gArrayBuffer = updated.buffer;

        if (gDocId) await window.formSuitePersist.saveState(gDocId, { schema: gSchema, values: gValues });
        if (gDocId) await window.formSuitePersist.putBytes(gDocId, updated);
        const metaObj = await persistCurrentDoc(updated, gFileHandle, gFileName);
        gDocId = metaObj.docId;
        persistDocMeta(metaObj);
        announceDocUpdate();

        if (supportsFS) {
          const handle = gFileHandle || await window.formSuitePersist.getHandle?.(gDocId);
          tr.step('writeback handle?', { has: !!handle });
          if (handle?.createWritable) {
            const perm = await ensureWritePermission(handle);
            tr.step('ensureWritePermission', perm);
            if (perm === 'granted') {
              const stream = await handle.createWritable();
              await stream.write(updated);
              await stream.close();
              setStatus(`Saved back to "${handle.name || (gFileName + '.docx')}".`);
              gFileHandle = handle;
              gDirty = false;
              await updateWriteAccessBanner();
              tr.end('wrote back to original');
              return;
            } else {
              await updateWriteAccessBanner(); // shows banner
              tr.warn('permission denied; fallback to download');
            }
          }
        }

        const blob = new Blob([updated], { type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = (gFileName || 'document') + '.docx';
        document.body.appendChild(a); a.click(); a.remove();
        setStatus('Saved: downloaded updated DOCX.');
        gDirty = false;
        tr.end('downloaded copy');
      } catch (e) { tr.error('save failed', e); setStatus(`Error saving: ${e.message || e}`); }
      finally { tr.end(); }
    }

    async function doExport() {
      const tr = TRACE('doExport', { hasBuf: !!gArrayBuffer, docId: gDocId });
      try {
        if (!gArrayBuffer) { tr.warn('no buffer'); return; }
        const restored = gDocId ? (await window.formSuitePersist.loadState(gDocId)) : null;
        tr.step('restored state', { hasSchema: !!restored?.schema, hasValues: !!restored?.values });
        if (restored?.schema) gSchema = restored.schema;

        const __domVals2 = collectFormValues(gSchema);
        const __baseVals2 = (restored && restored.values) ? restored.values : {};
        gValues = Object.assign({}, __baseVals2, __domVals2);

        const tagMap = await getTagMapFor(gDocId);
        setStatus('Preparing exportâ€¦');

        const payload = JSON.stringify({ title: gSchema.title || 'Form', fields: gSchema.fields || [], values: gValues || {}, tagMap, updatedAt: new Date().toISOString() });
        const updated = await writeDocVarSettings(gArrayBuffer, PAYLOAD_KEY, payload);

        const sdtMap = {};
        for (const [tag, fieldId] of Object.entries(tagMap)) {
          let v = gValues?.[fieldId];
          if (v == null) v = '';
          if (typeof v === 'object') { try { v = JSON.stringify(v); } catch { v = String(v); } }
          sdtMap[tag] = String(v);
        }
        const updated2 = await writeSDTs(updated, sdtMap);
        gArrayBuffer = updated2.buffer;

        if (gDocId) await window.formSuitePersist.saveState(gDocId, { schema: gSchema, values: gValues });
        if (gDocId) await window.formSuitePersist.putBytes(gDocId, updated2);
        const metaObj = await persistCurrentDoc(updated2, gFileHandle, gFileName);
        gDocId = metaObj.docId;
        persistDocMeta(metaObj);
        announceDocUpdate();

        if (supportsFS) {
          const handle = gFileHandle || await window.formSuitePersist.getHandle?.(gDocId);
          tr.step('writeback handle?', { has: !!handle });
          if (handle?.createWritable) {
            const perm = await ensureWritePermission(handle);
            tr.step('ensureWritePermission', perm);
            if (perm === 'granted') {
              const stream = await handle.createWritable();
              await stream.write(updated2);
              await stream.close();
              setStatus(`Exported back to "${handle.name || (gFileName + '.docx')}".`);
              gFileHandle = handle;
              gDirty = false;
              await updateWriteAccessBanner();
              tr.end('export wrote back'); return;
            } else {
              await updateWriteAccessBanner(); // shows banner
            }
          }
        }

        const blob = new Blob([updated2], { type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = (gFileName || 'document').replace(/\.docx$/i, '') + ' (export).docx';
        document.body.appendChild(a); a.click(); a.remove();
        setStatus('Exported: downloaded copy.');
        gDirty = false;
        tr.end('downloaded export');
      } catch (e) { tr.error('export failed', e); setStatus(`Error exporting: ${e.message || e}`); }
      finally { tr.end(); }
    }

    // =========================
    // PAYLOAD PREVIEW (editable)
    // =========================
    let __payloadApplyTimer = null;
    let __payloadEditBusy = false;

    async function applyPayloadObject(obj, { broadcast = true, save = true } = {}) {
      const tr = TRACE('applyPayloadObject', { broadcast, save, keys: Object.keys(obj||{}).length });
      try {
        if (!obj || typeof obj !== 'object') { tr.warn('no object'); return; }
        const nextSchema = { title: obj.title || 'Form', fields: Array.isArray(obj.fields) ? obj.fields : [] };
        const nextValues = (obj.values && typeof obj.values === 'object') ? obj.values : {};
        const nextTagMap = (obj.tagMap && typeof obj.tagMap === 'object') ? obj.tagMap : {};
        const nowIso = new Date().toISOString();

        gSchema = nextSchema;
        gValues = nextValues;

        if (gDocId && save) {
          await window.formSuitePersist.saveState(gDocId, {
            schema: gSchema,
            values: gValues,
            tagMap: nextTagMap,
            payload: { CRONOS_PAYLOAD: obj },
            schemaUpdatedAt: nowIso
          });
        } else {
          try { localStorage.setItem(STORAGE_KEY, JSON.stringify({ title: gSchema.title, fields: gSchema.fields })); } catch (e) { tr.warn('ls set failed', e); }
        }

        buildForm(document.getElementById('formMount'), gSchema, gValues);
        await updatePreview(gValues);

        if (broadcast) {
          try { bc?.postMessage({ type: 'schema-updated', docId: gDocId, ts: Date.now() }); } catch (e) { tr.warn('broadcast failed', e); }
        }

        gDirty = true;
        setStatus('Payload applied (overrides schema & values). Not yet saved to DOCX.');
        if (previewStatus) { previewStatus.textContent = 'Applied'; setTimeout(()=> previewStatus.textContent='', 1200); }
        tr.end('applied');
      } catch (e) { tr.error('failed', e); tr.end(); }
    }

    if (payloadEl) {
      payloadEl.addEventListener('input', () => {
        const tr = TRACE('payloadEl:input');
        try {
          clearTimeout(__payloadApplyTimer);
          __payloadApplyTimer = setTimeout(async () => {
            const tr2 = TRACE('payloadEl:debouncedApply');
            if (__payloadEditBusy) { tr2.step('busy skip'); tr2.end(); return; }
            try {
              const txt = payloadEl.value;
              const obj = JSON.parse(txt);
              __payloadEditBusy = true;
              await applyPayloadObject(obj);
            } catch (e) {
              if (previewStatus) previewStatus.textContent = 'Invalid JSON';
              tr2.warn('invalid JSON', e);
            } finally {
              __payloadEditBusy = false;
              tr2.end();
            }
          }, 350);
        } finally { tr.end(); }
      });
    }

    // =========================
    // WIRE UP UI
    // =========================
    btnOpen.addEventListener('click', doOpen);
    btnSave.addEventListener('click', doSave);
    btnExport.addEventListener('click', doExport);
    btnSaveFromPreview?.addEventListener('click', doSave);

    btnRegrant.addEventListener('click', async () => {
      const tr = TRACE('btnRegrant:click');
      try {
        await updateWriteAccessBanner({ tryPrompt: true });
      } catch (e) { tr.error('regrant failed', e); permNote.style.display='block'; }
      finally { tr.end(); }
    });

    window.addEventListener('beforeunload', async () => {
      const tr = TRACE('beforeunload');
      try {
        if (!gDocId) { tr.end('no docId'); return; }
        const vals = collectFormValues(gSchema);
        await window.formSuitePersist.saveState(gDocId, { schema: gSchema, values: { ...(gValues||{}), ...vals } });
        persistDocMeta({ docId: gDocId, name: gFileName });
      } catch (e) { tr.warn('beforeunload failed', e); }
      finally { tr.end(); }
    });
  </script>
</body>
</html>
