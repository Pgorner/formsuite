<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<title>DOCX Baseline Rebuilder – Laden, Erkennen & Wiederherstellen</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{--ink:#0f172a;--muted:#6b7280;--card:#fff;--bg:#f8fafc;--border:#e5e7eb;--accent:#3b82f6}
  *{box-sizing:border-box} html,body{margin:0;background:var(--bg);color:var(--ink);font:14px/1.45 system-ui,Segoe UI,Roboto,Arial}
  header{padding:16px 20px;border-bottom:1px solid var(--border);background:#fff;position:sticky;top:0;z-index:1}
  h1{font-size:18px;margin:0} main{max-width:1040px;margin:20px auto;padding:0 16px 56px}
  .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}.spacer{flex:1}
  .card{background:var(--card);border:1px solid var(--border);border-radius:10px;box-shadow:0 1px 0 rgba(0,0,0,.03);padding:16px;margin:16px 0}
  input[type="file"]{padding:8px;border:1px dashed var(--border);border-radius:8px;background:#fff}
  button{border:1px solid var(--border);background:#fff;border-radius:8px;padding:10px 14px;cursor:pointer}
  button.primary{background:var(--accent);color:#fff;border-color:var(--accent)} button:disabled{opacity:.6;cursor:not-allowed}
  .muted{color:var(--muted)} #status{white-space:pre-wrap;font:12px ui-monospace,Consolas,Menlo}
  .tree{max-height:560px;overflow:auto;border:1px solid var(--border);border-radius:10px;padding:6px 8px;background:#fff}
  .tree ul{margin:0;padding-left:18px}
  .node{display:flex;align-items:center;gap:8px;padding:4px 2px;border-radius:6px}
  .node:hover{background:#f1f5f9}
  .num{font-variant-numeric:tabular-nums;opacity:.9;min-width:3.5ch;text-align:right}
  .title{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:70ch}
  .lvl-1 .title{font-weight:700}.lvl-2 .title{font-weight:600}.lvl-3 .title{font-weight:500}
  .badge{margin-left:auto;font-size:11px;color:#334155;background:#e2e8f0;border-radius:999px;padding:2px 6px}
</style>
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
</head>
<body>
<header>
  <h1>DOCX Baseline Rebuilder</h1>
  <div class="muted">
    Lädt auch <b>veränderte</b> Dateien, hakt bereits <b>entfernte</b> Abschnitte an und kann sie per Haken wieder <b>herstellen</b>.
    Arbeitet immer aus einer <b>Baseline</b> (Original-XML) in <code>customXml/originalDocument.xml</code>.
  </div>
</header>

<main>
  <div class="card">
    <div class="row">
      <input id="fileInput" type="file" accept=".docx" />
      <button id="btnLoad" class="primary">Laden</button>
      <div class="spacer"></div>
      <label title="Aus dem Baseline-Dokument neu erzeugen und Felder von Word aktualisieren lassen">
        <input id="chkRebuildToc" type="checkbox" checked/> TOC neu setzen
      </label>
      <label><input type="radio" name="mode" value="hide" checked/> Verstecken</label>
      <label><input type="radio" name="mode" value="delete"/> Löschen</label>
      <button id="btnSelectAll">Alle wählen</button>
      <button id="btnClearAll">Alle abwählen</button>
      <button id="btnExport" class="primary" disabled>Export</button>
    </div>
    <div id="status" class="muted" style="margin-top:8px"></div>
  </div>

  <div class="card">
    <strong>Überschriften (Baseline; Haken = im Export ausblenden/löschen)</strong>
    <div id="tree" class="tree"></div>
  </div>
</main>

<script>
/* ===== Namespaces & State ===== */
const W_NS="http://schemas.openxmlformats.org/wordprocessingml/2006/main";
const XML_NS="http://www.w3.org/XML/1998/namespace";
const BASE_PATH='customXml/originalDocument.xml';
const INDEX_PATH='customXml/sections.json';
const SEL_PATH='customXml/selection.json';

let zip=null, fileNameBase='document';
let styleMap={};
let activeDoc=null;        // aktuell im DOCX vorhandenes document.xml (zum Erkennen)
let baseDoc=null;          // eingefrorene Baseline (Quelle für Export)
let settingsDoc=null;

let allParasBase=[], headingsFlat=[], treeRoot=[];
const statusEl=document.getElementById('status'), treeEl=document.getElementById('tree');
const setStatus=s=>statusEl.textContent=s;

/* ===== Style map ===== */
function levelFromStyleHint(str){
  if(!str) return 0; const s=String(str).trim().toLowerCase();
  const ps=[/heading\s*([1-9])/,/überschrift\s*([1-9])/,/titre\s*([1-9])/,/t[ií]tulo\s*([1-9])/,/encabezado\s*([1-9])/,/rubrik\s*([1-9])/,/zagolovok\s*([1-9])/,/заголовок\s*([1-9])/];
  for(const re of ps){ const m=s.match(re); if(m) return +m[1]; }
  const m2=s.match(/^heading([1-9])$/i); return m2?+m2[1]:0;
}
async function buildStyleMap(zip){
  const f=zip.file('word/styles.xml'); if(!f) return {};
  const xml=new DOMParser().parseFromString(await f.async('string'),"application/xml");
  const byId={}, styles=xml.getElementsByTagNameNS(W_NS,'style');
  for(let i=0;i<styles.length;i++){
    const st=styles[i]; if((st.getAttributeNS(W_NS,'type')||st.getAttribute('w:type'))!=='paragraph') continue;
    const id=st.getAttributeNS(W_NS,'styleId')||st.getAttribute('w:styleId')||''; if(!id) continue;
    const nameEl=st.getElementsByTagNameNS(W_NS,'name')[0];
    const name=nameEl?(nameEl.getAttributeNS(W_NS,'val')||nameEl.getAttribute('w:val')||''):'';
    const basedEl=st.getElementsByTagNameNS(W_NS,'basedOn')[0];
    const basedOn=basedEl?((basedEl.getAttributeNS && basedEl.getAttributeNS(W_NS,'val'))||(basedEl.getAttribute && basedEl.getAttribute('w:val'))||''):'';
    let lvl=0; const pPr=st.getElementsByTagNameNS(W_NS,'pPr')[0];
    if(pPr){ const ol=pPr.getElementsByTagNameNS(W_NS,'outlineLvl')[0];
      if(ol){ const v=ol.getAttributeNS(W_NS,'val')||ol.getAttribute('w:val'); if(v!=null && v!==''){ const n=+v; if(Number.isFinite(n)) lvl=Math.max(1,Math.min(9,n+1));}}}
    if(!lvl) lvl=levelFromStyleHint(id)||levelFromStyleHint(name)||0;
    byId[id]={basedOn, rawLevel:lvl};
  }
  const res={}, resolve=(id,d=0)=>{ if(!id||!byId[id]||d>12) return 0; if(res[id]!=null) return res[id];
    const info=byId[id]; if(info.rawLevel){ res[id]=info.rawLevel; return res[id]; }
    return res[id]=resolve(info.basedOn, d+1)||0;
  };
  Object.keys(byId).forEach(id=>resolve(id)); return res;
}

/* ===== Paragraph utils ===== */
function textOfPara(p){
  const ts=p.getElementsByTagNameNS(W_NS,'t'); let s=''; for(let i=0;i<ts.length;i++) s+=ts[i].textContent;
  return s.replace(/\s+/g,' ').trim();
}
function detectHeadingLevel(p){
  const pPr=p.getElementsByTagNameNS(W_NS,'pPr')[0];
  if(pPr){
    const ol=pPr.getElementsByTagNameNS(W_NS,'outlineLvl')[0];
    if(ol){ const v=ol.getAttributeNS(W_NS,'val')||ol.getAttribute('w:val'); if(v!=null&&v!==''){ const n=+v; if(Number.isFinite(n)) return Math.max(1,Math.min(9,n+1));}}
    const pStyle=pPr.getElementsByTagNameNS(W_NS,'pStyle')[0];
    if(pStyle){ const id=pStyle.getAttributeNS(W_NS,'val')||pStyle.getAttribute('w:val')||''; const lvl=styleMap?.[id]; if(lvl) return lvl; }
  }
  return 0;
}
function stripLeadingNumber(s){
  return String(s||'').replace(/^[\s\t\u00A0]*\d+(?:[.\u00A0 \t]+\d+)*[.\u00A0 \t]*/,'').trim();
}

/* ===== Baseline sections & tree ===== */
function collectAllParagraphsBase(){ allParasBase = Array.from(baseDoc.getElementsByTagNameNS(W_NS,'p')); }
function computeSectionsFromBase(){
  headingsFlat=[];
  for(let i=0;i<allParasBase.length;i++){
    const p=allParasBase[i], lvl=detectHeadingLevel(p); if(!lvl) continue;
    const t=textOfPara(p); if(!t) continue;
    headingsFlat.push({ id:`sec_${i.toString().padStart(6,'0')}`, pIdx:i, level:lvl, title:t, normTitle:stripLeadingNumber(t), start:i, end:allParasBase.length });
  }
  for(let i=0;i<headingsFlat.length;i++){
    const cur=headingsFlat[i]; let end=allParasBase.length;
    for(let j=i+1;j<headingsFlat.length;j++){ if(headingsFlat[j].level<=cur.level){ end=headingsFlat[j].pIdx; break; } }
    cur.end=end;
  }
}
function buildTree(){
  treeRoot=[]; const st=[];
  for(const h of headingsFlat){
    const n={...h, children:[], selected:false, num:""};
    while(st.length && st[st.length-1].level>=n.level) st.pop();
    if(!st.length) treeRoot.push(n); else st[st.length-1].children.push(n);
    st.push(n);
  }
}
function renumberTree(root){
  const c=Array(10).fill(0);
  (function walk(list){
    for(const n of list){
      c[n.level]++; for(let k=n.level+1;k<10;k++) c[k]=0;
      n.num=Array.from({length:n.level},(_,i)=>String(c[i+1])).join('.');
      if(n.children?.length) walk(n.children);
    }
  })(root);
}
function renderTree(){
  renumberTree(treeRoot);
  treeEl.innerHTML=''; const top=document.createElement('ul');
  function mk(list){
    const ul=document.createElement('ul');
    for(const n of list){
      const li=document.createElement('li');
      const row=document.createElement('div'); row.className=`node lvl-${n.level}`;
      const cb=document.createElement('input'); cb.type='checkbox'; cb.checked=n.selected;
      cb.addEventListener('change',()=>{ n.selected=cb.checked; if(n.children) markChildren(n.children, cb.checked); });
      const num=document.createElement('span'); num.className='num'; num.textContent=n.num;
      const title=document.createElement('span'); title.className='title'; title.textContent=n.title;
      const badge=document.createElement('span'); badge.className='badge'; badge.textContent=`H${n.level}`;
      row.append(cb,num,title,badge); li.appendChild(row);
      if(n.children?.length) li.appendChild(mk(n.children));
      ul.appendChild(li);
    } return ul;
  }
  function markChildren(list,val){ for(const x of list){ x.selected=val; if(x.children) markChildren(x.children,val); } }
  top.appendChild(mk(treeRoot)); treeEl.appendChild(top);
}

/* ===== Selection persistence & detection ===== */
function getSelectionFromTree(){
  const ids=[];
  (function walk(list){
    for(const n of list){ if(n.selected) ids.push(n.id); if(n.children) walk(n.children); }
  })(treeRoot);
  return ids;
}
function applySelectionToTree(idsSet){
  (function walk(list){
    for(const n of list){ n.selected = idsSet.has(n.id); if(n.children) applySelectionToTree(n.children); }
  })(treeRoot);
}

/* Heuristik: Welche Baseline-Headings sind aktuell im DOC sichtbar?
   -> wir sammeln alle sichtbaren (Heading-)Absätze aus activeDoc, normalisieren ihren Text (Nummer vorn weg)
   -> ist ein Baseline-Heading *nicht* dabei => gilt als "entfernt" => im Tree vorangekreuzt */
function detectRemovedHeadingsAgainstActive(){
  if(!activeDoc){ return new Set(); }
  const vis = new Set();
  const paras = Array.from(activeDoc.getElementsByTagNameNS(W_NS,'p'));
  for(const p of paras){
    const lvl = detectHeadingLevel(p); if(!lvl) continue;
    const t = stripLeadingNumber(textOfPara(p));
    if(t) vis.add(`${lvl}::${t}`);
  }
  const removed = new Set();
  for(const h of headingsFlat){
    const key = `${h.level}::${h.normTitle}`;
    if(!vis.has(key)) removed.add(h.id);
  }
  return removed;
}

/* ===== Baseline/Index/Selection management ===== */
async function ensureBaselineAndIndex(){
  if(!zip.file(BASE_PATH)){
    const docText = await zip.file('word/document.xml').async('string');
    zip.file(BASE_PATH, docText);
  }
  if(!zip.file(INDEX_PATH)){
    const baseText = await zip.file(BASE_PATH).async('string');
    baseDoc = new DOMParser().parseFromString(baseText,"application/xml");
    collectAllParagraphsBase(); computeSectionsFromBase();
    const idx = {version:1, sections: headingsFlat.map(h=>({id:h.id,start:h.start,end:h.end,level:h.level,title:h.title}))};
    zip.file(INDEX_PATH, JSON.stringify(idx, null, 2));
  }
}
async function loadBaselineAndIndex(){
  const baseText = await zip.file(BASE_PATH).async('string');
  baseDoc = new DOMParser().parseFromString(baseText,"application/xml");
  collectAllParagraphsBase(); computeSectionsFromBase();
}

/* ===== Hide/Delete sicher (inkl. Tabellen/SDT/Textbox) ===== */
function applyVanishRunDeep(node){
  if(node.namespaceURI===W_NS && node.localName==='p'){
    let pPr=node.getElementsByTagNameNS(W_NS,'pPr')[0];
    if(!pPr){ pPr=node.ownerDocument.createElementNS(W_NS,'w:pPr'); node.insertBefore(pPr,node.firstChild); }
    let rPr=pPr.getElementsByTagNameNS(W_NS,'rPr')[0];
    if(!rPr){ rPr=node.ownerDocument.createElementNS(W_NS,'w:rPr'); pPr.insertBefore(rPr,pPr.firstChild); }
    if(!rPr.getElementsByTagNameNS(W_NS,'vanish')[0]) rPr.appendChild(node.ownerDocument.createElementNS(W_NS,'w:vanish'));
  }
  if(node.namespaceURI===W_NS && node.localName==='r'){
    let rPr=node.getElementsByTagNameNS(W_NS,'rPr')[0];
    if(!rPr){ rPr=node.ownerDocument.createElementNS(W_NS,'w:rPr'); node.insertBefore(rPr,node.firstChild); }
    if(!rPr.getElementsByTagNameNS(W_NS,'vanish')[0]) rPr.appendChild(node.ownerDocument.createElementNS(W_NS,'w:vanish'));
  }
  for(let c=node.firstChild;c;c=c.nextSibling) applyVanishRunDeep(c);
}
function canReplaceWithParagraph(parent){
  if(!parent || parent.namespaceURI!==W_NS) return false;
  const ok=new Set(['body','sdtContent','tc','hdr','ftr','footnote','endnote','comment','docPartBody']);
  return ok.has(parent.localName);
}
function makeHiddenPlaceholderParagraph(doc, marker=''){
  const p=doc.createElementNS(W_NS,'w:p');
  const pPr=doc.createElementNS(W_NS,'w:pPr');
  const rPr=doc.createElementNS(W_NS,'w:rPr'); rPr.appendChild(doc.createElementNS(W_NS,'w:vanish'));
  pPr.appendChild(rPr); p.appendChild(pPr);
  const r=doc.createElementNS(W_NS,'w:r'); const t=doc.createElementNS(W_NS,'w:t'); t.setAttributeNS(XML_NS,'xml:space','preserve'); t.textContent=marker;
  r.appendChild(t); p.appendChild(r); return p;
}
function nextNodeInDocOrder(node, root){
  if(!node) return null;
  if(node.firstChild) return node.firstChild;
  while(node && node!==root){ if(node.nextSibling) return node.nextSibling; node=node.parentNode; }
  return null;
}
function transformFromBase(mode, selectedIdsSet){
  // Clone the frozen baseline
  const d = new DOMParser().parseFromString(new XMLSerializer().serializeToString(baseDoc), "application/xml");
  const body = d.getElementsByTagNameNS(W_NS, 'body')[0] || d.documentElement;
  const hide = (mode === 'hide');

  // NOTE: all start/end are based on baseline indices and still valid on the clone
  const paras = Array.from(d.getElementsByTagNameNS(W_NS, 'p'));

  // Build work ranges from selected headings, processed descending to avoid index drift
  const ranges = headingsFlat
    .filter(h => selectedIdsSet.has(h.id))
    .map(h => ({ start: h.start, end: h.end }))
    .sort((a, b) => b.start - a.start);

  // Helper: create a unique, invisible boundary paragraph
  function makeBoundary(doc){
    const p = doc.createElementNS(W_NS, 'w:p');
    const pPr = doc.createElementNS(W_NS, 'w:pPr');
    const rPr = doc.createElementNS(W_NS, 'w:rPr');
    rPr.appendChild(doc.createElementNS(W_NS, 'w:vanish'));
    pPr.appendChild(rPr);
    p.appendChild(pPr);

    // also add a tiny text node so some Word parsers don't drop empty p
    const r = doc.createElementNS(W_NS, 'w:r');
    const t = doc.createElementNS(W_NS, 'w:t');
    t.setAttributeNS(XML_NS,'xml:space','preserve');
    t.textContent = ''; // empty text
    r.appendChild(t);
    p.appendChild(r);
    // tag it so we can recognize it even if structure shifts
    p.setAttribute('data-boundary', 'true');
    return p;
  }

  // Doc-order iterator limited to the body subtree (robust even while mutating)
  function nextInBody(node){
    if(!node) return null;
    if(node.firstChild) return node.firstChild;
    while(node && node !== body){
      if(node.nextSibling) return node.nextSibling;
      node = node.parentNode;
    }
    return null;
  }

  for(const { start, end } of ranges){
    const startP = paras[start];
    const endP   = end < paras.length ? paras[end] : null;

    if(!startP || !startP.parentNode){
      continue; // defensive
    }

    // Insert a hidden clone of the heading (with style removed so it drops from TOC),
    // then remove the original heading paragraph.
    const clone = startP.cloneNode(true);
    let pPr = clone.getElementsByTagNameNS(W_NS,'pPr')[0];
    if(!pPr){
      pPr = clone.ownerDocument.createElementNS(W_NS,'w:pPr');
      clone.insertBefore(pPr, clone.firstChild);
    }
    const pStyle = pPr.getElementsByTagNameNS(W_NS,'pStyle')[0];
    if(pStyle) pPr.removeChild(pStyle);
    applyVanishRunDeep(clone);

    startP.parentNode.insertBefore(clone, startP);
    startP.parentNode.removeChild(startP);

    // Create and insert a hard stop boundary right before endP (or at end of body)
    let boundary = null;
    if(endP && endP.parentNode){
      boundary = makeBoundary(d);
      endP.parentNode.insertBefore(boundary, endP);
    } else {
      // no next heading -> place boundary at end of body so we don't overrun
      boundary = makeBoundary(d);
      body.appendChild(boundary);
    }

    // Now safely walk forward from just after our clone until we hit the boundary.
    let cur = nextInBody(clone);
    while(cur && cur !== boundary){
      const next = nextInBody(cur);

      if(cur.namespaceURI === W_NS){
        const parent = cur.parentNode;

        if(cur.localName === 'p'){
          // Paragraphs: hide text or remove
          if(hide){
            applyVanishRunDeep(cur);
          } else if(parent){
            parent.removeChild(cur);
          }
        }
        else if(cur.localName === 'tbl' || cur.localName === 'sdt' || cur.localName === 'customXml'){
          if(hide){
            // Replace heavy containers by a vanished placeholder paragraph when legal
            if(parent && canReplaceWithParagraph(parent)){
              parent.insertBefore(makeHiddenPlaceholderParagraph(d, ''), cur);
              parent.removeChild(cur);
            } else {
              // Deep-vanish all inner paragraphs (incl. nested tables)
              const ps = cur.getElementsByTagNameNS(W_NS,'p');
              for(let i=0;i<ps.length;i++) applyVanishRunDeep(ps[i]);
            }
          } else if(parent){
            parent.removeChild(cur);
          }
        }
        else if(cur.localName === 'txbxContent'){
          // Textbox content: vanish paragraphs
          const ps = cur.getElementsByTagNameNS(W_NS,'p');
          for(let i=0;i<ps.length;i++) if(hide) applyVanishRunDeep(ps[i]);
        }
        else if(cur.localName !== 'sectPr'){
          // Generic fallback: vanish inner paragraphs on hide; remove on delete
          if(hide){
            const ps = cur.getElementsByTagNameNS(W_NS,'p');
            for(let i=0;i<ps.length;i++) applyVanishRunDeep(ps[i]);
          } else if(parent){
            parent.removeChild(cur);
          }
        }
      }

      cur = next;
    }

    // Remove the temporary boundary
    if(boundary && boundary.parentNode){
      boundary.parentNode.removeChild(boundary);
    }
  }

  return d;
}


/* ===== TOC ===== */
function findAncestor(node, names){ const set=new Set(names); let n=node; while(n){ if(n.namespaceURI===W_NS && set.has(n.localName)) return n; n=n.parentNode; } return null; }
function nextAfter(node, root){ if(!node) return null; if(node.nextSibling) return node.nextSibling; let p=node.parentNode; while(p && p!==root){ if(p.nextSibling) return p.nextSibling; p=p.parentNode; } return null; }
function findAllTOCRanges(docx){
  const ranges=[]; const body=docx.getElementsByTagNameNS(W_NS,'body')[0]||docx.documentElement;
  const fldChars=Array.from(docx.getElementsByTagNameNS(W_NS,'fldChar'));
  for(const begin of fldChars){
    if(begin.getAttributeNS(W_NS,'val')!=='begin') continue;
    let cur=begin, instr='', hasTOC=false, separate=null, end=null;
    while(cur){ cur=nextNodeInDocOrder(cur,body); if(!cur) break;
      if(cur.namespaceURI===W_NS && cur.localName==='instrText'){ instr+=cur.textContent||''; const u=instr.toUpperCase(); if(u.includes(' TOC ')||u.startsWith('TOC ')||u.includes('TOC\\')||u.includes('TOC "')) hasTOC=true; }
      if(cur.namespaceURI===W_NS && cur.localName==='fldChar'){ const t=cur.getAttributeNS(W_NS,'val'); if(t==='separate') separate=cur; if(t==='end'){ end=cur; break; } }
    }
    if(hasTOC && separate && end) ranges.push({begin,separate,end,instr});
  }
  return ranges;
}
function rebuildTOCs(docx){
  const body=docx.getElementsByTagNameNS(W_NS,'body')[0]||docx.documentElement;
  for(const rg of findAllTOCRanges(docx)){
    const switches=(rg.instr && rg.instr.match(/TOC[\s\S]*$/i)?.[0]) || `TOC \\o "1-3" \\h \\z \\u`;
    const sdt=findAncestor(rg.begin,['sdt']);
    const container=sdt || findAncestor(rg.begin,['p']); if(!container||!container.parentNode) continue;
    const p=docx.createElementNS(W_NS,'w:p');
    const fldSimple=docx.createElementNS(W_NS,'w:fldSimple'); fldSimple.setAttributeNS(W_NS,'w:instr',switches);
    const r=docx.createElementNS(W_NS,'w:r'); const t=docx.createElementNS(W_NS,'w:t'); t.textContent=''; r.appendChild(t); fldSimple.appendChild(r); p.appendChild(fldSimple);
    container.parentNode.insertBefore(p, container); container.parentNode.removeChild(container);
    if(!sdt){
      let cur=nextAfter(rg.separate, body);
      while(cur && cur!==rg.end){ const nxt=nextAfter(cur, body); if(cur.parentNode) cur.parentNode.removeChild(cur); cur=nxt; }
    }
  }
}

/* ===== Export helper ===== */
async function exportFromDoc(newDoc, suffix){
  // 1) Settings bereitstellen (oder minimal erzeugen)
  if(!settingsDoc){
    const s = zip.file('word/settings.xml');
    settingsDoc = s
      ? new DOMParser().parseFromString(await s.async('string'), "application/xml")
      : new DOMParser().parseFromString(`<w:settings xmlns:w="${W_NS}"/>`, "application/xml");
  }
  // UpdateFields einschalten
  {
    const root = settingsDoc.documentElement;
    let upd = root.getElementsByTagNameNS(W_NS,'updateFields')[0];
    if(!upd){ upd = settingsDoc.createElementNS(W_NS,'w:updateFields'); root.appendChild(upd); }
    upd.setAttributeNS(W_NS,'w:val','true');
  }

  // 2) Auswahl serialisieren (fürs Wiederherstellen später)
  const selectedIds = getSelectionFromTree();
  const selectionJson = JSON.stringify({version:1, hiddenIds:selectedIds}, null, 2);

  // 3) Neues ZIP aufbauen – nur echte Dateien kopieren, keine Ordner;
  //    außerdem die Teile ersetzen, die wir neu schreiben.
  const out = new JSZip();
  for (const [name, entry] of Object.entries(zip.files)) {
    if (entry.dir) continue; // << wichtig: Ordner überspringen
    if (name === 'word/document.xml' ||
        name === 'word/settings.xml' ||
        name === SEL_PATH) {
      continue; // wir schreiben diese Teile unten neu
    }
    out.file(name, await zip.file(name).async('arraybuffer'));
  }

  // 4) Unsere neuen/aktualisierten Teile hinzufügen
  out.file('word/document.xml', new XMLSerializer().serializeToString(newDoc));
  out.file('word/settings.xml', new XMLSerializer().serializeToString(settingsDoc));
  out.file(SEL_PATH, selectionJson);

  // 5) Download
  const blob = await out.generateAsync({ type:'blob' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${fileNameBase}-${suffix}.docx`;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}


/* ===== UI wiring ===== */
document.getElementById('btnLoad').addEventListener('click', async ()=>{
  const f=document.getElementById('fileInput').files?.[0]; if(!f){ alert('Bitte .docx wählen'); return; }
  fileNameBase=f.name.replace(/\.docx$/i,'')||'document';
  setStatus('Lade DOCX …');
  zip=await JSZip.loadAsync(f);
  styleMap=await buildStyleMap(zip);

  // aktives document.xml (zum Abgleich)
  activeDoc=new DOMParser().parseFromString(await zip.file('word/document.xml').async('string'),"application/xml");
  const s=zip.file('word/settings.xml');
  settingsDoc=s?new DOMParser().parseFromString(await s.async('string'),"application/xml"):null;

  // Baseline + Index sicherstellen/laden
  await ensureBaselineAndIndex();
  await loadBaselineAndIndex();

  // Tree aufbauen
  buildTree();

  // 1) Auswahl aus selection.json (falls vorhanden)
  let appliedFrom = 'Heuristik';
  if(zip.file(SEL_PATH)){
    try{
      const sel = JSON.parse(await zip.file(SEL_PATH).async('string'));
      if(sel && Array.isArray(sel.hiddenIds)){
        const ids = new Set(sel.hiddenIds);
        (function apply(list){ for(const n of list){ n.selected = ids.has(n.id); if(n.children) apply(n.children);} })(treeRoot);
        appliedFrom = 'selection.json';
      }
    }catch{}
  } else {
    // 2) Heuristik: gegen aktives Dokument abgleichen
    const removedIds = detectRemovedHeadingsAgainstActive(); // was fehlt -> Haken AN
    (function apply(list){ for(const n of list){ n.selected = removedIds.has(n.id); if(n.children) apply(n.children);} })(treeRoot);
  }

  renderTree();
  document.getElementById('btnExport').disabled = headingsFlat.length===0;
  setStatus(`Baseline ✓  • Überschriften: ${headingsFlat.length} • Vorauswahl: ${appliedFrom}`);
});

document.getElementById('btnSelectAll').addEventListener('click', ()=>{
  (function mark(list){ for(const n of list){ n.selected=true; if(n.children) mark(n.children);} })(treeRoot);
  renderTree();
});
document.getElementById('btnClearAll').addEventListener('click', ()=>{
  (function mark(list){ for(const n of list){ n.selected=false; if(n.children) mark(n.children);} })(treeRoot);
  renderTree();
});

document.getElementById('btnExport').addEventListener('click', async ()=>{
  if(!baseDoc){ alert('Bitte zuerst laden.'); return; }
  const idsSet = new Set(getSelectionFromTree());
  const mode = document.querySelector('input[name="mode"]:checked').value;

  let newDoc = transformFromBase(mode, idsSet);
  if(document.getElementById('chkRebuildToc').checked) rebuildTOCs(newDoc);

  await exportFromDoc(newDoc, mode==='hide'?'hidden':'deleted');
  setStatus('Export fertig. Auswahl gespeichert (customXml/selection.json).');
});
</script>
</body>
</html>
