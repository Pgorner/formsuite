<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Form Suite — Form</title>
  <link rel="icon" href="favicon.ico" type="image/gif" sizes="32x32">
  <link rel="shortcut icon" href="favicon.ico" type="image/gif">
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/themes/material_blue.css">
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <header>
    <div class="row">
      <span class="brand logo-md">
        <img src="logo.gif" alt="Form Suite logo" class="logo" />
        <strong>Form Suite</strong>
      </span>
      <span class="muted">·</span><span class="muted">Form</span>
      <span class="muted">·</span><a href="builder.html">Form Builder</a>
      <span class="muted">·</span><a href="matcher.html">Tag Matcher</a>
      <span class="muted">·</span><a href="rules.html">Rules</a>
      <span class="muted">·</span><a href="extractor.html">Extractor</a>
    </div>
  </header>

  <main>
    <section class="panel">
      <div class="title-row"></div>
      <div class="row" style="margin-top:8px;">
        <span id="docStatus" class="muted">No active document. Open one in the <a href="extractor.html">Extractor</a>.</span>
      </div>
      <div id="permNote" class="note warn" style="display:none; margin-top:10px">
        This DOCX was opened via picker but I don’t have write permission to the original file.
        Exports will download a copy instead of writing back.
        <button id="btnRegrant" class="ghost" style="margin-left:8px">Grant write access</button>
      </div>
    </section>

    <section class="panel">
      <div id="formMount"></div>
    </section>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <script src="persistence.js"></script>
  <script src="address-autocomplete.js"></script>
  <script>
    const STORAGE_KEY = 'FORM_SCHEMA_V1';
    const PAYLOAD_KEY = 'CRONOS_PAYLOAD';
    const supportsFS = 'showSaveFilePicker' in window;

    const els = {
      docStatus: document.getElementById('docStatus'),
      formMount: document.getElementById('formMount'),
      permNote:  document.getElementById('permNote'),
      btnRegrant:document.getElementById('btnRegrant'),
    };

    let currentDoc = null, schema = null, values = {};
    let btnExportMain = null;

    // ---------- Status + Hard Reset ----------
    function setStatus(s) { els.docStatus.innerHTML = s; }
    async function hardResetOpenForm(reason = '') {
      try {} catch {}
      schema = null;
      values = {};
      if (els.formMount) els.formMount.innerHTML = `<div class="muted">No schema found. Create one in the <a href="builder.html">Builder</a>.</div>`;
      if (btnExportMain) btnExportMain.disabled = true;
      els.permNote.style.display = 'none';
      if (reason) setStatus(`No active document (${reason}). Open one in the <a href="extractor.html">Extractor</a>.`);
      else setStatus(`No active document. Open one in the <a href="extractor.html">Extractor</a>.`);
    }

    // ---------- One Active-Doc Signal (canonical) ----------
    const ACTIVE_DOC_KEY = 'FS_ACTIVE_DOC_META'; // unified key across the app

    function readActiveDocSync() {
      // Prefer live persistence info in this tab
      const p = window.formSuitePersist?.getCurrentDocMeta?.()
             || window.formSuitePersist?.getActiveDoc?.sync?.();
      if (p?.docId) {
        const meta = { docId: p.docId, name: p.name || p.docTitle || 'document' };
        try { localStorage.setItem(ACTIVE_DOC_KEY, JSON.stringify(meta)); } catch {}
        return meta;
      }
      // Canonical LS
      try { const v = localStorage.getItem(ACTIVE_DOC_KEY); if (v) return JSON.parse(v); } catch {}
      // Legacy migration (older Extractor)
      try {
        const legacy = localStorage.getItem('FS_CURRENT_DOC_META');
        if (legacy) {
          const m = JSON.parse(legacy);
          if (m?.docId) {
            localStorage.setItem(ACTIVE_DOC_KEY, legacy);
            return m;
          }
        }
      } catch {}
      return null;
    }

    function installActiveDocListener(onChange) {
      const bcLegacy = ('BroadcastChannel' in window) ? new BroadcastChannel('form-suite-doc') : null;
      const bcCanon  = ('BroadcastChannel' in window) ? new BroadcastChannel('fs-active-doc') : null;

      function emit(meta) {
        if (meta?.docId) {
          try { localStorage.setItem(ACTIVE_DOC_KEY, JSON.stringify({ docId: meta.docId, name: meta.name })); } catch {}
        } else {
          try { localStorage.removeItem(ACTIVE_DOC_KEY); } catch {}
        }
        onChange(meta || null);
      }

      bcLegacy?.addEventListener('message', (ev) => {
        const m = ev?.data || {};
        if (m.type === 'doc-cleared') { emit(null); return; }
        if (m.type === 'doc-switched' || m.type === 'doc-updated') {
          emit((m.docId) ? { docId: m.docId, name: m.name } : readActiveDocSync());
        }
        if (m.type === 'schema-updated') {
          const meta = readActiveDocSync();
          if (meta?.docId && (!m.docId || m.docId === meta.docId)) emit(meta);
        }
      });

      bcCanon?.addEventListener('message', (ev) => {
        const m = ev?.data || {};
        if (m.type === 'active:set')   emit({ docId: m.docId, name: m.name });
        if (m.type === 'active:clear') emit(null);
      });

      window.addEventListener('storage', (e) => {
        if (e.key === ACTIVE_DOC_KEY) {
          const v = e.newValue ? JSON.parse(e.newValue) : null;
          emit(v);
        }
        if (e.key === 'FS_CURRENT_DOC_META' && !localStorage.getItem(ACTIVE_DOC_KEY)) {
          const v = e.newValue ? JSON.parse(e.newValue) : null;
          if (v?.docId) {
            try { localStorage.setItem(ACTIVE_DOC_KEY, e.newValue); } catch {}
            emit(v);
          }
        }
      });
    }

    installActiveDocListener(async (meta) => {
      currentDoc = meta;
      if (!currentDoc?.docId) { await hardResetOpenForm('cleared'); return; }
      const st = await window.formSuitePersist.loadState?.(currentDoc.docId);
      schema = st?.schema || null;
      values = st?.values || {};
      setStatus(`Active DOCX: <span class="kbd">${currentDoc.name}</span>${schema ? '' : ' — <span class="muted">no schema yet</span>'}`);
      renderForm();
      await updateWriteAccessBanner();
    });

    // ---------- Foreground refresh (coalesced) ----------
    let __refreshLock = false;
    let __refreshPending = false;

    async function ensureActiveDocOrReset() {
      if (__refreshLock) { __refreshPending = true; return; }
      __refreshLock = true;
      try {
        currentDoc = readActiveDocSync() || currentDoc;
        if (!currentDoc?.docId) { await hardResetOpenForm('no active doc'); return; }

        const bytes = await fetchWorkingDocBytes();
        if (!bytes) { await hardResetOpenForm('lost access'); return; }

        const st = await window.formSuitePersist.loadState?.(currentDoc.docId);
        schema = st?.schema || null;
        values = st?.values || {};
        setStatus(`Active DOCX: <span class="kbd">${currentDoc.name}</span>${schema ? '' : ' — <span class="muted">no schema yet</span>'}`);
        renderForm();
        await updateWriteAccessBanner();
      } catch (e) {
        console.warn('ensureActiveDocOrReset failed:', e);
      } finally {
        __refreshLock = false;
        if (__refreshPending) { __refreshPending = false; ensureActiveDocOrReset(); }
      }
    }

    document.addEventListener('visibilitychange', async () => {
      if (document.visibilityState !== 'visible') return;
      await ensureActiveDocOrReset();
    });
    window.addEventListener('focus', async () => { await ensureActiveDocOrReset(); });

    // ---------- Permission banner ----------
    async function updateWriteAccessBanner({ tryPrompt = false } = {}) {
      try {
        if (!supportsFS || !currentDoc?.docId) { els.permNote.style.display = 'none'; return 'unsupported'; }
        const h = await window.formSuitePersist.getHandle?.(currentDoc.docId);
        if (!h?.queryPermission) { els.permNote.style.display = 'none'; return 'no-handle'; }

        let p = await h.queryPermission({ mode: 'readwrite' });
        if (p !== 'granted' && tryPrompt) {
          try { p = await h.requestPermission({ mode: 'readwrite' }) || p; } catch {}
        }
        els.permNote.style.display = (p === 'granted') ? 'none' : 'block';
        return p || 'denied';
      } catch (e) {
        console.warn('updateWriteAccessBanner failed:', e);
        els.permNote.style.display = 'block';
        return 'error';
      }
    }
    els.btnRegrant?.addEventListener('click', async () => {
      await updateWriteAccessBanner({ tryPrompt: true });
    });

    // ---------- Pyodide (robust) ----------
    let pyLoaded = false;
    let py = null;

    async function ensurePy(forceReinit = false) {
      if (forceReinit && py && py._module) { pyLoaded = false; py = null; }
      if (!pyLoaded) {
        await new Promise((res, rej) => {
          if (window.loadPyodide) return res();
          const s = document.createElement('script');
          s.src = "https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js";
          s.onload = res; s.onerror = rej; document.head.appendChild(s);
        });
        py = await loadPyodide({ indexURL: "https://cdn.jsdelivr.net/pyodide/v0.24.1/full/" });

        await py.runPythonAsync(`
import io, zipfile, json
import xml.etree.ElementTree as ET

_W_NS = "http://schemas.openxmlformats.org/wordprocessingml/2006/main"
def _q(local): return "{%s}%s" % (_W_NS, local)

# ---------------------- existing functions ----------------------
def write_docvar(u8, var_name, value):
    data = bytes(u8); outbuf = io.BytesIO()
    with zipfile.ZipFile(io.BytesIO(data), "r") as zfin, zipfile.ZipFile(outbuf,"w",compression=zipfile.ZIP_DEFLATED) as zfout:
        try: names = set(zfin.namelist())
        except: names = set()
        if "word/settings.xml" in names:
            try: root = ET.fromstring(zfin.read("word/settings.xml"))
            except ET.ParseError: root = ET.Element(_q("settings"))
        else:
            root = ET.Element(_q("settings"))
        doc_vars = root.find(_q("docVars"))
        if doc_vars is None:
            doc_vars = ET.SubElement(root, _q("docVars"))
        target = None
        for dv in doc_vars.findall(_q("docVar")):
            if dv.get(_q("name")) == var_name:
                target = dv; break
        if target is None:
            target = ET.SubElement(doc_vars, _q("docVar"), {_q("name"): var_name, _q("val"): value})
        else:
            target.set(_q("val"), value)
        settings_bytes = ET.tostring(root, encoding="utf-8", xml_declaration=True)
        for n in zfin.namelist():
            if n == "word/settings.xml": continue
            zfout.writestr(n, zfin.read(n))
        zfout.writestr("word/settings.xml", settings_bytes)
    return outbuf.getvalue()

def _set_sdt_text(content_el, value):
    texts = content_el.findall(".//w:t", {"w": _W_NS})
    if texts:
        first = True
        for t in texts:
            if first:
                t.text = value
                first = False
            else:
                t.text = ""
        return
    has_block = (content_el.find(".//w:p", {"w": _W_NS}) is not None) or (content_el.find(".//w:tbl", {"w": _W_NS}) is not None)
    for ch in list(content_el): content_el.remove(ch)
    if has_block:
        p = ET.SubElement(content_el, _q("p")); r = ET.SubElement(p, _q("r"))
    else:
        r = ET.SubElement(content_el, _q("r"))
    t = ET.SubElement(r, _q("t")); t.text = value
    if (value.strip() != value) or ("\\n" in value) or ("  " in value):
        t.set("{http://www.w3.org/XML/1998/namespace}space", "preserve")

def write_sdts_by_tag(u8, tag_to_text_json):
    try: mapping = json.loads(tag_to_text_json or "{}")
    except Exception: mapping = {}
    if not mapping: return u8
    data = bytes(u8); outbuf = io.BytesIO()
    with zipfile.ZipFile(io.BytesIO(data), "r") as zfin, zipfile.ZipFile(outbuf,"w",compression=zipfile.ZIP_DEFLATED) as zfout:
        names = zfin.namelist()
        def is_target(name):
            if not (name.startswith("word/") and name.endswith(".xml")): return False
            skip = {"word/styles.xml","word/numbering.xml","word/theme/theme1.xml","word/fontTable.xml","word/settings.xml","word/webSettings.xml"}
            return name not in skip and not name.startswith("word/_rels/")
        for n in names:
            if not is_target(n):
                zfout.writestr(n, zfin.read(n)); continue
            try:
                root = ET.fromstring(zfin.read(n))
            except ET.ParseError:
                zfout.writestr(n, zfin.read(n)); continue
            changed = False
            for sdt in root.findall(".//w:sdt", {"w": _W_NS}):
                pr = sdt.find("w:sdtPr", {"w": _W_NS})
                if pr is None: continue
                tag_el = pr.find("w:tag", {"w": _W_NS})
                tag_val = tag_el.get(_q("val")) if tag_el is not None else ""
                if not tag_val or tag_val not in mapping: continue
                content_el = sdt.find("w:sdtContent", {"w": _W_NS}) or sdt
                val = mapping.get(tag_val, "")
                if not isinstance(val, str):
                    try: val = json.dumps(val, ensure_ascii=False)
                    except Exception: val = str(val)
                _set_sdt_text(content_el, val); changed = True
            out_xml = ET.tostring(root, encoding="utf-8", xml_declaration=True) if changed else zfin.read(n)
            zfout.writestr(n, out_xml)
    return outbuf.getvalue()

# ---------------------- NEW: visibility tooling ----------------------
def _ensure_fsHidden_style(zfin, zfout, names):
    if "word/styles.xml" in names:
        try: root = ET.fromstring(zfin.read("word/styles.xml"))
        except ET.ParseError: root = ET.Element(_q("styles"))
    else:
        root = ET.Element(_q("styles"))
    have = False
    for st in root.findall(_q("style")):
        if st.get(_q("type")) == "character" and st.get(_q("styleId")) == "fsHidden":
            have = True; break
    if not have:
        st = ET.Element(_q("style"), {_q("type"): "character", _q("styleId"): "fsHidden"})
        ET.SubElement(st, _q("name"), {_q("val"): "fsHidden"})
        rpr = ET.SubElement(st, _q("rPr"))
        ET.SubElement(rpr, _q("vanish"))
        root.append(st)
    zfout.writestr("word/styles.xml", ET.tostring(root, encoding="utf-8", xml_declaration=True))

def _heading_level(p_el):
    ppr = p_el.find(_q("pPr"))
    if ppr is not None:
        ol = ppr.find(_q("outlineLvl"))
        if ol is not None and ol.get(_q("val")) is not None:
            try: return int(ol.get(_q("val"))) + 1
            except: pass
        ps = ppr.find(_q("pStyle"))
        if ps is not None and ps.get(_q("val")):
            v = ps.get(_q("val")).lower()
            if v.startswith("heading"):
                try: return int(v.replace("heading","").strip())
                except: return None
    return None

def _apply_rStyle_hidden_to_runs(el):
    for r in el.findall(".//w:r", {"w": _W_NS}):
        rpr = r.find(_q("rPr"))
        if rpr is None:
            rpr = ET.SubElement(r, _q("rPr"))
        has = False
        for rs in rpr.findall(_q("rStyle")):
            if rs.get(_q("val")) == "fsHidden":
                has = True; break
        if not has:
            ET.SubElement(rpr, _q("rStyle"), {_q("val"): "fsHidden"})

def apply_visibility(u8, idx_to_action_json):
    """
    idx_to_action_json: {"12":"HIDE","13":"SHOW", ...}
    Semantics:
      - First, remove ALL occurrences of our own rStyle=fsHidden (global reset).
      - Then, apply HIDE to current target ranges.
      - SHOW is accepted but redundant post-reset.
    """
    try: idx_to_action = {int(k): v for (k,v) in json.loads(idx_to_action_json).items()}
    except Exception: idx_to_action = {}
    data = bytes(u8)
    outbuf = io.BytesIO()
    with zipfile.ZipFile(io.BytesIO(data), "r") as zfin, zipfile.ZipFile(outbuf, "w", compression=zipfile.ZIP_DEFLATED) as zfout:
        names = zfin.namelist()

        # Copy everything except styles.xml (we rewrite after ensuring fsHidden)
        for n in names:
            if n == "word/styles.xml": continue
            zfout.writestr(n, zfin.read(n))

        _ensure_fsHidden_style(zfin, zfout, set(names))

        def is_doc_part(n):
            if not (n.startswith("word/") and n.endswith(".xml")): return False
            skip = {"word/styles.xml","word/numbering.xml","word/theme/theme1.xml","word/fontTable.xml","word/settings.xml","word/webSettings.xml"}
            return n not in skip and not n.startswith("word/_rels/")

        # PASS 1: global reset (remove fsHidden rStyle everywhere)
        parts_roots = {}
        for n in names:
            if not is_doc_part(n): continue
            try:
                root = ET.fromstring(zfin.read(n))
            except ET.ParseError:
                parts_roots[n] = None
                continue
            for r in root.findall(".//w:r", {"w": _W_NS}):
                rpr = r.find(_q("rPr"))
                if rpr is None: continue
                for rs in list(rpr.findall(_q("rStyle"))):
                    if rs.get(_q("val")) == "fsHidden":
                        rpr.remove(rs)
            parts_roots[n] = root

        # PASS 2: apply current HIDE ranges
        global_idx = 0
        for n in names:
            if not is_doc_part(n): continue
            root = parts_roots.get(n)
            if root is None: continue

            body = root.find(_q("body"))
            if body is None:
                zfout.writestr(n, ET.tostring(root, encoding="utf-8", xml_declaration=True)); continue

            elems = []
            for ch in list(body):
                if ch.tag == _q("p"):
                    lvl = _heading_level(ch)
                    elems.append((ch, "p", lvl))
                elif ch.tag == _q("tbl"):
                    elems.append((ch, "tbl", None))
                else:
                    elems.append((ch, "other", None))

            heading_positions = []
            for i,(el,t,lvl) in enumerate(elems):
                if t == "p" and lvl is not None:
                    global_idx += 1
                    heading_positions.append((i, lvl, global_idx))

            for h_i, (pos, lvl, idx) in enumerate(heading_positions):
                act = idx_to_action.get(idx)
                if act != "HIDE":
                    continue
                start = pos + 1
                if h_i + 1 < len(heading_positions):
                    end = len(elems)
                    for j in range(h_i+1, len(heading_positions)):
                        np, nl, _ = heading_positions[j]
                        if nl <= lvl:
                            end = np
                            break
                else:
                    end = len(elems)
                for j in range(start, end):
                    el, t, _lvl = elems[j]
                    if t in ("p","tbl"):
                        _apply_rStyle_hidden_to_runs(el)

            zfout.writestr(n, ET.tostring(root, encoding="utf-8", xml_declaration=True))

    return outbuf.getvalue()
        `);

        pyLoaded = true;
      }
    }

    async function writeDocVar(bytes, name, value) {
      await ensurePy();
      const fn = py.globals.get('write_docvar');
      const pyBytes = py.toPy(new Uint8Array(bytes));
      let pyOut;
      try { pyOut = fn(pyBytes, name, value); }
      finally { try{fn.destroy();}catch{} try{pyBytes.destroy();}catch{} }
      let u8;
      if (pyOut?.toJs) u8 = pyOut.toJs({ create_proxies:false });
      else if (pyOut?.getBuffer) u8 = new Uint8Array(pyOut.getBuffer());
      else u8 = new Uint8Array([]);
      try { pyOut.destroy?.(); } catch {}
      return u8;
    }

    async function writeSDTs(arrayBufferOrBytes, tagToTextObj) {
      await ensurePy();
      const u8in = arrayBufferOrBytes instanceof Uint8Array ? arrayBufferOrBytes : new Uint8Array(arrayBufferOrBytes);
      const fn = py.globals.get('write_sdts_by_tag');
      const pyBytes = py.toPy(u8in);
      const pyMap   = py.toPy(JSON.stringify(tagToTextObj || {}));
      let pyOut;
      try { pyOut = fn(pyBytes, pyMap); }
      finally { try{fn.destroy();}catch{} try{pyBytes.destroy();}catch{} try{pyMap.destroy();}catch{} }
      let u8;
      if (pyOut?.toJs) u8 = pyOut.toJs({ create_proxies:false });
      else if (pyOut?.getBuffer) u8 = new Uint8Array(pyOut.getBuffer());
      else u8 = new Uint8Array([]);
      try { pyOut.destroy?.(); } catch {}
      return u8;
    }

    // ---------- Helpers: sanitize ----------
    function sanitizeValues(schema, vals) {
      const out = {};
      const fields = Array.isArray(schema?.fields) ? schema.fields : [];

      for (const f of fields) {
        const id = f.id;
        let v = vals?.[id];

        if (f.type === 'datediff') {
          const d = vals?.[id];
          if (d && typeof d === 'object') {
            const outObj = {
              days: Number(d.days ?? 0),
              months: Number(d.months ?? 0),
              years: Number(d.years ?? 0),
              formatted: String(d.formatted ?? '')
            };
            if (outObj.formatted) out[id] = outObj;
          } else if (Number.isFinite(Number(d))) {
            const n = Number(d);
            out[id] = { days: n, months: 0, years: 0, formatted: `${n}-0-0 (${n})` };
          }
          // continue loop
          continue;
        }

        // ADDRESS
        if (f.type === 'address') {
          const vv = vals?.[id];
          if (typeof vv === 'string') {
            const s = vv.trim();
            if (s || f.required) out[id] = s ? { formatted: s } : { formatted: '' };
          } else if (vv && typeof vv === 'object') {
            const o = {
              formatted: vv.formatted || '',
              street: vv.street || '',
              houseNumber: vv.houseNumber || '',
              postcode: vv.postcode || '',
              city: vv.city || '',
              country: vv.country || '',
              lat: (vv.lat ?? null),
              lon: (vv.lon ?? null)
            };
            if (o.formatted || f.required) out[id] = o;
          }
          continue;
        }

        // MULTICHOICE (now: options + conditional fields)
        if (f.type === 'multichoice') {
          // 1) the main value remains an array of selected option values
          let arr = Array.isArray(v) ? v.slice() : (typeof v === 'string' ? v.split(',') : []);
          arr = arr.map(x => String(x).trim()).filter(Boolean);

          // If classic f.options is present, filter against it; if grouped (f.mc) exists, allow any of those
          let allowed = null;
          if (Array.isArray(f.options) && f.options.length) {
            allowed = new Set(f.options.map(String));
          } else if (f.mc && Array.isArray(f.mc.groups)) {
            allowed = new Set(
              f.mc.groups.flatMap(g => (g.items || []).map(it => String(it.value || '')))
            );
          }
          if (allowed) arr = arr.filter(x => allowed.has(String(x)));
          if (arr.length) out[id] = arr;
          else if (f.required) out[id] = [];

          // 2) Conditional extras: persist under synthesized ids
          if (f.mc && Array.isArray(f.mc.groups)) {
            for (const g of f.mc.groups) {
              for (const it of (g.items || [])) {
                const optVal = String(it?.value || '');
                const extras = Array.isArray(it?.fields) ? it.fields : [];
                for (const ex of extras) {
                  const exType = (ex?.type === 'date' || ex?.type === 'number' || ex?.type === 'text') ? ex.type : 'text';
                  const exId   = String(ex?.id || '');
                  if (!exId) continue;
                  const k = mcExtraKey(f.id, optVal, exId);
                  const raw = vals?.[k];

                  if (exType === 'date') {
                    const s = String(raw ?? '');
                    if (s) out[k] = s; // ISO string (we already keep it as text)
                  } else if (exType === 'number') {
                    if (raw === '' || raw == null) continue;
                    const num = (typeof raw === 'number') ? raw : Number(String(raw).replace(',', '.'));
                    if (Number.isFinite(num)) out[k] = num;
                  } else { // text
                    const s = String(raw ?? '');
                    if (s) out[k] = s;
                  }
                }
              }
            }
          }
          continue;
        }

        // SELECT
        if (f.type === 'select') {
          let s = Array.isArray(v) ? String(v[0] ?? '') : String(v ?? '');
          if (Array.isArray(f.options) && f.options.length) {
            const allowed = new Set(f.options.map(String));
            if (!allowed.has(s)) s = '';
          }
          if (s === '') { if (f.required) out[id] = s; }
          else out[id] = s;
          continue;
        }

        // NUMBER
        if (f.type === 'number') {
          if (v === '' || v == null) continue;
          const num = (typeof v === 'number') ? v : Number(String(v).replace(',', '.'));
          if (Number.isFinite(num)) out[id] = num;
          continue;
        }

        // DATE
        if (f.type === 'date') { out[id] = String(v ?? ''); continue; }

        // TABLE
        if (f.type === 'table') {
          const cols = Array.isArray(f.columns) ? f.columns : [];
          const colIds = cols.map(c => c.id);
          const arr = Array.isArray(v) ? v : [];
          const cleaned = arr.map(row => {
            const o = {};
            for (const cid of colIds) {
              let cell = row?.[cid];
              if (cell == null) cell = '';
              o[cid] = (typeof cell === 'string') ? cell : String(cell);
            }
            return o;
          }).filter(r => Object.values(r).some(val => String(val).trim() !== ''));
          const min = Math.max(0, parseInt(f.minRows || 0, 10));
          while (cleaned.length < min) {
            const empty = {}; colIds.forEach(cid => empty[cid] = ''); cleaned.push(empty);
          }
          if (cleaned.length) out[id] = cleaned;
          else if (f.required) out[id] = [];
          continue;
        }

        // TEXT-ish default
        const s = String(v ?? '');
        if (s || f.required) out[id] = s;
      }

      return out;
    }

    function sanitizeTagMap(tagMap, validIds) {
      const out = {};
      for (const [tag, fid] of Object.entries(tagMap || {})) {
        if (validIds.has(fid)) out[tag] = fid;
      }
      return out;
    }

    // ---------- Init ----------
    init().catch(console.error);

    async function init() {
      currentDoc = readActiveDocSync();

      if (currentDoc?.docId) {
        const bytes = await fetchWorkingDocBytes();
        if (!bytes) { await hardResetOpenForm('no bytes / no permission'); return; }

        const st = await window.formSuitePersist.loadState?.(currentDoc.docId);
        schema = st?.schema || null;
        values = st?.values || {};
        setStatus(`Active DOCX: <span class="kbd">${currentDoc.name}</span>${schema ? '' : ' — <span class="muted">no schema yet</span>'}`);
        await updateWriteAccessBanner();
      } else {
        schema = loadLS();
        values = {};
      }

      renderForm();
    }

    // ---------- Robust bytes fetcher ----------
    async function fetchWorkingDocBytes() {
      try { const b = await window.formSuitePersist.getCurrentDocBytes?.(); if (b && b.byteLength) return b; } catch {}
      try { if (currentDoc?.docId) { const b2 = await window.formSuitePersist.getBytes?.(currentDoc.docId); if (b2 && b2.byteLength) return b2; } } catch {}
      try {
        const h = await window.formSuitePersist.getHandle?.(currentDoc?.docId);
        if (h?.getFile) {
          let p = await window.formSuitePersist.ensurePermission?.(h, 'readwrite');
          if (p !== 'granted') p = await window.formSuitePersist.ensurePermission?.(h, 'read');
          if (p === 'granted') { const f = await h.getFile(); return await f.arrayBuffer(); }
        }
      } catch {}
      try { await window.formSuitePersist.regrantAll?.(); const b3 = await window.formSuitePersist.getCurrentDocBytes?.(); if (b3 && b3.byteLength) return b3; } catch {}
      return null;
    }

    // ---- DATEDIFF helpers ----
    function parseDateByFormat(str, fmt) {
      if (!str) return null;
      try {
        // use flatpickr's own parser so we honor custom formats
        const d = (window.flatpickr && window.flatpickr.parseDate)
          ? window.flatpickr.parseDate(String(str), fmt || 'Y-m-d')
          : new Date(String(str));
        return (d && !isNaN(d.getTime())) ? d : null;
      } catch { return null; }
    }

    function diffInDays(a, b) {
      // normalize to midnight to avoid TZ drift
      const A = new Date(a.getFullYear(), a.getMonth(), a.getDate());
      const B = new Date(b.getFullYear(), b.getMonth(), b.getDate());
      const ms = B - A; // to - from
      return Math.floor(ms / (24*60*60*1000));
    }
    function diffInMonths(a, b) {
      // calendar months between a -> b (subtract 1 if day-of-month hasn't been reached)
      let months = (b.getFullYear() - a.getFullYear()) * 12 + (b.getMonth() - a.getMonth());
      if (b.getDate() < a.getDate()) months -= 1;
      return months;
    }
    function diffInYears(a, b) {
      // full calendar years between a -> b
      let years = b.getFullYear() - a.getFullYear();
      const bBeforeAnniversary = (b.getMonth() < a.getMonth()) || (b.getMonth() === a.getMonth() && b.getDate() < a.getDate());
      if (bBeforeAnniversary) years -= 1;
      return years;
    }

    // returns number or null
    function computeDateDiff(fromDate, toDate, unit = 'days') {
      if (!fromDate || !toDate) return null;
      const u = String(unit || 'days').toLowerCase();
      if (u === 'years')  return diffInYears(fromDate, toDate);
      if (u === 'months') return diffInMonths(fromDate, toDate);
      return diffInDays(fromDate, toDate); // default days
    }

    // Modern, pretty flatpickr with sensible defaults for our app.
    // - Non-editable (click-to-pick), ISO storage via value, nice alt display.
    // - Month dropdown, week numbers, nicer arrows, better mobile behavior.
    // - Will add a CSS class on the first allowed day so it pops visually.
    function createPrettyDatepicker(input, extraOpts = {}) {
      const baseOpts = {
        dateFormat: 'Y-m-d',        // stored value
        altInput: true,
        altFormat: 'D, j M Y',      // human display
        allowInput: false,          // click-only
        disableMobile: true,        // consistent look everywhere
        static: true,               // keep the calendar anchored by input
        monthSelectorType: 'dropdown',
        weekNumbers: true,
        prevArrow: '‹',
        nextArrow: '›',
        onReady: (sel, str, inst) => {
          if (inst.altInput) {
            inst.altInput.readOnly = true;
            // wrap altInput to attach icon styling
            const wrap = inst.altInput.parentElement;
            if (wrap && !wrap.classList.contains('flatpickr-has-icon')) {
              wrap.classList.add('flatpickr-has-icon');
            }
          }
        },
        // Highlight the first available day (e.g., minDate) for quick visual guidance
        onDayCreate: (dObj, dStr, fp, dayElem) => {
          const min = fp.config.minDate ? fp.parseDate(fp.config.minDate, 'Y-m-d') : null;
          if (!min) return;
          // If the rendered day equals minDate, decorate it
          const thisDate = dayElem.dateObj;
          if (min && thisDate && thisDate.toDateString() === min.toDateString()) {
            dayElem.classList.add('is-first-allowed');
          }
        }
      };
      return flatpickr(input, { ...baseOpts, ...extraOpts });
    }


    // --- MC helpers: stable key for a conditional sub-field of a multichoice option
    function slugifyMc(s) {
      return String(s || '')
        .normalize('NFKD')
        .replace(/[\u0300-\u036f]/g, '')
        .replace(/[^a-zA-Z0-9]+/g, '_')
        .replace(/^_+|_+$/g, '')
        .toLowerCase();
    }
    function mcExtraKey(fieldId, optionValue, extraId) {
      return `${fieldId}__${slugifyMc(optionValue)}__${slugifyMc(extraId)}`;
    }

    // ---------- Render whole form ----------

    function renderForm() {
      // local fallbacks in case helpers weren't injected elsewhere
      const __slugifyMc = (window.slugifyMc) ? window.slugifyMc : function (s) {
        return String(s || '')
          .normalize('NFKD')
          .replace(/[\u0300-\u036f]/g, '')
          .replace(/[^a-zA-Z0-9]+/g, '_')
          .replace(/^_+|_+$/g, '')
          .toLowerCase();
      };
      const __mcExtraKey = (window.mcExtraKey) ? window.mcExtraKey : function (fieldId, optionValue, extraId) {
        return `${fieldId}__${__slugifyMc(optionValue)}__${__slugifyMc(extraId)}`;
      };

      const mount = els.formMount;
      mount.innerHTML = '';
      if (!schema || !Array.isArray(schema.fields) || !schema.fields.length) {
        mount.innerHTML = `<div class="muted">No schema found. Create one in the <a href="builder.html">Builder</a>.</div>`;
        if (btnExportMain) btnExportMain.disabled = true;
        return;
      }

      // ---------- hydrate defaults for tables ----------
      (schema.fields || []).forEach(f => {
        if (f.type === 'table') {
          if (!Array.isArray(values[f.id])) {
            const min = Math.max(0, parseInt(f.minRows || 0, 10));
            values[f.id] = Array.from({ length: min }, () => emptyRow(f));
          } else {
            values[f.id] = values[f.id].map(r => ({ ...emptyRow(f), ...(r || {}) }));
          }
        }
      });

      // ---------- build form container (responsive grid) ----------
      const form = document.createElement('form');
      form.classList.add('form-grid');

      if (schema.title) {
        const h = document.createElement('h4');
        h.textContent = schema.title;
        h.style.gridColumn = '1 / -1';
        form.appendChild(h);
      }

      // refs used by datediff + guards
      const inputRefs = {};     // id -> input element (date/text/select)
      const datediffRefs = [];  // { field, outEl, fromId, toId }

      // ---------- render each field ----------
      (schema.fields || []).forEach(f => {
        const wrap = document.createElement('div');
        wrap.className = 'field';

        // width hints per type
        if (f.type === 'address' || f.type === 'datediff') wrap.classList.add('span-2');
        if (f.type === 'table') wrap.classList.add('full', 'field--table');
        if (f.type === 'multichoice') wrap.classList.add('full', 'field--multichoice');
        if (f.wide === true) wrap.classList.add('span-2');
        if (f.full === true) wrap.classList.add('full');

        // Label (address widget renders its own)
        if (f.type !== 'address') {
          const label = document.createElement('label');
          label.htmlFor = f.id;
          label.textContent = f.label || f.id;
          if (f.required) {
            const star = document.createElement('span');
            star.textContent = ' *';
            star.style.color = '#ef4444';
            label.appendChild(star);
          }
          wrap.appendChild(label);
        }

        // ---- TEXT ----
        if (f.type === 'text') {
          const input = document.createElement('input');
          input.type = 'text';
          input.id = f.id; input.name = f.id; input.style.width = '100%';
          if (f.required) input.required = true;
          if (values[f.id] != null) input.value = values[f.id];
          input.addEventListener('change', () => { values[f.id] = input.value; scheduleSaveState(); });
          wrap.appendChild(input);
          inputRefs[f.id] = input;

        // ---- NUMBER ----
        } else if (f.type === 'number') {
          const input = document.createElement('input');
          input.type = 'number';
          input.id = f.id; input.name = f.id; input.style.width = '100%';
          if (f.required) input.required = true;
          if (values[f.id] != null) input.value = values[f.id];
          input.addEventListener('change', () => { values[f.id] = Number(input.value); scheduleSaveState(); });
          wrap.appendChild(input);
          inputRefs[f.id] = input;

        // ---- SELECT ----
        } else if (f.type === 'select') {
          const input = document.createElement('select');
          input.id = f.id; input.name = f.id; input.style.width = '100%';
          (f.options || []).forEach(v => {
            const o = document.createElement('option');
            o.value = String(v); o.textContent = String(v);
            input.appendChild(o);
          });
          if (f.required) input.required = true;
          if (values[f.id] != null) input.value = values[f.id];
          input.addEventListener('change', () => { values[f.id] = input.value; scheduleSaveState(); });
          wrap.appendChild(input);
          inputRefs[f.id] = input;

        // ---- MULTICHOICE (groups + conditional fields + preselect/locked) ----
        } else if (f.type === 'multichoice') {
          const host = document.createElement('div');
          host.className = 'mc-group';
          host.style.display = 'grid';
          host.style.gridTemplateColumns = 'repeat(auto-fill,minmax(260px,1fr))';
          host.style.gap = '8px 16px';
          if (Number.isFinite(+f.columns) && +f.columns > 0) {
            host.style.gridTemplateColumns = `repeat(${+f.columns}, minmax(220px, 1fr))`;
          }

          // normalize items from schema
          const items = [];
          if (f.mc && Array.isArray(f.mc.groups) && f.mc.groups.length) {
            f.mc.groups.forEach(g => (g.items || []).forEach(it =>
              items.push({
                value: String(it.value ?? it.label ?? ''),
                alwaysSelected: !!it.alwaysSelected,
                preselected: !!it.preselected,
                fields: Array.isArray(it.fields) ? it.fields : []
              })
            ));
          } else if (Array.isArray(f.options)) {
            f.options.forEach(v => {
              if (v && typeof v === 'object') {
                items.push({
                  value: String(v.value ?? v.label ?? ''),
                  alwaysSelected: !!v.alwaysSelected,
                  preselected: !!v.preselected,
                  fields: Array.isArray(v.fields) ? v.fields : []
                });
              } else {
                items.push({ value: String(v), alwaysSelected: false, preselected: false, fields: [] });
              }
            });
          }

          // 1) PRESELECT on first load (only when there's no saved selection yet)
          if (!Array.isArray(values[f.id])) {
            const initial = items
              .filter(it => it.alwaysSelected || it.preselected)
              .map(it => it.value);
            if (initial.length) values[f.id] = initial.slice();
          }

          const selected = new Set(Array.isArray(values[f.id]) ? values[f.id].map(String) : []);

          function persistMainSelection() {
            const boxes = host.querySelectorAll(`input[type="checkbox"][data-mc="1"]`);
            values[f.id] = Array.from(boxes)
              .filter(b => b.checked)
              .map(b => b.value);
            scheduleSaveState();
          }

          function drawOption(item) {
            const optVal = item.value;
            const optId  = `${f.id}__${__slugifyMc(optVal)}`;
            const hasExtras = Array.isArray(item.fields) && item.fields.length > 0;

            // wrapper card
            const card = document.createElement('div');
            card.className = 'mc-item';
            card.style.display = 'block';
            card.style.background = 'var(--card)';
            card.style.border = '1px solid var(--border-strong)';
            card.style.borderRadius = '8px';
            card.style.padding = '10px 10px';

            // line 1: checkbox + label
            const row1 = document.createElement('div');
            row1.className = 'row';
            row1.style.alignItems = 'center';
            row1.style.justifyContent = 'space-between';
            row1.style.gap = '10px';

            const left = document.createElement('label');
            left.className = 'row';
            left.style.alignItems = 'center';
            left.style.gap = '8px';
            left.style.cursor = 'pointer';
            left.setAttribute('for', optId);

            const cb = document.createElement('input');
            cb.type = 'checkbox';
            cb.dataset.mc = '1';
            cb.name = f.id;
            cb.id = optId;
            cb.value = optVal;

            // 2) IMMER AUSGEWÄHLT (locked) + preselect logic
            const locked = !!item.alwaysSelected;
            const isPreselected = !!item.preselected;
            cb.checked = locked || selected.has(optVal) || (!selected.size && isPreselected);
            if (locked) cb.disabled = true;

            const txt = document.createElement('span');
            txt.textContent = optVal;

            left.appendChild(cb);
            left.appendChild(txt);
            row1.appendChild(left);

            // line 2: conditional fields (only render if option defines extras)
            let extrasWrap = null;
            if (hasExtras) {
              extrasWrap = document.createElement('div');
              // 4) no gap if no extras or when hidden
              extrasWrap.style.marginTop = '0';
              extrasWrap.style.display = (cb.checked || locked) ? '' : 'none';

              function mountExtraFields() {
                extrasWrap.innerHTML = '';
                if (!item.fields.length) return;

                // only add vertical spacing when we actually place extras
                extrasWrap.style.marginTop = (cb.checked || locked) ? '8px' : '0';

                item.fields.forEach(ex => {
                  const exType = (ex?.type === 'date' || ex?.type === 'number' || ex?.type === 'text') ? ex.type : 'text';
                  const exId   = String(ex?.id || '');
                  if (!exId) return;
                  const exKey  = __mcExtraKey(f.id, optVal, exId);

                  const line = document.createElement('div');
                  line.className = 'row';
                  line.style.gap = '8px';
                  line.style.alignItems = 'center';

                  const lab = document.createElement('label');
                  lab.textContent = String(ex?.label || exId);
                  lab.style.minWidth = '120px';
                  lab.style.color = 'var(--muted)';

                  if (exType === 'date') {
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.dataset.type = 'date';
                    input.style.minWidth = '180px';

                    extrasWrap.appendChild(line);
                    line.appendChild(lab);
                    line.appendChild(input);

                    const fp = createPrettyDatepicker(input, {
                      dateFormat: 'Y-m-d',
                      altInput: true,
                      altFormat: 'D, j M Y',
                      defaultDate: values[exKey] || null,
                      onChange: () => { values[exKey] = input.value; scheduleSaveState(); },
                      onValueUpdate: () => { values[exKey] = input.value; scheduleSaveState(); }
                    });
                    fp.set('allowInput', false);
                    if (fp.altInput) fp.altInput.readOnly = true;
                    return;
                  }

                  const input = document.createElement('input');
                  if (exType === 'number') {
                    input.type = 'number';
                    input.value = values[exKey] ?? '';
                    input.addEventListener('change', () => {
                      values[exKey] = Number(input.value);
                      scheduleSaveState();
                    });
                  } else {
                    input.type = 'text';
                    input.value = values[exKey] ?? '';
                    input.addEventListener('change', () => {
                      values[exKey] = input.value;
                      scheduleSaveState();
                    });
                  }

                  extrasWrap.appendChild(line);
                  line.appendChild(lab);
                  line.appendChild(input);
                });
              }

              mountExtraFields();

              // 3) toggle extras visibility with selection
              cb.addEventListener('change', () => {
                if (locked) { cb.checked = true; return; }
                persistMainSelection();
                const show = cb.checked || locked;
                extrasWrap.style.display = show ? '' : 'none';
                extrasWrap.style.marginTop = (show && item.fields.length) ? '8px' : '0';
              });
            } else {
              // no extras: still persist selection changes; ensure no gap
              cb.addEventListener('change', () => {
                if (locked) { cb.checked = true; return; }
                persistMainSelection();
              });
            }

            card.appendChild(row1);
            if (extrasWrap) card.appendChild(extrasWrap);
            host.appendChild(card);
          }

          items.forEach(drawOption);
          // keep persisted array updated after initial draw (covers preselect defaults)
          values[f.id] = Array.from(host.querySelectorAll(`input[type="checkbox"][data-mc="1"]`))
            .filter(b => b.checked)
            .map(b => b.value);
          scheduleSaveState();

          wrap.appendChild(host);

        // ---- DATE ----
        } else if (f.type === 'date') {
          const input = document.createElement('input');
          input.type = 'text';
          input.dataset.type = 'date';
          input.id = f.id; input.name = f.id; input.style.width = '100%';
          if (f.required) input.required = true;
          wrap.appendChild(input);

          const fp = createPrettyDatepicker(input, {
            dateFormat: 'Y-m-d',
            altInput: true,
            altFormat: 'D-d-M-Y',
            allowInput: false,
            clickOpens: true,
            defaultDate: values[f.id] || null,
            onReady: (_sel, _str, inst) => { if (inst.altInput) inst.altInput.readOnly = true; },
            onChange: () => { values[f.id] = input.value; scheduleSaveState(); if (window.recomputeDatediffs) window.recomputeDatediffs(); },
            onValueUpdate: () => { values[f.id] = input.value; scheduleSaveState(); if (window.recomputeDatediffs) window.recomputeDatediffs(); }
          });
          fp.set('allowInput', false);
          if (fp.altInput) fp.altInput.readOnly = true;
          inputRefs[f.id] = input;

        // ---- ADDRESS ----
        } else if (f.type === 'address') {
          const host = document.createElement('div');
          host.className = 'addr-host';
          wrap.appendChild(host);

          const initial =
            typeof values[f.id] === 'string'
              ? { formatted: values[f.id] }
              : (values[f.id] || null);

          AddressAuto.mount(host, {
            id: f.id,
            label: f.label || 'Address',
            required: !!f.required,
            value: initial || null,
            onChange: (val) => { values[f.id] = val; scheduleSaveState(); }
          });

        // ---- TABLE ----
        } else if (f.type === 'table') {
          renderTableField(wrap, f);

        // ---- DATEDIFF ----
        } else if (f.type === 'datediff') {
          const fromId = f.fromId || f.from || '';
          const toId   = f.toId   || f.to   || '';

          const out = document.createElement('div');
          out.id = f.id;
          out.className = 'datediff-out';
          out.setAttribute('role', 'status');
          out.setAttribute('aria-live', 'polite');
          out.textContent = '—';
          wrap.appendChild(out);

          datediffRefs.push({ field: f, outEl: out, fromId, toId });

        // ---- DEFAULT ----
        } else {
          const input = document.createElement('input');
          input.type = 'text';
          input.id = f.id; input.name = f.id; input.style.width = '100%';
          if (values[f.id] != null) input.value = values[f.id];
          input.addEventListener('change', () => { values[f.id] = input.value; scheduleSaveState(); });
          wrap.appendChild(input);
          inputRefs[f.id] = input;
        }

        form.appendChild(wrap);
      });

      // ---------- bottom bar ----------
      const bar = document.createElement('div');
      bar.className = 'bar';
      bar.style.gridColumn = '1 / -1';
      btnExportMain = document.createElement('button');
      btnExportMain.type = 'button';
      btnExportMain.className = 'secondary';
      btnExportMain.textContent = 'Export…';
      btnExportMain.disabled = !currentDoc;
      btnExportMain.addEventListener('click', onExportFromOpenForm);
      bar.appendChild(btnExportMain);
      form.appendChild(bar);

      mount.appendChild(form);

      // ---------- datediff helpers ----------
      function getDateForField(fid) {
        const el = inputRefs[fid];
        if (!el) return null;
        const fp = el?._flatpickr;
        if (fp?.selectedDates?.[0] instanceof Date) return fp.selectedDates[0];
        const iso = values[fid];
        if (iso) {
          const d = (window.flatpickr && window.flatpickr.parseDate)
            ? window.flatpickr.parseDate(String(iso), 'Y-m-d')
            : new Date(String(iso));
          return (d && !isNaN(d)) ? d : null;
        }
        return null;
      }

      function recomputeDatediffs() {
        datediffRefs.forEach(({ field, outEl, fromId, toId }) => {
          const a = getDateForField(fromId);
          const b = getDateForField(toId);
          if (!a || !b) {
            outEl.textContent = '—';
            values[field.id] = null;
            return;
          }
          const days   = diffInDays(a, b);
          const months = diffInMonths(a, b);
          const years  = diffInYears(a, b);
          const display = `${days} Days · ${months} Months · ${years} Years (${days} total)`;
          outEl.textContent = display;
          values[field.id] = { days, months, years, formatted: display };
        });
        scheduleSaveState();
      }
      window.recomputeDatediffs = recomputeDatediffs;

      // ---------- date guards (FROM precedence; TO strictly after FROM) ----------
      (function wireDateGuards() {
        function nextDay(d) {
          if (!d) return null;
          const n = new Date(d.getFullYear(), d.getMonth(), d.getDate());
          n.setDate(n.getDate() + 1);
          return n;
        }

        datediffRefs.forEach(({ fromId, toId }) => {
          const fromEl = inputRefs[fromId];
          const toEl   = inputRefs[toId];
          const fpFrom = fromEl?._flatpickr;
          const fpTo   = toEl?._flatpickr;
          if (!fpFrom || !fpTo) return;

          fpFrom.set('allowInput', false);
          fpTo.set('allowInput', false);
          if (fpFrom.altInput) fpFrom.altInput.readOnly = true;
          if (fpTo.altInput)   fpTo.altInput.readOnly   = true;

          const syncToWithFrom = (opts = { snap: true, jump: true }) => {
            const from = fpFrom.selectedDates?.[0] || null;
            const minForTo = nextDay(from);
            fpTo.set('minDate', minForTo || null);

            const toSel = fpTo.selectedDates?.[0] || null;
            if (!toSel && minForTo && opts.snap) fpTo.setDate(minForTo, true);
            if (from && toSel && toSel <= from && opts.snap) fpTo.setDate(minForTo, true);
            if (minForTo && opts.jump) { try { fpTo.jumpToDate(minForTo); } catch {} }

            if (typeof window.recomputeDatediffs === 'function') window.recomputeDatediffs();
          };

          // initial + hooks
          syncToWithFrom({ snap: true, jump: false });
          fpFrom.config.onChange.push(() => syncToWithFrom({ snap: true, jump: true }));
          fpFrom.config.onValueUpdate.push(() => syncToWithFrom({ snap: true, jump: true }));
          fpTo.config.onOpen.push(() => syncToWithFrom({ snap: false, jump: true }));

          const recompute = () => { if (window.recomputeDatediffs) window.recomputeDatediffs(); };
          fpTo.config.onChange.push(recompute);
          fpTo.config.onValueUpdate.push(recompute);
        });
      })();

      // initial compute
      recomputeDatediffs();
    }


    // ----- TABLE FIELD -----
    function renderTableField(container, field) {
      if (!Array.isArray(values[field.id])) values[field.id] = [];
      const data = values[field.id];

      // --- Inline editor (no special card/container) ---
      const editorWrap = document.createElement('div');
      editorWrap.style.display = 'flex';
      editorWrap.style.flexWrap = 'wrap';
      editorWrap.style.gap = '10px';

      const editorInputs = {};
      let editorState = emptyRow(field);

      // helpers for sizing
      const measurer = document.createElement('canvas').getContext('2d');
      function textPx(str) {
        try { measurer.font = getComputedStyle(document.body).font; } catch {}
        return Math.ceil(measurer.measureText(String(str || '')).width);
      }
      function longest(arr) {
        return arr.reduce((a, b) => (String(b).length > String(a).length ? String(b) : String(a)), '');
      }

      (field.columns || []).forEach(col => {
        const pair = document.createElement('label');
        pair.style.display = 'flex';
        pair.style.alignItems = 'center';
        pair.style.gap = '8px';

        const lbl = document.createElement('span');
        lbl.textContent = col.label || col.id;

        let el;
        if (col.type === 'select') {
          el = document.createElement('select');
          const opts = (col.options || []);
          const empty = document.createElement('option'); empty.value = ''; empty.textContent = '— wählen —';
          el.appendChild(empty);
          opts.forEach(opt => {
            const o = document.createElement('option');
            o.value = String(opt); o.textContent = String(opt);
            el.appendChild(o);
          });
          el.style.minWidth = Math.max(140, Math.min(360, textPx(longest(opts)) + 56)) + 'px';
          el.addEventListener('change', () => { editorState[col.id] = el.value; });
        } else if (col.type === 'date') {
          el = document.createElement('input');
          el.type = 'text';
          el.style.minWidth = Math.max(140, Math.min(360, textPx('YYYY-MM-DD') + 20)) + 'px';
          setTimeout(() => {
            flatpickr(el, { allowInput: true, dateFormat: 'Y-m-d', onChange: () => { editorState[col.id] = el.value; } });
          }, 0);
          el.addEventListener('change', () => { editorState[col.id] = el.value; });
        } else if (col.type === 'number') {
          el = document.createElement('input');
          el.type = 'number';
          el.style.minWidth = Math.max(120, Math.min(360, textPx('000000') + 20)) + 'px';
          el.addEventListener('change', () => { editorState[col.id] = el.value; });
        } else {
          el = document.createElement('input');
          el.type = 'text';
          el.style.minWidth = Math.max(160, Math.min(360, textPx(lbl.textContent) + 20)) + 'px';
          el.addEventListener('change', () => { editorState[col.id] = el.value; });
        }

        editorInputs[col.id] = el;
        pair.appendChild(lbl);
        pair.appendChild(el);
        editorWrap.appendChild(pair);
      });

      // --- Toolbar ---
      const toolbar = document.createElement('div');
      toolbar.className = 'row';
      toolbar.style.gap = '8px';

      const btnAdd = document.createElement('button');
      btnAdd.type = 'button';
      btnAdd.textContent = 'Zeile hinzufügen';

      const btnSave = document.createElement('button');
      btnSave.type = 'button';
      btnSave.className = 'secondary';
      btnSave.textContent = 'Änderungen speichern';

      const btnDelete = document.createElement('button');
      btnDelete.type = 'button';
      btnDelete.className = 'ghost';
      btnDelete.textContent = 'Zeile löschen';

      const btnCancel = document.createElement('button');
      btnCancel.type = 'button';
      btnCancel.className = 'ghost';
      btnCancel.textContent = 'Abbrechen';

      toolbar.appendChild(btnAdd);
      toolbar.appendChild(btnSave);
      toolbar.appendChild(btnDelete);
      toolbar.appendChild(btnCancel);

      const status = document.createElement('div');
      status.className = 'muted';
      status.style.minHeight = '1.2em';

      // --- Table preview ---
      const tableWrap = document.createElement('div');
      tableWrap.style.overflow = 'auto';
      const table = document.createElement('table');
      table.style.width = '100%';
      const thead = document.createElement('thead');
      const trh = document.createElement('tr');
      thead.appendChild(trh);
      const tbody = document.createElement('tbody');
      table.appendChild(thead);
      table.appendChild(tbody);
      tableWrap.appendChild(table);

      (field.columns || []).forEach(col => {
        const th = document.createElement('th');
        th.textContent = col.label || col.id;
        trh.appendChild(th);
      });

      let selectedIndex = -1;

      function drawTable() {
        tbody.innerHTML = '';
        data.forEach((row, idx) => {
          const tr = document.createElement('tr');
          const isSel = idx === selectedIndex;

          // persistent "selected" styling (stronger than hover)
          if (isSel) {
            tr.style.background = '#DBEAFE';           // strong light blue
            tr.style.outline = '2px solid #93C5FD';    // visible border
            tr.style.outlineOffset = '-2px';
          } else {
            tr.style.background = '';
            tr.style.outline = '';
            tr.style.outlineOffset = '';
          }

          tr.addEventListener('click', () => {
            selectedIndex = idx;        // do NOT toggle off on second click
            drawTable();
            loadIntoEditor(idx);
          });

          (field.columns || []).forEach(col => {
            const td = document.createElement('td');
            td.textContent = row[col.id] || '';
            tr.appendChild(td);
          });
          tbody.appendChild(tr);
        });
        updateToolbar();
      }

      function clearSelection() { selectedIndex = -1; updateToolbar(); }
      function updateToolbar() {
        const min = Math.max(0, parseInt(field.minRows || 0, 10));
        const max = Math.max(0, parseInt(field.maxRows || 0, 10));

        // Add is always visible
        btnAdd.disabled = (max && data.length >= max);

        // Only show these when a row is selected
        const showEdit = selectedIndex >= 0;
        btnSave.style.display   = showEdit ? '' : 'none';
        btnDelete.style.display = showEdit ? '' : 'none';
        btnCancel.style.display = showEdit ? '' : 'none';

        btnSave.disabled   = !showEdit;
        btnDelete.disabled = !showEdit || (min && data.length <= min);
        btnCancel.disabled = !showEdit;
      }

      function loadIntoEditor(i) {
        const rec = data[i] || emptyRow(field);
        for (const c of (field.columns || [])) {
          const el = editorInputs[c.id];
          if (!el) continue;
          el.value = rec[c.id] || '';
        }
        editorState = { ...rec };
        updateToolbar();
      }

      function resetEditor() {
        editorState = emptyRow(field);
        for (const c of (field.columns || [])) {
          const el = editorInputs[c.id];
          if (!el) continue;
          el.value = '';
        }
      }

      // initial rows (respect minRows) + first draw
      if (!data.length) {
        const min = Math.max(0, parseInt(field.minRows || 0, 10));
        for (let i = 0; i < min; i++) data.push(emptyRow(field));
      }
      drawTable(); // no auto-selection by default

      // actions
      btnAdd.addEventListener('click', () => {
        const max = Math.max(0, parseInt(field.maxRows || 0, 10));
        if (max && data.length >= max) return;
        // Always create a NEW row with current editor content
        data.push({ ...editorState });
        drawTable();
        scheduleSaveState();
        status.textContent = 'Zeile hinzugefügt.';
      });

      btnSave.addEventListener('click', () => {
        if (selectedIndex < 0 || selectedIndex >= data.length) return;
        data[selectedIndex] = { ...editorState };
        drawTable();
        scheduleSaveState();
        status.textContent = 'Änderungen gespeichert.';
      });

      btnDelete.addEventListener('click', () => {
        const min = Math.max(0, parseInt(field.minRows || 0, 10));
        if (selectedIndex < 0) return;
        if (min && data.length <= min) return;
        data.splice(selectedIndex, 1);
        clearSelection();
        resetEditor();
        drawTable();
        scheduleSaveState();
        status.textContent = 'Zeile gelöscht.';
      });

      btnCancel.addEventListener('click', () => {
        clearSelection();
        resetEditor();
        drawTable();
        status.textContent = 'Auswahl aufgehoben.';
      });

      // append so preview appears BELOW the buttons
      container.appendChild(editorWrap);
      container.appendChild(toolbar);
      container.appendChild(status);
      container.appendChild(tableWrap);
    }

    function renderTableField(container, field) {
      if (!Array.isArray(values[field.id])) values[field.id] = [];
      const data = values[field.id];

      // --- Inline editor (no special card/container) ---
      const editorWrap = document.createElement('div');
      editorWrap.style.display = 'flex';
      editorWrap.style.flexWrap = 'wrap';
      editorWrap.style.gap = '10px';

      const editorInputs = {};
      let editorState = emptyRow(field);

      // helpers for sizing
      const measurer = document.createElement('canvas').getContext('2d');
      function textPx(str) {
        try { measurer.font = getComputedStyle(document.body).font; } catch {}
        return Math.ceil(measurer.measureText(String(str || '')).width);
      }
      function longest(arr) {
        return arr.reduce((a, b) => (String(b).length > String(a).length ? String(b) : String(a)), '');
      }

      (field.columns || []).forEach(col => {
        const pair = document.createElement('label');
        pair.style.display = 'flex';
        pair.style.alignItems = 'center';
        pair.style.gap = '8px';

        const lbl = document.createElement('span');
        lbl.textContent = col.label || col.id;

        let el;
        if (col.type === 'select') {
          el = document.createElement('select');
          const opts = (col.options || []);
          const empty = document.createElement('option'); empty.value = ''; empty.textContent = '— wählen —';
          el.appendChild(empty);
          opts.forEach(opt => {
            const o = document.createElement('option');
            o.value = String(opt); o.textContent = String(opt);
            el.appendChild(o);
          });
          el.style.minWidth = Math.max(140, Math.min(360, textPx(longest(opts)) + 56)) + 'px';
          el.addEventListener('change', () => { editorState[col.id] = el.value; });
        } else if (col.type === 'date') {
          el = document.createElement('input');
          el.type = 'text';
          el.style.minWidth = Math.max(140, Math.min(360, textPx('YYYY-MM-DD') + 20)) + 'px';
          setTimeout(() => {
            flatpickr(el, { allowInput: true, dateFormat: 'Y-m-d', onChange: () => { editorState[col.id] = el.value; } });
          }, 0);
          el.addEventListener('change', () => { editorState[col.id] = el.value; });
        } else if (col.type === 'number') {
          el = document.createElement('input');
          el.type = 'number';
          el.style.minWidth = Math.max(120, Math.min(360, textPx('000000') + 20)) + 'px';
          el.addEventListener('change', () => { editorState[col.id] = el.value; });
        } else {
          el = document.createElement('input');
          el.type = 'text';
          el.style.minWidth = Math.max(160, Math.min(360, textPx(lbl.textContent) + 20)) + 'px';
          el.addEventListener('change', () => { editorState[col.id] = el.value; });
        }

        editorInputs[col.id] = el;
        pair.appendChild(lbl);
        pair.appendChild(el);
        editorWrap.appendChild(pair);
      });

      // --- Toolbar ---
      const toolbar = document.createElement('div');
      toolbar.className = 'row';
      toolbar.style.gap = '8px';

      const btnAdd = document.createElement('button');
      btnAdd.type = 'button';
      btnAdd.textContent = 'Zeile hinzufügen';

      const btnSave = document.createElement('button');
      btnSave.type = 'button';
      btnSave.className = 'secondary';
      btnSave.textContent = 'Änderungen speichern';

      const btnDelete = document.createElement('button');
      btnDelete.type = 'button';
      btnDelete.className = 'ghost';
      btnDelete.textContent = 'Zeile löschen';

      const btnCancel = document.createElement('button');
      btnCancel.type = 'button';
      btnCancel.className = 'ghost';
      btnCancel.textContent = 'Abbrechen';

      toolbar.appendChild(btnAdd);
      toolbar.appendChild(btnSave);
      toolbar.appendChild(btnDelete);
      toolbar.appendChild(btnCancel);

      const status = document.createElement('div');
      status.className = 'muted';
      status.style.minHeight = '1.2em';

      // --- Table preview ---
      const tableWrap = document.createElement('div');
      tableWrap.style.overflow = 'auto';
      const table = document.createElement('table');
      table.style.width = '100%';
      const thead = document.createElement('thead');
      const trh = document.createElement('tr');
      thead.appendChild(trh);
      const tbody = document.createElement('tbody');
      table.appendChild(thead);
      table.appendChild(tbody);
      tableWrap.appendChild(table);

      (field.columns || []).forEach(col => {
        const th = document.createElement('th');
        th.textContent = col.label || col.id;
        trh.appendChild(th);
      });

      let selectedIndex = -1;

      function drawTable() {
        tbody.innerHTML = '';
        data.forEach((row, idx) => {
          const tr = document.createElement('tr');
          const isSel = idx === selectedIndex;

          // persistent "selected" styling (stronger than hover)
          if (isSel) {
            tr.style.background = '#DBEAFE';           // strong light blue
            tr.style.outline = '2px solid #93C5FD';    // visible border
            tr.style.outlineOffset = '-2px';
          } else {
            tr.style.background = '';
            tr.style.outline = '';
            tr.style.outlineOffset = '';
          }

          tr.addEventListener('click', () => {
            selectedIndex = idx;        // do NOT toggle off on second click
            drawTable();
            loadIntoEditor(idx);
          });

          (field.columns || []).forEach(col => {
            const td = document.createElement('td');
            td.textContent = row[col.id] || '';
            tr.appendChild(td);
          });
          tbody.appendChild(tr);
        });
        updateToolbar();
      }

      function clearSelection() { selectedIndex = -1; updateToolbar(); }
      function updateToolbar() {
        const min = Math.max(0, parseInt(field.minRows || 0, 10));
        const max = Math.max(0, parseInt(field.maxRows || 0, 10));

        // Add is always visible
        btnAdd.disabled = (max && data.length >= max);

        // Only show these when a row is selected
        const showEdit = selectedIndex >= 0;
        btnSave.style.display   = showEdit ? '' : 'none';
        btnDelete.style.display = showEdit ? '' : 'none';
        btnCancel.style.display = showEdit ? '' : 'none';

        btnSave.disabled   = !showEdit;
        btnDelete.disabled = !showEdit || (min && data.length <= min);
        btnCancel.disabled = !showEdit;
      }

      function loadIntoEditor(i) {
        const rec = data[i] || emptyRow(field);
        for (const c of (field.columns || [])) {
          const el = editorInputs[c.id];
          if (!el) continue;
          el.value = rec[c.id] || '';
        }
        editorState = { ...rec };
        updateToolbar();
      }

      function resetEditor() {
        editorState = emptyRow(field);
        for (const c of (field.columns || [])) {
          const el = editorInputs[c.id];
          if (!el) continue;
          el.value = '';
        }
      }

      // initial rows (respect minRows) + first draw
      if (!data.length) {
        const min = Math.max(0, parseInt(field.minRows || 0, 10));
        for (let i = 0; i < min; i++) data.push(emptyRow(field));
      }
      drawTable(); // no auto-selection by default

      // actions
      btnAdd.addEventListener('click', () => {
        const max = Math.max(0, parseInt(field.maxRows || 0, 10));
        if (max && data.length >= max) return;
        // Always create a NEW row with current editor content
        data.push({ ...editorState });
        drawTable();
        scheduleSaveState();
        status.textContent = 'Zeile hinzugefügt.';
      });

      btnSave.addEventListener('click', () => {
        if (selectedIndex < 0 || selectedIndex >= data.length) return;
        data[selectedIndex] = { ...editorState };
        drawTable();
        scheduleSaveState();
        status.textContent = 'Änderungen gespeichert.';
      });

      btnDelete.addEventListener('click', () => {
        const min = Math.max(0, parseInt(field.minRows || 0, 10));
        if (selectedIndex < 0) return;
        if (min && data.length <= min) return;
        data.splice(selectedIndex, 1);
        clearSelection();
        resetEditor();
        drawTable();
        scheduleSaveState();
        status.textContent = 'Zeile gelöscht.';
      });

      btnCancel.addEventListener('click', () => {
        clearSelection();
        resetEditor();
        drawTable();
        status.textContent = 'Auswahl aufgehoben.';
      });

      // append so preview appears BELOW the buttons
      container.appendChild(editorWrap);
      container.appendChild(toolbar);
      container.appendChild(status);
      container.appendChild(tableWrap);
    }


    function emptyRow(field){ const r={}; (field.columns||[]).forEach(c=>r[c.id]=''); return r; }

    // Debounced state save
    let __saveTimer = null;
    function scheduleSaveState() {
      clearTimeout(__saveTimer);
      __saveTimer = setTimeout(saveState, 150);
    }
    function saveState() {
      if (!currentDoc?.docId) return;
      const cleanValues = sanitizeValues(schema, values);
      window.formSuitePersist.saveState(currentDoc.docId, { schema, values: cleanValues });
    }
    function saveLS(s) { try { localStorage.setItem(STORAGE_KEY, JSON.stringify(s||{})); } catch {} }
    function loadLS() { try { return JSON.parse(localStorage.getItem(STORAGE_KEY)||'null'); } catch { return null; } }
    window.addEventListener('beforeunload', () => {
      try { if (currentDoc?.docId) saveState(); else if (schema) saveLS(schema); } catch {}
    });

    // ---------- Export (Open Form) ----------
    async function onExportFromOpenForm() {
      if (!currentDoc?.docId) { alert('No active document. Open or pick a DOCX first.'); return; }

      const canBytes = await fetchWorkingDocBytes();
      if (!canBytes) { await hardResetOpenForm('no bytes / no permission'); return; }

      const attempt = async () => {
        await ensurePy();
        const docBytes = await fetchWorkingDocBytes(); if (!docBytes) return;

        const state  = await window.formSuitePersist.loadState?.(currentDoc.docId);
        const tagMap = (state?.payload?.CRONOS_PAYLOAD?.tagMap)
                    || (state?.cronos_payload?.tagMap)
                    || (state?.CRONOS_PAYLOAD?.tagMap)
                    || (state?.tagMap)
                    || {};

        const validIds = new Set((schema?.fields || []).map(f => f.id));
        const safeValues = sanitizeValues(schema, values || {});
        const cleanTagMap = sanitizeTagMap(tagMap, validIds);

        const payload = JSON.stringify({
          title: schema?.title || 'Form',
          fields: schema?.fields || [],
          values: safeValues,
          tagMap: cleanTagMap
        });

        // 1) write CRONOS_PAYLOAD → settings.xml
        const updated = await writeDocVar(docBytes, PAYLOAD_KEY, payload);

        // 2) fill SDTs (prefer formatted string for address objects)
        const sdtMap = {};
        for (const [tag, fieldId] of Object.entries(cleanTagMap)) {
          let v = safeValues?.[fieldId];
          if (v == null) v = '';
          if (typeof v === 'object') {
            v = v.formatted ?? (function(){ try { return JSON.stringify(v); } catch { return String(v); } })();
          }
          sdtMap[tag] = String(v);
        }
        let updated2 = await writeSDTs(updated, sdtMap);

        // 3) evaluate rules → visibility map (SHOW overrides HIDE)
        const rules = loadRulesForDoc(state);
        const visibilityMap = evaluateRulesToVisibility(schema, safeValues, rules);

        // 4) apply visibility using fsHidden (non-destructive)
        if (Object.keys(visibilityMap).length) {
          updated2 = await applyVisibilityByRules(updated2, visibilityMap);
        }

        // keep OPFS in sync for the workspace
        await window.formSuitePersist.putBytes?.(currentDoc.docId, updated2);

        // 5) Save As...
        if (supportsFS && window.showSaveFilePicker) {
          try {
            const suggested = (currentDoc.name?.replace(/\.docx$/i,'') || 'document') + ' (export).docx';
            const handle = await showSaveFilePicker({
              suggestedName: suggested,
              types: [{ description: 'Word document', accept: { 'application/vnd.openxmlformats-officedocument.wordprocessingml.document': ['.docx'] } }]
            });
            const stream = await handle.createWritable(); await stream.write(updated2); await stream.close();
          } catch (e) { if (e?.name === 'AbortError') return; throw e; }
        } else {
          const blob = new Blob([updated2], { type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' });
          const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
          a.download = (currentDoc?.name||'document').replace(/\.docx$/i,' (export).docx');
          a.click(); setTimeout(() => URL.revokeObjectURL(a.href), 2000);
        }
      };

      try { await attempt(); }
      catch (e) {
        const msg = String(e?.message || e || '');
        if (msg.includes('already been destroyed') || msg.includes('proxy has been destroyed')) {
          await ensurePy(true);
          try { await attempt(); return; } catch (e2) {
            if (e2?.name === 'AbortError' || /export canceled/.test((e2?.message||'').toLowerCase())) return;
            console.error('Export failed after retry:', e2); alert('Export failed: ' + (e2?.message || e2)); return;
          }
        }
        if (e?.name === 'AbortError' || /export canceled/.test((e?.message||'').toLowerCase())) return;
        console.error('Export failed (Open Form):', e); alert('Export failed: ' + (e?.message || e));
      }
    }

    // ---------- Rules → Visibility map (SHOW supersedes HIDE) ----------
    function loadRulesForDoc(state) {
      return (
        state?.rules ||
        state?.payload?.rules ||
        state?.CRONOS_RULES ||
        state?.cronos_rules ||
        []
      );
    }

    function ruleMatchesValue(op, expected, actual) {
      const a = actual;
      if (op === 'equals')    return String(a) === String(expected);
      if (op === 'notEquals') return String(a) !== String(expected);
      if (op === 'anyOf') {
        const arr = Array.isArray(expected) ? expected.map(String) : [String(expected)];
        if (Array.isArray(a)) return a.map(String).some(v => arr.includes(v));
        return arr.includes(String(a));
      }
      if (op === 'allOf') {
        const arr = Array.isArray(expected) ? expected.map(String) : [String(expected)];
        if (!Array.isArray(a)) return false;
        const aset = new Set(a.map(String));
        return arr.every(v => aset.has(v));
      }
      if (op === 'contains') {
        return String(a ?? '').toLowerCase().includes(String(expected ?? '').toLowerCase());
      }
      return false;
    }

    function evaluateRulesToVisibility(schema, values, rules) {
      const out = Object.create(null);
      if (!Array.isArray(rules) || !rules.length) return out;

      const cleanVals = sanitizeValues(schema, values || {});
      const getVal = (fid) => cleanVals[fid];

      for (const r of rules) {
        if (!r) continue;
        const action = (String(r.action || '').toUpperCase() === 'SHOW') ? 'SHOW'
                    : (String(r.action || '').toUpperCase() === 'HIDE') ? 'HIDE'
                    : null;
        if (!action) continue;

        const fieldId = r.fieldId || r.field || r.whenField;
        const op      = r.op || r.operator || 'equals';
        theExp = r.values ?? r.value ?? r.expected;
        const exp = theExp;
        const targets = Array.isArray(r.targets) ? r.targets : [];

        const actual  = getVal(fieldId);
        if (!ruleMatchesValue(op, exp, actual)) continue;

        for (const t of targets) {
          const key = t?.key ?? t?.idx ?? t?.id;
          if (key == null) continue;
          const idx = Number(key);
          if (!Number.isFinite(idx)) continue;
          const prev = out[idx];
          if (action === 'SHOW') out[idx] = 'SHOW';
          else if (action === 'HIDE' && prev !== 'SHOW') out[idx] = 'HIDE';
        }
      }
      return out;
    }

    // ---------- Bridge to Python: apply visibility using fsHidden ----------
    async function applyVisibilityByRules(bytesU8, visibilityMap) {
      if (!visibilityMap || !Object.keys(visibilityMap).length) return bytesU8;
      await ensurePy();
      const fn = py.globals.get('apply_visibility');
      const pyBytes = py.toPy(bytesU8 instanceof Uint8Array ? bytesU8 : new Uint8Array(bytesU8));
      const pyMap   = py.toPy(JSON.stringify(visibilityMap));
      let pyOut;
      try { pyOut = fn(pyBytes, pyMap); }
      finally { try{fn.destroy();}catch{} try{pyBytes.destroy();}catch{} try{pyMap.destroy();}catch{} }
      let u8;
      if (pyOut?.toJs) u8 = pyOut.toJs({ create_proxies:false });
      else if (pyOut?.getBuffer) u8 = new Uint8Array(pyOut.getBuffer());
      else u8 = new Uint8Array([]);
      try { pyOut.destroy?.(); } catch {}
      return u8;
    }

    // ---------- Logo triple-click: focus mode (kept minimal) ----------
    (function() {
      const logo = document.querySelector('header .logo');
      const header = document.querySelector('header .row');
      if (!logo || !header) return;

      let clickCount = 0;
      let clickTimer = null;
      let focusMode = false;

      logo.addEventListener('click', () => {
        clickCount++;
        clearTimeout(clickTimer);
        clickTimer = setTimeout(() => { clickCount = 0; }, 600);

        if (clickCount === 3) {
          clickCount = 0;
          focusMode = !focusMode;

          if (focusMode) {
            header.querySelectorAll('a, span.muted').forEach(el => {
              if (!el.closest('.brand')) el.style.display = 'none';
            });
            if (!location.pathname.endsWith('index.html')) {
              location.href = 'index.html';
            }
          } else {
            header.querySelectorAll('a, span.muted').forEach(el => { el.style.display = ''; });
          }
        }
      });
    })();
  </script>
</body>
</html>
