<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Form Suite — Open Form</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
  <link rel="stylesheet" href="style.css">
  <style>
    /* Compact editor layout for table rows */
    .compact-editor { display:flex; flex-wrap:wrap; gap:8px 12px; align-items:flex-start; }
    .compact-editor .pair {
      display:flex; align-items:center; gap:6px;
      padding:6px 8px;
      background:var(--card,#fff); border-radius:8px;
    }
    .compact-editor .pair .lbl { white-space:nowrap; font-size:0.95rem; color:var(--ink,#0f172a); }
    .compact-editor .pair input, .compact-editor .pair select {
      width:auto; min-width:120px; max-width:360px;
    }
    .table-card table { width:100%; table-layout:auto; border-collapse:collapse; }
    .table-card th, .table-card td { padding:6px 8px; border-bottom:1px solid var(--border,#e5e7eb); }
    .table-card tbody tr { cursor:pointer; }
    .table-card tbody tr[data-sel="1"] { background:#f0f9ff; }
    .right { margin-left:auto; }
    .btn-primary, .btn-secondary, .btn-danger { margin-right:6px; }
  </style>
</head>
<body>
  <header>
    <div class="row">
      <span class="brand logo-md">
        <img src="logo.gif" alt="Form Suite logo" class="logo" />
        <strong>Form Suite</strong>
      </span>
      <span class="muted">·</span><span class="muted">Open Form</span>
      <span class="muted">·</span><a href="builder.html">Form Builder</a>
      <span class="muted">·</span><a href="matcher.html">Tag Matcher</a>
      <span class="muted">·</span><a href="extractor.html">Extractor</a>
    </div>
  </header>

  <main>
    <section class="panel">
      <div class="title-row"></div>
      <div class="row" style="margin-top:8px;">
        <span id="docStatus" class="muted">No active document. Open one in the <a href="extractor.html">Extractor</a>.</span>
      </div>
    </section>

    <section class="panel">
      <div id="formMount"></div>
    </section>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <script src="persistence.js"></script>
  <script>
    const STORAGE_KEY = 'FORM_SCHEMA_V1';
    const PAYLOAD_KEY = 'CRONOS_PAYLOAD';
    const supportsFS = 'showSaveFilePicker' in window;

    const els = {
      docStatus: document.getElementById('docStatus'),
      formMount: document.getElementById('formMount')
    };

    let currentDoc = null, schema = null, values = {};
    let btnExportMain = null;

    // ---------- File-Guard helpers ----------
    function setStatus(s) { els.docStatus.innerHTML = s; }
    async function hardResetOpenForm(reason = '') {
      try {
        // try not to wipe workspace state here; Extractor handles that.
      } catch {}
      // local UI reset
      schema = null;
      values = {};
      if (els.formMount) els.formMount.innerHTML = `<div class="muted">No schema found. Create one in the <a href="builder.html">Builder</a>.</div>`;
      if (btnExportMain) btnExportMain.disabled = true;
      if (reason) setStatus(`No active document (${reason}). Open one in the <a href="extractor.html">Extractor</a>.`);
      else setStatus(`No active document. Open one in the <a href="extractor.html">Extractor</a>.`);
    }

// ---------- One Active-Doc Signal (unifier) ----------
const ACTIVE_DOC_KEY = 'FS_ACTIVE_DOC_META'; // <— canonical key used across the app

function readActiveDocSync() {
  // 1) Prefer persistence (if available in this tab)
  const p =
    window.formSuitePersist?.getCurrentDocMeta?.() ||
    window.formSuitePersist?.getActiveDoc?.sync?.();
  if (p?.docId) {
    const meta = { docId: p.docId, name: p.name || p.docTitle || 'document' };
    try { localStorage.setItem(ACTIVE_DOC_KEY, JSON.stringify(meta)); } catch {}
    return meta;
  }

  // 2) Canonical LS
  try {
    const v = localStorage.getItem(ACTIVE_DOC_KEY);
    if (v) return JSON.parse(v);
  } catch {}

  // 3) Migration from older key (Extractor used this)
  try {
    const legacy = localStorage.getItem('FS_CURRENT_DOC_META');
    if (legacy) {
      const m = JSON.parse(legacy);
      if (m?.docId) {
        localStorage.setItem(ACTIVE_DOC_KEY, legacy);
        return m;
      }
    }
  } catch {}
  return null;
}

  // Broadcast + storage listener → normalize into ACTIVE_DOC_KEY
  function installActiveDocListener(onChange) {
    const bcLegacy = ('BroadcastChannel' in window) ? new BroadcastChannel('form-suite-doc') : null;
    const bcCanon  = ('BroadcastChannel' in window) ? new BroadcastChannel('fs-active-doc') : null;

    function emit(meta) {
      // keep LS in sync so all tabs have a single source of truth
      if (meta?.docId) {
        try { localStorage.setItem(ACTIVE_DOC_KEY, JSON.stringify({ docId: meta.docId, name: meta.name })); } catch {}
      } else {
        try { localStorage.removeItem(ACTIVE_DOC_KEY); } catch {}
      }
      onChange(meta || null);
    }

    bcLegacy?.addEventListener('message', async (ev) => {
      const m = ev?.data || {};
      // Map old messages to canonical event
      if (m.type === 'doc-cleared') { emit(null); return; }
      if (m.type === 'doc-switched' || m.type === 'doc-updated') {
        emit((m.docId) ? { docId: m.docId, name: m.name } : readActiveDocSync());
      }
      if (m.type === 'schema-updated') {
        // schema changed for current doc; keep meta unchanged but refresh state below via ensureActiveDocOrReset()
        const meta = readActiveDocSync();
        if (meta?.docId && (!m.docId || m.docId === meta.docId)) emit(meta);
      }
    });

    bcCanon?.addEventListener('message', (ev) => {
      const m = ev?.data || {};
      if (m.type === 'active:set')   emit({ docId: m.docId, name: m.name });
      if (m.type === 'active:clear') emit(null);
    });

    window.addEventListener('storage', (e) => {
      if (e.key === ACTIVE_DOC_KEY) {
        const v = e.newValue ? JSON.parse(e.newValue) : null;
        emit(v);
      }
      // one-time migration from legacy key if canonical not set yet
      if (e.key === 'FS_CURRENT_DOC_META' && !localStorage.getItem(ACTIVE_DOC_KEY)) {
        const v = e.newValue ? JSON.parse(e.newValue) : null;
        if (v?.docId) {
          try { localStorage.setItem(ACTIVE_DOC_KEY, e.newValue); } catch {}
          emit(v);
        }
      }
    });
  }

  // Hook it into this page
  installActiveDocListener(async (meta) => {
    currentDoc = meta;
    if (!currentDoc?.docId) { await hardResetOpenForm('cleared'); return; }
    // Load the per-doc workspace schema/values and show
    const st = await window.formSuitePersist.loadState?.(currentDoc.docId);
    schema = st?.schema || null;
    values = st?.values || {};
    setStatus(`Active DOCX: <span class="kbd">${currentDoc.name}</span>${schema ? '' : ' — <span class="muted">no schema yet</span>'}`);
    renderForm();
  });


    // ---------- Focus/visibility refresh with guard ----------
    document.addEventListener('visibilitychange', async () => {
      if (document.visibilityState !== 'visible') return;
      await ensureActiveDocOrReset();
    });
    window.addEventListener('focus', async () => { await ensureActiveDocOrReset(); });

    async function ensureActiveDocOrReset() {
      try {
        // Always resolve from the single canonical source
        currentDoc = readActiveDocSync() || currentDoc;
        if (!currentDoc?.docId) { await hardResetOpenForm('no active doc'); return; }

        // If bytes are gone, clear UI to avoid stale export attempts
        const bytes = await fetchWorkingDocBytes();
        if (!bytes) { await hardResetOpenForm('lost access'); return; }

        // Show per-doc workspace state (no localStorage fallback here)
        const st = await window.formSuitePersist.loadState?.(currentDoc.docId);
        schema = st?.schema || null;
        values = st?.values || {};
        setStatus(`Active DOCX: <span class="kbd">${currentDoc.name}</span>${schema ? '' : ' — <span class="muted">no schema yet</span>'}`);
        renderForm();
      } catch (e) {
        console.warn('ensureActiveDocOrReset failed:', e);
      }
    }


    // ---------- Pyodide (robust) ----------
    let pyLoaded = false;
    let py = null;

    async function ensurePy(forceReinit = false) {
      if (forceReinit && py && py._module) { pyLoaded = false; py = null; }
      if (!pyLoaded) {
        await new Promise((res, rej) => {
          if (window.loadPyodide) return res();
          const s = document.createElement('script');
          s.src = "https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js";
          s.onload = res; s.onerror = rej; document.head.appendChild(s);
        });
        py = await loadPyodide({ indexURL: "https://cdn.jsdelivr.net/pyodide/v0.24.1/full/" });
        await py.runPythonAsync(`
import io, zipfile, json
import xml.etree.ElementTree as ET
_W_NS = "http://schemas.openxmlformats.org/wordprocessingml/2006/main"
def _q(local): return "{%s}%s" % (_W_NS, local)
def write_docvar(u8, var_name, value):
    data = bytes(u8); outbuf = io.BytesIO()
    with zipfile.ZipFile(io.BytesIO(data), "r") as zfin, zipfile.ZipFile(outbuf,"w",compression=zipfile.ZIP_DEFLATED) as zfout:
        try: names = set(zfin.namelist())
        except: names = set()
        if "word/settings.xml" in names:
            try: root = ET.fromstring(zfin.read("word/settings.xml"))
            except ET.ParseError: root = ET.Element(_q("settings"))
        else: root = ET.Element(_q("settings"))
        doc_vars = root.find("{%s}docVars" % _W_NS)
        if doc_vars is None: doc_vars = ET.SubElement(root, _q("docVars"))
        target = None
        for dv in doc_vars.findall("{%s}docVar" % _W_NS):
            if dv.get(_q("name")) == var_name: target = dv; break
        if target is None:
            target = ET.SubElement(doc_vars, _q("docVar"), {_q("name"): var_name, _q("val"): value})
        else:
            target.set(_q("val"), value)
        settings_bytes = ET.tostring(root, encoding="utf-8", xml_declaration=True)
        for n in zfin.namelist():
            if n == "word/settings.xml": continue
            zfout.writestr(n, zfin.read(n))
        zfout.writestr("word/settings.xml", settings_bytes)
    return outbuf.getvalue()
def _set_sdt_text(content_el, value):
    texts = content_el.findall(".//w:t", {"w": _W_NS})
    if texts:
        first = True
        for t in texts:
            if first: t.text = value; first = False
            else: t.text = ""
        return
    has_block = (content_el.find(".//w:p", {"w": _W_NS}) is not None) or (content_el.find(".//w:tbl", {"w": _W_NS}) is not None)
    for ch in list(content_el): content_el.remove(ch)
    if has_block:
        p = ET.SubElement(content_el, _q("p")); r = ET.SubElement(p, _q("r"))
    else:
        r = ET.SubElement(content_el, _q("r"))
    t = ET.SubElement(r, _q("t")); t.text = value
    if (value.strip() != value) or ("\\n" in value) or ("  " in value):
        t.set("{http://www.w3.org/XML/1998/namespace}space", "preserve")
def write_sdts_by_tag(u8, tag_to_text_json):
    try: mapping = json.loads(tag_to_text_json or "{}")
    except Exception: mapping = {}
    if not mapping: return u8
    data = bytes(u8); outbuf = io.BytesIO()
    with zipfile.ZipFile(io.BytesIO(data), "r") as zfin, zipfile.ZipFile(outbuf,"w",compression=zipfile.ZIP_DEFLATED) as zfout:
        names = zfin.namelist()
        def is_target(name):
            if not (name.startswith("word/") and name.endswith(".xml")): return False
            skip = {"word/styles.xml","word/numbering.xml","word/theme/theme1.xml","word/fontTable.xml","word/settings.xml","word/webSettings.xml"}
            return name not in skip and not name.startswith("word/_rels/")
        for n in names:
            if not is_target(n):
                zfout.writestr(n, zfin.read(n)); continue
            try: root = ET.fromstring(zfin.read(n))
            except ET.ParseError:
                zfout.writestr(n, zfin.read(n)); continue
            changed = False
            for sdt in root.findall(".//w:sdt", {"w": _W_NS}):
                pr = sdt.find("w:sdtPr", {"w": _W_NS})
                if pr is None: continue
                tag_el = pr.find("w:tag", {"w": _W_NS})
                tag_val = tag_el.get(_q("val")) if tag_el is not None else ""
                if not tag_val or tag_val not in mapping: continue
                content_el = sdt.find("w:sdtContent", {"w": _W_NS}) or sdt
                val = mapping.get(tag_val, "")
                if not isinstance(val, str):
                    try: val = json.dumps(val, ensure_ascii=False)
                    except Exception: val = str(val)
                _set_sdt_text(content_el, val); changed = True
            out_xml = ET.tostring(root, encoding="utf-8", xml_declaration=True) if changed else zfin.read(n)
            zfout.writestr(n, out_xml)
    return outbuf.getvalue()
`);
        pyLoaded = true;
      }
    }

    async function writeDocVar(bytes, name, value) {
      await ensurePy();
      const fn = py.globals.get('write_docvar');
      const pyBytes = py.toPy(new Uint8Array(bytes));
      let pyOut;
      try { pyOut = fn(pyBytes, name, value); }
      finally { try{fn.destroy();}catch{} try{pyBytes.destroy();}catch{} }
      let u8;
      if (pyOut?.toJs) u8 = pyOut.toJs({ create_proxies:false });
      else if (pyOut?.getBuffer) u8 = new Uint8Array(pyOut.getBuffer());
      else u8 = new Uint8Array([]);
      try { pyOut.destroy?.(); } catch {}
      return u8;
    }

    async function writeSDTs(arrayBufferOrBytes, tagToTextObj) {
      await ensurePy();
      const u8in = arrayBufferOrBytes instanceof Uint8Array ? arrayBufferOrBytes : new Uint8Array(arrayBufferOrBytes);
      const fn = py.globals.get('write_sdts_by_tag');
      const pyBytes = py.toPy(u8in);
      const pyMap   = py.toPy(JSON.stringify(tagToTextObj || {}));
      let pyOut;
      try { pyOut = fn(pyBytes, pyMap); }
      finally { try{fn.destroy();}catch{} try{pyBytes.destroy();}catch{} try{pyMap.destroy();}catch{} }
      let u8;
      if (pyOut?.toJs) u8 = pyOut.toJs({ create_proxies:false });
      else if (pyOut?.getBuffer) u8 = new Uint8Array(pyOut.getBuffer());
      else u8 = new Uint8Array([]);
      try { pyOut.destroy?.(); } catch {}
      return u8;
    }

    // ---------- Helpers: sanitize ----------
    function sanitizeValues(schema, vals) {
      const out = {};
      const fields = Array.isArray(schema?.fields) ? schema.fields : [];
      for (const f of fields) {
        const id = f.id;
        let v = vals?.[id];

        if (v == null) continue;

        if (f.type === 'multichoice') {
          let arr = Array.isArray(v) ? v.slice() : (typeof v === 'string' ? v.split(',') : []);
          arr = arr.map(x => String(x).trim()).filter(Boolean);
          if (Array.isArray(f.options) && f.options.length) {
            const allowed = new Set(f.options.map(String));
            arr = arr.filter(x => allowed.has(String(x)));
          }
          if (!arr.length) continue;
          out[id] = arr;
          continue;
        }

        if (f.type === 'select') {
          let s = Array.isArray(v) ? String(v[0] ?? '') : String(v ?? '');
          if (Array.isArray(f.options) && f.options.length) {
            const allowed = new Set(f.options.map(String));
            if (!allowed.has(s)) s = '';
          }
          if (s === '') { if (f.required) out[id] = s; continue; }
          out[id] = s;
          continue;
        }

        if (f.type === 'number') {
          if (v === '' || v == null) continue;
          const num = (typeof v === 'number') ? v : Number(String(v).replace(',', '.'));
          if (Number.isFinite(num)) out[id] = num;
          continue;
        }

        if (f.type === 'date') {
          out[id] = String(v ?? '');
          continue;
        }

        if (f.type === 'table') {
          const cols = Array.isArray(f.columns) ? f.columns : [];
          const colIds = cols.map(c => c.id);
          const arr = Array.isArray(v) ? v : [];
          const cleaned = arr.map(row => {
            const o = {};
            for (const cid of colIds) {
              let cell = row?.[cid];
              if (cell == null) cell = '';
              o[cid] = (typeof cell === 'string') ? cell : String(cell);
            }
            return o;
          }).filter(r => Object.values(r).some(val => String(val).trim() !== ''));
          const min = Math.max(0, parseInt(f.minRows || 0, 10));
          while (cleaned.length < min) {
            const empty = {}; colIds.forEach(cid => empty[cid] = ''); cleaned.push(empty);
          }
          if (!cleaned.length) continue;
          out[id] = cleaned;
          continue;
        }

        // default: text/unknown -> string
        const s = String(v ?? '');
        if (s === '' && !f.required) continue;
        out[id] = s;
      }
      return out;
    }

    function sanitizeTagMap(tagMap, validIds) {
      const out = {};
      for (const [tag, fid] of Object.entries(tagMap || {})) {
        if (validIds.has(fid)) out[tag] = fid;
      }
      return out;
    }

    // ---------- Init ----------
    init().catch(console.error);

    async function init() {
      // Resolve current doc once from the canonical place
      currentDoc = readActiveDocSync();

      if (currentDoc?.docId) {
        const bytes = await fetchWorkingDocBytes();
        if (!bytes) { await hardResetOpenForm('no bytes / no permission'); return; }

        const st = await window.formSuitePersist.loadState?.(currentDoc.docId);
        schema = st?.schema || null;
        values = st?.values || {};
        setStatus(`Active DOCX: <span class="kbd">${currentDoc.name}</span>${schema ? '' : ' — <span class="muted">no schema yet</span>'}`);
      } else {
        // No active doc → show local draft (optional UX)
        schema = loadLS();
        values = {};
      }

      renderForm();
    }


    // ---------- Robust bytes fetcher ----------
    async function fetchWorkingDocBytes() {
      try { const b = await window.formSuitePersist.getCurrentDocBytes?.(); if (b && b.byteLength) return b; } catch {}
      try { if (currentDoc?.docId) { const b2 = await window.formSuitePersist.getBytes?.(currentDoc.docId); if (b2 && b2.byteLength) return b2; } } catch {}
      try {
        const h = await window.formSuitePersist.getHandle?.(currentDoc?.docId);
        if (h?.getFile) {
          let p = await window.formSuitePersist.ensurePermission?.(h, 'readwrite');
          if (p !== 'granted') p = await window.formSuitePersist.ensurePermission?.(h, 'read');
          if (p === 'granted') { const f = await h.getFile(); return await f.arrayBuffer(); }
        }
      } catch {}
      try { await window.formSuitePersist.regrantAll?.(); const b3 = await window.formSuitePersist.getCurrentDocBytes?.(); if (b3 && b3.byteLength) return b3; } catch {}
      return null;
    }

    // ---------- Render whole form ----------
    function renderForm() {
      const mount = els.formMount;
      mount.innerHTML = '';
      if (!schema || !Array.isArray(schema.fields) || !schema.fields.length) {
        mount.innerHTML = `<div class="muted">No schema found. Create one in the <a href="builder.html">Builder</a>.</div>`;
        // if there's no schema, also disable Export
        if (btnExportMain) btnExportMain.disabled = true;
        return;
      }
      const form = document.createElement('form');
      form.style.display='grid'; form.style.gap='12px';
      if (schema.title) { const h=document.createElement('h4'); h.textContent=schema.title; form.appendChild(h); }

      // hydrate table defaults
      schema.fields.forEach(f => {
        if (f.type === 'table') {
          if (!Array.isArray(values[f.id])) {
            const min = Math.max(0, parseInt(f.minRows || 0, 10));
            const rows = Math.max(min, 0);
            values[f.id] = Array.from({ length: rows }, () => emptyRow(f));
          } else {
            values[f.id] = values[f.id].map(r => ({ ...emptyRow(f), ...r }));
          }
        }
      });

      // fields
      schema.fields.forEach(f => {
        const wrap = document.createElement('div'); wrap.className='field';
        const label = document.createElement('label'); label.htmlFor=f.id; label.textContent=f.label||f.id;
        if (f.required){ const star=document.createElement('span'); star.textContent=' *'; star.style.color='#ef4444'; label.appendChild(star); }
        wrap.appendChild(label);

        if (f.type === 'text') {
          const input = document.createElement('input'); input.type='text'; input.id=f.id; input.name=f.id; input.style.width='100%';
          if (f.required) input.required=true; if (values[f.id]!=null) input.value=values[f.id];
          input.addEventListener('change', () => { values[f.id] = input.value; saveState(); });
          wrap.appendChild(input);

        } else if (f.type === 'select') {
          const input = document.createElement('select'); input.id=f.id; input.name=f.id; input.style.width='100%';
          (f.options||[]).forEach(v => { const o=document.createElement('option'); o.value=String(v); o.textContent=String(v); input.appendChild(o); });
          if (f.required) input.required=true; if (values[f.id]!=null) input.value=values[f.id];
          input.addEventListener('change', () => { values[f.id] = input.value; saveState(); });
          wrap.appendChild(input);

        } else if (f.type === 'multichoice') {
          const group = document.createElement('div'); group.className='mc-group';
          const cur = new Set(Array.isArray(values[f.id]) ? values[f.id].map(String) : []);
          (f.options||[]).forEach((opt, idx) => {
            const row = document.createElement('label');
            row.style.display = (f.layout === 'inline') ? 'inline-flex' : 'flex';
            row.style.alignItems = 'center';
            row.style.gap = '8px';
            row.style.margin = '6px 12px 6px 0';

            const cb = document.createElement('input');
            cb.type = 'checkbox';
            cb.name = f.id;
            cb.id = `${f.id}__${idx}`;
            cb.value = String(opt);
            if (cur.has(String(opt))) cb.checked = true;

            cb.addEventListener('change', () => {
              const boxes = group.querySelectorAll(`input[name="${CSS.escape(f.id)}"]`);
              values[f.id] = Array.from(boxes).filter(b => b.checked).map(b => b.value);
              saveState();
            });

            const txt = document.createElement('span'); txt.textContent = String(opt);
            row.appendChild(cb); row.appendChild(txt);
            group.appendChild(row);
          });
          wrap.appendChild(group)

        } else if (f.type === 'date') {
          const input = document.createElement('input'); input.type='text'; input.dataset.type='date'; input.dataset.format=f.dateFormat||'Y-m-d';
          input.id=f.id; input.name=f.id; input.style.width='100%';
          if (f.required) input.required=true; if (values[f.id]!=null) input.value=values[f.id];
          wrap.appendChild(input);
          const fmt = input.dataset.format || 'Y-m-d';
          flatpickr(input, { dateFormat: fmt, allowInput:true, onChange: () => { values[f.id] = input.value; saveState(); } });

        } else if (f.type === 'table') {
          renderTableField(wrap, f);

        } else {
          const input = document.createElement('input'); input.type='text'; input.id=f.id; input.name=f.id; input.style.width='100%';
          if (values[f.id]!=null) input.value=values[f.id];
          input.addEventListener('change', () => { values[f.id] = input.value; saveState(); });
          wrap.appendChild(input);
        }
        form.appendChild(wrap);
      });

      // bottom bar with Export…
      const bar = document.createElement('div'); bar.className='bar';
      btnExportMain = document.createElement('button'); btnExportMain.type='button'; btnExportMain.className='secondary'; btnExportMain.textContent='Export…';
      // Enable only when active doc AND we (likely) have bytes
      btnExportMain.disabled = !currentDoc;
      btnExportMain.addEventListener('click', onExportFromOpenForm);
      bar.appendChild(btnExportMain); form.appendChild(bar);

      mount.appendChild(form);
    }

    // ----- TABLE FIELD -----
    function renderTableField(container, field) {
      if (!Array.isArray(values[field.id])) values[field.id] = [];
      const data = values[field.id];

      const card = document.createElement('div'); card.className='table-card'; card.style.display='grid'; card.style.gap='10px';

      const h2 = document.createElement('h4');
      h2.textContent = (field.label || field.id) + ' — Editor';
      h2.style.margin = '6px 0 0';
      card.appendChild(h2);

      const editorWrap = document.createElement('div'); editorWrap.className = 'compact-editor';
      const editorInputs = {};
      let editorState = emptyRow(field);

      const measurer = document.createElement('canvas').getContext('2d');
      function textPx(str) {
        try { measurer.font = getComputedStyle(document.body).font; } catch {}
        const m = measurer.measureText(String(str||'')); return Math.ceil(m.width);
      }
      function longest(arr) { return arr.reduce((a,b)=> (String(b).length > String(a).length ? String(b) : String(a)), ''); }

      (field.columns || []).forEach(col => {
        const pair = document.createElement('div'); pair.className='pair';
        const lbl = document.createElement('span'); lbl.className='lbl'; lbl.textContent = col.label || col.id;
        let el;

        if (col.type === 'select') {
          el = document.createElement('select');
          const options = (col.options || []);
          const emptyOpt = document.createElement('option'); emptyOpt.value=''; emptyOpt.textContent='— wählen —'; el.appendChild(emptyOpt);
          options.forEach(opt => { const o=document.createElement('option'); o.value=String(opt); o.textContent=String(opt); el.appendChild(o); });
          const w = Math.max(140, Math.min(360, textPx(longest(options))+24+32));
          el.style.minWidth = w + 'px';
          el.addEventListener('change', () => { editorState[col.id] = el.value; });

        } else if (col.type === 'date') {
          el = document.createElement('input'); el.type='text';
          const w = Math.max(140, Math.min(360, textPx('YYYY-MM-DD')+20));
          el.style.minWidth = w + 'px';
          setTimeout(() => { flatpickr(el, { allowInput:true, dateFormat:'Y-m-d', onChange: () => { editorState[col.id] = el.value; } }); }, 0);
          el.addEventListener('change', () => { editorState[col.id] = el.value; });

        } else if (col.type === 'number') {
          el = document.createElement('input'); el.type='number';
          const w = Math.max(120, Math.min(360, textPx('000000')+20));
          el.style.minWidth = w + 'px';
          el.addEventListener('change', () => { editorState[col.id] = el.value; });

        } else {
          el = document.createElement('input'); el.type='text';
          const w = Math.max(160, Math.min(360, textPx(lbl.textContent)+20));
          el.style.minWidth = w + 'px';
          el.addEventListener('change', () => { editorState[col.id] = el.value; });
        }

        editorInputs[col.id] = el;
        pair.appendChild(lbl); pair.appendChild(el);
        editorWrap.appendChild(pair);
      });

      card.appendChild(editorWrap);

      const toolbar = document.createElement('div'); toolbar.className='row';
      const btnAdd = document.createElement('button'); btnAdd.type='button'; btnAdd.className='btn-primary'; btnAdd.textContent='Zeile hinzufügen';
      const btnSave = document.createElement('button'); btnSave.type='button'; btnSave.className='btn-secondary'; btnSave.textContent='Änderungen speichern';
      const btnDelete = document.createElement('button'); btnDelete.type='button'; btnDelete.className='btn-danger'; btnDelete.textContent='Zeile löschen';
      toolbar.appendChild(btnAdd); toolbar.appendChild(btnSave); toolbar.appendChild(btnDelete);
      card.appendChild(toolbar);

      const status = document.createElement('div'); status.className='muted'; status.style.minHeight='1.2em'; status.style.marginTop='-4px';
      card.appendChild(status);

      const tableWrap = document.createElement('div'); tableWrap.style.overflow='auto';
      const table = document.createElement('table'); table.style.width='100%'; tableWrap.appendChild(table);
      const thead = document.createElement('thead'); const trh = document.createElement('tr'); thead.appendChild(trh); table.appendChild(thead);
      const tbody = document.createElement('tbody'); table.appendChild(tbody);

      (field.columns || []).forEach(col => {
        const th = document.createElement('th'); th.textContent = col.label || col.id; trh.appendChild(th);
      });

      let selectedIndex = -1;

      function drawTable() {
        tbody.innerHTML = '';
        data.forEach((row, idx) => {
          const tr = document.createElement('tr'); tr.dataset.sel = (idx === selectedIndex) ? '1' : '';
          tr.addEventListener('click', () => { selectedIndex = (selectedIndex === idx ? -1 : idx); drawTable(); if (selectedIndex>=0) loadIntoEditor(idx); });
          (field.columns || []).forEach(col => {
            const td = document.createElement('td'); td.textContent = row[col.id] || ''; tr.appendChild(td);
          });
          tbody.appendChild(tr);
        });
        updateToolbar();
      }

      function clearSelection() { selectedIndex = -1; updateToolbar(); }
      function updateToolbar() {
        const min = Math.max(0, parseInt(field.minRows || 0, 10));
        const max = Math.max(0, parseInt(field.maxRows || 0, 10));
        btnAdd.disabled = (max && data.length >= max);
        btnSave.disabled = (selectedIndex < 0);
        btnDelete.disabled = (selectedIndex < 0) || (min && data.length <= min);
      }

      function loadIntoEditor(i) {
        const rec = data[i] || emptyRow(field);
        for (const c of (field.columns || [])) { const el = editorInputs[c.id]; if (!el) continue; el.value = rec[c.id] || ''; }
        editorState = { ...rec };
        updateToolbar();
      }

      if (Array.isArray(values[field.id]) && values[field.id].length) {
        selectedIndex = 0; loadIntoEditor(0);
      } else {
        const min = Math.max(0, parseInt(field.minRows || 0, 10));
        for (let i=0;i<min;i++) data.push(emptyRow(field));
        drawTable();
      }

      function resetEditor() {
        editorState = emptyRow(field);
        for (const c of (field.columns || [])) { const el = editorInputs[c.id]; if (!el) continue; el.value = ''; }
      }

      btnAdd.addEventListener('click', () => {
        const max = Math.max(0, parseInt(field.maxRows || 0, 10));
        if (max && data.length >= max) return;
        data.push({ ...editorState });
        resetEditor(); clearSelection(); drawTable(); saveState();
        status.textContent = 'Zeile hinzugefügt.';
      });
      btnSave.addEventListener('click', () => {
        if (selectedIndex < 0 || selectedIndex >= data.length) return;
        data[selectedIndex] = { ...editorState };
        drawTable(); saveState();
        status.textContent = 'Änderungen gespeichert.';
      });
      btnDelete.addEventListener('click', () => {
        const min = Math.max(0, parseInt(field.minRows || 0, 10));
        if (selectedIndex < 0) return;
        if (min && data.length <= min) return;
        data.splice(selectedIndex, 1);
        clearSelection(); drawTable(); saveState();
        status.textContent = 'Zeile gelöscht.';
      });

      container.appendChild(card);
      drawTable();
    }

    function emptyRow(field){ const r={}; (field.columns||[]).forEach(c=>r[c.id]=''); return r; }

    function saveState() {
      if (!currentDoc?.docId) return;
      // sanitize vor dem Persistieren
      const cleanValues = sanitizeValues(schema, values);
      window.formSuitePersist.saveState(currentDoc.docId, { schema, values: cleanValues });
    }
    function saveLS(s) { try { localStorage.setItem(STORAGE_KEY, JSON.stringify(s||{})); } catch {} }
    function loadLS() { try { return JSON.parse(localStorage.getItem(STORAGE_KEY)||'null'); } catch { return null; } }

    // ---------- Export (Open Form) ----------
    async function onExportFromOpenForm() {
      if (!currentDoc?.docId) { alert('No active document. Open or pick a DOCX first.'); return; }

      // Guard: check again that bytes are accessible before proceeding.
      const canBytes = await fetchWorkingDocBytes();
      if (!canBytes) { await hardResetOpenForm('no bytes / no permission'); return; }

      const attempt = async () => {
        await ensurePy();
        const docBytes = await fetchWorkingDocBytes(); if (!docBytes) return;

        const state  = await window.formSuitePersist.loadState?.(currentDoc.docId);
        const tagMap = (state?.payload?.CRONOS_PAYLOAD?.tagMap)
                    || (state?.cronos_payload?.tagMap)
                    || (state?.CRONOS_PAYLOAD?.tagMap)
                    || (state?.tagMap)
                    || {};

        // --- sanitize values & tagMap before building payload ---
        const validIds = new Set((schema?.fields || []).map(f => f.id));
        const safeValues = sanitizeValues(schema, values || {});
        const cleanTagMap = sanitizeTagMap(tagMap, validIds);

        const payload = JSON.stringify({
          title: schema?.title || 'Form',
          fields: schema?.fields || [],
          values: safeValues,
          tagMap: cleanTagMap
        });

        const updated = await writeDocVar(docBytes, PAYLOAD_KEY, payload);

        // SDT mapping aus bereinigten Daten
        const sdtMap = {};
        for (const [tag, fieldId] of Object.entries(cleanTagMap)) {
          let v = safeValues?.[fieldId];
          if (v == null) v = '';
          if (typeof v === 'object') { try { v = JSON.stringify(v); } catch { v = String(v); } }
          sdtMap[tag] = String(v);
        }
        const updated2 = await writeSDTs(updated, sdtMap);

        // keep OPFS in sync for the workspace
        await window.formSuitePersist.putBytes?.(currentDoc.docId, updated2);

        if (supportsFS && window.showSaveFilePicker) {
          try {
            const suggested = (currentDoc.name?.replace(/\.docx$/i,'') || 'document') + ' (export).docx';
            const handle = await showSaveFilePicker({
              suggestedName: suggested,
              types: [{ description: 'Word document', accept: { 'application/vnd.openxmlformats-officedocument.wordprocessingml.document': ['.docx'] } }]
            });
            const stream = await handle.createWritable(); await stream.write(updated2); await stream.close();
          } catch (e) { if (e?.name === 'AbortError') return; throw e; }
        } else {
          const blob = new Blob([updated2], { type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' });
          const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
          a.download = (currentDoc?.name||'document').replace(/\.docx$/i,' (export).docx');
          a.click(); setTimeout(() => URL.revokeObjectURL(a.href), 2000);
        }
      };

      try { await attempt(); }
      catch (e) {
        const msg = String(e?.message || e || '');
        if (msg.includes('already been destroyed') || msg.includes('proxy has been destroyed')) {
          await ensurePy(true);
          try { await attempt(); return; } catch (e2) {
            if (e2?.name === 'AbortError' || /export canceled/.test((e2?.message||'').toLowerCase())) return;
            console.error('Export failed after retry:', e2); alert('Export failed: ' + (e2?.message || e2)); return;
          }
        }
        if (e?.name === 'AbortError' || /export canceled/.test((e?.message||'').toLowerCase())) return;
        console.error('Export failed (Open Form):', e); alert('Export failed: ' + (e?.message || e));
      }
    }


    (function() {
      const logo = document.querySelector('header .logo');
      const header = document.querySelector('header .row');
      if (!logo || !header) return;

      let clickCount = 0;
      let clickTimer = null;
      let focusMode = false;

      logo.addEventListener('click', () => {
        clickCount++;
        clearTimeout(clickTimer);
        clickTimer = setTimeout(() => { clickCount = 0; }, 600); // reset if not triple fast

        if (clickCount === 3) {
          clickCount = 0;
          focusMode = !focusMode;

          if (focusMode) {
            // hide all siblings of brand/logo except the current page title
            header.querySelectorAll('a, span.muted').forEach(el => {
              if (!el.closest('.brand')) {
                el.style.display = 'none';
              }
            });
            // navigate to index.html
            if (!location.pathname.endsWith('index.html')) {
              location.href = 'index.html';
            }
          } else {
            // restore all
            header.querySelectorAll('a, span.muted').forEach(el => {
              el.style.display = '';
            });
          }
        }
      });
    })();
  </script>
</body>
</html>
