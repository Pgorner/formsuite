<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Form Suite — Form</title>
  <link rel="icon" href="favicon.ico" type="image/gif" sizes="32x32">
  <link rel="shortcut icon" href="favicon.ico" type="image/gif">
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/themes/material_blue.css">
  <link rel="stylesheet" href="style.css">

<style id="fs-multi-style">
/* Multi-select dropdown (checkbox-style) */
.fs-multi { position: relative; width: 100%; }
.fs-multi-btn {
  width: 100%;
  text-align: left;
  padding: 8px 10px;
  border: 1px solid rgba(0,0,0,.25);
  border-radius: 6px;
  background: #fff;
  cursor: pointer;
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  align-items: center;
  min-height: 38px;
}
.fs-multi-placeholder { color: rgba(0,0,0,.55); }
.fs-multi-chip {
  background: #e6f0ff;
  color: #1a1a1a;
  border: 1px solid #c7dbff;
  border-radius: 12px;
  padding: 2px 8px;
  font-size: 12px;
  line-height: 18px;
  white-space: nowrap;
}

.fs-multi-menu {
  position: absolute;
  left: 0; right: 0;
  margin-top: 6px;
  border: 1px solid rgba(0,0,0,.25);
  border-radius: 6px;
  background: #fff;
  max-height: 240px;
  overflow: auto;
  display: none;
  z-index: 2000;
}
.fs-multi-menu.open { display: block; }
.fs-multi-opt {
  display: flex;
  gap: 10px;
  align-items: center;
  padding: 8px 10px;
  cursor: pointer;
  user-select: none;
}
.fs-multi-opt.selected { background: rgba(0,0,0,.06); }
.fs-multi-opt:hover { background: rgba(0,0,0,.04); }
.fs-multi-opt input[type="checkbox"] { pointer-events: none; }
</style>

</head>
<body>
  <header>
    <div class="row">
      <span class="brand logo-md">
        <img src="logo.gif" alt="Form Suite logo" class="logo" />
        <strong>Form Suite</strong>
      </span>
      <span class="muted">·</span><span class="muted">Form</span>
      <span class="muted">·</span><a href="builder.html">Form Builder</a>
      <span class="muted">·</span><a href="matcher.html">Tag Matcher</a>
      <span class="muted">·</span><a href="rules.html">Rules</a>
      <span class="muted">·</span><a href="extractor.html">Extractor</a>
    </div>
  </header>

  <main>
    <section class="panel">
      <div class="title-row"></div>
      <div class="row" style="margin-top:8px;">
        <span id="docStatus" class="muted">No active document. Open one in the <a href="extractor.html">Extractor</a>.</span>
      </div>
      <div id="permNote" class="note warn" style="display:none; margin-top:10px">
        This DOCX was opened via picker but I don’t have write permission to the original file.
        You can still work from the cached copy, but changes cannot be written back until permission is granted.
        <button id="btnRegrant" class="ghost" style="margin-left:8px">Grant write access</button>
      </div>
    </section>

    <section class="panel">
      <div id="formMount"></div>
    </section>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

  <!-- Canonical single coordination layer -->
  <script src="persistence.js"></script>

  <!-- Canonical rules normalization + visibility eval -->
  <script src="rules-core.js"></script>

  <!-- UI helper -->
  <script src="fs-focus-nav.js"></script>

  <!-- Optional component -->
  <script src="address-autocomplete.js"></script>

  <script>
  'use strict';

  // ============================================================
  // TRACE (debug logs everywhere)
  // ============================================================
  (function ensureTrace() {
    if (typeof window.TRACE === 'function') return;
    const DEBUG = { on: true, seq: 0 };
    const ts = () => new Date().toISOString().slice(11, 23);
    window.TRACE = function TRACE(name, details) {
      const id = ++DEBUG.seq;
      const prefix = `[Form ${ts()} #${id}] ${name}`;
      if (DEBUG.on) console.log(prefix, details ?? '');
      const t0 = (typeof performance !== 'undefined' ? performance.now() : Date.now());
      return {
        step(msg, data) { if (DEBUG.on) console.log(`${prefix}  ↳ ${msg}`, data ?? ''); },
        warn(msg, data) { if (DEBUG.on) console.warn(`${prefix}  ⚠ ${msg}`, data ?? ''); },
        error(msg, err) { if (DEBUG.on) console.error(`${prefix}  ✖ ${msg}`, err); },
        end(extra) {
          if (!DEBUG.on) return;
          const t1 = (typeof performance !== 'undefined' ? performance.now() : Date.now());
          const ms = Math.round((t1 - t0) * 1000) / 1000;
          console.log(`${prefix} done (${ms}ms)`, extra ?? '');
        }
      };
    };
  })();

  // ============================================================
  // DOM
  // ============================================================
  const els = {
    docStatus:  document.getElementById('docStatus'),
    formMount:  document.getElementById('formMount'),
    permNote:   document.getElementById('permNote'),
    btnRegrant: document.getElementById('btnRegrant'),
  };
  function setStatus(html) { els.docStatus.innerHTML = html; }

  // ============================================================
  // Canonical coordination layer
  // ============================================================
  function P() { return window.formSuitePersist; }
  function U() { return window.formSuiteUtils; }

  // Canonical channels (must match the other pages)
  const BC_ACTIVE  = 'fs-active-doc';
  const BC_PAYLOAD = 'fs-payload-v1';

  // ============================================================
  // CANONICAL IN-MEMORY STATE (stable identities; never replaced)
  // ============================================================
  const STATE = {
    doc: null,          // {docId, name}
    schema: null,       // object
    fieldRules: [],     // array
    values: {},         // object (stable identity)
    dirty: false,
    lastSaveAt: 0,
    refreshLock: false,
    refreshPending: false
  };

  // ============================================================
  // Local schema fallback (ONLY when no active doc)
  // ============================================================
  const LS_SCHEMA_FALLBACK = 'FORM_SCHEMA_V1';
  function saveLocalSchemaFallback(s) { try { localStorage.setItem(LS_SCHEMA_FALLBACK, JSON.stringify(s || {})); } catch {} }
  function loadLocalSchemaFallback()  { try { return JSON.parse(localStorage.getItem(LS_SCHEMA_FALLBACK) || 'null'); } catch { return null; } }

  // ============================================================
  // helpers: identity-stable merge
  // ============================================================
  function clearAndAssignObject(target, src) {
    if (!target || typeof target !== 'object') return;
    for (const k of Object.keys(target)) delete target[k];
    if (src && typeof src === 'object') {
      for (const k of Object.keys(src)) target[k] = src[k];
    }
  }

  function deepCloneSafe(v) {
    try {
      if (typeof structuredClone === 'function') return structuredClone(v);
    } catch {}
    try { return JSON.parse(JSON.stringify(v)); } catch { return v; }
  }

  // ============================================================
  // TABLE helpers (canonical data normalization)
  // ============================================================
  function emptyRow(field){
    const r = {};
    (field.columns || []).forEach(c => {
      const isMultiSelectCol = (String(c?.type) === 'select' && !!c?.multiple);
      r[String(c.id || '')] = isMultiSelectCol ? [] : '';
    });
    return r;
  }


  // ============================================================
  // TABLE % calcs (row-level)
  // ============================================================
  function computeTableRowCalcs(tableField, rowObj) {
    if (!tableField || !rowObj) return;
    const cols = Array.isArray(tableField.columns) ? tableField.columns : [];
    cols.forEach(col => {
      if (String(col?.type) !== 'number') return;
      const calc = (col && typeof col.calc === 'object' && col.calc) ? col.calc : null;
      if (!calc) return;
      const sources = Array.isArray(calc.sources) ? calc.sources.map(String).filter(Boolean) : [];
      const totalOf = String(calc.totalOf || '').trim();
      const decimals = (calc.decimals != null) ? (calc.decimals|0) : 1;

      // computed mode only (sources selected)
      if (sources.length) {
        let sum = 0;
        let hasAny = false;
        sources.forEach(sid => {
          const n = parseScalarNumber(rowObj[sid]);
          if (n != null) { sum += n; hasAny = true; }
        });

        let out = '';
        if (totalOf) {
          const denom = resolveTotalForTableRef(totalOf, rowObj);
          if (hasAny && denom != null && denom !== 0) out = formatPercentString((sum / denom) * 100.0, decimals);
          else out = '';
        } else {
          out = hasAny ? String(sum) : '';
        }
        rowObj[String(col.id)] = out;
      }
    });
  }


  function rowIsEmpty(field, row) {
    try {
      return !(field.columns || []).some(c => {
        const cid = String(c?.id || '');
        if (!cid) return false;

        const isMulti = (String(c?.type) === 'select' && !!c?.multiple);
        const v = row?.[cid];

        if (isMulti) return Array.isArray(v) ? v.length > 0 : String(v ?? '').trim() !== '';
        return String(v ?? '').trim() !== '';
      });
    } catch {
      return true;
    }
  }

  function normalizeTableArray(field, arr) {
    const base = emptyRow(field);
    const min = Math.max(0, parseInt(field.minRows || 0, 10));
    const max = Math.max(0, parseInt(field.maxRows || 0, 10));

    let out = Array.isArray(arr) ? arr.slice() : [];

    // Ensure shape + coerce per-column types (esp. multi-select -> array)
    out = out.map(r0 => {
      const r = { ...base, ...(r0 || {}) };

      (field.columns || []).forEach(c => {
        const cid = String(c.id || '');
        if (!cid) return;

        const isMulti = (String(c?.type) === 'select' && !!c?.multiple);
        if (!isMulti) {
          if (r[cid] == null) r[cid] = '';
          return;
        }

        // Multi-select cell: ensure array-of-strings
        const v = r[cid];

        if (Array.isArray(v)) {
          r[cid] = v.map(String).filter(s => s !== '');
        } else if (typeof v === 'string') {
          const s = v.trim();
          if (!s) r[cid] = [];
          else if (s.startsWith('[')) {
            try {
              const parsed = JSON.parse(s);
              r[cid] = Array.isArray(parsed) ? parsed.map(String).filter(Boolean) : [];
            } catch {
              r[cid] = s.split(',').map(x => x.trim()).filter(Boolean);
            }
          } else {
            r[cid] = s.split(',').map(x => x.trim()).filter(Boolean);
          }
        } else if (v == null) {
          r[cid] = [];
        } else {
          r[cid] = [String(v)].filter(Boolean);
        }

        // Optional: enforce allowed options only
        const opts = Array.isArray(c.options) ? c.options.map(String) : [];
        if (opts.length) {
          const ok = new Set(opts);
          r[cid] = r[cid].filter(x => ok.has(String(x)));
        }
      });

      return r;
    });

    // Remove fully empty rows (canonical behavior: draft/placeholder rows are not data)
    out = out.filter(r => !rowIsEmpty(field, r));

    // Enforce max (drop extra trailing rows, but keep earliest rows)
    if (max && out.length > max) out = out.slice(0, max);

    // Enforce min by padding (schema constraint)
    while (out.length < min) out.push({ ...base });

    return out;
  }

  function normalizeAllTablesInValues(schemaObj, vals) {
    try {
      if (!schemaObj || !Array.isArray(schemaObj.fields) || !vals || typeof vals !== 'object') return vals;
      for (const f of (schemaObj.fields || [])) {
        if (String(f?.type) !== 'table') continue;
        const fid = String(f.id || '');
        if (!fid) continue;
        vals[fid] = normalizeTableArray(f, vals[fid]);
      }
      return vals;
    } catch {
      return vals;
    }
  }

  // ============================================================
  // Sanitizer (canonical: utils + table enforcement)
  // ============================================================
  function sanitizeValues(schemaObj, vals) {
    const tr = TRACE('sanitizeValues', {
      hasUtils: !!U(),
      hasSanitizer: !!U()?.sanitizeValues,
      hasSchema: !!schemaObj
    });

    try {
      const inVals = (vals && typeof vals === 'object') ? vals : {};

      // Preserve non-scalar values (arrays/objects) that are part of the schema
      const preservedNonScalars = {};
      if (schemaObj && Array.isArray(schemaObj.fields)) {
        (schemaObj.fields || []).forEach(f => {
          const fid = String(f?.id || '');
          if (!fid) return;

          const t = String(f?.type || '');
          const isMultiSelect = (t === 'select' && !!f?.multiple);
          const isMultiChoice = (t === 'multichoice');
          const isTable       = (t === 'table');
          const isAddress     = (t === 'address');

          if (!(isTable || isMultiChoice || isMultiSelect || isAddress)) return;

          const v = inVals[fid];
          if (isAddress) {
            if (v && typeof v === 'object' && !Array.isArray(v)) preservedNonScalars[fid] = v;
            return;
          }
          if (Array.isArray(v)) preservedNonScalars[fid] = v;
        });
      }

      let out = inVals;
      if (U()?.sanitizeValues) out = U().sanitizeValues(schemaObj, inVals);
      if (!out || typeof out !== 'object') out = {};

      // Restore preserved non-scalars if missing after sanitize
      for (const fid of Object.keys(preservedNonScalars)) {
        const pv = preservedNonScalars[fid];
        if (Array.isArray(pv)) {
          if (!Array.isArray(out[fid])) out[fid] = pv;
        } else {
          if (!(out[fid] && typeof out[fid] === 'object' && !Array.isArray(out[fid]))) out[fid] = pv;
        }
      }

      // Canonical: table arrays are always normalized and schema-enforced.
      out = normalizeAllTablesInValues(schemaObj, out);

      tr.end({
        keys: Object.keys(out || {}).length,
        preservedNonScalars: Object.keys(preservedNonScalars).length
      });
      return out;
    } catch (e) {
      tr.warn('sanitize fallback', e);
      const fallback = (vals && typeof vals === 'object') ? vals : {};
      tr.end('fallback');
      return normalizeAllTablesInValues(schemaObj, fallback);
    }
  }

  // ============================================================
  // Canonical setters (all UI writes go through these)
  // ============================================================
  function markDirty() { STATE.dirty = true; }

  function setValue(fid, v) {
    STATE.values[String(fid || '')] = v;
    markDirty();
    scheduleSaveValues();
    try { if (typeof window.recomputePercentCalcs === 'function') window.recomputePercentCalcs({ source: String(fid||'') }); } catch {}
    try { window.dispatchEvent(new CustomEvent('fs-values-changed', { detail: { fid: String(fid||'') } })); } catch {}
  }

  function getValue(fid) {
    return STATE.values[String(fid || '')];
  }

  // ============================================================
  // % helpers (number calc)
  // ============================================================
  function stripPercent(v) {
    if (v == null) return '';
    const s = String(v).trim();
    return s.endsWith('%') ? s.slice(0, -1).trim() : s;
  }
  function parseScalarNumber(v) {
    if (v == null || v === '') return null;
    if (typeof v === 'number' && !isNaN(v)) return v;
    const s = stripPercent(v);
    const n = parseFloat(String(s).replace(',', '.'));
    return isNaN(n) ? null : n;
  }
  function formatPercentString(n, decimals) {
    if (n == null || isNaN(n)) return '';
    const d = Math.max(0, Math.min(6, (decimals|0)));
    let s = Number(n).toFixed(d);
    // trim trailing zeros
    if (d > 0) s = s.replace(/\.0+$/, '').replace(/(\.\d*?)0+$/, '$1');
    return s + '%';
  }
  function isPercentString(v) {
    return (typeof v === 'string') && v.trim().endsWith('%');
  }
  function resolveTotalForTableRef(totalOfRef, rowObj) {
    const ref = String(totalOfRef || '').trim();
    if (!ref) return null;
    const m = ref.match(/^(field|col)\s*:\s*(.+)$/i);
    if (m) {
      const kind = String(m[1]).toLowerCase();
      const id = String(m[2]).trim();
      if (!id) return null;
      if (kind === 'field') return parseScalarNumber(getValue(id));
      if (kind === 'col') return parseScalarNumber(rowObj ? rowObj[id] : null);
      return null;
    }
    // backward/loose: try external field first, else column
    const asField = parseScalarNumber(getValue(ref));
    if (asField != null) return asField;
    return parseScalarNumber(rowObj ? rowObj[ref] : null);
  }


  function ensureTableValue(field) {
    const fid = String(field?.id || '');
    if (!fid) return [];
    if (!Array.isArray(STATE.values[fid])) STATE.values[fid] = [];
    // Normalize immediately so UI always sees canonical rows (no empties)
    STATE.values[fid] = normalizeTableArray(field, STATE.values[fid]);
    return STATE.values[fid];
  }

  // ============================================================
  // Permission Banner (canonical via persistence)
  // ============================================================
  async function updateWriteAccessBanner({ tryPrompt = false } = {}) {
    const tr = TRACE('updateWriteAccessBanner', { tryPrompt, docId: STATE.doc?.docId });
    try {
      if (!('showSaveFilePicker' in window)) { els.permNote.style.display = 'none'; tr.end('unsupported'); return 'unsupported'; }
      if (!STATE.doc?.docId)                 { els.permNote.style.display = 'none'; tr.end('no-doc'); return 'no-doc'; }

      const h = await P()?.getHandle?.(STATE.doc.docId);
      if (!h?.queryPermission) { els.permNote.style.display = 'none'; tr.end('no-handle'); return 'no-handle'; }

      let p = await h.queryPermission({ mode: 'readwrite' });
      if (p !== 'granted' && tryPrompt) {
        try { p = await h.requestPermission({ mode: 'readwrite' }) || p; } catch {}
      }

      els.permNote.style.display = (p === 'granted') ? 'none' : 'block';
      tr.end({ perm: p });
      return p || 'denied';
    } catch (e) {
      tr.warn('failed (showing banner)', e);
      els.permNote.style.display = 'block';
      tr.end('error');
      return 'error';
    }
  }

  els.btnRegrant?.addEventListener('click', async () => {
    const tr = TRACE('btnRegrant click');
    const p = await updateWriteAccessBanner({ tryPrompt: true });
    tr.step('perm result', p);
    if (p === 'granted') await refreshFromCanonical({ reason: 'regrant' });
    tr.end();
  });

  // ============================================================
  // Canonical save (workspace only; stable identities; deterministic)
  // ============================================================
  let __saveTimer = null;

  function scheduleSaveValues() {
    clearTimeout(__saveTimer);
    __saveTimer = setTimeout(saveValuesNow, 150);
  }

  function flushSaveNow() {
    try {
      clearTimeout(__saveTimer);
      __saveTimer = null;
      saveValuesNow();
    } catch {}
  }

  function saveValuesNow() {
    const tr = TRACE('saveValuesNow', { docId: STATE.doc?.docId, dirty: STATE.dirty });
    try {
      if (!STATE.doc?.docId) { tr.end('no-doc'); return; }
      if (!STATE.schema || !Array.isArray(STATE.schema.fields)) {
        const snapshot0 = deepCloneSafe(STATE.values);
        const clean0 = sanitizeValues(STATE.schema || { title:'Form', fields:[] }, snapshot0);
        clearAndAssignObject(STATE.values, clean0);
        P()?.saveState?.(STATE.doc.docId, { values: clean0 });
        STATE.dirty = false;
        STATE.lastSaveAt = Date.now();
        tr.end({ keys: Object.keys(clean0||{}).length, schema: 'missing' });
        return;
      }

      const snap = deepCloneSafe(STATE.values);
      const clean = sanitizeValues(STATE.schema, snap);
      clearAndAssignObject(STATE.values, clean);
      P()?.saveState?.(STATE.doc.docId, { values: clean });

      STATE.dirty = false;
      STATE.lastSaveAt = Date.now();
      tr.end({ keys: Object.keys(clean||{}).length });
    } catch (e) {
      tr.error('failed', e);
      tr.end('error');
    }
  }

  window.addEventListener('beforeunload', () => {
    try {
      flushSaveNow();
      if (!STATE.doc?.docId && STATE.schema) saveLocalSchemaFallback(STATE.schema);
    } catch {}
  });

  // ============================================================
  // Canonical hydration: persistence helper only
  // ============================================================
  async function hydrateWorkspaceIfEmpty(docId) {
    const tr = TRACE('hydrateWorkspaceIfEmpty', { docId });
    try {
      if (!docId) { tr.end('no-docId'); return false; }
      const did = await P()?.hydrateFromDocxIfEmpty?.(docId);
      tr.end({ didHydrate: !!did });
      return !!did;
    } catch (e) {
      tr.warn('failed', e);
      tr.end('error');
      return false;
    }
  }

  // ============================================================
  // Canonical normalization (single workflow)
  // ============================================================
  function normalizeRulesForCurrentState(st) {
    const tr = TRACE('normalizeRulesForCurrentState', {
      docId: STATE.doc?.docId,
      hasSchema: !!st?.schema,
      rulesLen: Array.isArray(st?.rules) ? st.rules.length : null,
      fieldRulesLen: Array.isArray(st?.fieldRules) ? st.fieldRules.length : null,
    });

    try {
      const hasDeriver = (typeof window.deriveNormalizedRulesForDoc === 'function');
      if (!hasDeriver) { tr.end('no-deriver'); return { fieldRules: Array.isArray(st?.fieldRules) ? st.fieldRules : [] }; }

      const baseline = {
        flat: Array.isArray(st?.headingsFlat) ? st.headingsFlat : (Array.isArray(st?.headings) ? st.headings : []),
        tree: Array.isArray(st?.headingsTree) ? st.headingsTree : [],
      };

      const schemaForDerive = st?.schema || STATE.schema || { title: 'Form', fields: [] };

      const normalized = window.deriveNormalizedRulesForDoc(st || {}, schemaForDerive, baseline) || {};
      const nextHeadingRules = Array.isArray(normalized.headingRules)
        ? normalized.headingRules
        : (Array.isArray(st?.rules) ? st.rules : []);
      const nextFieldRules = Array.isArray(normalized.fieldRules)
        ? normalized.fieldRules
        : (Array.isArray(st?.fieldRules) ? st.fieldRules : []);

      const same = (a,b) => { try { return JSON.stringify(a||[]) === JSON.stringify(b||[]); } catch { return false; } };
      const curHeading = Array.isArray(st?.rules) ? st.rules : [];
      const curField   = Array.isArray(st?.fieldRules) ? st.fieldRules : [];

      if (STATE.doc?.docId && (!same(curHeading, nextHeadingRules) || !same(curField, nextFieldRules))) {
        tr.step('persist normalized rules (replace)', {
          headingChanged: !same(curHeading, nextHeadingRules),
          fieldChanged: !same(curField, nextFieldRules),
        });
        try { Promise.resolve(P()?.saveState?.(STATE.doc.docId, { rules: nextHeadingRules, fieldRules: nextFieldRules })); } catch {}
      }

      tr.end({ nextFieldRulesLen: nextFieldRules.length });
      return { fieldRules: nextFieldRules };
    } catch (e) {
      tr.warn('failed', e);
      tr.end('error');
      return { fieldRules: Array.isArray(st?.fieldRules) ? st.fieldRules : [] };
    }
  }

  // ============================================================
  // Canonical refresh from workspace (override-safe; does not break identities)
  // ============================================================
  async function refreshFromCanonical({ reason = '' } = {}) {
    const tr = TRACE('refreshFromCanonical', { reason });

    if (STATE.refreshLock) {
      STATE.refreshPending = true;
      tr.end('coalesced');
      return;
    }

    STATE.refreshLock = true;
    try {
      if (STATE.dirty) flushSaveNow();

      const meta = await P()?.getActiveDocMeta?.();
      STATE.doc = (meta && meta.docId) ? meta : null;

      if (!STATE.doc?.docId) {
        await hardResetOpenForm(`no active doc${reason ? ' ('+reason+')' : ''}`);
        tr.end('no-doc');
        return;
      }

      await hydrateWorkspaceIfEmpty(STATE.doc.docId);

      const st = await P()?.loadState?.(STATE.doc.docId);

      STATE.schema = st?.schema || null;

      const nextValues = (st?.values && typeof st.values === 'object') ? st.values : {};
      clearAndAssignObject(STATE.values, nextValues);

      normalizeAllTablesInValues(STATE.schema, STATE.values);

      const norm = normalizeRulesForCurrentState(st);
      STATE.fieldRules = norm.fieldRules || [];

      setStatus(`Active DOCX: <span class="kbd">${STATE.doc.name || STATE.doc.docId}</span>${STATE.schema ? '' : ' — <span class="muted">no schema yet</span>'}`);

      await updateWriteAccessBanner();

      const ae = document.activeElement;
      const isEditing = !!(ae && (ae.tagName === 'INPUT' || ae.tagName === 'TEXTAREA' || ae.tagName === 'SELECT' || ae.tagName === 'BUTTON'));

      if (!isEditing) {
        renderForm();
      } else {
        try { applyFieldVisibility(); } catch {}
        try { if (typeof window.recomputeDatediffs === 'function') window.recomputeDatediffs(); } catch {}
      }

      tr.end({ isEditing, hasSchema: !!STATE.schema, valuesKeys: Object.keys(STATE.values||{}).length });
    } catch (e) {
      tr.error('failed', e);
      tr.end('error');
    } finally {
      STATE.refreshLock = false;
      if (STATE.refreshPending) {
        STATE.refreshPending = false;
        refreshFromCanonical({ reason: 'pending' });
      }
    }
  }

  async function hardResetOpenForm(reason = '') {
    const tr = TRACE('hardResetOpenForm', { reason });

    STATE.doc = null;
    STATE.schema = null;
    STATE.fieldRules = [];
    clearAndAssignObject(STATE.values, {});
    STATE.dirty = false;

    els.permNote.style.display = 'none';
    setStatus(`No active document${reason ? ` (${reason})` : ''}. Open one in the <a href="extractor.html">Extractor</a>.`);

    if (els.formMount) {
      els.formMount.innerHTML = `<div class="muted">No schema found. Create one in the <a href="builder.html">Builder</a>.</div>`;
    }
    tr.end();
  }

  // ============================================================
  // Canonical listeners
  // ============================================================
  function installCanonicalListeners() {
    const tr = TRACE('installCanonicalListeners');

    try {
      const bcActive = new BroadcastChannel(BC_ACTIVE);
      bcActive.addEventListener('message', (ev) => {
        const m = ev?.data || {};
        if (!m?.type) return;

        if (m.type === 'active:clear') {
          TRACE('BC_ACTIVE', m);
          refreshFromCanonical({ reason: 'active:clear' });
          return;
        }
        if ((m.type === 'active:set' || m.type === 'active:updated') && m.docId) {
          TRACE('BC_ACTIVE', m);
          refreshFromCanonical({ reason: m.type });
        }
      });
      tr.step('listening', { channel: BC_ACTIVE });
    } catch (e) {
      tr.warn('BC_ACTIVE failed', e);
    }

    try {
      const bcPayload = new BroadcastChannel(BC_PAYLOAD);
      bcPayload.addEventListener('message', (ev) => {
        const msg = ev?.data || {};
        if (msg?.t !== 'payload') return;

        const docId = msg.docId;
        if (!docId || docId !== STATE.doc?.docId) return;

        const patch = msg.patch || {};
        const touches =
          ('schema' in patch) ||
          ('rules' in patch) ||
          ('fieldRules' in patch) ||
          ('values' in patch) ||
          ('tagMap' in patch);

        if (!touches) return;

        TRACE('BC_PAYLOAD', { docId, keys: Object.keys(patch || {}) });
        refreshFromCanonical({ reason: 'payload-patch' });
      });
      tr.step('listening', { channel: BC_PAYLOAD });
    } catch (e) {
      tr.warn('BC_PAYLOAD failed', e);
    }

    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible') refreshFromCanonical({ reason: 'visible' });
      if (document.visibilityState === 'hidden') flushSaveNow();
    });
    window.addEventListener('focus', () => refreshFromCanonical({ reason: 'focus' }));

    tr.end();
  }

  // ============================================================
  // Init
  // ============================================================
  init().catch((e) => console.error('[Form] init failed', e));

  async function init() {
    const tr = TRACE('init');

    if (!P()) {
      tr.error('persistence layer missing', new Error('window.formSuitePersist not found'));
      await hardResetOpenForm('persistence missing');
      tr.end('fatal');
      return;
    }

    installCanonicalListeners();

    STATE.doc = await P()?.getActiveDocMeta?.();
    if (STATE.doc?.docId) {
      await refreshFromCanonical({ reason: 'init' });
    } else {
      STATE.schema = loadLocalSchemaFallback();
      clearAndAssignObject(STATE.values, {});
      STATE.fieldRules = [];
      renderForm();
    }

    tr.end();
  }

  // ============================================================
  // Date helpers (datediff)
  // ============================================================
  function diffInDays(a, b) {
    const A = new Date(a.getFullYear(), a.getMonth(), a.getDate());
    const B = new Date(b.getFullYear(), b.getMonth(), b.getDate());
    return Math.floor((B - A) / (24 * 60 * 60 * 1000));
  }
  function diffInMonths(a, b) {
    let months = (b.getFullYear() - a.getFullYear()) * 12 + (b.getMonth() - a.getMonth());
    if (b.getDate() < a.getDate()) months -= 1;
    return months;
  }
  function diffInYears(a, b) {
    let years = b.getFullYear() - a.getFullYear();
    const beforeAnniversary =
      (b.getMonth() < a.getMonth()) ||
      (b.getMonth() === a.getMonth() && b.getDate() < a.getDate());
    if (beforeAnniversary) years -= 1;
    return years;
  }

  function createPrettyDatepicker(input, extraOpts = {}) {
    if (!document.getElementById('fp-zindex-fix')) {
      const st = document.createElement('style');
      st.id = 'fp-zindex-fix';
      st.textContent = `
        .flatpickr-calendar { z-index: 50; }
        .flatpickr-wrapper { position: relative; }
      `;
      document.head.appendChild(st);
    }

    const baseOpts = {
      dateFormat: 'Y-m-d',
      altInput: true,
      altFormat: 'D, j M Y',
      allowInput: false,
      clickOpens: true,
      disableMobile: true,
      static: true,
      wrap: false,
      monthSelectorType: 'dropdown',
      weekNumbers: true,
      prevArrow: '‹',
      nextArrow: '›',
      onReady: (_sel, _str, inst) => {
        if (inst.altInput) {
          inst.altInput.readOnly = true;
          inst.altInput.tabIndex = 0;
          inst.altInput.style.pointerEvents = 'auto';
          const wrap = inst.altInput.parentElement;
          if (wrap && !wrap.classList.contains('flatpickr-wrapper')) {
            wrap.classList.add('flatpickr-wrapper');
            if (getComputedStyle(wrap).position === 'static') wrap.style.position = 'relative';
          }
        }
      }
    };

    return flatpickr(input, { ...baseOpts, ...extraOpts });
  }

  function slugifyMc(s) {
    return String(s || '')
      .normalize('NFKD')
      .replace(/[\u0300-\u036f]/g, '')
      .replace(/[^a-zA-Z0-9]+/g, '_')
      .replace(/^_+|_+$/g, '')
      .toLowerCase();
  }
  function mcExtraKey(fieldId, optionValue, extraId) {
    return `${fieldId}__${slugifyMc(optionValue)}__${slugifyMc(extraId)}`;
  }

  // ============================================================
  // Field visibility (UI), using rules-core evaluateFieldRulesToVisibility
  // ============================================================
  function applyFieldVisibility() {
    const tr = TRACE('applyFieldVisibility', { hasSchema: !!STATE.schema, fields: STATE.schema?.fields?.length, rules: STATE.fieldRules?.length });
    try {
      if (!STATE.schema || !Array.isArray(STATE.schema.fields)) { tr.end('no-schema'); return; }
      if (typeof window.evaluateFieldRulesToVisibility !== 'function') { tr.end('no-evaluator'); return; }

      const visMap = window.evaluateFieldRulesToVisibility(STATE.schema, STATE.values || {}, STATE.fieldRules || []);

      const clearDisabled = (el) => {
        el.style.opacity = '';
        el.style.pointerEvents = '';
        el.removeAttribute('aria-disabled');
        el.querySelectorAll('input,select,textarea,button').forEach(i => { try { i.disabled = false; } catch {} });
      };

      document.querySelectorAll('.field[data-field-id]').forEach(node => { node.style.display = ''; clearDisabled(node); });
      document.querySelectorAll('.mc-item[data-opt-id]').forEach(node => { node.style.display = ''; clearDisabled(node); });

      const esc = (window.CSS && CSS.escape)
        ? CSS.escape
        : (s => String(s)
          .replace(/\\/g,'\\\\')
          .replace(/"/g,'\\"')
          .replace(/\]/g,'\\]')
          .replace(/\[/g,'\\[')
          .replace(/\(/g,'\\(')
          .replace(/\)/g,'\\)')
          .replace(/\./g,'\\.')
        );

      const deselectMcItem = (mcEl) => {
        const cb = mcEl.querySelector('input[type="checkbox"][data-mc="1"]');
        if (!cb) return;
        const fid = cb.name;
        const optVal = cb.value;

        if (cb.checked) cb.checked = false;
        const arr = Array.isArray(STATE.values[fid]) ? STATE.values[fid].map(String) : [];
        STATE.values[fid] = arr.filter(v => v !== String(optVal));
        markDirty();
        scheduleSaveValues();
      };

      const deselectFieldWrapper = (wrapEl) => {
        const fid = wrapEl?.dataset?.fieldId || '';
        if (!fid) return;

        const fld = (STATE.schema?.fields || []).find(f => String(f.id) === String(fid));
        const t = String(fld?.type || '').toLowerCase();

        // CRITICAL: do not clear structured table data on hide/disable.
        if (t === 'table') return;

        if (t === 'multichoice') {
          wrapEl.querySelectorAll('input[type="checkbox"][data-mc="1"]').forEach(cb => { cb.checked = false; });
          STATE.values[fid] = [];
          markDirty();
          scheduleSaveValues();
          return;
        }

        if (t === 'select') {
          // single-select only; multi uses fs-multi
          const sel = wrapEl.querySelector('select');
          if (sel) { sel.value = ''; STATE.values[fid] = ''; markDirty(); scheduleSaveValues(); }
          return;
        }

        if (t === 'text') {
          const inp = wrapEl.querySelector('input[type="text"]:not([data-type="date"])');
          if (inp) { inp.value = ''; STATE.values[fid] = ''; markDirty(); scheduleSaveValues(); }
          return;
        }

        if (t === 'number') {
          const inp = wrapEl.querySelector('input[type="number"]');
          if (inp) { inp.value = ''; STATE.values[fid] = ''; markDirty(); scheduleSaveValues(); }
          return;
        }

        if (t === 'date') {
          const inp = wrapEl.querySelector('input[data-type="date"]');
          if (inp) {
            try { if (inp._flatpickr) inp._flatpickr.clear(); } catch {}
            inp.value = '';
            STATE.values[fid] = '';
            markDirty();
            scheduleSaveValues();
          }
        }
      };

      for (const id of Object.keys(visMap || {})) {
        const dir = visMap[id];

        if (typeof id === 'string' && id.includes('__opt__')) {
          document.querySelectorAll(`.mc-item[data-opt-id="${esc(id)}"]`).forEach(el => {
            deselectMcItem(el);
            if (dir === 'HIDE') {
              el.style.display = 'none';
            } else {
              el.style.display = '';
              el.style.opacity = '0.5';
              el.style.pointerEvents = 'none';
              el.setAttribute('aria-disabled', 'true');
              el.querySelectorAll('input,select,textarea,button').forEach(i => { try { i.disabled = true; } catch {} });
            }
          });
          continue;
        }

        document.querySelectorAll(`.field[data-field-id="${esc(id)}"]`).forEach(el => {
          deselectFieldWrapper(el);
          if (dir === 'HIDE') {
            el.style.display = 'none';
          } else {
            el.style.display = '';
            el.style.opacity = '0.5';
            el.style.pointerEvents = 'none';
            el.setAttribute('aria-disabled', 'true');
            el.querySelectorAll('input,select,textarea,button').forEach(i => { try { i.disabled = true; } catch {} });
          }
        });
      }

      tr.end({ visKeys: Object.keys(visMap || {}).length });
    } catch (e) {
      tr.warn('failed (UI kept resilient)', e);
      tr.end('error');
    }
  }

  // ============================================================
  // Safe option normalization (fix: avoid [object Object] in selects)
  // ============================================================
  function normOptions(field){
    const raw = (field && field.options) || [];
    return (Array.isArray(raw) ? raw : []).map(o => {
      if (o && typeof o === "object") {
        const value = (o.value ?? o.id ?? o.key ?? o.code ?? String(o));
        const label = (o.label ?? o.text ?? o.name ?? String(value));
        return { value:String(value), label:String(label) };
      }
      return { value:String(o), label:String(o) };
    });
  }

  // ==========================================
  // Multi-select UI (shared by fields + table columns)
  // ==========================================
  function createFsMultiSelectControl({ fid = null, options = [], initialSelected = [], placeholder = '— select —', onChange = null }) {
    const opts = (Array.isArray(options) ? options : []).map(o => {
      if (o && typeof o === 'object') {
        const value = String(o.value ?? o.id ?? o.key ?? o.code ?? o);
        const label = String(o.label ?? o.text ?? o.name ?? value);
        return { value, label };
      }
      return { value: String(o), label: String(o) };
    });

    const root = document.createElement('div');
    root.className = 'fs-multi';
    if (fid != null) root.dataset.fid = String(fid);

    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'fs-multi-btn';
    btn.setAttribute('aria-haspopup', 'listbox');
    btn.setAttribute('aria-expanded', 'false');

    const menu = document.createElement('div');
    menu.className = 'fs-multi-menu';
    menu.setAttribute('role', 'listbox');

    // Optional hidden input (keeps compatibility with form.elements and older code paths)
    let hidden = null;
    if (fid != null) {
      hidden = document.createElement('input');
      hidden.type = 'hidden';
      hidden.id = String(fid);
      hidden.name = String(fid);
    }

    let selected = Array.isArray(initialSelected) ? initialSelected.map(String) : [];
    const labelByValue = new Map(opts.map(o => [o.value, o.label]));

    const normalizeSelected = () => {
      const ok = new Set(opts.map(o => o.value));
      selected = selected.map(String).filter(v => ok.has(v));
    };

    const updateBtnText = () => {
      normalizeSelected();
      btn.innerHTML = '';
      if (!selected.length) {
        const ph = document.createElement('span');
        ph.className = 'fs-multi-placeholder';
        ph.textContent = placeholder;
        btn.appendChild(ph);
      } else {
        selected
          .map(v => labelByValue.get(v) ?? v)
          .forEach(l => {
            const chip = document.createElement('span');
            chip.className = 'fs-multi-chip';
            chip.textContent = String(l);
            btn.appendChild(chip);
          });
      }
    };

    const syncMenu = () => {
      const nodes = menu.querySelectorAll('.fs-multi-opt');
      nodes.forEach(n => {
        const v = String(n.dataset.value || '');
        const isSel = selected.includes(v);
        n.classList.toggle('selected', isSel);
        const cb = n.querySelector('input[type="checkbox"]');
        if (cb) cb.checked = isSel;
      });
    };

    const commit = (fire = true) => {
      normalizeSelected();
      updateBtnText();
      syncMenu();
      if (hidden) hidden.value = selected.join(',');
      if (fire && typeof onChange === 'function') onChange(selected.slice());
    };

    opts.forEach(({ value, label }) => {
      const row = document.createElement('div');
      row.className = 'fs-multi-opt';
      row.dataset.value = value;

      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.tabIndex = -1;

      const lab = document.createElement('span');
      lab.textContent = label;

      row.appendChild(cb);
      row.appendChild(lab);

      row.addEventListener('click', (evt) => {
        evt.preventDefault();
        evt.stopPropagation();

        const idx = selected.indexOf(value);
        if (idx >= 0) selected.splice(idx, 1);
        else selected.push(value);

        commit(true);
      });

      menu.appendChild(row);
    });

    btn.addEventListener('click', (e) => {
      e.preventDefault();
      const open = !menu.classList.contains('open');
      menu.classList.toggle('open', open);
      btn.setAttribute('aria-expanded', open ? 'true' : 'false');
      if (open) syncMenu();
    });

    document.addEventListener('click', (e) => {
      if (!root.contains(e.target)) {
        menu.classList.remove('open');
        btn.setAttribute('aria-expanded', 'false');
      }
    });

    root.appendChild(btn);
    root.appendChild(menu);
    if (hidden) root.appendChild(hidden);

    // initial paint (no onChange spam)
    commit(false);

    const api = {
      el: root,
      setSelected(next, fire = false) {
        selected = Array.isArray(next) ? next.map(String) : [];
        commit(!!fire);
      },
      getSelected() {
        normalizeSelected();
        return selected.slice();
      }
    };

    // Attach for external sync (table editor)
    root.dataset.type = 'multiselect';
    root.__fsMultiApi = api;

    return api;
  }

  // ============================================================
  // Render Form
  // ============================================================
  function renderForm() {
    const tr = TRACE('renderForm', { hasSchema: !!STATE.schema, fields: STATE.schema?.fields?.length, docId: STATE.doc?.docId });

    (function injectMcStyles() {
      const ID = 'mc-caret-styles';
      if (document.getElementById(ID)) return;
      const s = document.createElement('style');
      s.id = ID;
      s.textContent = `
        .mc-item { position: relative; }
        .mc-toggle { all: unset; position: absolute; top: 10px; right: 10px; display: inline-flex; align-items: center; justify-content: center; cursor: pointer; line-height: 1; padding: 0; margin: 0; pointer-events: auto; }
        .mc-toggle:focus-visible { outline: 2px solid var(--focus, #2563eb); outline-offset: 2px; border-radius: 4px; }
        .mc-caret { width: 14px; height: 14px; transition: transform .18s ease, opacity .18s ease; opacity: .85; transform: rotate(0deg); display: block; }
        .mc-caret.open { transform: rotate(90deg); }
        .mc-extras { display: none; height: 0; grid-template-columns: 1fr; row-gap: 8px; padding-bottom: 2px; width: 100%; }
        .mc-option-label{ display:grid; grid-template-columns:auto 1fr; column-gap:8px; align-items:center; cursor:pointer; line-height:1.25; }
        .mc-option-label > span{ white-space:normal; word-break:break-word; }
        .mc-option-checkbox{ align-self:center; margin-top:0; transform:none; }
      `;
      document.head.appendChild(s);
    })();

    const mount = els.formMount;
    mount.innerHTML = '';

    if (!STATE.schema || !Array.isArray(STATE.schema.fields) || !STATE.schema.fields.length) {
      mount.innerHTML = `<div class="muted">No schema found. Create one in the <a href="builder.html">Builder</a>.</div>`;
      tr.end('no-schema');
      return;
    }

    // Canonical: tables in values are always normalized BEFORE UI mount.
    normalizeAllTablesInValues(STATE.schema, STATE.values);

    const form = document.createElement('form');
    form.classList.add('form-grid');

    if (STATE.schema.title) {
      const h = document.createElement('h4');
      h.textContent = STATE.schema.title;
      h.style.gridColumn = '1 / -1';
      form.appendChild(h);
    }

    const inputRefs = {};
    const mcDateRefs = {};
    const datediffRefs = [];
    const guardPairs = [];

    function getDateForField(fid) {
      const el = inputRefs[fid];
      if (!el) return null;
      const fp = el?._flatpickr;
      if (fp?.selectedDates?.[0] instanceof Date) return fp.selectedDates[0];

      const iso = getValue(fid);
      if (iso) {
        const d = (window.flatpickr && window.flatpickr.parseDate)
          ? window.flatpickr.parseDate(String(iso), 'Y-m-d')
          : new Date(String(iso));
        return (d && !isNaN(d)) ? d : null;
      }
      return null;
    }

    function recomputeDatediffs() {
      datediffRefs.forEach(({ storeKey, outEl, resolve }) => {
        const { a, b } = resolve();
        if (!a || !b) {
          outEl.textContent = '—';
          STATE.values[storeKey] = null;
          return;
        }
        const days = diffInDays(a, b);
        const months = diffInMonths(a, b);
        const years = diffInYears(a, b);
        const display = `${days}D ${months}M ${years}Y (${days} Days total)`;
        outEl.textContent = display;
        STATE.values[storeKey] = { days, months, years, formatted: display };
      });
      markDirty();
      scheduleSaveValues();
    }
    window.recomputeDatediffs = recomputeDatediffs;


    // ============================================================
    // % calcs (number + derived table cells store "37%")
    // ============================================================
    const percentRefs = []; // { fieldId, inputEl, hintEl, cfg }
    function recomputePercentCalcs(meta) {
      try {
        let changed = false;

        percentRefs.forEach(ref => {
          const fid = ref.fieldId;
          const cfg = ref.cfg || {};
          const sources = Array.isArray(cfg.sources) ? cfg.sources.map(String).filter(Boolean) : [];
          const totalOf = String(cfg.totalOf || '').trim();
          const decimals = (cfg.decimals != null) ? (cfg.decimals|0) : 1;

          // Manual partial mode: no sources, has totalOf
          if (!sources.length && totalOf) {
            const total = parseScalarNumber(getValue(totalOf));
            const storedPct = getValue(fid);
            const pctNum = isPercentString(storedPct) ? parseScalarNumber(storedPct) : null;

            // Update hint (always show stored % string if present)
            if (ref.hintEl) ref.hintEl.textContent = (typeof storedPct === 'string' && storedPct.trim()) ? storedPct : '—';

            // Derive partial display from stored percent and current total
            if (ref.inputEl && document.activeElement !== ref.inputEl) {
              if (total != null && total !== 0 && pctNum != null) {
                const partial = (pctNum / 100.0) * total;
                ref.inputEl.value = String(partial);
              } else if (!storedPct) {
                ref.inputEl.value = '';
              }
            }
            return;
          }

          // Computed mode: sources selected (read-only)
          if (sources.length) {
            let sum = 0;
            let hasAny = false;
            sources.forEach(sid => {
              const n = parseScalarNumber(getValue(sid));
              if (n != null) { sum += n; hasAny = true; }
            });

            let out = '';
            if (totalOf) {
              const total = parseScalarNumber(getValue(totalOf));
              if (hasAny && total != null && total !== 0) {
                out = formatPercentString((sum / total) * 100.0, decimals);
              } else {
                out = '';
              }
            } else {
              // no denominator -> store numeric sum as string
              out = hasAny ? String(sum) : '';
            }

            if (getValue(fid) !== out) { STATE.values[fid] = out; changed = true; }
            if (ref.inputEl) ref.inputEl.value = out;
            if (ref.hintEl) ref.hintEl.textContent = out || '—';
            return;
          }
        });

        if (changed) { markDirty(); scheduleSaveValues(); }
      } catch (e) {
        try { console.warn('[fs] recomputePercentCalcs failed', e); } catch {}
      }
    }
    window.recomputePercentCalcs = recomputePercentCalcs;


    // ---- Fields ----
    (STATE.schema.fields || []).forEach(f => {
      const wrap = document.createElement('div');
      wrap.className = 'field';
      try { wrap.dataset.fieldId = String(f.id || ''); } catch {}

      if (f.type === 'address' || f.type === 'datediff') wrap.classList.add('span-2');
      if (f.type === 'table') wrap.classList.add('full', 'field--table');
      if (f.type === 'multichoice') wrap.classList.add('full', 'field--multichoice');
      if (f.wide === true) wrap.classList.add('span-2');
      if (f.full === true) wrap.classList.add('full');

      if (f.type !== 'address') {
        const label = document.createElement('label');
        label.htmlFor = f.id;
        label.textContent = f.label || f.id;
        if (f.required) {
          const star = document.createElement('span');
          star.textContent = ' *';
          star.style.color = '#ef4444';
          label.appendChild(star);
        }
        wrap.appendChild(label);
      }

      // Text
      if (f.type === 'text') {
        const input = document.createElement('input');
        input.type = 'text';
        input.id = f.id; input.name = f.id; input.style.width = '100%';
        if (f.required) input.required = true;
        if (getValue(f.id) != null) input.value = getValue(f.id);

        const commit = () => { setValue(f.id, input.value); applyFieldVisibility(); };
        input.addEventListener('input', commit);
        input.addEventListener('change', commit);

        wrap.appendChild(input);
        inputRefs[f.id] = input;
      }

      // Number
      else if (f.type === 'number') {
        const cfg = (f && typeof f.calc === 'object' && f.calc) ? f.calc : null;
        const sources = Array.isArray(cfg?.sources) ? cfg.sources.map(String).filter(Boolean) : [];
        const totalOf = String(cfg?.totalOf || '').trim();
        const decimals = (cfg?.decimals != null) ? (cfg.decimals|0) : 1;

        const hasCalc = !!totalOf || sources.length > 0;

        // Manual partial mode (no sources, has totalOf): numeric input, stores "37%"
        // Computed mode (sources): read-only text input with "37%"
        const input = document.createElement('input');
        input.id = f.id; input.name = f.id; input.style.width = '100%';

        const hint = document.createElement('div');
        hint.className = 'muted';
        hint.style.marginTop = '4px';
        hint.textContent = '—';

        if (hasCalc && sources.length) {
          input.type = 'text';
          input.readOnly = true;
          input.disabled = true;
          input.classList.add('kbd');
          wrap.appendChild(input);
          wrap.appendChild(hint);

          // register for recompute
          percentRefs.push({ fieldId: String(f.id), inputEl: input, hintEl: hint, cfg: { sources, totalOf, decimals } });
          // compute initial
          setTimeout(() => { try { window.recomputePercentCalcs?.({ init: true }); } catch {} }, 0);

        } else if (hasCalc && totalOf) {
          input.type = 'number';
          if (f.required) input.required = true;

          // Initial display: derive partial from stored % and current total
          const stored = getValue(f.id);
          const tot = parseScalarNumber(getValue(totalOf));
          if (isPercentString(stored) && tot != null && tot !== 0) {
            const pct = parseScalarNumber(stored);
            if (pct != null) input.value = String((pct / 100.0) * tot);
          } else if (stored != null && stored !== '') {
            // fallback: if somehow numeric stored, show it
            const n = parseScalarNumber(stored);
            if (n != null) input.value = String(n);
          }

          const commit = () => {
            const raw = input.value;
            const partial = (raw === '' ? null : Number(raw));
            const tot2 = parseScalarNumber(getValue(totalOf));
            let out = '';
            if (partial != null && !isNaN(partial) && tot2 != null && tot2 !== 0) {
              out = formatPercentString((partial / tot2) * 100.0, decimals);
            } else {
              out = '';
            }
            STATE.values[String(f.id)] = out;
            hint.textContent = out || '—';
            markDirty();
            scheduleSaveValues();
            applyFieldVisibility();
          };
          input.addEventListener('input', commit);
          input.addEventListener('change', commit);

          wrap.appendChild(input);
          wrap.appendChild(hint);

          percentRefs.push({ fieldId: String(f.id), inputEl: input, hintEl: hint, cfg: { sources: [], totalOf, decimals } });
          setTimeout(() => { try { window.recomputePercentCalcs?.({ init: true }); } catch {} }, 0);

        } else {
          // Plain number field
          input.type = 'number';
          if (f.required) input.required = true;
          if (getValue(f.id) != null) input.value = getValue(f.id);

          const commit = () => {
            const v = input.value;
            setValue(f.id, (v === '' ? '' : Number(v)));
            applyFieldVisibility();
          };
          input.addEventListener('input', commit);
          input.addEventListener('change', commit);
          wrap.appendChild(input);
          inputRefs[f.id] = input;
        }

        inputRefs[f.id] = input;
      }


      // Select
      else if (f.type === 'select') {
        const opts = normOptions(f);
        const isMulti = !!f.multiple;

        // Single-select: native <select>
        if (!isMulti) {
          const input = document.createElement('select');
          input.id = f.id; input.name = f.id; input.style.width = '100%';

          const empty = document.createElement('option');
          empty.value = '';
          empty.textContent = '— select —';
          input.appendChild(empty);

          opts.forEach(({value,label}) => {
            const o = document.createElement('option');
            o.value = value;
            o.textContent = label;
            input.appendChild(o);
          });

          if (f.required) input.required = true;

          const cur = getValue(f.id);
          if (cur != null) input.value = String(cur);

          const commit = () => {
            setValue(f.id, input.value);
            applyFieldVisibility();
          };
          input.addEventListener('change', commit);

          wrap.appendChild(input);
          inputRefs[f.id] = input;
        }

        // Multi-select: custom dropdown
        else {
          const cur = getValue(f.id);
          const selected = Array.isArray(cur)
            ? cur.map(String)
            : (cur != null && cur !== '' ? [String(cur)] : []);

          const api = createFsMultiSelectControl({
            fid: f.id,
            options: opts,
            initialSelected: selected,
            placeholder: '-- select --',
            onChange: (arr) => {
              setValue(f.id, arr);
              applyFieldVisibility();
            }
          });

          wrap.appendChild(api.el);
          inputRefs[f.id] = api.el;
        }
      }

      // Date
      else if (f.type === 'date') {
        const input = document.createElement('input');
        input.type = 'text';
        input.dataset.type = 'date';
        input.id = f.id; input.name = f.id; input.style.width = '100%';
        if (f.required) input.required = true;
        wrap.appendChild(input);

        const fp = createPrettyDatepicker(input, {
          dateFormat: 'Y-m-d',
          altInput: true,
          altFormat: 'D, j M Y',
          allowInput: false,
          clickOpens: true,
          defaultDate: getValue(f.id) || null,
          onChange: () => { setValue(f.id, input.value); recomputeDatediffs(); applyFieldVisibility(); },
          onValueUpdate: () => { setValue(f.id, input.value); recomputeDatediffs(); applyFieldVisibility(); }
        });
        fp.set('allowInput', false);
        if (fp.altInput) fp.altInput.readOnly = true;
        inputRefs[f.id] = input;
      }

      // Address (optional component)
      else if (f.type === 'address') {
        const host = document.createElement('div');
        host.className = 'addr-host';
        wrap.appendChild(host);

        const initial =
          typeof getValue(f.id) === 'string'
            ? { formatted: getValue(f.id) }
            : (getValue(f.id) || null);

        if (window.AddressAuto?.mount) {
          AddressAuto.mount(host, {
            id: f.id,
            label: f.label || 'Address',
            required: !!f.required,
            value: initial || null,
            onChange: (val) => { setValue(f.id, val); }
          });
        } else {
          const input = document.createElement('input');
          input.type = 'text';
          input.id = f.id; input.name = f.id; input.style.width = '100%';
          input.value = (initial && typeof initial === 'object') ? (initial.formatted || '') : (initial || '');
          input.addEventListener('input', () => setValue(f.id, input.value));
          input.addEventListener('change', () => setValue(f.id, input.value));
          host.appendChild(input);
          inputRefs[f.id] = input;
        }
      }

      // Table
      else if (f.type === 'table') {
        renderTableField(wrap, f);
      }

      // Datediff
      else if (f.type === 'datediff') {
        const fromId = f.fromId || f.from || '';
        const toId = f.toId || f.to || '';

        const out = document.createElement('div');
        out.id = f.id;
        out.className = 'datediff-out kbd';
        out.setAttribute('role', 'status');
        out.setAttribute('aria-live', 'polite');
        out.textContent = '—';
        wrap.appendChild(out);

        datediffRefs.push({
          storeKey: f.id,
          outEl: out,
          resolve: () => ({ a: getDateForField(fromId), b: getDateForField(toId) })
        });

        guardPairs.push({ fromId, toId });
      }

      // Multichoice (kept; all writes through STATE)
      else if (f.type === 'multichoice') {
        // (unchanged content from your file below)
        const mcContainer = document.createElement('div');
        mcContainer.className = 'mc-container';
        mcContainer.style.display = 'block';

        const items = [];
        if (f.mc && Array.isArray(f.mc.groups) && f.mc.groups.length) {
          f.mc.groups.forEach(g => (g.items || []).forEach(it => {
            items.push({
              value: String(it.value ?? it.label ?? ''),
              alwaysSelected: !!it.alwaysSelected,
              preselected: !!it.preselected,
              fields: Array.isArray(it.fields) ? it.fields : []
            });
          }));
        } else if (Array.isArray(f.options)) {
          f.options.forEach(v => {
            if (v && typeof v === 'object') {
              items.push({
                value: String(v.value ?? v.label ?? ''),
                alwaysSelected: !!v.alwaysSelected,
                preselected: !!v.preselected,
                fields: Array.isArray(v.fields) ? v.fields : []
              });
            } else {
              items.push({ value: String(v), alwaysSelected: false, preselected: false, fields: [] });
            }
          });
        }

        if (!Array.isArray(getValue(f.id))) {
          const initial = items.filter(it => it.alwaysSelected || it.preselected).map(it => it.value);
          if (initial.length) STATE.values[f.id] = initial.slice();
        }
        const selected = new Set(Array.isArray(getValue(f.id)) ? getValue(f.id).map(String) : []);

        function persistMainSelection() {
          const boxes = mcContainer.querySelectorAll(`input[type="checkbox"][data-mc="1"]`);
          STATE.values[f.id] = Array.from(boxes).filter(b => b.checked).map(b => b.value);
          markDirty();
          scheduleSaveValues();
        }

        function setExtrasOpen(extras, caretEl, open) {
          if (!extras) return;
          const DURATION = 220;

          if (extras._animTimer) { clearTimeout(extras._animTimer); extras._animTimer = null; }
          if (extras._onTe) { extras.removeEventListener('transitionend', extras._onTe); extras._onTe = null; }

          const onEnd = () => {
            extras.style.transition = '';
            extras.style.willChange = '';
            extras.style.opacity = open ? '1' : '0';
            extras.style.marginTop = open ? '8px' : '0px';
            extras.style.height = open ? 'auto' : '0px';
            extras.style.overflow = 'visible';
            if (!open) extras.style.display = 'none';
            if (extras._onTe) {
              extras.removeEventListener('transitionend', extras._onTe);
              extras._onTe = null;
            }
          };
          extras._onTe = onEnd;
          extras.addEventListener('transitionend', onEnd);

          if (caretEl) caretEl.classList.toggle('open', !!open);

          if (open) {
            extras.style.display = 'grid';
            extras.style.overflow = 'visible';
            extras.style.willChange = 'height, opacity, margin-top';
            extras.style.opacity = '0';
            extras.style.marginTop = '0px';
            extras.style.height = '0px';

            requestAnimationFrame(() => {
              const h = extras.scrollHeight;
              extras.classList.add('open');
              extras.style.transition = `height ${DURATION}ms ease, opacity ${DURATION}ms ease, margin-top ${DURATION}ms ease`;
              extras.style.height = h + 'px';
              extras.style.opacity = '1';
              extras.style.marginTop = '8px';
              extras._animTimer = setTimeout(onEnd, DURATION + 40);
            });
          } else {
            const current = extras.offsetHeight || extras.scrollHeight || 0;
            extras.classList.remove('open');
            extras.style.display = 'grid';
            extras.style.overflow = 'hidden';
            extras.style.willChange = 'height, opacity, margin-top';
            extras.style.transition = '';
            extras.style.height = current + 'px';
            extras.style.opacity = '1';
            extras.style.marginTop = '8px';

            requestAnimationFrame(() => {
              extras.style.transition = `height ${DURATION}ms ease, opacity ${DURATION}ms ease, margin-top ${DURATION}ms ease`;
              extras.style.height = '0px';
              extras.style.opacity = '0';
              extras.style.marginTop = '0px';
              extras._animTimer = setTimeout(onEnd, DURATION + 40);
            });
          }
        }

        function getDateForExtraKey(key) {
          const el = mcDateRefs[key];
          const fp = el?._flatpickr;
          if (fp?.selectedDates?.[0] instanceof Date) return fp.selectedDates[0];

          const iso = STATE.values[key];
          if (iso) {
            const d = (window.flatpickr && window.flatpickr.parseDate)
              ? window.flatpickr.parseDate(String(iso), 'Y-m-d')
              : new Date(String(iso));
            return (d && !isNaN(d)) ? d : null;
          }
          return null;
        }

        function drawOption(item, parentHost) {
          const optVal = item.value;
          const optId = `${f.id}__${slugifyMc(optVal)}`;
          const hasExtras = Array.isArray(item.fields) && item.fields.length > 0;

          const card = document.createElement('div');
          card.className = 'mc-item';
          try { card.dataset.optId = `${f.id}__opt__${slugifyMc(optVal)}`; } catch {}

          card.style.position = 'relative';
          card.style.display = 'flex';
          card.style.flexDirection = 'column';
          card.style.alignItems = 'stretch';
          card.style.background = 'var(--card)';
          card.style.border = '1px solid var(--border-strong)';
          card.style.borderRadius = '8px';
          card.style.padding = '10px 10px';

          const row1 = document.createElement('div');
          row1.className = 'row';
          row1.style.alignItems = 'center';
          row1.style.gap = '8px';
          row1.style.width = '100%';

          const left = document.createElement('label');
          left.className = 'mc-option-label';
          left.setAttribute('for', optId);
          left.style.flex = '1';

          const cb = document.createElement('input');
          cb.type = 'checkbox';
          cb.dataset.mc = '1';
          cb.name = f.id;
          cb.id = optId;
          cb.value = optVal;
          cb.className = 'mc-option-checkbox';

          const locked = !!item.alwaysSelected;
          const isPreselected = !!item.preselected;
          cb.checked = locked || selected.has(optVal) || (!selected.size && isPreselected);
          if (locked) cb.disabled = true;

          const txt = document.createElement('span');
          txt.textContent = optVal;

          left.appendChild(cb);
          left.appendChild(txt);
          row1.appendChild(left);

          let extrasWrap = null;
          if (hasExtras) {
            extrasWrap = document.createElement('div');
            extrasWrap.className = 'mc-extras';
            extrasWrap.style.display = 'none';
            extrasWrap.style.height = '0px';

            const mountExtraFields = () => {
              extrasWrap.innerHTML = '';
              if (!item.fields.length) return;

              item.fields.forEach(ex => {
                const exType = String(ex?.type || 'text');
                const exId = String(ex?.id || '');
                if (!exId) return;

                const exKey = mcExtraKey(f.id, optVal, exId);

                const line = document.createElement('div');
                line.className = 'row';
                line.style.gap = '8px';
                line.style.alignItems = 'center';
                line.style.marginTop = '2px';

                const lab = document.createElement('label');
                lab.textContent = String(ex?.label || exId);
                lab.style.minWidth = '120px';
                lab.style.color = 'var(--muted)';

                if (exType === 'date') {
                  const input = document.createElement('input');
                  input.type = 'text';
                  input.dataset.type = 'date';
                  input.style.minWidth = '180px';

                  extrasWrap.appendChild(line);
                  line.appendChild(lab);
                  line.appendChild(input);

                  const fp = createPrettyDatepicker(input, {
                    dateFormat: 'Y-m-d',
                    altInput: true,
                    altFormat: 'D, j M Y',
                    defaultDate: STATE.values[exKey] || null,
                    onChange: () => { STATE.values[exKey] = input.value; markDirty(); scheduleSaveValues(); recomputeDatediffs(); },
                    onValueUpdate: () => { STATE.values[exKey] = input.value; markDirty(); scheduleSaveValues(); recomputeDatediffs(); }
                  });
                  fp.set('allowInput', false);
                  if (fp.altInput) fp.altInput.readOnly = true;

                  mcDateRefs[exKey] = input;
                  return;
                }

                if (exType === 'number') {
                  const input = document.createElement('input');
                  input.type = 'number';
                  input.value = STATE.values[exKey] ?? '';
                  input.addEventListener('input', () => { STATE.values[exKey] = (input.value === '' ? '' : Number(input.value)); markDirty(); scheduleSaveValues(); });
                  input.addEventListener('change', () => { STATE.values[exKey] = (input.value === '' ? '' : Number(input.value)); markDirty(); scheduleSaveValues(); });
                  extrasWrap.appendChild(line);
                  line.appendChild(lab);
                  line.appendChild(input);
                  return;
                }

                if (exType === 'datediff') {
                  const fromId = ex.fromId || ex.from || '';
                  const toId = ex.toId || ex.to || '';
                  const fromKey = mcExtraKey(f.id, optVal, fromId);
                  const toKey = mcExtraKey(f.id, optVal, toId);

                  const out = document.createElement('div');
                  out.className = 'datediff-out kbd';
                  out.setAttribute('role', 'status');
                  out.setAttribute('aria-live', 'polite');
                  out.textContent = '—';

                  extrasWrap.appendChild(line);
                  line.appendChild(lab);
                  line.appendChild(out);

                  datediffRefs.push({
                    storeKey: exKey,
                    outEl: out,
                    resolve: () => ({ a: getDateForExtraKey(fromKey), b: getDateForExtraKey(toKey) })
                  });
                  return;
                }

                const input = document.createElement('input');
                input.type = 'text';
                input.value = STATE.values[exKey] ?? '';
                input.addEventListener('input', () => { STATE.values[exKey] = input.value; markDirty(); scheduleSaveValues(); });
                input.addEventListener('change', () => { STATE.values[exKey] = input.value; markDirty(); scheduleSaveValues(); });
                extrasWrap.appendChild(line);
                line.appendChild(lab);
                line.appendChild(input);
              });
            };

            mountExtraFields();
          }

          if (hasExtras) {
            const caretBtn = document.createElement('button');
            caretBtn.type = 'button';
            caretBtn.className = 'mc-toggle';
            caretBtn.setAttribute('aria-expanded', 'false');
            caretBtn.setAttribute('aria-label', 'Details ein-/ausklappen');

            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('viewBox', '0 0 24 24');
            svg.setAttribute('width', '14');
            svg.setAttribute('height', '14');
            svg.classList.add('mc-caret');

            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', 'M9 18l6-6-6-6');
            path.setAttribute('fill', 'none');
            path.setAttribute('stroke', 'currentColor');
            path.setAttribute('stroke-width', '2');
            path.setAttribute('stroke-linecap', 'round');
            path.setAttribute('stroke-linejoin', 'round');
            svg.appendChild(path);

            caretBtn.appendChild(svg);
            row1.appendChild(caretBtn);

            setExtrasOpen(extrasWrap, svg, false);

            caretBtn.addEventListener('click', (e) => {
              e.preventDefault();
              const willOpen = !extrasWrap.classList.contains('open');
              caretBtn.setAttribute('aria-expanded', String(willOpen));
              setExtrasOpen(extrasWrap, svg, willOpen);
            });
          }

          cb.addEventListener('change', () => {
            if (locked) { cb.checked = true; return; }
            persistMainSelection();
            applyFieldVisibility();
          });

          card.appendChild(row1);
          if (extrasWrap) card.appendChild(extrasWrap);
          parentHost.appendChild(card);
        }

        if (f.mc && Array.isArray(f.mc.groups) && f.mc.groups.length) {
          f.mc.groups.forEach(g => {
            const section = document.createElement('div');
            section.className = 'mc-group-section';
            section.style.marginBottom = '10px';

            if (g.title) {
              const h = document.createElement('div');
              h.className = 'mc-group-title';
              h.textContent = String(g.title);
              h.style.color = 'var(--muted)';
              h.style.fontWeight = '600';
              h.style.fontSize = '.95rem';
              h.style.margin = '4px 0 6px';
              section.appendChild(h);
            }

            const host = document.createElement('div');
            host.className = 'mc-group';
            host.style.display = 'grid';
            host.style.gridTemplateColumns = 'repeat(auto-fill,minmax(260px,1fr))';
            host.style.gap = '8px 16px';
            host.style.alignItems = 'start';

            if (Number.isFinite(+f.columns) && +f.columns > 0) {
              host.style.gridTemplateColumns = `repeat(${+f.columns}, minmax(220px, 1fr))`;
            }

            (g.items || []).forEach(it => drawOption({
              value: String(it.value ?? it.label ?? ''),
              alwaysSelected: !!it.alwaysSelected,
              preselected: !!it.preselected,
              fields: Array.isArray(it.fields) ? it.fields : []
            }, host));

            section.appendChild(host);
            mcContainer.appendChild(section);
          });
        } else {
          const host = document.createElement('div');
          host.className = 'mc-group';
          host.style.display = 'grid';
          host.style.gridTemplateColumns = 'repeat(auto-fill,minmax(260px,1fr))';
          host.style.gap = '8px 16px';
          host.style.alignItems = 'start';

          if (Number.isFinite(+f.columns) && +f.columns > 0) {
            host.style.gridTemplateColumns = `repeat(${+f.columns}, minmax(220px, 1fr))`;
          }

          items.forEach(it => drawOption(it, host));
          mcContainer.appendChild(host);
        }

        STATE.values[f.id] = Array.from(mcContainer.querySelectorAll(`input[type="checkbox"][data-mc="1"]`))
          .filter(b => b.checked)
          .map(b => b.value);
        markDirty();
        scheduleSaveValues();

        wrap.appendChild(mcContainer);
      }

      // Fallback
      else {
        const input = document.createElement('input');
        input.type = 'text';
        input.id = f.id; input.name = f.id; input.style.width = '100%';
        if (getValue(f.id) != null) input.value = getValue(f.id);

        const commit = () => { setValue(f.id, input.value); };
        input.addEventListener('input', commit);
        input.addEventListener('change', commit);

        wrap.appendChild(input);
        inputRefs[f.id] = input;
      }

      form.appendChild(wrap);
    });

    form.addEventListener('change', () => applyFieldVisibility());
    mount.appendChild(form);

    (function wireTopLevelDateGuards() {
      function nextDay(d) {
        if (!d) return null;
        const n = new Date(d.getFullYear(), d.getMonth(), d.getDate());
        n.setDate(n.getDate() + 1);
        return n;
      }

      guardPairs.forEach(({ fromId, toId }) => {
        const fromEl = inputRefs[fromId];
        const toEl = inputRefs[toId];
        const fpFrom = fromEl?._flatpickr;
        const fpTo = toEl?._flatpickr;
        if (!fpFrom || !fpTo) return;

        fpFrom.set('allowInput', false);
        fpTo.set('allowInput', false);
        if (fpFrom.altInput) fpFrom.altInput.readOnly = true;
        if (fpTo.altInput) fpTo.altInput.readOnly = true;

        const syncToWithFrom = (opts = { snap: true, jump: true }) => {
          const from = fpFrom.selectedDates?.[0] || null;
          const minForTo = nextDay(from);
          fpTo.set('minDate', minForTo || null);

          const toSel = fpTo.selectedDates?.[0] || null;
          if (!toSel && minForTo && opts.snap) fpTo.setDate(minForTo, true);
          if (from && toSel && toSel <= from && opts.snap) fpTo.setDate(minForTo, true);
          if (minForTo && opts.jump) { try { fpTo.jumpToDate(minForTo); } catch {} }

          recomputeDatediffs();
        };

        syncToWithFrom({ snap: true, jump: false });
        fpFrom.config.onChange.push(() => syncToWithFrom({ snap: true, jump: true }));
        fpFrom.config.onValueUpdate.push(() => syncToWithFrom({ snap: true, jump: true }));
        fpTo.config.onOpen.push(() => syncToWithFrom({ snap: false, jump: true }));

        const recompute = () => recomputeDatediffs();
        fpTo.config.onChange.push(recompute);
        fpTo.config.onValueUpdate.push(recompute);
      });
    })();

    recomputeDatediffs();
    applyFieldVisibility();

    tr.end();
  }

  // ============================================================
  // TABLE FIELD — FULL FIX (updated toolbar wording/behavior)
  // Requirements:
  //  - When entering (draft mode): show "Zeile hinzufügen" + "Abbrechen"
  //  - When editing existing row: show "Zeile löschen" + "Abbrechen" (+ "Neue Zeile")
  //  - "Abbrechen" in draft mode clears draft (no row added)
  //  - "Abbrechen" in edit mode ends editing (no undo; edits already persisted)
  // ============================================================
  function renderTableField(container, field) {
    const fid = String(field?.id || '');
    const tr = TRACE('renderTableField', { fid, cols: (field?.columns||[]).length });

    // Canonical committed rows
    let rows = ensureTableValue(field);

    // UI state
    let selectedIndex = null;          // index in rows or null
    let draft = emptyRow(field);       // not persisted
    let statusText = '';

    // UI root
    const editorWrap = document.createElement('div');
    editorWrap.style.display = 'flex';
    editorWrap.style.flexWrap = 'wrap';
    editorWrap.style.gap = '10px';

    const toolbar = document.createElement('div');
    toolbar.className = 'row';
    toolbar.style.gap = '8px';
    toolbar.style.alignItems = 'center';

    const status = document.createElement('div');
    status.className = 'muted';
    status.style.minHeight = '1.2em';

    const tableWrap = document.createElement('div');
    tableWrap.style.overflow = 'auto';

    const table = document.createElement('table');
    table.style.width = '100%';

    const thead = document.createElement('thead');
    const trh = document.createElement('tr');
    thead.appendChild(trh);

    const tbody = document.createElement('tbody');

    table.appendChild(thead);
    table.appendChild(tbody);
    tableWrap.appendChild(table);

    // Buttons
    const btnAdd = document.createElement('button');
    btnAdd.type = 'button';
    btnAdd.textContent = 'Zeile hinzufügen';

    const btnNew = document.createElement('button');
    btnNew.type = 'button';
    btnNew.className = 'secondary';
    btnNew.textContent = 'Neue Zeile';

    const btnDelete = document.createElement('button');
    btnDelete.type = 'button';
    btnDelete.className = 'ghost';
    btnDelete.textContent = 'Zeile löschen';

    const btnCancel = document.createElement('button');
    btnCancel.type = 'button';
    btnCancel.className = 'ghost';
    btnCancel.textContent = 'Abbrechen';

    toolbar.appendChild(btnAdd);
    toolbar.appendChild(btnNew);
    toolbar.appendChild(btnDelete);
    toolbar.appendChild(btnCancel);

    // Header cells
    (field.columns || []).forEach(col => {
      const th = document.createElement('th');
      th.textContent = col.label || col.id;
      trh.appendChild(th);
    });

    // Editor inputs
    const editorInputs = {};
    const measurer = document.createElement('canvas').getContext('2d');
    function textPx(str) {
      try { measurer.font = getComputedStyle(document.body).font; } catch {}
      return Math.ceil(measurer.measureText(String(str || '')).width);
    }
    function longest(arr) {
      return (arr || []).reduce((a, b) => (String(b).length > String(a).length ? String(b) : String(a)), '');
    }

    function currentModel() {
      // editing existing row -> that row; else draft buffer
      if (typeof selectedIndex === 'number' && selectedIndex >= 0 && selectedIndex < rows.length) return rows[selectedIndex];
      return draft;
    }

    function setSelected(idxOrNull) {
      selectedIndex = (typeof idxOrNull === 'number') ? idxOrNull : null;
      syncEditorFromModel();
      updateToolbar();
      drawTable();
    }

    function syncEditorFromModel() {
      const model = currentModel();
      (field.columns || []).forEach(c => {
        const el = editorInputs[c.id];
        if (!el) return;

        const isMulti = (String(c?.type) === 'select' && !!c?.multiple);
        const fallback = isMulti ? [] : '';
        const v = (model && Object.prototype.hasOwnProperty.call(model, c.id)) ? model[c.id] : fallback;

        if (isMulti && el.dataset.type === 'multiselect' && el.__fsMultiApi) {
          el.__fsMultiApi.setSelected(Array.isArray(v) ? v : [], false);
          return;
        }

        // number+calc: display partial in editor if stored is % and this is manual mode
        if (String(c?.type) === 'number' && c && typeof c.calc === 'object' && c.calc) {
          const calc = c.calc;
          const sources = Array.isArray(calc.sources) ? calc.sources.map(String).filter(Boolean) : [];
          const totalOf = String(calc.totalOf || '').trim();
          if (!sources.length && totalOf) {
            // v is stored percent string (e.g. "37%"), show partial = % * total
            const pct = isPercentString(v) ? parseScalarNumber(v) : null;
            const denom = resolveTotalForTableRef(totalOf, model);
            if (pct != null && denom != null && denom !== 0) {
              const partial = (pct / 100.0) * denom;
              el.value = String(partial);
            } else {
              el.value = '';
            }
          } else {
            // computed mode or other: show raw stored string
            el.value = (v == null) ? '' : String(v);
          }

        } else {
          el.value = (v == null) ? '' : String(v);
        }

        try { if (el._flatpickr && el.value) el._flatpickr.setDate(el.value, false); } catch {}
        try { if (el._flatpickr && !el.value) el._flatpickr.clear(); } catch {}
      });
    }


    function syncModelFromEditor(colId, value) {
      const model = currentModel();
      model[colId] = value;

      // Apply computed calc columns (sources -> read-only outputs)
      try { computeTableRowCalcs(field, model); } catch {}
      try {
        (field.columns || []).forEach(c => {
          if (String(c?.type) !== 'number') return;
          const calc = (c && typeof c.calc === 'object' && c.calc) ? c.calc : null;
          const sources = Array.isArray(calc?.sources) ? calc.sources.map(String).filter(Boolean) : [];
          if (!sources.length) return;
          const el2 = editorInputs[c.id];
          if (el2) el2.value = (model[c.id] == null) ? '' : String(model[c.id]);
        });
      } catch {}

      // Editing existing row is immediately canonical -> normalize & persist
      if (typeof selectedIndex === 'number' && selectedIndex >= 0 && selectedIndex < rows.length) {
        rows[selectedIndex] = { ...emptyRow(field), ...(rows[selectedIndex] || {}) };
        STATE.values[fid] = normalizeTableArray(field, rows);
        rows = STATE.values[fid];
        markDirty();
        scheduleSaveValues();
      } else {
        // draft is transient
        updateToolbar();
      }
      statusText = '';
      status.textContent = statusText;
    }

    (field.columns || []).forEach(col => {
      const pair = document.createElement('label');
      pair.style.display = 'flex';
      pair.style.alignItems = 'center';
      pair.style.gap = '8px';

      const lbl = document.createElement('span');
      lbl.textContent = col.label || col.id;

      let el;
      if (col.type === 'select') {
        const opts = Array.isArray(col.options) ? col.options : [];
        const isMulti = !!col.multiple;

        if (!isMulti) {
          el = document.createElement('select');
          const empty = document.createElement('option');
          empty.value = '';
          empty.textContent = '— wählen —';
          el.appendChild(empty);
          opts.forEach(opt => {
            const o = document.createElement('option');
            o.value = String(opt);
            o.textContent = String(opt);
            el.appendChild(o);
          });
          el.style.minWidth = Math.max(140, Math.min(360, textPx(longest(opts)) + 56)) + 'px';
          el.addEventListener('change', () => syncModelFromEditor(col.id, el.value));
        } else {
          const model = currentModel();
          const cur = model?.[col.id];
          const api = createFsMultiSelectControl({
            fid: null,
            options: opts,
            initialSelected: Array.isArray(cur) ? cur : [],
            placeholder: '-- select --',
            onChange: (arr) => syncModelFromEditor(col.id, arr)
          });
          el = api.el;
          el.style.minWidth = '260px';
        }
      } else if (col.type === 'date') {
        el = document.createElement('input');
        el.type = 'text';
        el.dataset.type = 'date';
        el.style.minWidth = Math.max(140, Math.min(360, textPx('YYYY-MM-DD') + 20)) + 'px';

        createPrettyDatepicker(el, {
          dateFormat: 'Y-m-d',
          altInput: true,
          altFormat: 'D, j M Y',
          allowInput: false,
          clickOpens: true,
          defaultDate: '',
          onChange: () => syncModelFromEditor(col.id, el.value),
          onValueUpdate: () => syncModelFromEditor(col.id, el.value),
        });
      } else if (col.type === 'number') {
        const calc = (col && typeof col.calc === 'object' && col.calc) ? col.calc : null;
        const sources = Array.isArray(calc?.sources) ? calc.sources.map(String).filter(Boolean) : [];
        const totalOf = String(calc?.totalOf || '').trim();
        const decimals = (calc?.decimals != null) ? (calc.decimals|0) : 1;

        // computed mode (sources) -> show read-only "37%"
        if (sources.length) {
          el = document.createElement('input');
          el.type = 'text';
          el.readOnly = true;
          el.disabled = true;
          el.classList.add('kbd');
          el.style.minWidth = '140px';
          el.value = '';
        } else if (totalOf) {
          // manual partial mode -> numeric input, stores percent string in model
          el = document.createElement('input');
          el.type = 'number';
          el.style.minWidth = Math.max(120, Math.min(360, textPx('000000') + 20)) + 'px';

          const commitPartial = () => {
            const raw = el.value;
            const partial = (raw === '' ? null : Number(raw));
            const denom = resolveTotalForTableRef(totalOf, currentModel());
            let out = '';
            if (partial != null && !isNaN(partial) && denom != null && denom !== 0) {
              out = formatPercentString((partial / denom) * 100.0, decimals);
            } else {
              out = '';
            }
            syncModelFromEditor(col.id, out);
          };
          el.addEventListener('input', commitPartial);
          el.addEventListener('change', commitPartial);
        } else {
          el = document.createElement('input');
          el.type = 'number';
          el.style.minWidth = Math.max(120, Math.min(360, textPx('000000') + 20)) + 'px';
          el.addEventListener('input', () => syncModelFromEditor(col.id, el.value === '' ? '' : Number(el.value)));
          el.addEventListener('change', () => syncModelFromEditor(col.id, el.value === '' ? '' : Number(el.value)));
        }
      } else {
        el = document.createElement('input');
        el.type = 'text';
        el.style.minWidth = Math.max(160, Math.min(360, textPx(lbl.textContent) + 20)) + 'px';
        el.addEventListener('input', () => syncModelFromEditor(col.id, el.value));
        el.addEventListener('change', () => syncModelFromEditor(col.id, el.value));
      }

      editorInputs[col.id] = el;
      pair.appendChild(lbl);
      pair.appendChild(el);
      editorWrap.appendChild(pair);
    });

    function committedCount() {
      rows = ensureTableValue(field);
      return rows.filter(r => !rowIsEmpty(field, r)).length;
    }

    function updateToolbar() {
      rows = ensureTableValue(field);
      const min = Math.max(0, parseInt(field.minRows || 0, 10));
      const max = Math.max(0, parseInt(field.maxRows || 0, 10));
      const isEditingExisting = (typeof selectedIndex === 'number' && selectedIndex >= 0 && selectedIndex < rows.length);

      const draftHasData = !rowIsEmpty(field, draft);

      // Draft mode: show Add + Cancel; hide Delete; hide New (per requirement)
      if (!isEditingExisting) {
        btnAdd.style.display = '';
        btnAdd.textContent = 'Zeile hinzufügen';
        btnAdd.disabled = !draftHasData || (!!max && committedCount() >= max);

        btnCancel.style.display = '';
        btnCancel.textContent = 'Abbrechen';
        btnCancel.disabled = !draftHasData; // adjust if you want always enabled

        btnNew.style.display = 'none';
        btnDelete.style.display = 'none';
        return;
      }

      // Edit mode: show New + Delete + Cancel; hide Add
      btnAdd.style.display = 'none';

      btnNew.style.display = '';
      btnNew.textContent = 'Änderungen speichern';
      btnNew.disabled = false;

      btnDelete.style.display = '';
      btnDelete.disabled = (!!min && committedCount() <= min);

      btnCancel.style.display = '';
      btnCancel.textContent = 'Abbrechen';
      btnCancel.disabled = false;
    }

    function drawTable() {
      rows = ensureTableValue(field);
      tbody.innerHTML = '';

      const hasAny = rows.some(r => !rowIsEmpty(field, r));
      tableWrap.style.display = hasAny ? '' : 'none';

      rows.forEach((row, idx) => {
        if (rowIsEmpty(field, row)) return;

        const trEl = document.createElement('tr');
        const isSel = (idx === selectedIndex);

        if (isSel) {
          trEl.style.background = '#DBEAFE';
          trEl.style.outline = '2px solid #93C5FD';
          trEl.style.outlineOffset = '-2px';
        }

        trEl.addEventListener('click', () => {
          setSelected(idx);
          statusText = '';
          status.textContent = statusText;
        });

        (field.columns || []).forEach(col => {
          const td = document.createElement('td');

          const isMulti = (String(col?.type) === 'select' && !!col?.multiple);
          const v = row?.[col.id];

          if (isMulti) td.textContent = Array.isArray(v) ? v.join(', ') : String(v ?? '');
          else td.textContent = v ?? '';

          trEl.appendChild(td);
        });

        tbody.appendChild(trEl);
      });
    }

    // Recompute computed columns if external values (e.g. total-of fields) change
    function recomputeAndRefreshFromOutside() {
      try {
        let changed = false;
        rows = ensureTableValue(field);

        rows.forEach(r => {
          const before = JSON.stringify(r);
          try { computeTableRowCalcs(field, r); } catch {}
          if (JSON.stringify(r) !== before) changed = true;
        });

        if (changed) {
          STATE.values[fid] = normalizeTableArray(field, rows);
          rows = STATE.values[fid];
          markDirty();
          scheduleSaveValues();
        }

        // Refresh UI
        syncEditorFromModel();
        drawTable();
      } catch {}
    }

    const onValuesChanged = () => recomputeAndRefreshFromOutside();
    window.addEventListener('fs-values-changed', onValuesChanged);


    // Actions
    btnAdd.addEventListener('click', () => {
      rows = ensureTableValue(field);

      if (rowIsEmpty(field, draft)) {
        statusText = 'Keine Eingaben zum Hinzufügen.';
        status.textContent = statusText;
        updateToolbar();
        return;
      }

      const max = Math.max(0, parseInt(field.maxRows || 0, 10));
      if (max && committedCount() >= max) {
        statusText = 'Maximale Anzahl Zeilen erreicht.';
        status.textContent = statusText;
        updateToolbar();
        return;
      }

            const newRow = { ...emptyRow(field), ...draft };
      try { computeTableRowCalcs(field, newRow); } catch {}
      rows.push(newRow);
      STATE.values[fid] = normalizeTableArray(field, rows);
      rows = STATE.values[fid];

      draft = emptyRow(field);
      syncEditorFromModel();

      markDirty();
      scheduleSaveValues();

      statusText = 'Zeile hinzugefügt.';
      status.textContent = statusText;

      updateToolbar();
      drawTable();
    });

    btnNew.addEventListener('click', () => {
      // Go back to draft entry
      selectedIndex = null;
      draft = emptyRow(field);
      syncEditorFromModel();
      updateToolbar();
      drawTable();
      statusText = 'Neue Zeile.';
      status.textContent = statusText;
    });

    btnDelete.addEventListener('click', () => {
      rows = ensureTableValue(field);

      const min = Math.max(0, parseInt(field.minRows || 0, 10));
      if (!(typeof selectedIndex === 'number') || selectedIndex < 0 || selectedIndex >= rows.length) return;
      if (min && committedCount() <= min) return;

      rows.splice(selectedIndex, 1);
      STATE.values[fid] = normalizeTableArray(field, rows);
      rows = STATE.values[fid];

      selectedIndex = null;
      draft = emptyRow(field);
      syncEditorFromModel();

      markDirty();
      scheduleSaveValues();

      statusText = 'Zeile gelöscht.';
      status.textContent = statusText;

      updateToolbar();
      drawTable();
    });

    btnCancel.addEventListener('click', () => {
      const isEditingExisting = (typeof selectedIndex === 'number' && selectedIndex >= 0 && selectedIndex < rows.length);

      // Draft mode cancel: clear draft inputs
      if (!isEditingExisting) {
        draft = emptyRow(field);
        syncEditorFromModel();
        updateToolbar();
        statusText = 'Abgebrochen.';
        status.textContent = statusText;
        return;
      }

      // Edit mode cancel: stop editing row (no undo)
      selectedIndex = null;
      draft = emptyRow(field);
      syncEditorFromModel();
      updateToolbar();
      drawTable();
      statusText = 'Bearbeitung beendet.';
      status.textContent = statusText;
    });

    // Mount
    container.appendChild(editorWrap);
    container.appendChild(toolbar);
    container.appendChild(status);
    container.appendChild(tableWrap);

    // Init
    updateToolbar();
    syncEditorFromModel();
    drawTable();

    tr.end({ rows: rows.length });
  }

  // ============================================================
  // Expose for cross-callbacks
  // ============================================================
  try { window.applyFieldVisibility = applyFieldVisibility; } catch {}
  try { installLogoFocusNav(); } catch {}
  </script>
</body>
</html>
