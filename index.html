<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Form Suite — Form</title>
  <link rel="icon" href="favicon.ico" type="image/gif" sizes="32x32">
  <link rel="shortcut icon" href="favicon.ico" type="image/gif">
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/themes/material_blue.css">
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <header>
    <div class="row">
      <span class="brand logo-md">
        <img src="logo.gif" alt="Form Suite logo" class="logo" />
        <strong>Form Suite</strong>
      </span>
      <span class="muted">·</span><span class="muted">Form</span>
      <span class="muted">·</span><a href="builder.html">Form Builder</a>
      <span class="muted">·</span><a href="matcher.html">Tag Matcher</a>
      <span class="muted">·</span><a href="rules.html">Rules</a>
      <span class="muted">·</span><a href="extractor.html">Extractor</a>
    </div>
  </header>

  <main>
    <section class="panel">
      <div class="title-row"></div>
      <div class="row" style="margin-top:8px;">
        <span id="docStatus" class="muted">No active document. Open one in the <a href="extractor.html">Extractor</a>.</span>
      </div>
      <div id="permNote" class="note warn" style="display:none; margin-top:10px">
        This DOCX was opened via picker but I don’t have write permission to the original file.
        Exports will download a copy instead of writing back.
        <button id="btnRegrant" class="ghost" style="margin-left:8px">Grant write access</button>
      </div>
    </section>

    <section class="panel">
      <div id="formMount"></div>
    </section>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <script src="persistence.js"></script>
  <script src="address-autocomplete.js"></script>
  <script>
    const STORAGE_KEY = 'FORM_SCHEMA_V1';
    const PAYLOAD_KEY = 'CRONOS_PAYLOAD';
    const supportsFS = 'showSaveFilePicker' in window;

    const els = {
      docStatus: document.getElementById('docStatus'),
      formMount: document.getElementById('formMount'),
      permNote:  document.getElementById('permNote'),
      btnRegrant:document.getElementById('btnRegrant'),
    };

    let currentDoc = null, schema = null, values = {}, fieldRules = [];
    let btnExportMain = null;

    // ---------- Status + Hard Reset ----------
    function setStatus(s) { els.docStatus.innerHTML = s; }
    async function hardResetOpenForm(reason = '') {
      try {} catch {}
      schema = null;
      values = {};
      fieldRules = [];
      if (els.formMount) els.formMount.innerHTML = `<div class="muted">No schema found. Create one in the <a href="builder.html">Builder</a>.</div>`;
      if (btnExportMain) btnExportMain.disabled = true;
      els.permNote.style.display = 'none';
      if (reason) setStatus(`No active document (${reason}). Open one in the <a href="extractor.html">Extractor</a>.`);
      else setStatus(`No active document. Open one in the <a href="extractor.html">Extractor</a>.`);
    }

    // ---------- One Active-Doc Signal (canonical) ----------
    const ACTIVE_DOC_KEY = 'FS_ACTIVE_DOC_META'; // unified key across the app

    function readActiveDocSync() {
      // Prefer live persistence info in this tab
      const p = window.formSuitePersist?.getCurrentDocMeta?.()
             || window.formSuitePersist?.getActiveDoc?.sync?.();
      if (p?.docId) {
        const meta = { docId: p.docId, name: p.name || p.docTitle || 'document' };
        try { localStorage.setItem(ACTIVE_DOC_KEY, JSON.stringify(meta)); } catch {}
        return meta;
      }
      // Canonical LS
      try { const v = localStorage.getItem(ACTIVE_DOC_KEY); if (v) return JSON.parse(v); } catch {}
      // Legacy migration (older Extractor)
      try {
        const legacy = localStorage.getItem('FS_CURRENT_DOC_META');
        if (legacy) {
          const m = JSON.parse(legacy);
          if (m?.docId) {
            localStorage.setItem(ACTIVE_DOC_KEY, legacy);
            return m;
          }
        }
      } catch {}
      return null;
    }

    function installActiveDocListener(onChange) {
      const bcLegacy = ('BroadcastChannel' in window) ? new BroadcastChannel('form-suite-doc') : null;
      const bcCanon  = ('BroadcastChannel' in window) ? new BroadcastChannel('fs-active-doc') : null;

      function emit(meta) {
        if (meta?.docId) {
          try { localStorage.setItem(ACTIVE_DOC_KEY, JSON.stringify({ docId: meta.docId, name: meta.name })); } catch {}
        } else {
          try { localStorage.removeItem(ACTIVE_DOC_KEY); } catch {}
        }
        onChange(meta || null);
      }

      bcLegacy?.addEventListener('message', (ev) => {
        const m = ev?.data || {};
        if (m.type === 'doc-cleared') { emit(null); return; }
        if (m.type === 'doc-switched' || m.type === 'doc-updated') {
          emit((m.docId) ? { docId: m.docId, name: m.name } : readActiveDocSync());
        }
        if (m.type === 'schema-updated') {
          const meta = readActiveDocSync();
          if (meta?.docId && (!m.docId || m.docId === meta.docId)) emit(meta);
        }
      });

      bcCanon?.addEventListener('message', (ev) => {
        const m = ev?.data || {};
        if (m.type === 'active:set')   emit({ docId: m.docId, name: m.name });
        if (m.type === 'active:clear') emit(null);
        if (m.type === 'active:updated') {
          const meta = readActiveDocSync();
          if (meta?.docId) emit(meta);
        }
      });

      window.addEventListener('storage', (e) => {
        if (e.key === ACTIVE_DOC_KEY) {
          const v = e.newValue ? JSON.parse(e.newValue) : null;
          emit(v);
        }
        if (e.key === 'FS_CURRENT_DOC_META' && !localStorage.getItem(ACTIVE_DOC_KEY)) {
          const v = e.newValue ? JSON.parse(e.newValue) : null;
          if (v?.docId) {
            try { localStorage.setItem(ACTIVE_DOC_KEY, e.newValue); } catch {}
            emit(v);
          }
        }
      });
    }

    installActiveDocListener(async (meta) => {
      currentDoc = meta;
      if (!currentDoc?.docId) { await hardResetOpenForm('cleared'); return; }
      const st = await window.formSuitePersist.loadState?.(currentDoc.docId);
      schema = st?.schema || null;
      values = st?.values || {};
      fieldRules = loadFieldRulesForDoc(st);
      if (!schema) {
        // Attempt one-time hydration from DOCX payload so Form loads without visiting Extractor
        await hydrateWorkspaceFromDocxIfEmpty();
      }
      setStatus(`Active DOCX: <span class="kbd">${currentDoc.name}</span>${schema ? '' : ' — <span class="muted">no schema yet</span>'}`);
      renderForm();
      await updateWriteAccessBanner();
    });

    // ---------- Foreground refresh (coalesced) ----------
    let __refreshLock = false;
    let __refreshPending = false;

    async function ensureActiveDocOrReset() {
      if (__refreshLock) { __refreshPending = true; return; }
      __refreshLock = true;
      try {
        currentDoc = readActiveDocSync() || currentDoc;
        if (!currentDoc?.docId) { await hardResetOpenForm('no active doc'); return; }

        const st = await window.formSuitePersist.loadState?.(currentDoc.docId);
        schema = st?.schema || null;
        values = st?.values || {};
        fieldRules = loadFieldRulesForDoc(st);
        if (!schema) {
          await hydrateWorkspaceFromDocxIfEmpty();
        }
        setStatus(`Active DOCX: <span class="kbd">${currentDoc.name}</span>${schema ? '' : ' — <span class="muted">no schema yet</span>'}`);
        renderForm();
        await updateWriteAccessBanner();
      } catch (e) {
        console.warn('ensureActiveDocOrReset failed:', e);
      } finally {
        __refreshLock = false;
        if (__refreshPending) { __refreshPending = false; ensureActiveDocOrReset(); }
      }
    }

    document.addEventListener('visibilitychange', async () => {
      if (document.visibilityState !== 'visible') return;
      await ensureActiveDocOrReset();
    });
    window.addEventListener('focus', async () => { await ensureActiveDocOrReset(); });

    // ---------- Permission banner ----------
    async function updateWriteAccessBanner({ tryPrompt = false } = {}) {
      try {
        if (!supportsFS || !currentDoc?.docId) { els.permNote.style.display = 'none'; return 'unsupported'; }
        const h = await window.formSuitePersist.getHandle?.(currentDoc.docId);
        if (!h?.queryPermission) { els.permNote.style.display = 'none'; return 'no-handle'; }

        let p = await h.queryPermission({ mode: 'readwrite' });
        if (p !== 'granted' && tryPrompt) {
          try { p = await h.requestPermission({ mode: 'readwrite' }) || p; } catch {}
        }
        els.permNote.style.display = (p === 'granted') ? 'none' : 'block';
        return p || 'denied';
      } catch (e) {
        console.warn('updateWriteAccessBanner failed:', e);
        els.permNote.style.display = 'block';
        return 'error';
      }
    }
    els.btnRegrant?.addEventListener('click', async () => {
      const p = await updateWriteAccessBanner({ tryPrompt: true });
      if (p === 'granted') {
        await ensureActiveDocOrReset();
      }
    });

    // ---------- Pyodide (robust) ----------
    let pyLoaded = false;
    let py = null;

    async function ensurePy(forceReinit = false) {
      if (forceReinit && py && py._module) { pyLoaded = false; py = null; }
      if (!pyLoaded) {
        await new Promise((res, rej) => {
          if (window.loadPyodide) return res();
          const s = document.createElement('script');
          s.src = "https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js";
          s.onload = res; s.onerror = rej; document.head.appendChild(s);
        });
        py = await loadPyodide({ indexURL: "https://cdn.jsdelivr.net/pyodide/v0.24.1/full/" });

        await py.runPythonAsync(`
import io, zipfile, json
import xml.etree.ElementTree as ET

_W_NS = "http://schemas.openxmlformats.org/wordprocessingml/2006/main"
def _q(local): return "{%s}%s" % (_W_NS, local)

# ---------------------- existing helpers ----------------------
def write_docvar(u8, var_name, value):
    data = bytes(u8); outbuf = io.BytesIO()
    with zipfile.ZipFile(io.BytesIO(data), "r") as zfin, zipfile.ZipFile(outbuf,"w",compression=zipfile.ZIP_DEFLATED) as zfout:
        try: names = set(zfin.namelist())
        except: names = set()
        if "word/settings.xml" in names:
            try: root = ET.fromstring(zfin.read("word/settings.xml"))
            except ET.ParseError: root = ET.Element(_q("settings"))
        else:
            root = ET.Element(_q("settings"))
        doc_vars = root.find(_q("docVars"))
        if doc_vars is None:
            doc_vars = ET.SubElement(root, _q("docVars"))
        target = None
        for dv in doc_vars.findall(_q("docVar")):
            if dv.get(_q("name")) == var_name:
                target = dv; break
        if target is None:
            target = ET.SubElement(doc_vars, _q("docVar"), {_q("name"): var_name, _q("val"): value})
        else:
            target.set(_q("val"), value)
        settings_bytes = ET.tostring(root, encoding="utf-8", xml_declaration=True)
        for n in zfin.namelist():
            if n == "word/settings.xml": continue
            zfout.writestr(n, zfin.read(n))
        zfout.writestr("word/settings.xml", settings_bytes)
    return outbuf.getvalue()

def read_docvar_settings(u8, var_name):
    data = bytes(u8)
    with zipfile.ZipFile(io.BytesIO(data), "r") as zf:
        try:
            xml = zf.read("word/settings.xml")
        except KeyError:
            return None
        try:
            root = ET.fromstring(xml)
        except ET.ParseError:
            return None
        W_NS = "http://schemas.openxmlformats.org/wordprocessingml/2006/main"
        def _q(local):
            return "{%s}%s" % (W_NS, local)
        doc_vars = root.find(_q("docVars"))
        if doc_vars is None:
            return None
        for dv in doc_vars.findall(_q("docVar")):
            if dv.get(_q("name")) == var_name:
                return dv.get(_q("val"))
    return None

def read_docvar_custom(u8, var_name):
    data = bytes(u8)
    name = str(var_name or "")
    with zipfile.ZipFile(io.BytesIO(data), "r") as zf:
        try:
            xml = zf.read("docProps/custom.xml")
        except KeyError:
            return None
        try:
            root = ET.fromstring(xml)
        except ET.ParseError:
            return None
        ns = {
            'cp': 'http://schemas.openxmlformats.org/officeDocument/2006/custom-properties',
            'vt': 'http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes'
        }
        for prop in root.findall('cp:property', ns):
            if prop.get('name') == name:
                for child in list(prop):
                    if child.text is not None:
                        return child.text
    return None

def _set_sdt_text(content_el, value):
    texts = content_el.findall(".//w:t", {"w": _W_NS})
    if texts:
        first = True
        for t in texts:
            if first:
                t.text = value
                first = False
            else:
                t.text = ""
        return
    has_block = (content_el.find(".//w:p", {"w": _W_NS}) is not None) or (content_el.find(".//w:tbl", {"w": _W_NS}) is not None)
    for ch in list(content_el): content_el.remove(ch)
    if has_block:
        p = ET.SubElement(content_el, _q("p")); r = ET.SubElement(p, _q("r"))
    else:
        r = ET.SubElement(content_el, _q("r"))
    t = ET.SubElement(r, _q("t")); t.text = value
    if (value.strip() != value) or ("\\n" in value) or ("  " in value):
        t.set("{http://www.w3.org/XML/1998/namespace}space", "preserve")

def write_sdts_by_tag(u8, tag_to_text_json):
    try: mapping = json.loads(tag_to_text_json or "{}")
    except Exception: mapping = {}
    if not mapping: return u8
    data = bytes(u8); outbuf = io.BytesIO()
    with zipfile.ZipFile(io.BytesIO(data), "r") as zfin, zipfile.ZipFile(outbuf,"w",compression=zipfile.ZIP_DEFLATED) as zfout:
        names = zfin.namelist()
        def is_target(name):
            if not (name.startswith("word/") and name.endswith(".xml")): return False
            skip = {"word/styles.xml","word/numbering.xml","word/theme/theme1.xml","word/fontTable.xml","word/settings.xml","word/webSettings.xml"}
            return name not in skip and not name.startswith("word/_rels/")
        for n in names:
            if not is_target(n):
                zfout.writestr(n, zfin.read(n)); continue
            try:
                root = ET.fromstring(zfin.read(n))
            except ET.ParseError:
                zfout.writestr(n, zfin.read(n)); continue
            changed = False
            for sdt in root.findall(".//w:sdt", {"w": _W_NS}):
                pr = sdt.find("w:sdtPr", {"w": _W_NS})
                if pr is None: continue
                tag_el = pr.find("w:tag", {"w": _W_NS})
                tag_val = tag_el.get(_q("val")) if tag_el is not None else ""
                if not tag_val or tag_val not in mapping: continue
                content_el = sdt.find("w:sdtContent", {"w": _W_NS}) or sdt
                val = mapping.get(tag_val, "")
                if not isinstance(val, str):
                    try: val = json.dumps(val, ensure_ascii=False)
                    except Exception: val = str(val)
                _set_sdt_text(content_el, val); changed = True
            out_xml = ET.tostring(root, encoding="utf-8", xml_declaration=True) if changed else zfin.read(n)
            zfout.writestr(n, out_xml)
    return outbuf.getvalue()

# ---------- heading + block collectors ----------
def _heading_level(p_el):
    ppr = p_el.find(_q("pPr"))
    if ppr is not None:
        ol = ppr.find(_q("outlineLvl"))
        if ol is not None and ol.get(_q("val")) is not None:
            try: return int(ol.get(_q("val"))) + 1
            except: pass
        ps = ppr.find(_q("pStyle"))
        if ps is not None and ps.get(_q("val")):
            v = ps.get(_q("val")).lower()
            if v.startswith("heading"):
                try: return int(v.replace("heading","").strip())
                except: return None
    return None

def _iter_blocks_within(container, top_level):
    for node in list(container):
        if node.tag == _q("sdt"):
            inner = node.find(_q("sdtContent"))
            if inner is not None:
                yield from _iter_blocks_within(inner, top_level)
            else:
                yield {"element": node, "type": "other", "level": None, "top": top_level}
        elif node.tag == _q("p"):
            yield {"element": node, "type": "p", "level": _heading_level(node), "top": top_level}
        elif node.tag == _q("tbl"):
            yield {"element": node, "type": "tbl", "level": None, "top": top_level}
        else:
            yield {"element": node, "type": "other", "level": None, "top": top_level}

def _collect_body_blocks(body_el):
    blocks = []
    for child in list(body_el):
        if child.tag == _q("sdt"):
            content = child.find(_q("sdtContent"))
            if content is not None:
                blocks.extend(_iter_blocks_within(content, child))
            else:
                blocks.append({"element": child, "type": "other", "level": None, "top": child})
        elif child.tag == _q("p"):
            blocks.append({"element": child, "type": "p", "level": _heading_level(child), "top": child})
        elif child.tag == _q("tbl"):
            blocks.append({"element": child, "type": "tbl", "level": None, "top": child})
        else:
            blocks.append({"element": child, "type": "other", "level": None, "top": child})
    return blocks

# ---------- removal/backup/cleanup helpers ----------
def _is_empty_para(p):
    if p.findall(".//w:fldSimple", {"w": _W_NS}): return False
    if p.findall(".//w:drawing", {"w": _W_NS}): return False
    if p.findall(".//w:object",  {"w": _W_NS}): return False
    if p.findall(".//w:pict",    {"w": _W_NS}): return False
    ts = p.findall(".//w:t", {"w": _W_NS})
    return all(((t.text or "").strip() == "") for t in ts)

def _has_page_break_run(p):
    for br in p.findall(".//w:br", {"w": _W_NS}):
        t = br.get(_q("type"))
        if (t or "").lower() == "page":
            return True
    return False

def _has_page_break_before(p):
    pPr = p.find(_q("pPr"))
    if pPr is None: return False
    return pPr.find(_q("pageBreakBefore")) is not None

def _compact_whitespace(root):
    body = root.find(_q("body")) or root
    # remove empty paragraphs unless they carry a page break
    for node in list(body):
        if node.tag == _q("p"):
            keep_for_page = _has_page_break_run(node) or _has_page_break_before(node)
            if (not keep_for_page) and _is_empty_para(node):
                try: body.remove(node)
                except: pass
    # collapse duplicate page-break-only paras
    def _is_pure_pb(p):
        if p.tag != _q("p"): return False
        if not _has_page_break_run(p): return False
        ts = p.findall(".//w:t", {"w": _W_NS})
        return all(((t.text or "").strip() == "") for t in ts)
    prev_pb = False
    for node in list(body):
        if _is_pure_pb(node):
            if prev_pb:
                try: body.remove(node)
                except: pass
            else:
                prev_pb = True
        else:
            prev_pb = False

def _prune_empty_sdts(root):
    # best-effort: remove SDTs whose content has only empty paragraphs (no tables)
    for sdt in list(root.findall(".//w:sdt", {"w": _W_NS})):
        content = sdt.find(_q("sdtContent"))
        if content is None:
            continue
        if content.find(".//w:tbl", {"w": _W_NS}) is not None:
            continue
        keep = False
        for p in content.findall(".//w:p", {"w": _W_NS}):
            if not _is_empty_para(p):
                keep = True
                break
        if not keep:
            # remove sdt by scanning parent
            removed = False
            for cand in root.iter():
                for ch in list(cand):
                    if ch is sdt:
                        try: cand.remove(ch); removed = True
                        except: pass
                        break
                if removed: break

def _prune_dead_tables(root):
    for tbl in list(root.findall(".//w:tbl", {"w": _W_NS})):
        trs = tbl.findall(".//w:tr", {"w": _W_NS})
        has_cell = False
        for tr in trs:
            if tr.find(".//w:tc", {"w": _W_NS}) is not None:
                has_cell = True; break
        if not has_cell:
            # remove this <w:tbl>
            removed = False
            for cand in root.iter():
                for ch in list(cand):
                    if ch is tbl:
                        try: cand.remove(ch); removed = True
                        except: pass
                        break
                if removed: break

def _ensure_backup_embedded(zfin, zfout, names, backup_path="customXml/originalDocument.xml", override_bytes=None):
    if backup_path in names:
        # Already present → keep existing backup to preserve the untouched original
        return
    if override_bytes is not None:
        try:
            zfout.writestr(backup_path, override_bytes)
        except Exception:
            pass
        return
    try:
        orig = zfin.read("word/document.xml")
        zfout.writestr(backup_path, orig)
    except KeyError:
        pass

def _ensure_update_fields(zfin, zfout):
    try:
        raw = zfin.read("word/settings.xml")
        try:
            root = ET.fromstring(raw)
        except ET.ParseError:
            root = ET.Element(_q("settings"))
    except KeyError:
        root = ET.Element(_q("settings"))

    upd = root.find(_q("updateFields"))
    if upd is None:
        upd = ET.SubElement(root, _q("updateFields"))
    upd.set(_q("val"), "true")

    zfout.writestr("word/settings.xml", ET.tostring(root, encoding="utf-8", xml_declaration=True))

def _extract_part_from_bytes(data_like, part_name):
    if data_like is None:
        return None
    try:
        data = bytes(data_like)
    except Exception:
        return None
    try:
        with zipfile.ZipFile(io.BytesIO(data), "r") as zf:
            return zf.read(part_name)
    except Exception:
        return None

# ----- TOC minimal rebuild -----
def _next_in_doc_order(node, root):
    if node is None: return None
    found = False
    for el in root.iter():
        if found: return el
        if el is node: found = True
    return None

def _find_toc_ranges(root):
    ranges = []
    body = root.find(_q("body")) or root
    fldChars = root.findall(".//w:fldChar", {"w": _W_NS})
    for begin in fldChars:
        if begin.get(_q("val")) != "begin":
            continue
        cur = begin
        instr = ""
        separate = None
        end = None
        while True:
            cur = _next_in_doc_order(cur, body)
            if cur is None: break
            if cur.tag == _q("instrText"): instr += (cur.text or "")
            if cur.tag == _q("fldChar"):
                v = cur.get(_q("val"))
                if v == "separate": separate = cur
                if v == "end":
                    end = cur
                    break
        u = (instr or "").strip().upper()
        if u.startswith("TOC"):
            if separate is not None and end is not None:
                ranges.append((begin, separate, end, instr))
    return ranges

def _rebuild_toc(root): 
    # Replace existing complex range with a minimal fldSimple paragraph
    for (begin, separate, end, instr) in _find_toc_ranges(root):
        switches = (instr.strip() if instr else r'TOC \\o "1-3" \\h \\z \\u')
        # locate host paragraph of 'begin'
        host_p = None
        for par in root.findall(".//w:p", {"w": _W_NS}):
            for el in par.iter():
                if el is begin:
                    host_p = par; break
            if host_p is not None: break
        if host_p is None: continue
        # parent of host_p
        parent = None
        for cand in root.iter():
            for ch in list(cand):
                if ch is host_p:
                    parent = cand; break
            if parent is not None: break
        if parent is None: continue

        # new paragraph with simple TOC field
        p = ET.Element(_q("p"))
        fld = ET.SubElement(p, _q("fldSimple"), {_q("instr"): switches})
        r = ET.SubElement(fld, _q("r")); ET.SubElement(r, _q("t")).text = ""

        idx = list(parent).index(host_p)
        parent.insert(idx, p)

        # remove host_p and following siblings up to node that contains 'end'
        # Simplest: rebuild parent's children excluding nodes that belong to the TOC range
        new_children = []
        skipping = False
        end_reached = False
        for ch in list(parent):
            if not skipping and ch is host_p:
                skipping = True
                continue
            if skipping:
                hit_end = False
                for el in ch.iter():
                    if el is end:
                        hit_end = True; break
                if hit_end:
                    skipping = False
                    end_reached = True
                    continue
                else:
                    continue
            new_children.append(ch)
        # replace
        for ch in list(parent): parent.remove(ch)
        for ch in new_children: parent.append(ch)

# ---------- CORE: remove ranges & embed backup ----------
def apply_removal_with_backup(u8, idx_to_action_json, backup_path="customXml/originalDocument.xml", original_bytes=None):
    """
    idx_to_action_json: {"12":"HIDE","13":"SHOW", ...}
      - For headings where action == "HIDE": remove [heading .. next heading with <= level)
      - Embed original as customXml/originalDocument.xml (if not already present)
      - Cleanup empty SDTs, dead tables, whitespace
      - Rebuild TOC (minimal fldSimple form)
    """
    try:
        idx_to_action = {int(k): v for (k, v) in json.loads(idx_to_action_json).items()}
    except Exception:
        idx_to_action = {}

    data = bytes(u8)
    override_backup = _extract_part_from_bytes(original_bytes, "word/document.xml")
    outbuf = io.BytesIO()

    with zipfile.ZipFile(io.BytesIO(data), "r") as zfin, \
         zipfile.ZipFile(outbuf, "w", compression=zipfile.ZIP_DEFLATED) as zfout:

        names = zfin.namelist()
        # Copy everything first
        for n in names:
            zfout.writestr(n, zfin.read(n))

        # Ensure embedded backup exists (using untouched original if provided)
        _ensure_backup_embedded(zfin, zfout, names, backup_path=backup_path, override_bytes=override_backup)

        # Process primary document (you can extend to headers/footers if needed)
        doc_parts = [n for n in names if n == "word/document.xml"]

        global_idx = 0
        for part in doc_parts:
            try:
                root = ET.fromstring(zfin.read(part))
            except ET.ParseError:
                continue

            body = root.find(_q("body"))
            if body is None:
                zfout.writestr(part, ET.tostring(root, encoding="utf-8", xml_declaration=True))
                continue

            elems = _collect_body_blocks(body)

            heading_positions = []
            for i, blk in enumerate(elems):
                if blk.get("type") == "p" and blk.get("level") is not None:
                    global_idx += 1
                    heading_positions.append((i, blk.get("level"), global_idx))

            to_remove_top_nodes = set()
            for h_i, (pos, lvl, idx) in enumerate(heading_positions):
                if idx_to_action.get(idx) != "HIDE":
                    continue
                # compute end boundary
                if h_i + 1 < len(heading_positions):
                    end = len(elems)
                    for j in range(h_i + 1, len(heading_positions)):
                        np, nl, _ = heading_positions[j]
                        if nl <= lvl:
                            end = np
                            break
                else:
                    end = len(elems)
                # gather distinct top nodes to remove (no duplicates)
                seen = set()
                for j in range(pos, end):
                    top = elems[j].get("top")
                    if top is None: continue
                    k = id(top)
                    if k in seen: continue
                    seen.add(k)
                    to_remove_top_nodes.add(top)

            # Remove nodes by scanning parents (xml.etree has no getparent)
            if to_remove_top_nodes:
                for cand in root.iter():
                    for ch in list(cand):
                        if ch in to_remove_top_nodes:
                            try: cand.remove(ch)
                            except: pass

            # Cleanup & TOC rebuild
            _prune_empty_sdts(root)
            _prune_dead_tables(root)
            _compact_whitespace(root)
            _rebuild_toc(root)

            zfout.writestr(part, ET.tostring(root, encoding="utf-8", xml_declaration=True))

        # Align settings with Word expectations (updateFields must be true)
        _ensure_update_fields(zfin, zfout)

    return outbuf.getvalue()
`);

        pyLoaded = true;
      }
    }

    // Minimal readers for CRONOS_PAYLOAD using pyodide helpers
    async function readDocVarSettings(arrayBufferOrBytes, name) {
      await ensurePy();
      const u8in = arrayBufferOrBytes instanceof Uint8Array ? arrayBufferOrBytes : new Uint8Array(arrayBufferOrBytes);
      const fn = py.globals.get('read_docvar_settings');
      const pyBytes = py.toPy(u8in);
      let pyOut;
      try { pyOut = fn(pyBytes, name); }
      finally { try{fn.destroy();}catch{} try{pyBytes.destroy();}catch{} }
      let txt = null;
      if (pyOut && typeof pyOut.toJs === 'function') txt = pyOut.toJs({ create_proxies:false });
      else txt = pyOut ?? null;
      try { pyOut?.destroy?.(); } catch {}
      return txt;
    }

    async function readDocVarCustom(arrayBufferOrBytes, name) {
      await ensurePy();
      const u8in = arrayBufferOrBytes instanceof Uint8Array ? arrayBufferOrBytes : new Uint8Array(arrayBufferOrBytes);
      const fn = py.globals.get('read_docvar_custom');
      const pyBytes = py.toPy(u8in);
      let pyOut;
      try { pyOut = fn(pyBytes, name); }
      finally { try{fn.destroy();}catch{} try{pyBytes.destroy();}catch{} }
      let txt = null;
      if (pyOut && typeof pyOut.toJs === 'function') txt = pyOut.toJs({ create_proxies:false });
      else txt = pyOut ?? null;
      try { pyOut?.destroy?.(); } catch {}
      return txt;
    }

    // PAYLOAD_KEY is defined earlier in this script
    // Lightweight JSZip-based payload reader (no Pyodide dependency on index)
    async function ensureJSZip(){
      if (window.JSZip) return;
      await new Promise((res, rej) => {
        const s = document.createElement('script');
        s.src = 'https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js';
        s.onload = res; s.onerror = rej; document.head.appendChild(s);
      });
    }

    async function readPayloadFromDocx(bytes){
      try {
        await ensureJSZip();
        const zip = await window.JSZip.loadAsync(bytes);
        // Try settings.xml → w:docVars/w:docVar
        const settings = zip.file('word/settings.xml');
        if (settings) {
          const xmlText = await settings.async('string');
          const parser = new DOMParser();
          const xml = parser.parseFromString(xmlText, 'application/xml');
          const W_NS = 'http://schemas.openxmlformats.org/wordprocessingml/2006/main';
          const docVars = xml.getElementsByTagNameNS(W_NS, 'docVars')[0];
          if (docVars) {
            const vars = docVars.getElementsByTagNameNS(W_NS, 'docVar');
            for (let i = 0; i < vars.length; i++) {
              const dv = vars[i];
              const name = dv.getAttributeNS(W_NS, 'name') || dv.getAttribute('w:name') || dv.getAttribute('name');
              if (name === PAYLOAD_KEY) {
                const val = dv.getAttributeNS(W_NS, 'val') || dv.getAttribute('w:val') || dv.getAttribute('val') || '';
                return val || null;
              }
            }
          }
        }
        // Fallback: docProps/custom.xml → cp:property[name=PAYLOAD_KEY]
        const custom = zip.file('docProps/custom.xml');
        if (custom) {
          const xmlText = await custom.async('string');
          const parser = new DOMParser();
          const xml = parser.parseFromString(xmlText, 'application/xml');
          const props = xml.getElementsByTagName('property');
          for (let i = 0; i < props.length; i++) {
            const p = props[i];
            const nm = p.getAttribute('name');
            if (nm === PAYLOAD_KEY) {
              const child = p.firstElementChild;
              return child && child.textContent ? child.textContent : null;
            }
          }
        }
      } catch (e) { console.warn('readPayloadFromDocx failed', e); }
      return null;
    }

    let __hydrating = false;
    async function hydrateWorkspaceFromDocxIfEmpty() {
      try {
        if (__hydrating) return false;
        if (!currentDoc?.docId) return false;
        const st = await window.formSuitePersist.loadState?.(currentDoc.docId);
        const hasSchema = Array.isArray(st?.schema?.fields) && st.schema.fields.length > 0;
        if (hasSchema) return false; // nothing to do
        setStatus('Restoring from document…');
        const bytes = await fetchWorkingDocBytes();
        if (!bytes) return false;
        __hydrating = true;
        let payloadRaw = await readPayloadFromDocx(bytes);
        if (!payloadRaw) return false;
        let payload = null;
        try { payload = JSON.parse(payloadRaw); } catch { payload = null; }
        if (!payload || !Array.isArray(payload.fields) || !payload.fields.length) return false;

        const nextSchema = { title: payload.title || 'Form', fields: payload.fields };
        const cleanValues = sanitizeValues(nextSchema, payload.values || {});
        const tagMap = payload.tagMap || {};
        const rules  = Array.isArray(payload.rules) ? payload.rules : [];
        const restoredFieldRules = Array.isArray(payload.fieldRules) ? payload.fieldRules : [];
        await window.formSuitePersist.saveState(currentDoc.docId, {
          schema: nextSchema,
          values: cleanValues,
          tagMap,
          rules,
          fieldRules: restoredFieldRules,
          schemaUpdatedAt: new Date().toISOString()
        });
        // refresh local variables + UI
        schema = nextSchema;
        values = cleanValues;
        fieldRules = restoredFieldRules;
        renderForm();
        setStatus(`Active DOCX: <span class="kbd">${currentDoc.name}</span>`);
        return true;
      } catch (e) {
        console.warn('hydrateWorkspaceFromDocxIfEmpty failed:', e);
        return false;
      } finally {
        __hydrating = false;
      }
    }

    async function writeDocVar(bytes, name, value) {
      await ensurePy();
      const fn = py.globals.get('write_docvar');
      const pyBytes = py.toPy(new Uint8Array(bytes));
      let pyOut;
      try { pyOut = fn(pyBytes, name, value); }
      finally { try{fn.destroy();}catch{} try{pyBytes.destroy();}catch{} }
      let u8;
      if (pyOut?.toJs) u8 = pyOut.toJs({ create_proxies:false });
      else if (pyOut?.getBuffer) u8 = new Uint8Array(pyOut.getBuffer());
      else u8 = new Uint8Array([]);
      try { pyOut.destroy?.(); } catch {}
      return u8;
    }

    async function writeSDTs(arrayBufferOrBytes, tagToTextObj) {
      await ensurePy();
      const u8in = arrayBufferOrBytes instanceof Uint8Array ? arrayBufferOrBytes : new Uint8Array(arrayBufferOrBytes);
      const fn = py.globals.get('write_sdts_by_tag');
      const pyBytes = py.toPy(u8in);
      const pyMap   = py.toPy(JSON.stringify(tagToTextObj || {}));
      let pyOut;
      try { pyOut = fn(pyBytes, pyMap); }
      finally { try{fn.destroy();}catch{} try{pyBytes.destroy();}catch{} try{pyMap.destroy();}catch{} }
      let u8;
      if (pyOut?.toJs) u8 = pyOut.toJs({ create_proxies:false });
      else if (pyOut?.getBuffer) u8 = new Uint8Array(pyOut.getBuffer());
      else u8 = new Uint8Array([]);
      try { pyOut.destroy?.(); } catch {}
      return u8;
    }

    // ---------- Helpers: sanitize ----------
    function sanitizeValues(schema, vals) {
      const out = {};
      const fields = Array.isArray(schema?.fields) ? schema.fields : [];

      for (const f of fields) {
        const id = f.id;
        let v = vals?.[id];

        if (f.type === 'datediff') {
          const d = vals?.[id];
          if (d && typeof d === 'object') {
            const outObj = {
              days: Number(d.days ?? 0),
              months: Number(d.months ?? 0),
              years: Number(d.years ?? 0),
              formatted: String(d.formatted ?? '')
            };
            if (outObj.formatted) out[id] = outObj;
          } else if (Number.isFinite(Number(d))) {
            const n = Number(d);
            out[id] = { days: n, months: 0, years: 0, formatted: `${n}-0-0 (${n})` };
          }
          continue;
        }

        if (f.type === 'address') {
          const vv = vals?.[id];
          if (typeof vv === 'string') {
            const s = vv.trim();
            if (s || f.required) out[id] = s ? { formatted: s } : { formatted: '' };
          } else if (vv && typeof vv === 'object') {
            const o = {
              formatted: vv.formatted || '',
              street: vv.street || '',
              houseNumber: vv.houseNumber || '',
              postcode: vv.postcode || '',
              city: vv.city || '',
              country: vv.country || '',
              lat: (vv.lat ?? null),
              lon: (vv.lon ?? null)
            };
            if (o.formatted || f.required) out[id] = o;
          }
          continue;
        }

        if (f.type === 'multichoice') {
          let arr = Array.isArray(v) ? v.slice() : (typeof v === 'string' ? v.split(',') : []);
          arr = arr.map(x => String(x).trim()).filter(Boolean);

          let allowed = null;
          if (Array.isArray(f.options) && f.options.length) {
            allowed = new Set(
              f.options.map(o => (o && typeof o === 'object')
                ? String(o.value ?? o.label ?? '')
                : String(o)
              )
            );
          } else if (f.mc && Array.isArray(f.mc.groups)) {
            allowed = new Set(
              f.mc.groups.flatMap(g => (g.items || []).map(it => String((it?.value ?? it?.label ?? ''))))
            );
          }
          if (allowed) arr = arr.filter(x => allowed.has(String(x)));
          if (arr.length) out[id] = arr;
          else if (f.required) out[id] = [];

          if (f.mc && Array.isArray(f.mc.groups)) {
            for (const g of f.mc.groups) {
              for (const it of (g.items || [])) {
                const optVal = String(it?.value || '');
                const extras = Array.isArray(it?.fields) ? it.fields : [];
                for (const ex of extras) {
                  const exId = String(ex?.id || '');
                  if (!exId) continue;
                  const k = mcExtraKey(f.id, optVal, exId);
                  const raw = vals?.[k];

                  if (ex.type === 'date') {
                    const s = String(raw ?? '');
                    if (s) out[k] = s;
                    continue;
                  }

                  if (ex.type === 'number') {
                    if (raw === '' || raw == null) continue;
                    const num = (typeof raw === 'number') ? raw : Number(String(raw).replace(',', '.'));
                    if (Number.isFinite(num)) out[k] = num;
                    continue;
                  }

                  if (ex.type === 'datediff') {
                    if (raw && typeof raw === 'object' && typeof raw.days !== 'undefined') {
                      const o = {
                        days: Number(raw.days ?? 0),
                        months: Number(raw.months ?? 0),
                        years: Number(raw.years ?? 0),
                        formatted: String(raw.formatted ?? '')
                      };
                      if (o.formatted) out[k] = o;
                    }
                    continue;
                  }

                  const s = String(raw ?? '');
                  if (s) out[k] = s;
                }
              }
            }
          }
          continue;
        }

        if (f.type === 'select') {
          let s = Array.isArray(v) ? String(v[0] ?? '') : String(v ?? '');
          if (Array.isArray(f.options) && f.options.length) {
            const allowed = new Set(f.options.map(String));
            if (!allowed.has(s)) s = '';
          }
          if (s === '') { if (f.required) out[id] = s; }
          else out[id] = s;
          continue;
        }

        if (f.type === 'number') {
          if (v === '' || v == null) continue;
          const num = (typeof v === 'number') ? v : Number(String(v).replace(',', '.'));
          if (Number.isFinite(num)) out[id] = num;
          continue;
        }

        if (f.type === 'date') { out[id] = String(v ?? ''); continue; }

        if (f.type === 'table') {
          const cols = Array.isArray(f.columns) ? f.columns : [];
          const colIds = cols.map(c => c.id);
          const arr = Array.isArray(v) ? v : [];
          const cleaned = arr.map(row => {
            const o = {};
            for (const cid of colIds) {
              let cell = row?.[cid];
              if (cell == null) cell = '';
              o[cid] = (typeof cell === 'string') ? cell : String(cell);
            }
            return o;
          }).filter(r => Object.values(r).some(val => String(val).trim() !== ''));
          const min = Math.max(0, parseInt(f.minRows || 0, 10));
          while (cleaned.length < min) {
            const empty = {}; colIds.forEach(cid => empty[cid] = '', cleaned.push(empty));
          }
          if (cleaned.length) out[id] = cleaned;
          else if (f.required) out[id] = [];
          continue;
        }

        const s = String(v ?? '');
        if (s || f.required) out[id] = s;
      }

      return out;
    }

    function sanitizeTagMap(tagMap, validIds) {
      const out = {};
      for (const [tag, fid] of Object.entries(tagMap || {})) {
        if (validIds.has(fid)) out[tag] = fid;
      }
      return out;
    }

    // ---------- Init ----------
    init().catch(console.error);

    async function init() {
      currentDoc = readActiveDocSync();

      if (currentDoc?.docId) {
        const bytes = await fetchWorkingDocBytes();
        if (!bytes) { await hardResetOpenForm('no bytes / no permission'); return; }

        const st = await window.formSuitePersist.loadState?.(currentDoc.docId);
        schema = st?.schema || null;
        values = st?.values || {};
        setStatus(`Active DOCX: <span class="kbd">${currentDoc.name}</span>${schema ? '' : ' — <span class="muted">no schema yet</span>'}`);
        await updateWriteAccessBanner();
      } else {
        schema = loadLS();
        values = {};
        fieldRules = [];
      }

      renderForm();
    }

    // ---------- Robust bytes fetcher ----------
    async function fetchWorkingDocBytes() {
      try { const b = await window.formSuitePersist.getCurrentDocBytes?.(); if (b && b.byteLength) return b; } catch {}
      try { if (currentDoc?.docId) { const b2 = await window.formSuitePersist.getBytes?.(currentDoc.docId); if (b2 && b2.byteLength) return b2; } } catch {}
      try {
        const h = await window.formSuitePersist.getHandle?.(currentDoc?.docId);
        if (h?.getFile) {
          let p = await window.formSuitePersist.ensurePermission?.(h, 'readwrite');
          if (p !== 'granted') p = await window.formSuitePersist.ensurePermission?.(h, 'read');
          if (p === 'granted') { const f = await h.getFile(); return await f.arrayBuffer(); }
        }
      } catch {}
      try { await window.formSuitePersist.regrantAll?.(); const b3 = await window.formSuitePersist.getCurrentDocBytes?.(); if (b3 && b3.byteLength) return b3; } catch {}
      return null;
    }

    // ---- DATEDIFF helpers ----
    function parseDateByFormat(str, fmt) {
      if (!str) return null;
      try {
        const d = (window.flatpickr && window.flatpickr.parseDate)
          ? window.flatpickr.parseDate(String(str), fmt || 'Y-m-d')
          : new Date(String(str));
        return (d && !isNaN(d.getTime())) ? d : null;
      } catch { return null; }
    }

    function diffInDays(a, b) {
      const A = new Date(a.getFullYear(), a.getMonth(), a.getDate());
      const B = new Date(b.getFullYear(), b.getMonth(), b.getDate());
      const ms = B - A;
      return Math.floor(ms / (24*60*60*1000));
    }
    function diffInMonths(a, b) {
      let months = (b.getFullYear() - a.getFullYear()) * 12 + (b.getMonth() - a.getMonth());
      if (b.getDate() < a.getDate()) months -= 1;
      return months;
    }
    function diffInYears(a, b) {
      let years = b.getFullYear() - a.getFullYear();
      const bBeforeAnniversary = (b.getMonth() < a.getMonth()) || (b.getMonth() === a.getMonth() && b.getDate() < a.getDate());
      if (bBeforeAnniversary) years -= 1;
      return years;
    }

    function computeDateDiff(fromDate, toDate, unit = 'days') {
      if (!fromDate || !toDate) return null;
      const u = String(unit || 'days').toLowerCase();
      if (u === 'years')  return diffInYears(fromDate, toDate);
      if (u === 'months') return diffInMonths(fromDate, toDate);
      return diffInDays(fromDate, toDate);
    }

    function createPrettyDatepicker(input, extraOpts = {}) {
      if (!document.getElementById('fp-zindex-fix')) {
        const st = document.createElement('style');
        st.id = 'fp-zindex-fix';
        st.textContent = `
          .flatpickr-calendar { z-index: 50; }
          .flatpickr-wrapper { position: relative; }
        `;
        document.head.appendChild(st);
      }

      const baseOpts = {
        dateFormat: 'Y-m-d',
        altInput: true,
        altFormat: 'D, j M Y',
        allowInput: false,
        clickOpens: true,
        disableMobile: true,
        static: true,
        wrap: false,
        monthSelectorType: 'dropdown',
        weekNumbers: true,
        prevArrow: '‹',
        nextArrow: '›',
        onReady: (_sel, _str, inst) => {
          if (inst.altInput) {
            inst.altInput.readOnly = true;
            inst.altInput.tabIndex = 0;
            inst.altInput.style.pointerEvents = 'auto';
            const wrap = inst.altInput.parentElement;
            if (wrap && !wrap.classList.contains('flatpickr-wrapper')) {
              wrap.classList.add('flatpickr-wrapper');
              if (getComputedStyle(wrap).position === 'static') {
                wrap.style.position = 'relative';
              }
            }
          }
        }
      };

      return flatpickr(input, { ...baseOpts, ...extraOpts });
    }


    function slugifyMc(s) {
      return String(s || '')
        .normalize('NFKD')
        .replace(/[\u0300-\u036f]/g, '')
        .replace(/[^a-zA-Z0-9]+/g, '_')
        .replace(/^_+|_+$/g, '')
        .toLowerCase();
    }
    function mcExtraKey(fieldId, optionValue, extraId) {
      return `${fieldId}__${slugifyMc(optionValue)}__${slugifyMc(extraId)}`;
    }

    // ---------- Render whole form ----------
    function renderForm() {
      (function injectMcStyles(){
        const ID = 'mc-caret-styles';
        if (document.getElementById(ID)) return;
        const s = document.createElement('style');
        s.id = ID;
        s.textContent = `
          .mc-item { position: relative; }
          .mc-toggle { all: unset; position: absolute; top: 10px; right: 10px; display: inline-flex; align-items: center; justify-content: center; cursor: pointer; line-height: 1; padding: 0; margin: 0; pointer-events: auto; }
          .mc-toggle:focus-visible { outline: 2px solid var(--focus, #2563eb); outline-offset: 2px; border-radius: 4px; }
          .mc-caret { width: 14px; height: 14px; transition: transform .18s ease, opacity .18s ease; opacity: .85; transform: rotate(0deg); display: block; }
          .mc-caret.open { transform: rotate(90deg); }
          .mc-extras { display: none; height: 0; grid-template-columns: 1fr; row-gap: 8px; padding-bottom: 2px; width: 100%; }
          .mc-option-label{ display:grid; grid-template-columns:auto 1fr; column-gap:8px; align-items:center; cursor:pointer; line-height:1.25; }
          .mc-option-label > span{ white-space:normal; word-break:break-word; }
          .mc-option-checkbox{ align-self:center; margin-top:0; transform:none; }
        `;
        document.head.appendChild(s);
      })();

      const __slugifyMc = (window.slugifyMc) ? window.slugifyMc : function (s) {
        return String(s || '')
          .normalize('NFKD')
          .replace(/[\u0300-\u036f]/g, '')
          .replace(/[^a-zA-Z0-9]+/g, '_')
          .replace(/^_+|_+$/g, '')
          .toLowerCase();
      };
      const __mcExtraKey = (window.mcExtraKey) ? window.mcExtraKey : function (fieldId, optionValue, extraId) {
        return `${fieldId}__${__slugifyMc(optionValue)}__${__slugifyMc(extraId)}`;
      };

      const mount = els.formMount;
      mount.innerHTML = '';
      if (!schema || !Array.isArray(schema.fields) || !schema.fields.length) {
        mount.innerHTML = `<div class="muted">No schema found. Create one in the <a href="builder.html">Builder</a>.</div>`;
        if (btnExportMain) btnExportMain.disabled = true;
        return;
      }

      (schema.fields || []).forEach(f => {
        if (f.type === 'table') {
          if (!Array.isArray(values[f.id])) {
            const min = Math.max(0, parseInt(f.minRows || 0, 10));
            values[f.id] = Array.from({ length: min }, () => emptyRow(f));
          } else {
            values[f.id] = values[f.id].map(r => ({ ...emptyRow(f), ...(r || {}) }));
          }
        }
      });

      const form = document.createElement('form');
      form.classList.add('form-grid');

      if (schema.title) {
        const h = document.createElement('h4');
        h.textContent = schema.title;
        h.style.gridColumn = '1 / -1';
        form.appendChild(h);
      }

      const inputRefs  = {};
      const mcDateRefs = {};
      const datediffRefs = [];
      const guardPairs = [];

      function scheduleSaveState() {
        clearTimeout(scheduleSaveState._t);
        scheduleSaveState._t = setTimeout(() => {
          if (!currentDoc?.docId) return;
          const cleanValues = sanitizeValues(schema, values);
          window.formSuitePersist.saveState(currentDoc.docId, { schema, values: cleanValues });
        }, 150);
      }

      function setExtrasOpen(extras, caretEl, open) {
        if (!extras) return;
        const DURATION = 220;

        if (extras._animTimer) { clearTimeout(extras._animTimer); extras._animTimer = null; }
        if (extras._onTe) { extras.removeEventListener('transitionend', extras._onTe); extras._onTe = null; }

        const onEnd = () => {
          extras.style.transition = '';
          extras.style.willChange = '';
          extras.style.opacity = open ? '1' : '0';
          extras.style.marginTop = open ? '8px' : '0px';
          extras.style.height = open ? 'auto' : '0px';
          extras.style.overflow = 'visible';
          if (!open) extras.style.display = 'none';
          if (extras._onTe) {
            extras.removeEventListener('transitionend', extras._onTe);
            extras._onTe = null;
          }
        };
        extras._onTe = onEnd;
        extras.addEventListener('transitionend', onEnd);

        if (caretEl) caretEl.classList.toggle('open', !!open);

        if (open) {
          extras.style.display = 'grid';
          extras.style.overflow = 'visible';
          extras.style.willChange = 'height, opacity, margin-top';
          extras.style.opacity = '0';
          extras.style.marginTop = '0px';
          extras.style.height = '0px';

          requestAnimationFrame(() => {
            const h = extras.scrollHeight;
            extras.classList.add('open');
            extras.style.transition = `height ${DURATION}ms ease, opacity ${DURATION}ms ease, margin-top ${DURATION}ms ease`;
            extras.style.height = h + 'px';
            extras.style.opacity = '1';
            extras.style.marginTop = '8px';
            extras._animTimer = setTimeout(onEnd, DURATION + 40);
          });
        } else {
          const current = extras.offsetHeight || extras.scrollHeight || 0;
          extras.classList.remove('open');
          extras.style.display = 'grid';
          extras.style.overflow = 'hidden';
          extras.style.willChange = 'height, opacity, margin-top';
          extras.style.transition = '';
          extras.style.height = current + 'px';
          extras.style.opacity = '1';
          extras.style.marginTop = '8px';

          requestAnimationFrame(() => {
            extras.style.transition = `height ${DURATION}ms ease, opacity ${DURATION}ms ease, margin-top ${DURATION}ms ease`;
            extras.style.height = '0px';
            extras.style.opacity = '0';
            extras.style.marginTop = '0px';
            extras._animTimer = setTimeout(onEnd, DURATION + 40);
          });
        }
      }

      (schema.fields || []).forEach(f => {
        const wrap = document.createElement('div');
        wrap.className = 'field';
        try { wrap.dataset.fieldId = String(f.id || ''); } catch {}
        if (f.type === 'address' || f.type === 'datediff') wrap.classList.add('span-2');
        if (f.type === 'table') wrap.classList.add('full', 'field--table');
        if (f.type === 'multichoice') wrap.classList.add('full', 'field--multichoice');
        if (f.wide === true) wrap.classList.add('span-2');
        if (f.full === true) wrap.classList.add('full');

        if (f.type !== 'address') {
          const label = document.createElement('label');
          label.htmlFor = f.id;
          label.textContent = f.label || f.id;
          if (f.required) {
            const star = document.createElement('span');
            star.textContent = ' *';
            star.style.color = '#ef4444';
            label.appendChild(star);
          }
          wrap.appendChild(label);
        }

        if (f.type === 'text') {
          const input = document.createElement('input');
          input.type = 'text';
          input.id = f.id; input.name = f.id; input.style.width = '100%';
          if (f.required) input.required = true;
          if (values[f.id] != null) input.value = values[f.id];
          input.addEventListener('change', () => { values[f.id] = input.value; scheduleSaveState(); try{ applyFieldVisibility(); }catch{} });
          wrap.appendChild(input);
          inputRefs[f.id] = input;

        } else if (f.type === 'number') {
          const input = document.createElement('input');
          input.type = 'number';
          input.id = f.id; input.name = f.id; input.style.width = '100%';
          if (f.required) input.required = true;
          if (values[f.id] != null) input.value = values[f.id];
          input.addEventListener('change', () => { values[f.id] = Number(input.value); scheduleSaveState(); try{ applyFieldVisibility(); }catch{} });
          wrap.appendChild(input);
          inputRefs[f.id] = input;

        } else if (f.type === 'select') {
          const input = document.createElement('select');
          input.id = f.id; input.name = f.id; input.style.width = '100%';
          (f.options || []).forEach(v => {
            const o = document.createElement('option');
            o.value = String(v); o.textContent = String(v);
            input.appendChild(o);
          });
          if (f.required) input.required = true;
          if (values[f.id] != null) input.value = values[f.id];
          input.addEventListener('change', () => { values[f.id] = input.value; scheduleSaveState(); try{ applyFieldVisibility(); }catch{} });
          wrap.appendChild(input);
          inputRefs[f.id] = input;

        } else if (f.type === 'multichoice') {
          const mcContainer = document.createElement('div');
          mcContainer.className = 'mc-container';
          mcContainer.style.display = 'block';

          const items = [];
          if (f.mc && Array.isArray(f.mc.groups) && f.mc.groups.length) {
            f.mc.groups.forEach(g => (g.items || []).forEach(it =>
              items.push({
                value: String(it.value ?? it.label ?? ''),
                alwaysSelected: !!it.alwaysSelected,
                preselected: !!it.preselected,
                fields: Array.isArray(it.fields) ? it.fields : []
              })
            ));
          } else if (Array.isArray(f.options)) {
            f.options.forEach(v => {
              if (v && typeof v === 'object') {
                items.push({
                  value: String(v.value ?? v.label ?? ''),
                  alwaysSelected: !!v.alwaysSelected,
                  preselected: !!v.preselected,
                  fields: Array.isArray(v.fields) ? v.fields : []
                });
              } else {
                items.push({ value: String(v), alwaysSelected: false, preselected: false, fields: [] });
              }
            });
          }

          if (!Array.isArray(values[f.id])) {
            const initial = items.filter(it => it.alwaysSelected || it.preselected).map(it => it.value);
            if (initial.length) values[f.id] = initial.slice();
          }
          const selected = new Set(Array.isArray(values[f.id]) ? values[f.id].map(String) : []);

          function persistMainSelection() {
            const boxes = mcContainer.querySelectorAll(`input[type="checkbox"][data-mc="1"]`);
            values[f.id] = Array.from(boxes).filter(b => b.checked).map(b => b.value);
            scheduleSaveState();
          }

          function drawOption(item, parentHost) {
            const optVal = item.value;
            const optId  = `${f.id}__${__slugifyMc(optVal)}`;
            const hasExtras = Array.isArray(item.fields) && item.fields.length > 0;

            const card = document.createElement('div');
            card.className = 'mc-item';
            try { card.dataset.optId = `${f.id}__opt__${__slugifyMc(optVal)}`; } catch {}
            card.style.position = 'relative';
            card.style.display = 'flex';
            card.style.flexDirection = 'column';
            card.style.alignItems = 'stretch';
            card.style.background = 'var(--card)';
            card.style.border = '1px solid var(--border-strong)';
            card.style.borderRadius = '8px';
            card.style.padding = '10px 10px';

            const row1 = document.createElement('div');
            row1.className = 'row';
            row1.style.alignItems = 'center';
            row1.style.gap = '8px';
            row1.style.width = '100%';

            const left = document.createElement('label');
            left.className = 'mc-option-label';
            left.setAttribute('for', optId);
            left.style.flex = '1';

            const cb = document.createElement('input');
            cb.type = 'checkbox';
            cb.dataset.mc = '1';
            cb.name = f.id;
            cb.id = optId;
            cb.value = optVal;
            cb.className = 'mc-option-checkbox';

            const locked = !!item.alwaysSelected;
            const isPreselected = !!item.preselected;
            cb.checked = locked || selected.has(optVal) || (!selected.size && isPreselected);
            if (locked) cb.disabled = true;

            const txt = document.createElement('span');
            txt.textContent = optVal;

            left.appendChild(cb);
            left.appendChild(txt);
            row1.appendChild(left);

            let extrasWrap = null;
            if (hasExtras) {
              extrasWrap = document.createElement('div');
              extrasWrap.className = 'mc-extras';
              extrasWrap.style.display = 'none';
              extrasWrap.style.height  = '0px';

              const mountExtraFields = () => {
                extrasWrap.innerHTML = '';
                if (!item.fields.length) return;

                function getDateForExtraKey(key) {
                  const el = mcDateRefs[key];
                  const fp = el?._flatpickr;
                  if (fp?.selectedDates?.[0] instanceof Date) return fp.selectedDates[0];
                  const iso = values[key];
                  if (iso) {
                    const d = (window.flatpickr && window.flatpickr.parseDate)
                      ? window.flatpickr.parseDate(String(iso), 'Y-m-d')
                      : new Date(String(iso));
                    return (d && !isNaN(d)) ? d : null;
                  }
                  return null;
                }

                item.fields.forEach(ex => {
                  const exType = (ex?.type) ? String(ex.type) : 'text';
                  const exId   = String(ex?.id || '');
                  if (!exId) return;
                  const exKey  = __mcExtraKey(f.id, optVal, exId);

                  const line = document.createElement('div');
                  line.className = 'row';
                  line.style.gap = '8px';
                  line.style.alignItems = 'center';
                  line.style.marginTop = '2px';

                  const lab = document.createElement('label');
                  lab.textContent = String(ex?.label || exId);
                  lab.style.minWidth = '120px';
                  lab.style.color = 'var(--muted)';

                  if (exType === 'date') {
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.dataset.type = 'date';
                    input.style.minWidth = '180px';

                    extrasWrap.appendChild(line);
                    line.appendChild(lab);
                    line.appendChild(input);

                    const fp = createPrettyDatepicker(input, {
                      dateFormat: 'Y-m-d',
                      altInput: true,
                      altFormat: 'D, j M Y',
                      defaultDate: values[exKey] || null,
                      onChange: () => { values[exKey] = input.value; scheduleSaveState(); if (window.recomputeDatediffs) window.recomputeDatediffs(); },
                      onValueUpdate: () => { values[exKey] = input.value; scheduleSaveState(); if (window.recomputeDatediffs) window.recomputeDatediffs(); }
                    });
                    fp.set('allowInput', false);
                    if (fp.altInput) fp.altInput.readOnly = true;

                    mcDateRefs[exKey] = input;
                    return;
                  }

                  if (exType === 'number') {
                    const input = document.createElement('input');
                    input.type = 'number';
                    input.value = values[exKey] ?? '';
                    input.addEventListener('change', () => {
                      values[exKey] = Number(input.value);
                      scheduleSaveState();
                    });
                    extrasWrap.appendChild(line);
                    line.appendChild(lab);
                    line.appendChild(input);
                    return;
                  }

                  if (exType === 'datediff') {
                    const fromId = ex.fromId || ex.from || '';
                    const toId   = ex.toId   || ex.to   || '';
                    const fromKey = __mcExtraKey(f.id, optVal, fromId);
                    const toKey   = __mcExtraKey(f.id, optVal, toId);

                    const out = document.createElement('div');
                    out.className = 'datediff-out kbd';
                    out.setAttribute('role', 'status');
                    out.setAttribute('aria-live', 'polite');
                    out.textContent = '—';

                    extrasWrap.appendChild(line);
                    line.appendChild(lab);
                    line.appendChild(out);

                    datediffRefs.push({
                      storeKey: exKey,
                      outEl: out,
                      resolve: () => ({ a: getDateForExtraKey(fromKey), b: getDateForExtraKey(toKey) })
                    });
                    return;
                  }

                  const input = document.createElement('input');
                  input.type = 'text';
                  input.value = values[exKey] ?? '';
                  input.addEventListener('change', () => {
                    values[exKey] = input.value;
                    scheduleSaveState();
                  });
                  extrasWrap.appendChild(line);
                  line.appendChild(lab);
                  line.appendChild(input);
                });
              };
              mountExtraFields();
            }

            let caretBtn = null, caretIcon = null;
            if (hasExtras) {
              caretBtn = document.createElement('button');
              caretBtn.type = 'button';
              caretBtn.className = 'mc-toggle';
              caretBtn.setAttribute('aria-expanded', 'false');
              caretBtn.setAttribute('aria-label', 'Details ein-/ausklappen');

              const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
              svg.setAttribute('viewBox', '0 0 24 24');
              svg.setAttribute('width', '14');
              svg.setAttribute('height', '14');
              svg.classList.add('mc-caret');
              const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
              path.setAttribute('d', 'M9 18l6-6-6-6');
              path.setAttribute('fill', 'none');
              path.setAttribute('stroke', 'currentColor');
              path.setAttribute('stroke-width', '2');
              path.setAttribute('stroke-linecap', 'round');
              path.setAttribute('stroke-linejoin', 'round');
              svg.appendChild(path);

              caretIcon = svg;
              caretBtn.appendChild(svg);
              row1.appendChild(caretBtn);

              setExtrasOpen(extrasWrap, caretIcon, false);

              caretBtn.addEventListener('click', (e) => {
                e.preventDefault();
                const willOpen = !extrasWrap.classList.contains('open');
                caretBtn.setAttribute('aria-expanded', String(willOpen));
                setExtrasOpen(extrasWrap, caretIcon, willOpen);
              });
            }

            cb.addEventListener('change', () => {
              if (locked) { cb.checked = true; return; }
              persistMainSelection();
              try { applyFieldVisibility(); } catch {}
            });

            card.appendChild(row1);
            if (extrasWrap) card.appendChild(extrasWrap);
            parentHost.appendChild(card);
          }

          if (f.mc && Array.isArray(f.mc.groups) && f.mc.groups.length) {
            f.mc.groups.forEach(g => {
              const section = document.createElement('div');
              section.className = 'mc-group-section';
              section.style.marginBottom = '10px';

              if (g.title) {
                const h = document.createElement('div');
                h.className = 'mc-group-title';
                h.textContent = String(g.title);
                h.style.color = 'var(--muted)';
                h.style.fontWeight = '600';
                h.style.fontSize = '.95rem';
                h.style.margin = '4px 0 6px';
                section.appendChild(h);
              }

              const host = document.createElement('div');
              host.className = 'mc-group';
              host.style.display = 'grid';
              host.style.gridTemplateColumns = 'repeat(auto-fill,minmax(260px,1fr))';
              host.style.gap = '8px 16px';
              host.style.alignItems = 'start';
              if (Number.isFinite(+f.columns) && +f.columns > 0) {
                host.style.gridTemplateColumns = `repeat(${+f.columns}, minmax(220px, 1fr))`;
              }

              (g.items || []).forEach(it => drawOption({
                value: String(it.value ?? it.label ?? ''),
                alwaysSelected: !!it.alwaysSelected,
                preselected: !!it.preselected,
                fields: Array.isArray(it.fields) ? it.fields : []
              }, host));

              section.appendChild(host);
              mcContainer.appendChild(section);
            });
          } else {
            const host = document.createElement('div');
            host.className = 'mc-group';
            host.style.display = 'grid';
            host.style.gridTemplateColumns = 'repeat(auto-fill,minmax(260px,1fr))';
            host.style.gap = '8px 16px';
            host.style.alignItems = 'start';
            if (Number.isFinite(+f.columns) && +f.columns > 0) {
              host.style.gridTemplateColumns = `repeat(${+f.columns}, minmax(220px, 1fr))`;
            }
            items.forEach(it => drawOption(it, host));
            mcContainer.appendChild(host);
          }

          values[f.id] = Array.from(mcContainer.querySelectorAll(`input[type="checkbox"][data-mc="1"]`))
            .filter(b => b.checked)
            .map(b => b.value);
          scheduleSaveState();

          wrap.appendChild(mcContainer);

        } else if (f.type === 'date') {
          const input = document.createElement('input');
          input.type = 'text';
          input.dataset.type = 'date';
          input.id = f.id; input.name = f.id; input.style.width = '100%';
          if (f.required) input.required = true;
          wrap.appendChild(input);

          const fp = createPrettyDatepicker(input, {
            dateFormat: 'Y-m-d',
            altInput: true,
            altFormat: 'D-d-M-Y',
            allowInput: false,
            clickOpens: true,
            defaultDate: values[f.id] || null,
            onReady: (_sel, _str, inst) => { if (inst.altInput) inst.altInput.readOnly = true; },
            onChange: () => { values[f.id] = input.value; scheduleSaveState(); if (window.recomputeDatediffs) window.recomputeDatediffs(); try{ applyFieldVisibility(); }catch{} },
            onValueUpdate: () => { values[f.id] = input.value; scheduleSaveState(); if (window.recomputeDatediffs) window.recomputeDatediffs(); try{ applyFieldVisibility(); }catch{} }
          });
          fp.set('allowInput', false);
          if (fp.altInput) fp.altInput.readOnly = true;
          inputRefs[f.id] = input;

        } else if (f.type === 'address') {
          const host = document.createElement('div');
          host.className = 'addr-host';
          wrap.appendChild(host);

          const initial =
            typeof values[f.id] === 'string'
              ? { formatted: values[f.id] }
              : (values[f.id] || null);

          AddressAuto.mount(host, {
            id: f.id,
            label: f.label || 'Address',
            required: !!f.required,
            value: initial || null,
            onChange: (val) => { values[f.id] = val; scheduleSaveState(); }
          });

        } else if (f.type === 'table') {
          renderTableField(wrap, f);

        } else if (f.type === 'datediff') {
          const fromId = f.fromId || f.from || '';
          const toId   = f.toId   || f.to   || '';

          const out = document.createElement('div');
          out.id = f.id;
          out.className = 'datediff-out kbd';
          out.setAttribute('role', 'status');
          out.setAttribute('aria-live', 'polite');
          out.textContent = '—';
          wrap.appendChild(out);

          datediffRefs.push({
            storeKey: f.id,
            outEl: out,
            resolve: () => ({ a: getDateForField(fromId), b: getDateForField(toId) })
          });

          guardPairs.push({ fromId, toId });

        } else {
          const input = document.createElement('input');
          input.type = 'text';
          input.id = f.id; input.name = f.id; input.style.width = '100%';
          if (values[f.id] != null) input.value = values[f.id];
          input.addEventListener('change', () => { values[f.id] = input.value; scheduleSaveState(); });
          wrap.appendChild(input);
          inputRefs[f.id] = input;
        }

        form.appendChild(wrap);
      });

      const bar = document.createElement('div');
      bar.className = 'bar';
      bar.style.gridColumn = '1 / -1';
      btnExportMain = document.createElement('button');
      btnExportMain.type = 'button';
      btnExportMain.className = 'secondary';
      btnExportMain.textContent = 'Export…';
      btnExportMain.disabled = !currentDoc;
      btnExportMain.addEventListener('click', onExportFromOpenForm);
      bar.appendChild(btnExportMain);
      form.appendChild(bar);
      form.addEventListener('change', () => { try { applyFieldVisibility(); } catch {} });
      mount.appendChild(form);

      try { applyFieldVisibility(); } catch {}

      function getDateForField(fid) {
        const el = inputRefs[fid];
        if (!el) return null;
        const fp = el?._flatpickr;
        if (fp?.selectedDates?.[0] instanceof Date) return fp.selectedDates[0];
        const iso = values[fid];
        if (iso) {
          const d = (window.flatpickr && window.flatpickr.parseDate)
            ? window.flatpickr.parseDate(String(iso), 'Y-m-d')
            : new Date(String(iso));
          return (d && !isNaN(d)) ? d : null;
        }
        return null;
      }

      function recomputeDatediffs() {
        datediffRefs.forEach(({ storeKey, outEl, resolve }) => {
          const { a, b } = resolve();
          if (!a || !b) {
            outEl.textContent = '—';
            values[storeKey] = null;
            return;
          }
          const days   = diffInDays(a, b);
          const months = diffInMonths(a, b);
          const years  = diffInYears(a, b);
          const display = `${days}D ${months}M ${years}Y (${days} Days total)`;
          outEl.textContent = display;
          values[storeKey] = { days, months, years, formatted: display };
        });
        scheduleSaveState();
      }
      window.recomputeDatediffs = recomputeDatediffs;

      (function wireTopLevelDateGuards() {
        function nextDay(d) {
          if (!d) return null;
          const n = new Date(d.getFullYear(), d.getMonth(), d.getDate());
          n.setDate(n.getDate() + 1);
          return n;
        }
        guardPairs.forEach(({ fromId, toId }) => {
          const fromEl = inputRefs[fromId];
          const toEl   = inputRefs[toId];
          const fpFrom = fromEl?._flatpickr;
          const fpTo   = toEl?._flatpickr;
          if (!fpFrom || !fpTo) return;

          fpFrom.set('allowInput', false);
          fpTo.set('allowInput', false);
          if (fpFrom.altInput) fpFrom.altInput.readOnly = true;
          if (fpTo.altInput)   fpTo.altInput.readOnly   = true;

          const syncToWithFrom = (opts = { snap: true, jump: true }) => {
            const from = fpFrom.selectedDates?.[0] || null;
            const minForTo = nextDay(from);
            fpTo.set('minDate', minForTo || null);

            const toSel = fpTo.selectedDates?.[0] || null;
            if (!toSel && minForTo && opts.snap) fpTo.setDate(minForTo, true);
            if (from && toSel && toSel <= from && opts.snap) fpTo.setDate(minForTo, true);
            if (minForTo && opts.jump) { try { fpTo.jumpToDate(minForTo); } catch {} }

            if (typeof window.recomputeDatediffs === 'function') window.recomputeDatediffs();
          };

          syncToWithFrom({ snap: true, jump: false });
          fpFrom.config.onChange.push(() => syncToWithFrom({ snap: true, jump: true }));
          fpFrom.config.onValueUpdate.push(() => syncToWithFrom({ snap: true, jump: true }));
          fpTo.config.onOpen.push(() => syncToWithFrom({ snap: false, jump: true }));

          const recompute = () => { if (window.recomputeDatediffs) window.recomputeDatediffs(); };
          fpTo.config.onChange.push(recompute);
          fpTo.config.onValueUpdate.push(recompute);
        });
      })();

      recomputeDatediffs();
    }



    // ----- TABLE FIELD -----
    function renderTableField(container, field) {
      if (!Array.isArray(values[field.id])) values[field.id] = [];
      const data = values[field.id];

      const editorWrap = document.createElement('div');
      editorWrap.style.display = 'flex';
      editorWrap.style.flexWrap = 'wrap';
      editorWrap.style.gap = '10px';

      const editorInputs = {};
      let editorState = emptyRow(field);

      const measurer = document.createElement('canvas').getContext('2d');
      function textPx(str) {
        try { measurer.font = getComputedStyle(document.body).font; } catch {}
        return Math.ceil(measurer.measureText(String(str || '')).width);
      }
      function longest(arr) {
        return arr.reduce((a, b) => (String(b).length > String(a).length ? String(b) : String(a)), '');
      }

      function rowIsEmpty(row) {
        return !(field.columns || []).some(c => String(row?.[c.id] ?? '').trim() !== '');
      }

      (field.columns || []).forEach(col => {
        const pair = document.createElement('label');
        pair.style.display = 'flex';
        pair.style.alignItems = 'center';
        pair.style.gap = '8px';

        const lbl = document.createElement('span');
        lbl.textContent = col.label || col.id;

        let el;
        if (col.type === 'select') {
          el = document.createElement('select');
          const opts = (col.options || []);
          const empty = document.createElement('option'); empty.value = ''; empty.textContent = '— wählen —';
          el.appendChild(empty);
          opts.forEach(opt => {
            const o = document.createElement('option');
            o.value = String(opt); o.textContent = String(opt);
            el.appendChild(o);
          });
          el.style.minWidth = Math.max(140, Math.min(360, textPx(longest(opts)) + 56)) + 'px';
          el.addEventListener('change', () => { editorState[col.id] = el.value; });
        } else if (col.type === 'date') {
          el = document.createElement('input');
          el.type = 'text';
          el.style.minWidth = Math.max(140, Math.min(360, textPx('YYYY-MM-DD') + 20)) + 'px';
          setTimeout(() => {
            flatpickr(el, { allowInput: true, dateFormat: 'Y-m-d', onChange: () => { editorState[col.id] = el.value; } });
          }, 0);
          el.addEventListener('change', () => { editorState[col.id] = el.value; });
        } else if (col.type === 'number') {
          el = document.createElement('input');
          el.type = 'number';
          el.style.minWidth = Math.max(120, Math.min(360, textPx('000000') + 20)) + 'px';
          el.addEventListener('change', () => { editorState[col.id] = el.value; });
        } else {
          el = document.createElement('input');
          el.type = 'text';
          el.style.minWidth = Math.max(160, Math.min(360, textPx(lbl.textContent) + 20)) + 'px';
          el.addEventListener('change', () => { editorState[col.id] = el.value; });
        }

        editorInputs[col.id] = el;
        pair.appendChild(lbl);
        pair.appendChild(el);
        editorWrap.appendChild(pair);
      });

      const toolbar = document.createElement('div');
      toolbar.className = 'row';
      toolbar.style.gap = '8px';

      const btnAdd = document.createElement('button');
      btnAdd.type = 'button';
      btnAdd.textContent = 'Zeile hinzufügen';

      const btnSave = document.createElement('button');
      btnSave.type = 'button';
      btnSave.className = 'secondary';
      btnSave.textContent = 'Änderungen speichern';

      const btnDelete = document.createElement('button');
      btnDelete.type = 'button';
      btnDelete.className = 'ghost';
      btnDelete.textContent = 'Zeile löschen';

      const btnCancel = document.createElement('button');
      btnCancel.type = 'button';
      btnCancel.className = 'ghost';
      btnCancel.textContent = 'Abbrechen';

      toolbar.appendChild(btnAdd);
      toolbar.appendChild(btnSave);
      toolbar.appendChild(btnDelete);
      toolbar.appendChild(btnCancel);

      const status = document.createElement('div');
      status.className = 'muted';
      status.style.minHeight = '1.2em';

      const tableWrap = document.createElement('div');
      tableWrap.style.overflow = 'auto';
      const table = document.createElement('table');
      table.style.width = '100%';
      const thead = document.createElement('thead');
      const trh = document.createElement('tr');
      thead.appendChild(trh);
      const tbody = document.createElement('tbody');
      table.appendChild(thead);
      table.appendChild(tbody);
      tableWrap.appendChild(table);

      (field.columns || []).forEach(col => {
        const th = document.createElement('th');
        th.textContent = col.label || col.id;
        trh.appendChild(th);
      });

      let selectedIndex = -1;
      let visibleIndexMap = [];

      function applyPreviewVisibility() {
        const hasAnyNonEmpty = data.some(r => !rowIsEmpty(r));
        tableWrap.style.display = hasAnyNonEmpty ? '' : 'none';
      }

      function drawTable() {
        tbody.innerHTML = '';
        visibleIndexMap = [];

        data.forEach((row, realIdx) => {
          if (rowIsEmpty(row)) return;

          const tr = document.createElement('tr');
          const isSel = realIdx === selectedIndex;

          if (isSel) {
            tr.style.background = '#DBEAFE';
            tr.style.outline = '2px solid #93C5FD';
            tr.style.outlineOffset = '-2px';
          } else {
            tr.style.background = '';
            tr.style.outline = '';
            tr.style.outlineOffset = '';
          }

          tr.addEventListener('click', () => {
            selectedIndex = realIdx;
            drawTable();
            loadIntoEditor(realIdx);
          });

          (field.columns || []).forEach(col => {
            const td = document.createElement('td');
            td.textContent = row[col.id] || '';
            tr.appendChild(td);
          });

          tbody.appendChild(tr);
          visibleIndexMap.push(realIdx);
        });

        applyPreviewVisibility();
        updateToolbar();
      }

      function clearSelection() { selectedIndex = -1; updateToolbar(); }
      function updateToolbar() {
        const min = Math.max(0, parseInt(field.minRows || 0, 10));
        const max = Math.max(0, parseInt(field.maxRows || 0, 10));

        btnAdd.disabled = (max && data.length >= max);

        const showEdit = selectedIndex >= 0;
        btnSave.style.display   = showEdit ? '' : 'none';
        btnDelete.style.display = showEdit ? '' : 'none';
        btnCancel.style.display = showEdit ? '' : 'none';

        btnSave.disabled   = !showEdit;
        btnDelete.disabled = !showEdit || (min && data.length <= min);
        btnCancel.disabled = !showEdit;
      }

      function loadIntoEditor(i) {
        const rec = data[i] || emptyRow(field);
        for (const c of (field.columns || [])) {
          const el = editorInputs[c.id];
          if (!el) continue;
          el.value = rec[c.id] || '';
        }
        editorState = { ...rec };
        updateToolbar();
      }

      function resetEditor() {
        editorState = emptyRow(field);
        for (const c of (field.columns || [])) {
          const el = editorInputs[c.id];
          if (!el) continue;
          el.value = '';
        }
      }

      if (!data.length) {
        const min = Math.max(0, parseInt(field.minRows || 0, 10));
        for (let i = 0; i < min; i++) data.push(emptyRow(field));
      }
      drawTable();

      btnAdd.addEventListener('click', () => {
        const max = Math.max(0, parseInt(field.maxRows || 0, 10));
        if (max && data.length >= max) return;

        data.push({ ...editorState });
        drawTable();
        scheduleSaveState();
        status.textContent = 'Zeile hinzugefügt.';
      });

      btnSave.addEventListener('click', () => {
        if (selectedIndex < 0 || selectedIndex >= data.length) return;
        data[selectedIndex] = { ...editorState };
        drawTable();
        scheduleSaveState();
        status.textContent = 'Änderungen gespeichert.';
      });

      btnDelete.addEventListener('click', () => {
        const min = Math.max(0, parseInt(field.minRows || 0, 10));
        if (selectedIndex < 0) return;
        if (min && data.length <= min) return;
        data.splice(selectedIndex, 1);
        clearSelection();
        resetEditor();
        drawTable();
        scheduleSaveState();
        status.textContent = 'Zeile gelöscht.';
      });

      btnCancel.addEventListener('click', () => {
        clearSelection();
        resetEditor();
        drawTable();
        status.textContent = 'Auswahl aufgehoben.';
      });

      container.appendChild(editorWrap);
      container.appendChild(toolbar);
      container.appendChild(status);
      container.appendChild(tableWrap);

      applyPreviewVisibility();
    }

    function emptyRow(field){ const r={}; (field.columns||[]).forEach(c=>r[c.id]=''); return r; }

    let __saveTimer = null;
    function scheduleSaveState() {
      clearTimeout(__saveTimer);
      __saveTimer = setTimeout(saveState, 150);
    }
    function saveState() {
      if (!currentDoc?.docId) return;
      const cleanValues = sanitizeValues(schema, values);
      window.formSuitePersist.saveState(currentDoc.docId, { schema, values: cleanValues });
    }
    function saveLS(s) { try { localStorage.setItem(STORAGE_KEY, JSON.stringify(s||{})); } catch {} }
    function loadLS() { try { return JSON.parse(localStorage.getItem(STORAGE_KEY)||'null'); } catch { return null; } }
    window.addEventListener('beforeunload', () => {
      try { if (currentDoc?.docId) saveState(); else if (schema) saveLS(schema); } catch {}
    });

    // ============================================================
    // ==== LIVE HEADING INDEX & RULE MATERIALIZATION (NEW) =======
    // ============================================================
    function _normalizeTextJs(s){
      return String(s ?? '')
        .replace(/\u00A0/g, ' ')
        .replace(/\s+/g, ' ')
        .trim();
    }
    function _stripLeadingNumberJs(s){
      return String(s||'').replace(/^[\s\t\u00A0]*\d+(?:[.\u00A0 \t]+\d+)*[.\u00A0 \t]*/,'').trim();
    }
    function _normKeyJs(level, text){
      const t = _stripLeadingNumberJs(
        _normalizeTextJs(text)
          .normalize('NFKD')
          .replace(/[\u0300-\u036f]/g,'')
      ).toLowerCase();
      return `${level}::${t}`;
    }

    async function buildLiveHeadingIndexFromBytes(bytes){
      await ensureJSZip();
      const zip = await window.JSZip.loadAsync(bytes);
      const W_NS = "http://schemas.openxmlformats.org/wordprocessingml/2006/main";

      // styles → paragraph style → inferred level
      async function buildStyleMap(){
        const f = zip.file('word/styles.xml');
        if(!f) return {};
        const xml = new DOMParser().parseFromString(await f.async('string'), "application/xml");
        const byId = {};
        const styles = xml.getElementsByTagNameNS(W_NS, 'style');

        function levelFromStyleHint(str){
          if(!str) return 0; const s=String(str).trim().toLowerCase();
          const ps=[/heading\s*([1-9])/,/überschrift\s*([1-9])/,/titre\s*([1-9])/,/t[ií]tulo\s*([1-9])/,/encabezado\s*([1-9])/,/rubrik\s*([1-9])/,/zagolovok\s*([1-9])/,/заголовок\s*([1-9])/];
          for(const re of ps){ const m=s.match(re); if(m) return +m[1]; }
          const m2=s.match(/^heading([1-9])$/i); return m2?+m2[1]:0;
        }

        for(let i=0;i<styles.length;i++){
          const st = styles[i];
          const type = st.getAttributeNS(W_NS,'type') || st.getAttribute('w:type');
          if(type !== 'paragraph') continue;

          const id = st.getAttributeNS(W_NS,'styleId') || st.getAttribute('w:styleId') || '';
          if(!id) continue;

          const nameEl = st.getElementsByTagNameNS(W_NS,'name')[0];
          const name = nameEl ? (nameEl.getAttributeNS(W_NS,'val') || nameEl.getAttribute('w:val') || '') : '';

          const basedEl = st.getElementsByTagNameNS(W_NS,'basedOn')[0];
          const basedOn = basedEl ? ((basedEl.getAttributeNS && basedEl.getAttributeNS(W_NS,'val')) || (basedEl.getAttribute && basedEl.getAttribute('w:val')) || '') : '';

          let lvl = 0;
          const pPr = st.getElementsByTagNameNS(W_NS,'pPr')[0];
          if(pPr){
            const ol = pPr.getElementsByTagNameNS(W_NS,'outlineLvl')[0];
            if(ol){
              const v = ol.getAttributeNS(W_NS,'val') || ol.getAttribute('w:val');
              if(v != null && v !== ''){
                const n = +v;
                if(Number.isFinite(n)) lvl = Math.max(1, Math.min(9, n+1));
              }
            }
          }
          if(!lvl) lvl = levelFromStyleHint(id) || levelFromStyleHint(name) || 0;
          byId[id] = { basedOn, rawLevel:lvl };
        }
        const resolved = {};
        const resolve = (id, depth=0)=>{
          if(!id || !byId[id] || depth>12) return 0;
          if(resolved[id] != null) return resolved[id];
          const info = byId[id];
          if(info.rawLevel){ resolved[id] = info.rawLevel; return resolved[id]; }
          return (resolved[id] = resolve(info.basedOn, depth+1) || 0);
        };
        Object.keys(byId).forEach(id => resolve(id));
        return resolved;
      }

      const styleMap = await buildStyleMap();

      const doc = zip.file('word/document.xml');
      if(!doc) return { list:[], byIdx:new Map(), byKey:new Map() };
      const xml = new DOMParser().parseFromString(await doc.async('string'), 'application/xml');
      const body = xml.getElementsByTagNameNS(W_NS, 'body')[0] || xml.documentElement;
      const paras = Array.from(body.getElementsByTagNameNS(W_NS,'p'));

      function detectHeadingLevel(p){
        const pPr = p.getElementsByTagNameNS(W_NS,'pPr')[0];
        if(pPr){
          const ol = pPr.getElementsByTagNameNS(W_NS,'outlineLvl')[0];
          if(ol){
            const v = ol.getAttributeNS(W_NS,'val') || ol.getAttribute('w:val');
            if(v != null && v !== ''){
              const n = +v;
              if(Number.isFinite(n)) return Math.max(1, Math.min(9, n+1));
            }
          }
          const pStyle = pPr.getElementsByTagNameNS(W_NS,'pStyle')[0];
          if(pStyle){
            const id = pStyle.getAttributeNS(W_NS,'val') || pStyle.getAttribute('w:val') || '';
            const lvl = styleMap?.[id];
            if(lvl) return lvl;
          }
        }
        return 0;
      }
      function textOfPara(p){
        const ts = p.getElementsByTagNameNS(W_NS,'t'); let s='';
        for(let i=0;i<ts.length;i++){ s += ts[i].textContent; }
        return _normalizeTextJs(s);
      }

      const list = [];
      let idx = 0;
      for(const p of paras){
        const lvl = detectHeadingLevel(p);
        if(!lvl) continue;
        const txt = textOfPara(p);
        if(!txt) continue;
        idx += 1;
        list.push({ idx, level:lvl, text:txt, key:_normKeyJs(lvl, txt) });
      }
      const byIdx = new Map(list.map(h => [h.idx, h]));
      const byKey = new Map(list.map(h => [String(h.key), h]));
      return { list, byIdx, byKey };
    }

    function resolveTargetToIdxFactory(byIdx, byKey){
      return function resolveTargetToIdx(t){
        if (t && typeof t === 'object'){
          const stableRaw = t.stableKey ?? t.normKey ?? t.normalizedKey ?? t.headingKey;
          if (stableRaw != null){
            const stableStr = String(stableRaw);
            const hitStable = byKey.get(stableStr);
            if (hitStable) return hitStable.idx;
          }
        }
        const raw = t?.key ?? t?.idx ?? t?.id;
        if(raw == null) return null;

        // 1) numeric already?
        const n = Number(raw);
        if(Number.isFinite(n) && byIdx.has(n)) return n;

        // 2) legacy "1.2|Some Title"
        if(typeof raw === 'string' && raw.includes('|')){
          const [numbering, ...rest] = raw.split('|');
          const level = Math.max(1, (numbering.match(/\d+/g) || []).length);
          const title = rest.join('|').trim();
          const hit = byKey.get(_normKeyJs(level, title));
          if(hit) return hit.idx;
        }

        // 3) last resort: treat as text (assume level 1)
        if(typeof raw === 'string'){
          const hit = byKey.get(_normKeyJs(1, raw));
          if(hit) return hit.idx;
        }

        return null;
      };
    }

    function materializeRuleTargets(rules, resolveTargetToIdx){
      if(!Array.isArray(rules)) return [];
      return rules.map(r => {
        const targets = (r?.targets || [])
          .map(t => resolveTargetToIdx(t))
          .filter(v => Number.isFinite(v))
          .map(idx => ({ idx }));
        return { ...r, targets };
      });
    }

    async function materializeRulesNow(docBytes, rules){
      const { byIdx, byKey } = await buildLiveHeadingIndexFromBytes(docBytes);
      const resolve = resolveTargetToIdxFactory(byIdx, byKey);
      return materializeRuleTargets(rules, resolve);
    }
    // ============================================================

    // ---------- Export (Open Form) ----------
    async function onExportFromOpenForm() {
      if (!currentDoc?.docId) {
        alert('No active document. Open or pick a DOCX first.');
        return;
      }

      const canBytes = await fetchWorkingDocBytes();
      if (!canBytes) { await hardResetOpenForm('no bytes / no permission'); return; }

      let fileHandle = null;
      let skipPickerReason = '';
      if (supportsFS && window.showSaveFilePicker) {
        try {
          const suggested = (currentDoc.name?.replace(/\.docx$/i, '') || 'document') + ' (export).docx';
          fileHandle = await showSaveFilePicker({
            suggestedName: suggested,
            types: [{
              description: 'Word document',
              accept: { 'application/vnd.openxmlformats-officedocument.wordprocessingml.document': ['.docx'] }
            }]
          });
        } catch (e) {
          const msg = String(e?.message || '');
          if (e?.name === 'AbortError' || /canceled/i.test(msg)) return;
          if (e?.name === 'SecurityError' || e?.name === 'NotAllowedError' || /Must be handling a user gesture/i.test(msg)) {
            skipPickerReason = e?.name || 'SecurityError';
          } else {
            console.error('Save picker failed:', e);
            alert('Export failed: ' + (e?.message || e));
            return;
          }
        }
      }

      const attempt = async () => {
        await ensurePy();

        const docBytes = await fetchWorkingDocBytes();
        if (!docBytes) return;

        const originalBytes = (docBytes instanceof Uint8Array)
          ? docBytes
          : new Uint8Array(docBytes);

        const state  = await window.formSuitePersist.loadState?.(currentDoc.docId);
        const tagMap = (state?.payload?.CRONOS_PAYLOAD?.tagMap)
                    || (state?.cronos_payload?.tagMap)
                    || (state?.CRONOS_PAYLOAD?.tagMap)
                    || (state?.tagMap)
                    || {};
        const validIds   = new Set((schema?.fields || []).map(f => f.id));
        const safeValues = sanitizeValues(schema, values || {});
        const cleanTagMap = sanitizeTagMap(tagMap, validIds);
        const rules = await resolveHeadingRules(state, originalBytes, schema);
        const fieldRulesForDoc = loadFieldRulesForDoc(state);

        const payload = JSON.stringify({
          title: schema?.title || 'Form',
          fields: schema?.fields || [],
          values: safeValues,
          tagMap: cleanTagMap,
          rules,
          fieldRules: fieldRulesForDoc
        });

        // 1) write CRONOS_PAYLOAD → settings.xml
        const updated = await writeDocVar(docBytes, PAYLOAD_KEY, payload);

        // 2) fill SDTs
        const sdtMap = {};
        for (const [tag, fieldId] of Object.entries(cleanTagMap)) {
          let v = safeValues?.[fieldId];
          if (v == null) v = '';
          if (typeof v === 'object') {
            v = v.formatted ?? (function(){ try { return JSON.stringify(v); } catch { return String(v); } })();
          }
          sdtMap[tag] = String(v);
        }
        let updated2 = await writeSDTs(updated, sdtMap);

        // (3) rules → visibility (using LIVE indices)
        const rulesLive = await materializeRulesNow(originalBytes, rules);
        let visibilityMap = evaluateRulesToVisibility(schema, safeValues, rulesLive);

        if (!Object.keys(visibilityMap).length) {
          const fallbackResolver = (t) => {
            const raw = t?.idx ?? t?.key ?? t?.id;
            const n = Number(raw);
            return Number.isFinite(n) ? n : null;
          };

          const fallbackRules = materializeRuleTargets(rules, fallbackResolver);
          const fallbackMap = evaluateRulesToVisibility(schema, safeValues, fallbackRules);
          if (Object.keys(fallbackMap).length) {
            visibilityMap = fallbackMap;
          }
        }

        // 4) REMOVE sections (if requested) + embed untouched original backup
        const updated3 = await applyRemovalWithBackup(updated2, visibilityMap, originalBytes);

        await window.formSuitePersist.putBytes?.(currentDoc.docId, updated3);

        let saved = false;
        if (fileHandle) {
          try {
            const stream = await fileHandle.createWritable();
            await stream.write(updated3);
            await stream.close();
            saved = true;
          } catch (e) {
            const msg = String(e?.message || '');
            if (e?.name === 'AbortError' || /canceled/i.test(msg)) return;
            console.warn('Writing to handle failed, falling back to download:', e);
          }
        }

        if (!saved) {
          if (skipPickerReason) {
            console.info(`Falling back to download due to: ${skipPickerReason}`);
          }
          const blob = new Blob([updated3], {
            type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
          });
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = (currentDoc?.name || 'document').replace(/\.docx$/i, ' (export).docx');
          document.body.appendChild(a);
          a.click();
          setTimeout(() => { URL.revokeObjectURL(a.href); a.remove(); }, 2000);
        }
      };

      try {
        await attempt();
      } catch (e) {
        const msg = String(e?.message || e || '');
        if (msg.includes('already been destroyed') || msg.includes('proxy has been destroyed')) {
          await ensurePy(true);
          try { await attempt(); return; } catch (e2) {
            const m2 = String(e2?.message || '');
            if (e2?.name === 'AbortError' || /export canceled/i.test(m2)) return;
            console.error('Export failed after retry:', e2);
            alert('Export failed: ' + (e2?.message || e2));
            return;
          }
        }
        if (e?.name === 'AbortError' || /export canceled/i.test(msg.toLowerCase())) return;
        console.error('Export failed (Open Form):', e);
        alert('Export failed: ' + (e?.message || e));
      }
    }

    // ---------- Rules → Visibility map (SHOW supersedes HIDE) ----------
    function loadRulesForDoc(state) {
      return (
        state?.rules ||
        state?.payload?.CRONOS_PAYLOAD?.rules ||
        state?.payload?.rules ||
        state?.CRONOS_RULES ||
        state?.cronos_rules ||
        []
      );
    }

    function normalizeRulesInput(rules) {
      if (!Array.isArray(rules)) return [];
      return rules.filter(r => r && typeof r === 'object');
    }

    function getValidFieldIdSet(schema) {
      const out = new Set();
      const fields = Array.isArray(schema?.fields) ? schema.fields : [];
      const slug = (window.slugifyMc) ? window.slugifyMc : slugifyMc;

      for (const f of fields) {
        const idStr = String(f?.id ?? '');
        if (!idStr) continue;
        out.add(idStr);

        if (String(f?.type || '').toLowerCase() === 'multichoice') {
          const opts = [];
          if (Array.isArray(f.options)) opts.push(...f.options);
          if (f.mc && Array.isArray(f.mc.groups)) {
            for (const g of f.mc.groups) {
              (g.items || []).forEach(it => opts.push(it));
            }
          }
          for (const opt of opts) {
            const rawVal = (opt && typeof opt === 'object')
              ? (opt.value ?? opt.label ?? opt.text ?? opt.name ?? '')
              : opt;
            const slugStr = slug(String(rawVal || ''));
            if (slugStr) out.add(`${idStr}__opt__${slugStr}`);
          }
        }
      }

      return out;
    }

    function normalizeRulesForSchema(schema, rulesIn) {
      const valid = getValidFieldIdSet(schema);
      const rules = normalizeRulesInput(rulesIn);
      if (!rules.length) return [];

      const out = [];
      for (const rule of rules) {
        const fidRaw = rule.fieldId ?? rule.field ?? rule.whenField;
        const fieldId = String(fidRaw ?? '');
        if (!fieldId) continue;
        if (valid.size && !valid.has(fieldId)) continue;

        let clone;
        try {
          clone = JSON.parse(JSON.stringify(rule));
        } catch {
          clone = { ...rule };
        }

        clone.fieldId = fieldId;
        if (!Array.isArray(clone.targets)) clone.targets = [];
        clone.targets = clone.targets.filter(t => t && typeof t === 'object');
        out.push(clone);
      }

      return out;
    }

    async function resolveHeadingRules(state, docBytes, schema) {
      let normalized = normalizeRulesForSchema(schema, loadRulesForDoc(state));

      if (!normalized.length && docBytes) {
        try {
          const payloadTxt = await readPayloadFromDocx(docBytes);
          if (payloadTxt) {
            try {
              const payloadJson = JSON.parse(payloadTxt);
              const embeddedRaw = (
                payloadJson?.rules ||
                payloadJson?.CRONOS_PAYLOAD?.rules ||
                payloadJson?.payload?.rules ||
                []
              );
              const embedded = normalizeRulesForSchema(schema, embeddedRaw);
              if (embedded.length) normalized = embedded;
            } catch (err) {
              console.warn('Failed to parse embedded rules payload', err);
            }
          }
        } catch (e) {
          console.warn('Failed to read embedded payload for rules', e);
        }
      }

      return normalized;
    }

    function ruleMatchesValue(op, expected, actual) {
      const a = actual;
      if (op === 'equals')    return String(a) === String(expected);
      if (op === 'notEquals') return String(a) !== String(expected);
      if (op === 'anyOf') {
        const arr = Array.isArray(expected) ? expected.map(String) : [String(expected)];
        if (Array.isArray(a)) return a.map(String).some(v => arr.includes(v));
        return arr.includes(String(a));
      }
      if (op === 'allOf') {
        const arr = Array.isArray(expected) ? expected.map(String) : [String(expected)];
        if (!Array.isArray(a)) return false;
        const aset = new Set(a.map(String));
        return arr.every(v => aset.has(v));
      }
      if (op === 'contains') {
        return String(a ?? '').toLowerCase().includes(String(expected ?? '').toLowerCase());
      }
      return false;
    }

    function evaluateRulesToVisibility(schema, values, rules) {
      const out = Object.create(null);
      if (!Array.isArray(rules) || !rules.length) return out;

      const cleanVals = sanitizeValues(schema, values || {});
      const getVal = (fid) => cleanVals[fid];

      for (const r of rules) {
        if (!r) continue;
        const action = (String(r.action || '').toUpperCase() === 'SHOW') ? 'SHOW'
                    : (String(r.action || '').toUpperCase() === 'HIDE') ? 'HIDE'
                    : null;
        if (!action) continue;

        const fieldId = r.fieldId || r.field || r.whenField;
        const op      = r.op || r.operator || 'equals';
        const exp     = r.values ?? r.value ?? r.expected;
        const targets = Array.isArray(r.targets) ? r.targets : [];

        let match = false;
        if (typeof fieldId === 'string' && fieldId.includes('__opt__')) {
          const [baseId, slug] = fieldId.split('__opt__');
          const raw = getVal(baseId);
          const arr = Array.isArray(raw) ? raw.map(String) : [];
          const toSlug = (s) => String(s||'')
            .normalize('NFKD')
            .replace(/[\u0300-\u036f]/g, '')
            .replace(/[^a-zA-Z0-9]+/g, '_')
            .replace(/^_+|_+$/g, '')
            .toLowerCase();
          const selected = arr.some(v => toSlug(v) === String(slug||'').replace(/^_+/,'').toLowerCase());
          const expect = Array.isArray(exp) ? exp[0] : exp;
          const expectBool = (String(expect) === 'true');
          if (op === 'equals') match = (selected === expectBool);
        } else {
          const fld = (schema?.fields||[]).find(f => String(f.id) === String(fieldId));
          const t = String(fld?.type||'').toLowerCase();
          const actual = getVal(fieldId);
          if (t === 'date') {
            const expStr = Array.isArray(exp) ? String(exp[0]||'') : String(exp||'');
            const toDay = (s) => { if (!s) return NaN; const d = new Date(s); return isNaN(d) ? NaN : Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()); };
            const a = toDay(actual);
            const b = toDay(expStr);
            if (Number.isNaN(a) || Number.isNaN(b)) match = false;  // <-- fix here
            else if (op === 'before') match = a < b;
            else if (op === 'after') match = a > b;
            else if (op === 'equals') match = a == b;
          } else if (t === 'text' || t === 'number' || t === 'select') {
            const expVal = Array.isArray(exp) ? exp[0] : exp;
            if (op === 'equals') match = String(actual) === String(expVal);
            else if (op === 'notEquals') match = String(actual) !== String(expVal);
            else if (t === 'text' && op === 'contains') match = String(actual ?? '').toLowerCase().includes(String(expVal ?? '').toLowerCase());
          } else if (t === 'multichoice') {
            match = ruleMatchesValue(op, exp, actual);
          } else {
            match = ruleMatchesValue(op, exp, actual);
          }
        }
        if (!match) continue;

        for (const t of targets) {
          // After materialization, targets are { idx }
          const idx = Number(t?.idx ?? t?.key ?? t?.id);
          if (!Number.isFinite(idx)) continue;
          const prev = out[idx];
          if (action === 'SHOW') out[idx] = 'SHOW';
          else if (action === 'HIDE' && prev !== 'SHOW') out[idx] = 'HIDE';
        }
      }
      return out;
    }

    // ---------- Field Rules (UI visibility) ----------
    function loadFieldRulesForDoc(state) {
      return (
        state?.fieldRules ||
        state?.payload?.CRONOS_PAYLOAD?.fieldRules ||
        state?.payload?.fieldRules ||
        state?.CRONOS_FIELD_RULES ||
        state?.cronos_field_rules ||
        []
      );
    }

    function evaluateFieldRulesToVisibility(schema, values, rules) {
      const out = Object.create(null);
      if (!Array.isArray(rules) || !rules.length) return out;

      const cleanVals = sanitizeValues(schema, values || {});
      const getVal = (fid) => cleanVals[fid];

      for (const r of rules) {
        if (!r) continue;
        const action = (String(r.action || '').toUpperCase() === 'SHOW') ? 'SHOW'
                    : (String(r.action || '').toUpperCase() === 'HIDE') ? 'HIDE'
                    : null;
        if (!action) continue;

        const fieldId = r.fieldId || r.field || r.whenField;
        const op      = r.op || r.operator || 'equals';
        const exp     = r.values ?? r.value ?? r.expected;
        const targets = Array.isArray(r.targets) ? r.targets : [];
        const effect = (String(r.hideMode||'hide').toLowerCase() === 'disable') ? 'DISABLE' : 'HIDE';

        let match = false;
        if (typeof fieldId === 'string' && fieldId.includes('__opt__')) {
          const [baseId, slug] = fieldId.split('__opt__');
          const base = baseId;
          const raw = getVal(base);
          const arr = Array.isArray(raw) ? raw.map(String) : [];
          const toSlug = (s) => String(s||'')
            .normalize('NFKD')
            .replace(/[\u0300-\u036f]/g, '')
            .replace(/[^a-zA-Z0-9]+/g, '_')
            .replace(/^_+|_+$/g, '')
            .toLowerCase();
          const selected = arr.some(v => toSlug(v) === String(slug||'').replace(/^_+/,'').toLowerCase());
          const expect = Array.isArray(exp) ? exp[0] : exp;
          const expectBool = (String(expect) === 'true');
          if (op === 'equals') match = (selected === expectBool);
        } else {
          const fld = (schema?.fields||[]).find(f => String(f.id) === String(fieldId));
          const t = String(fld?.type||'').toLowerCase();
          const actual = getVal(fieldId);
          if (t === 'date') {
            const expStr = Array.isArray(exp) ? String(exp[0]||'') : String(exp||'');
            const toDay = (s) => { if (!s) return NaN; const d = new Date(s); return isNaN(d) ? NaN : Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()); };
            const a = toDay(actual);
            const b = toDay(expStr);
            if (Number.isNaN(a) || Number.isNaN(b)) match = false
            else if (op === 'before') match = a < b;
            else if (op === 'after') match = a > b;
            else if (op === 'equals') match = a == b;
          } else if (t === 'text' || t === 'number') {
            const expVal = Array.isArray(exp) ? exp[0] : exp;
            if (op === 'equals') match = String(actual) === String(expVal);
            else if (op === 'notEquals') match = String(actual) !== String(expVal);
          } else if (t === 'select') {
            const expVal = Array.isArray(exp) ? exp[0] : exp;
            if (op === 'equals') match = String(actual) === String(expVal);
            else if (op === 'notEquals') match = String(actual) !== String(expVal);
          } else if (t === 'multichoice') {
            match = ruleMatchesValue(op, exp, actual);
          } else {
            match = ruleMatchesValue(op, exp, actual);
          }
        }
        if (!match) continue;

        for (const t of targets) {
          const id = String(t?.id ?? t?.fieldId ?? '');
          if (!id) continue;
          const prev = out[id];
          if (action === 'SHOW') out[id] = 'SHOW';
          else if (action === 'HIDE' && prev !== 'SHOW') {
            if (prev === 'HIDE') out[id] = 'HIDE';
            else out[id] = effect;
          }
        }
      }
      return out;
    }

    function applyFieldVisibility() {
      try {
        if (!schema || !Array.isArray(schema.fields)) return;
        const visMap = evaluateFieldRulesToVisibility(schema, values || {}, fieldRules || []);
        const clearDisabled = (el) => {
          el.style.opacity = '';
          el.style.pointerEvents = '';
          el.removeAttribute('aria-disabled');
          el.querySelectorAll('input,select,textarea,button').forEach(i => { try { i.disabled = false; } catch {} });
        };
        document.querySelectorAll('.field[data-field-id]').forEach(node => { node.style.display = ''; clearDisabled(node); });
        document.querySelectorAll('.mc-item[data-opt-id]').forEach(node => { node.style.display = ''; clearDisabled(node); });

        const esc = (window.CSS && CSS.escape) ? CSS.escape : (s => String(s)
          .replace(/\\/g,'\\\\')
          .replace(/"/g,'\\"')
          .replace(/\]/g,'\\]')
          .replace(/\[/g,'\\[')
        );

        const deselectMcItem = (mcEl) => {
          const cb = mcEl.querySelector('input[type="checkbox"][data-mc="1"]');
          if (!cb) return;
          const fid = cb.name;
          const optVal = cb.value;
          if (cb.checked) cb.checked = false;
          const arr = Array.isArray(values[fid]) ? values[fid].map(String) : [];
          const next = arr.filter(v => v !== String(optVal));
          values[fid] = next;
          scheduleSaveState();
        };
        const deselectFieldWrapper = (wrapEl) => {
          const fid = wrapEl?.dataset?.fieldId || '';
          if (!fid) return;
          const fld = (schema?.fields || []).find(f => String(f.id) === String(fid));
          const t = String(fld?.type || '').toLowerCase();
          if (t === 'multichoice') {
            wrapEl.querySelectorAll('input[type="checkbox"][data-mc="1"]').forEach(cb => { cb.checked = false; });
            values[fid] = [];
            scheduleSaveState();
          } else if (t === 'select') {
            const sel = wrapEl.querySelector('select');
            if (sel) { sel.value = ''; values[fid] = ''; scheduleSaveState(); }
          } else if (t === 'text') {
            const inp = wrapEl.querySelector('input[type="text"]:not([data-type="date"])');
            if (inp) { inp.value = ''; values[fid] = ''; scheduleSaveState(); }
          } else if (t === 'number') {
            const inp = wrapEl.querySelector('input[type="number"]');
            if (inp) { inp.value = ''; values[fid] = ''; scheduleSaveState(); }
          } else if (t === 'date') {
            const inp = wrapEl.querySelector('input[data-type="date"]');
            if (inp) {
              try { if (inp._flatpickr) inp._flatpickr.clear(); } catch {}
              inp.value = '';
              values[fid] = '';
              scheduleSaveState();
            }
          }
        };

        Object.keys(visMap || {}).forEach(id => {
          const dir = visMap[id];
          if (typeof id === 'string' && id.includes('__opt__')) {
            document.querySelectorAll(`.mc-item[data-opt-id="${esc(id)}"]`).forEach(el => {
              deselectMcItem(el);
              if (dir === 'HIDE') el.style.display = 'none';
              else { el.style.display=''; el.style.opacity = '0.5'; el.style.pointerEvents = 'none'; el.setAttribute('aria-disabled','true'); el.querySelectorAll('input,select,textarea,button').forEach(i => { try { i.disabled = true; } catch {} }); }
            });
          } else {
            document.querySelectorAll(`.field[data-field-id="${esc(id)}"]`).forEach(el => {
              deselectFieldWrapper(el);
              if (dir === 'HIDE') el.style.display = 'none';
              else { el.style.display=''; el.style.opacity = '0.5'; el.style.pointerEvents = 'none'; el.setAttribute('aria-disabled','true'); el.querySelectorAll('input,select,textarea,button').forEach(i => { try { i.disabled = true; } catch {} }); }
            });
          }
        });
      } catch (e) { /* no-op */ }
    }

    // ---------- JS bridge to Python removal-with-backup ----------
    async function applyRemovalWithBackup(bytesU8, visibilityMap, originalBytes) {
      await ensurePy();
      const fn = py.globals.get('apply_removal_with_backup');
      const buf = bytesU8 instanceof Uint8Array ? bytesU8 : new Uint8Array(bytesU8);
      const pyBytes = py.toPy(buf);
      const pyMap   = py.toPy(JSON.stringify(visibilityMap || {}));
      const pyPath  = py.toPy('customXml/originalDocument.xml');
      const origBuf = (originalBytes instanceof Uint8Array)
        ? originalBytes
        : (originalBytes ? new Uint8Array(originalBytes) : null);
      let pyOut;
      let pyOrig = null;
      try {
        if (origBuf) {
          pyOrig = py.toPy(origBuf);
          pyOut = fn(pyBytes, pyMap, pyPath, pyOrig);
        } else {
          pyOut = fn(pyBytes, pyMap, pyPath);
        }
      }
      finally {
        try{fn.destroy();}catch{}
        try{pyBytes.destroy();}catch{}
        try{pyMap.destroy();}catch{}
        try{pyPath.destroy();}catch{}
        try{pyOrig?.destroy();}catch{}
      }
      let u8;
      if (pyOut?.toJs) u8 = pyOut.toJs({ create_proxies:false });
      else if (pyOut?.getBuffer) u8 = new Uint8Array(pyOut.getBuffer());
      else u8 = new Uint8Array([]);
      try { pyOut?.destroy?.(); } catch {}
      return u8;
    }

    // Expose for cross-callbacks
    try { window.applyFieldVisibility = applyFieldVisibility; } catch {}

    // ---------- Logo triple-click: focus mode ----------
    (function() {
      const logo = document.querySelector('header .logo');
      const header = document.querySelector('header .row');
      if (!logo || !header) return;

      let clickCount = 0;
      let clickTimer = null;
      let focusMode = false;

      logo.addEventListener('click', () => {
        clickCount++;
        clearTimeout(clickTimer);
        clickTimer = setTimeout(() => { clickCount = 0; }, 600);

        if (clickCount === 3) {
          clickCount = 0;
          focusMode = !focusMode;

          if (focusMode) {
            header.querySelectorAll('a, span.muted').forEach(el => {
              if (!el.closest('.brand')) el.style.display = 'none';
            });
            if (!location.pathname.endsWith('index.html')) {
              location.href = 'index.html';
            }
          } else {
            header.querySelectorAll('a, span.muted').forEach(el => { el.style.display = ''; });
          }
        }
      });
    })();
  </script>
</body>
</html>
