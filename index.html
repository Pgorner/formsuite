<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Form Suite — Form</title>
  <link rel="icon" href="favicon.ico" type="image/gif" sizes="32x32">
  <link rel="shortcut icon" href="favicon.ico" type="image/gif">
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/themes/material_blue.css">
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <header>
    <div class="row">
      <span class="brand logo-md">
        <img src="logo.gif" alt="Form Suite logo" class="logo" />
        <strong>Form Suite</strong>
      </span>
      <span class="muted">·</span><span class="muted">Form</span>
      <span class="muted">·</span><a href="builder.html">Form Builder</a>
      <span class="muted">·</span><a href="matcher.html">Tag Matcher</a>
      <span class="muted">·</span><a href="rules.html">Rules</a>
      <span class="muted">·</span><a href="extractor.html">Extractor</a>
    </div>
  </header>

  <main>
    <section class="panel">
      <div class="title-row"></div>
      <div class="row" style="margin-top:8px;">
        <span id="docStatus" class="muted">No active document. Open one in the <a href="extractor.html">Extractor</a>.</span>
      </div>
      <div id="permNote" class="note warn" style="display:none; margin-top:10px">
        This DOCX was opened via picker but I don’t have write permission to the original file.
        You can still work from the cached copy, but changes cannot be written back until permission is granted.
        <button id="btnRegrant" class="ghost" style="margin-left:8px">Grant write access</button>
      </div>
    </section>

    <section class="panel">
      <div id="formMount"></div>
    </section>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

  <!-- Canonical single coordination layer -->
  <script src="persistence.js"></script>

  <!-- Canonical rules normalization + visibility eval -->
  <script src="rules-core.js"></script>

  <!-- DOCX utilities (used by persistence hydrate helpers) -->
  <script src="docx-core.js"></script>

  <!-- UI helper -->
  <script src="fs-focus-nav.js"></script>

  <!-- Optional component -->
  <script src="address-autocomplete.js"></script>

  <script>
  'use strict';

  // ============================================================
  // TRACE (debug logs everywhere)
  // ============================================================
  (function ensureTrace() {
    if (typeof window.TRACE === 'function') return;
    const DEBUG = { on: true, seq: 0 };
    const ts = () => new Date().toISOString().slice(11, 23);
    window.TRACE = function TRACE(name, details) {
      const id = ++DEBUG.seq;
      const prefix = `[Form ${ts()} #${id}] ${name}`;
      if (DEBUG.on) console.log(prefix, details ?? '');
      const t0 = (typeof performance !== 'undefined' ? performance.now() : Date.now());
      return {
        step(msg, data) { if (DEBUG.on) console.log(`${prefix}  ↳ ${msg}`, data ?? ''); },
        warn(msg, data) { if (DEBUG.on) console.warn(`${prefix}  ⚠ ${msg}`, data ?? ''); },
        error(msg, err) { if (DEBUG.on) console.error(`${prefix}  ✖ ${msg}`, err); },
        end(extra) {
          if (!DEBUG.on) return;
          const t1 = (typeof performance !== 'undefined' ? performance.now() : Date.now());
          const ms = Math.round((t1 - t0) * 1000) / 1000;
          console.log(`${prefix} done (${ms}ms)`, extra ?? '');
        }
      };
    };
  })();

  // ============================================================
  // DOM
  // ============================================================
  const els = {
    docStatus:  document.getElementById('docStatus'),
    formMount:  document.getElementById('formMount'),
    permNote:   document.getElementById('permNote'),
    btnRegrant: document.getElementById('btnRegrant'),
  };
  function setStatus(html) { els.docStatus.innerHTML = html; }

  // ============================================================
  // Canonical coordination layer
  // ============================================================
  function P() { return window.formSuitePersist; }
  function U() { return window.formSuiteUtils; }

  // Canonical channels (must match the other pages)
  const BC_ACTIVE  = 'fs-active-doc';
  const BC_PAYLOAD = 'fs-payload-v1';

  // ============================================================
  // CANONICAL IN-MEMORY STATE (stable identities; never replaced)
  // ============================================================
  const STATE = {
    doc: null,          // {docId, name}
    schema: null,       // object
    fieldRules: [],     // array
    values: {},         // object (stable identity)
    dirty: false,
    lastSaveAt: 0,
    refreshLock: false,
    refreshPending: false
  };

  // ============================================================
  // Local schema fallback (ONLY when no active doc)
  // ============================================================
  const LS_SCHEMA_FALLBACK = 'FORM_SCHEMA_V1';
  function saveLocalSchemaFallback(s) { try { localStorage.setItem(LS_SCHEMA_FALLBACK, JSON.stringify(s || {})); } catch {} }
  function loadLocalSchemaFallback()  { try { return JSON.parse(localStorage.getItem(LS_SCHEMA_FALLBACK) || 'null'); } catch { return null; } }

  // ============================================================
  // helpers: identity-stable merge
  // ============================================================
  function clearAndAssignObject(target, src) {
    if (!target || typeof target !== 'object') return;
    for (const k of Object.keys(target)) delete target[k];
    if (src && typeof src === 'object') {
      for (const k of Object.keys(src)) target[k] = src[k];
    }
  }

  function deepCloneSafe(v) {
    try {
      if (typeof structuredClone === 'function') return structuredClone(v);
    } catch {}
    try { return JSON.parse(JSON.stringify(v)); } catch { return v; }
  }

  // ============================================================
  // TABLE helpers (canonical data normalization)
  // ============================================================
  function emptyRow(field){
    const r = {};
    (field.columns || []).forEach(c => { r[String(c.id || '')] = ''; });
    return r;
  }

  function rowIsEmpty(field, row) {
    try {
      return !(field.columns || []).some(c => String(row?.[c.id] ?? '').trim() !== '');
    } catch {
      return true;
    }
  }

  function normalizeTableArray(field, arr) {
    const base = emptyRow(field);
    const min = Math.max(0, parseInt(field.minRows || 0, 10));
    const max = Math.max(0, parseInt(field.maxRows || 0, 10));

    let out = Array.isArray(arr) ? arr.slice() : [];
    // Ensure shape
    out = out.map(r => ({ ...base, ...(r || {}) }));

    // Remove fully empty rows (canonical behavior: draft/placeholder rows are not data)
    out = out.filter(r => !rowIsEmpty(field, r));

    // Enforce max (drop extra trailing rows, but keep earliest rows)
    if (max && out.length > max) out = out.slice(0, max);

    // Enforce min by padding (schema constraint)
    while (out.length < min) out.push({ ...base });

    return out;
  }

  function normalizeAllTablesInValues(schemaObj, vals) {
    try {
      if (!schemaObj || !Array.isArray(schemaObj.fields) || !vals || typeof vals !== 'object') return vals;
      for (const f of (schemaObj.fields || [])) {
        if (String(f?.type) !== 'table') continue;
        const fid = String(f.id || '');
        if (!fid) continue;
        vals[fid] = normalizeTableArray(f, vals[fid]);
      }
      return vals;
    } catch {
      return vals;
    }
  }

  // ============================================================
  // Sanitizer (canonical: utils + table enforcement)
  // ============================================================
  function sanitizeValues(schemaObj, vals) {
    const tr = TRACE('sanitizeValues', {
      hasUtils: !!U(),
      hasSanitizer: !!U()?.sanitizeValues,
      hasSchema: !!schemaObj
    });

    try {
      const inVals = (vals && typeof vals === 'object') ? vals : {};

      let out = inVals;
      if (U()?.sanitizeValues) out = U().sanitizeValues(schemaObj, inVals);
      if (!out || typeof out !== 'object') out = {};

      // Canonical: table arrays are always normalized and schema-enforced.
      out = normalizeAllTablesInValues(schemaObj, out);

      tr.end({ keys: Object.keys(out || {}).length });
      return out;
    } catch (e) {
      tr.warn('sanitize fallback', e);
      const fallback = (vals && typeof vals === 'object') ? vals : {};
      tr.end('fallback');
      return normalizeAllTablesInValues(schemaObj, fallback);
    }
  }

  // ============================================================
  // Canonical setters (all UI writes go through these)
  // ============================================================
  function markDirty() { STATE.dirty = true; }

  function setValue(fid, v) {
    STATE.values[String(fid || '')] = v;
    markDirty();
    scheduleSaveValues();
  }

  function getValue(fid) {
    return STATE.values[String(fid || '')];
  }

  function ensureTableValue(field) {
    const fid = String(field?.id || '');
    if (!fid) return [];
    if (!Array.isArray(STATE.values[fid])) STATE.values[fid] = [];
    // Normalize immediately so UI always sees canonical rows (no empties)
    STATE.values[fid] = normalizeTableArray(field, STATE.values[fid]);
    return STATE.values[fid];
  }

  // ============================================================
  // Permission Banner (canonical via persistence)
  // ============================================================
  async function updateWriteAccessBanner({ tryPrompt = false } = {}) {
    const tr = TRACE('updateWriteAccessBanner', { tryPrompt, docId: STATE.doc?.docId });
    try {
      if (!('showSaveFilePicker' in window)) { els.permNote.style.display = 'none'; tr.end('unsupported'); return 'unsupported'; }
      if (!STATE.doc?.docId)                 { els.permNote.style.display = 'none'; tr.end('no-doc'); return 'no-doc'; }

      const h = await P()?.getHandle?.(STATE.doc.docId);
      if (!h?.queryPermission) { els.permNote.style.display = 'none'; tr.end('no-handle'); return 'no-handle'; }

      let p = await h.queryPermission({ mode: 'readwrite' });
      if (p !== 'granted' && tryPrompt) {
        try { p = await h.requestPermission({ mode: 'readwrite' }) || p; } catch {}
      }

      els.permNote.style.display = (p === 'granted') ? 'none' : 'block';
      tr.end({ perm: p });
      return p || 'denied';
    } catch (e) {
      tr.warn('failed (showing banner)', e);
      els.permNote.style.display = 'block';
      tr.end('error');
      return 'error';
    }
  }

  els.btnRegrant?.addEventListener('click', async () => {
    const tr = TRACE('btnRegrant click');
    const p = await updateWriteAccessBanner({ tryPrompt: true });
    tr.step('perm result', p);
    if (p === 'granted') await refreshFromCanonical({ reason: 'regrant' });
    tr.end();
  });

  // ============================================================
  // Canonical save (workspace only; stable identities; deterministic)
  // ============================================================
  let __saveTimer = null;

  function scheduleSaveValues() {
    clearTimeout(__saveTimer);
    __saveTimer = setTimeout(saveValuesNow, 150);
  }

  function flushSaveNow() {
    try {
      clearTimeout(__saveTimer);
      __saveTimer = null;
      saveValuesNow();
    } catch {}
  }

  function saveValuesNow() {
    const tr = TRACE('saveValuesNow', { docId: STATE.doc?.docId, dirty: STATE.dirty });
    try {
      if (!STATE.doc?.docId) { tr.end('no-doc'); return; }
      if (!STATE.schema || !Array.isArray(STATE.schema.fields)) {
        // Still allow saving raw values if schema missing, but keep table normalization best-effort
        const snapshot0 = deepCloneSafe(STATE.values);
        const clean0 = sanitizeValues(STATE.schema || { title:'Form', fields:[] }, snapshot0);
        clearAndAssignObject(STATE.values, clean0);
        P()?.saveState?.(STATE.doc.docId, { values: clean0 });
        STATE.dirty = false;
        STATE.lastSaveAt = Date.now();
        tr.end({ keys: Object.keys(clean0||{}).length, schema: 'missing' });
        return;
      }

      // Snapshot (so sanitizers cannot mutate live state)
      const snap = deepCloneSafe(STATE.values);

      // Canonical sanitize (including: table filtering + min/max enforcement)
      const clean = sanitizeValues(STATE.schema, snap);

      // Keep in-memory aligned WITHOUT changing object identity
      clearAndAssignObject(STATE.values, clean);

      // Persist canonical state
      P()?.saveState?.(STATE.doc.docId, { values: clean });

      STATE.dirty = false;
      STATE.lastSaveAt = Date.now();
      tr.end({ keys: Object.keys(clean||{}).length });
    } catch (e) {
      tr.error('failed', e);
      tr.end('error');
    }
  }

  window.addEventListener('beforeunload', () => {
    try {
      flushSaveNow();
      if (!STATE.doc?.docId && STATE.schema) saveLocalSchemaFallback(STATE.schema);
    } catch {}
  });

  // ============================================================
  // Canonical hydration: persistence helper only
  // ============================================================
  async function hydrateWorkspaceIfEmpty(docId) {
    const tr = TRACE('hydrateWorkspaceIfEmpty', { docId });
    try {
      if (!docId) { tr.end('no-docId'); return false; }
      const did = await P()?.hydrateFromDocxIfEmpty?.(docId);
      tr.end({ didHydrate: !!did });
      return !!did;
    } catch (e) {
      tr.warn('failed', e);
      tr.end('error');
      return false;
    }
  }

  // ============================================================
  // Canonical normalization (single workflow)
  // ============================================================
  function normalizeRulesForCurrentState(st) {
    const tr = TRACE('normalizeRulesForCurrentState', {
      docId: STATE.doc?.docId,
      hasSchema: !!st?.schema,
      rulesLen: Array.isArray(st?.rules) ? st.rules.length : null,
      fieldRulesLen: Array.isArray(st?.fieldRules) ? st.fieldRules.length : null,
    });

    try {
      const hasDeriver = (typeof window.deriveNormalizedRulesForDoc === 'function');
      if (!hasDeriver) { tr.end('no-deriver'); return { fieldRules: Array.isArray(st?.fieldRules) ? st.fieldRules : [] }; }

      const baseline = {
        flat: Array.isArray(st?.headingsFlat) ? st.headingsFlat : (Array.isArray(st?.headings) ? st.headings : []),
        tree: Array.isArray(st?.headingsTree) ? st.headingsTree : [],
      };

      const schemaForDerive = st?.schema || STATE.schema || { title: 'Form', fields: [] };

      const normalized = window.deriveNormalizedRulesForDoc(st || {}, schemaForDerive, baseline) || {};
      const nextHeadingRules = Array.isArray(normalized.headingRules)
        ? normalized.headingRules
        : (Array.isArray(st?.rules) ? st.rules : []);
      const nextFieldRules = Array.isArray(normalized.fieldRules)
        ? normalized.fieldRules
        : (Array.isArray(st?.fieldRules) ? st.fieldRules : []);

      const same = (a,b) => { try { return JSON.stringify(a||[]) === JSON.stringify(b||[]); } catch { return false; } };
      const curHeading = Array.isArray(st?.rules) ? st.rules : [];
      const curField   = Array.isArray(st?.fieldRules) ? st.fieldRules : [];

      if (STATE.doc?.docId && (!same(curHeading, nextHeadingRules) || !same(curField, nextFieldRules))) {
        tr.step('persist normalized rules (replace)', {
          headingChanged: !same(curHeading, nextHeadingRules),
          fieldChanged: !same(curField, nextFieldRules),
        });
        try { Promise.resolve(P()?.saveState?.(STATE.doc.docId, { rules: nextHeadingRules, fieldRules: nextFieldRules })); } catch {}
      }

      tr.end({ nextFieldRulesLen: nextFieldRules.length });
      return { fieldRules: nextFieldRules };
    } catch (e) {
      tr.warn('failed', e);
      tr.end('error');
      return { fieldRules: Array.isArray(st?.fieldRules) ? st.fieldRules : [] };
    }
  }

  // ============================================================
  // Canonical refresh from workspace (override-safe; does not break identities)
  // ============================================================
  async function refreshFromCanonical({ reason = '' } = {}) {
    const tr = TRACE('refreshFromCanonical', { reason });

    if (STATE.refreshLock) {
      STATE.refreshPending = true;
      tr.end('coalesced');
      return;
    }

    STATE.refreshLock = true;
    try {
      // If we have unsaved changes, flush first so refresh cannot stomp in-memory edits.
      if (STATE.dirty) flushSaveNow();

      const meta = await P()?.getActiveDocMeta?.();
      STATE.doc = (meta && meta.docId) ? meta : null;

      if (!STATE.doc?.docId) {
        await hardResetOpenForm(`no active doc${reason ? ' ('+reason+')' : ''}`);
        tr.end('no-doc');
        return;
      }

      await hydrateWorkspaceIfEmpty(STATE.doc.docId);

      const st = await P()?.loadState?.(STATE.doc.docId);

      // Merge schema (identity stable) by replacement on STATE.schema ref:
      // (schema is not mutated by UI the same way as values; safe to replace ref)
      STATE.schema = st?.schema || null;

      // Values: identity stable merge
      const nextValues = (st?.values && typeof st.values === 'object') ? st.values : {};
      clearAndAssignObject(STATE.values, nextValues);

      // Canonical: normalize tables immediately (removes empties, enforces min/max)
      normalizeAllTablesInValues(STATE.schema, STATE.values);

      const norm = normalizeRulesForCurrentState(st);
      STATE.fieldRules = norm.fieldRules || [];

      setStatus(`Active DOCX: <span class="kbd">${STATE.doc.name || STATE.doc.docId}</span>${STATE.schema ? '' : ' — <span class="muted">no schema yet</span>'}`);

      await updateWriteAccessBanner();

      const ae = document.activeElement;
      const isEditing = !!(ae && (ae.tagName === 'INPUT' || ae.tagName === 'TEXTAREA' || ae.tagName === 'SELECT'));

      if (!isEditing) {
        renderForm();
      } else {
        try { applyFieldVisibility(); } catch {}
        try { if (typeof window.recomputeDatediffs === 'function') window.recomputeDatediffs(); } catch {}
      }

      tr.end({ isEditing, hasSchema: !!STATE.schema, valuesKeys: Object.keys(STATE.values||{}).length });
    } catch (e) {
      tr.error('failed', e);
      tr.end('error');
    } finally {
      STATE.refreshLock = false;
      if (STATE.refreshPending) {
        STATE.refreshPending = false;
        refreshFromCanonical({ reason: 'pending' });
      }
    }
  }

  async function hardResetOpenForm(reason = '') {
    const tr = TRACE('hardResetOpenForm', { reason });

    STATE.doc = null;
    STATE.schema = null;
    STATE.fieldRules = [];
    clearAndAssignObject(STATE.values, {});
    STATE.dirty = false;

    els.permNote.style.display = 'none';
    setStatus(`No active document${reason ? ` (${reason})` : ''}. Open one in the <a href="extractor.html">Extractor</a>.`);

    if (els.formMount) {
      els.formMount.innerHTML = `<div class="muted">No schema found. Create one in the <a href="builder.html">Builder</a>.</div>`;
    }
    tr.end();
  }

  // ============================================================
  // Canonical listeners
  // ============================================================
  function installCanonicalListeners() {
    const tr = TRACE('installCanonicalListeners');

    try {
      const bcActive = new BroadcastChannel(BC_ACTIVE);
      bcActive.addEventListener('message', (ev) => {
        const m = ev?.data || {};
        if (!m?.type) return;

        if (m.type === 'active:clear') {
          TRACE('BC_ACTIVE', m);
          refreshFromCanonical({ reason: 'active:clear' });
          return;
        }
        if ((m.type === 'active:set' || m.type === 'active:updated') && m.docId) {
          TRACE('BC_ACTIVE', m);
          refreshFromCanonical({ reason: m.type });
        }
      });
      tr.step('listening', { channel: BC_ACTIVE });
    } catch (e) {
      tr.warn('BC_ACTIVE failed', e);
    }

    try {
      const bcPayload = new BroadcastChannel(BC_PAYLOAD);
      bcPayload.addEventListener('message', (ev) => {
        const msg = ev?.data || {};
        if (msg?.t !== 'payload') return;

        const docId = msg.docId;
        if (!docId || docId !== STATE.doc?.docId) return;

        const patch = msg.patch || {};
        const touches =
          ('schema' in patch) ||
          ('rules' in patch) ||
          ('fieldRules' in patch) ||
          ('values' in patch) ||
          ('tagMap' in patch);

        if (!touches) return;

        TRACE('BC_PAYLOAD', { docId, keys: Object.keys(patch || {}) });
        refreshFromCanonical({ reason: 'payload-patch' });
      });
      tr.step('listening', { channel: BC_PAYLOAD });
    } catch (e) {
      tr.warn('BC_PAYLOAD failed', e);
    }

    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible') refreshFromCanonical({ reason: 'visible' });
      if (document.visibilityState === 'hidden') flushSaveNow();
    });
    window.addEventListener('focus', () => refreshFromCanonical({ reason: 'focus' }));

    tr.end();
  }

  // ============================================================
  // Init
  // ============================================================
  init().catch((e) => console.error('[Form] init failed', e));

  async function init() {
    const tr = TRACE('init');

    if (!P()) {
      tr.error('persistence layer missing', new Error('window.formSuitePersist not found'));
      await hardResetOpenForm('persistence missing');
      tr.end('fatal');
      return;
    }

    installCanonicalListeners();

    STATE.doc = await P()?.getActiveDocMeta?.();
    if (STATE.doc?.docId) {
      await refreshFromCanonical({ reason: 'init' });
    } else {
      STATE.schema = loadLocalSchemaFallback();
      clearAndAssignObject(STATE.values, {});
      STATE.fieldRules = [];
      renderForm();
    }

    tr.end();
  }

  // ============================================================
  // Date helpers (datediff)
  // ============================================================
  function diffInDays(a, b) {
    const A = new Date(a.getFullYear(), a.getMonth(), a.getDate());
    const B = new Date(b.getFullYear(), b.getMonth(), b.getDate());
    return Math.floor((B - A) / (24 * 60 * 60 * 1000));
  }
  function diffInMonths(a, b) {
    let months = (b.getFullYear() - a.getFullYear()) * 12 + (b.getMonth() - a.getMonth());
    if (b.getDate() < a.getDate()) months -= 1;
    return months;
  }
  function diffInYears(a, b) {
    let years = b.getFullYear() - a.getFullYear();
    const beforeAnniversary =
      (b.getMonth() < a.getMonth()) ||
      (b.getMonth() === a.getMonth() && b.getDate() < a.getDate());
    if (beforeAnniversary) years -= 1;
    return years;
  }

  function createPrettyDatepicker(input, extraOpts = {}) {
    if (!document.getElementById('fp-zindex-fix')) {
      const st = document.createElement('style');
      st.id = 'fp-zindex-fix';
      st.textContent = `
        .flatpickr-calendar { z-index: 50; }
        .flatpickr-wrapper { position: relative; }
      `;
      document.head.appendChild(st);
    }

    const baseOpts = {
      dateFormat: 'Y-m-d',
      altInput: true,
      altFormat: 'D, j M Y',
      allowInput: false,
      clickOpens: true,
      disableMobile: true,
      static: true,
      wrap: false,
      monthSelectorType: 'dropdown',
      weekNumbers: true,
      prevArrow: '‹',
      nextArrow: '›',
      onReady: (_sel, _str, inst) => {
        if (inst.altInput) {
          inst.altInput.readOnly = true;
          inst.altInput.tabIndex = 0;
          inst.altInput.style.pointerEvents = 'auto';
          const wrap = inst.altInput.parentElement;
          if (wrap && !wrap.classList.contains('flatpickr-wrapper')) {
            wrap.classList.add('flatpickr-wrapper');
            if (getComputedStyle(wrap).position === 'static') wrap.style.position = 'relative';
          }
        }
      }
    };

    return flatpickr(input, { ...baseOpts, ...extraOpts });
  }

  function slugifyMc(s) {
    return String(s || '')
      .normalize('NFKD')
      .replace(/[\u0300-\u036f]/g, '')
      .replace(/[^a-zA-Z0-9]+/g, '_')
      .replace(/^_+|_+$/g, '')
      .toLowerCase();
  }
  function mcExtraKey(fieldId, optionValue, extraId) {
    return `${fieldId}__${slugifyMc(optionValue)}__${slugifyMc(extraId)}`;
  }

  // ============================================================
  // Field visibility (UI), using rules-core evaluateFieldRulesToVisibility
  // ============================================================
  function applyFieldVisibility() {
    const tr = TRACE('applyFieldVisibility', { hasSchema: !!STATE.schema, fields: STATE.schema?.fields?.length, rules: STATE.fieldRules?.length });
    try {
      if (!STATE.schema || !Array.isArray(STATE.schema.fields)) { tr.end('no-schema'); return; }
      if (typeof window.evaluateFieldRulesToVisibility !== 'function') { tr.end('no-evaluator'); return; }

      const visMap = window.evaluateFieldRulesToVisibility(STATE.schema, STATE.values || {}, STATE.fieldRules || []);

      const clearDisabled = (el) => {
        el.style.opacity = '';
        el.style.pointerEvents = '';
        el.removeAttribute('aria-disabled');
        el.querySelectorAll('input,select,textarea,button').forEach(i => { try { i.disabled = false; } catch {} });
      };

      document.querySelectorAll('.field[data-field-id]').forEach(node => { node.style.display = ''; clearDisabled(node); });
      document.querySelectorAll('.mc-item[data-opt-id]').forEach(node => { node.style.display = ''; clearDisabled(node); });

      const esc = (window.CSS && CSS.escape)
        ? CSS.escape
        : (s => String(s)
          .replace(/\\/g,'\\\\')
          .replace(/"/g,'\\"')
          .replace(/\]/g,'\\]')
          .replace(/\[/g,'\\[')
          .replace(/\(/g,'\\(')
          .replace(/\)/g,'\\)')
          .replace(/\./g,'\\.')
        );

      const deselectMcItem = (mcEl) => {
        const cb = mcEl.querySelector('input[type="checkbox"][data-mc="1"]');
        if (!cb) return;
        const fid = cb.name;
        const optVal = cb.value;

        if (cb.checked) cb.checked = false;
        const arr = Array.isArray(STATE.values[fid]) ? STATE.values[fid].map(String) : [];
        STATE.values[fid] = arr.filter(v => v !== String(optVal));
        markDirty();
        scheduleSaveValues();
      };

      const deselectFieldWrapper = (wrapEl) => {
        const fid = wrapEl?.dataset?.fieldId || '';
        if (!fid) return;

        const fld = (STATE.schema?.fields || []).find(f => String(f.id) === String(fid));
        const t = String(fld?.type || '').toLowerCase();

        // CRITICAL: do not clear structured table data on hide/disable.
        if (t === 'table') return;

        if (t === 'multichoice') {
          wrapEl.querySelectorAll('input[type="checkbox"][data-mc="1"]').forEach(cb => { cb.checked = false; });
          STATE.values[fid] = [];
          markDirty();
          scheduleSaveValues();
          return;
        }

        if (t === 'select') {
          const sel = wrapEl.querySelector('select');
          if (sel) { sel.value = ''; STATE.values[fid] = ''; markDirty(); scheduleSaveValues(); }
          return;
        }

        if (t === 'text') {
          const inp = wrapEl.querySelector('input[type="text"]:not([data-type="date"])');
          if (inp) { inp.value = ''; STATE.values[fid] = ''; markDirty(); scheduleSaveValues(); }
          return;
        }

        if (t === 'number') {
          const inp = wrapEl.querySelector('input[type="number"]');
          if (inp) { inp.value = ''; STATE.values[fid] = ''; markDirty(); scheduleSaveValues(); }
          return;
        }

        if (t === 'date') {
          const inp = wrapEl.querySelector('input[data-type="date"]');
          if (inp) {
            try { if (inp._flatpickr) inp._flatpickr.clear(); } catch {}
            inp.value = '';
            STATE.values[fid] = '';
            markDirty();
            scheduleSaveValues();
          }
        }
      };

      for (const id of Object.keys(visMap || {})) {
        const dir = visMap[id];

        if (typeof id === 'string' && id.includes('__opt__')) {
          document.querySelectorAll(`.mc-item[data-opt-id="${esc(id)}"]`).forEach(el => {
            deselectMcItem(el);
            if (dir === 'HIDE') {
              el.style.display = 'none';
            } else {
              el.style.display = '';
              el.style.opacity = '0.5';
              el.style.pointerEvents = 'none';
              el.setAttribute('aria-disabled', 'true');
              el.querySelectorAll('input,select,textarea,button').forEach(i => { try { i.disabled = true; } catch {} });
            }
          });
          continue;
        }

        document.querySelectorAll(`.field[data-field-id="${esc(id)}"]`).forEach(el => {
          deselectFieldWrapper(el);
          if (dir === 'HIDE') {
            el.style.display = 'none';
          } else {
            el.style.display = '';
            el.style.opacity = '0.5';
            el.style.pointerEvents = 'none';
            el.setAttribute('aria-disabled', 'true');
            el.querySelectorAll('input,select,textarea,button').forEach(i => { try { i.disabled = true; } catch {} });
          }
        });
      }

      tr.end({ visKeys: Object.keys(visMap || {}).length });
    } catch (e) {
      tr.warn('failed (UI kept resilient)', e);
      tr.end('error');
    }
  }

  // ============================================================
  // Safe option normalization (fix: avoid [object Object] in selects)
  // ============================================================
  function normOptions(field){
    const raw = (field && field.options) || [];
    return (Array.isArray(raw) ? raw : []).map(o => {
      if (o && typeof o === "object") {
        const value = (o.value ?? o.id ?? o.key ?? o.code ?? String(o));
        const label = (o.label ?? o.text ?? o.name ?? String(value));
        return { value:String(value), label:String(label) };
      }
      return { value:String(o), label:String(o) };
    });
  }

  // ============================================================
  // Render Form
  // ============================================================
  function renderForm() {
    const tr = TRACE('renderForm', { hasSchema: !!STATE.schema, fields: STATE.schema?.fields?.length, docId: STATE.doc?.docId });

    (function injectMcStyles() {
      const ID = 'mc-caret-styles';
      if (document.getElementById(ID)) return;
      const s = document.createElement('style');
      s.id = ID;
      s.textContent = `
        .mc-item { position: relative; }
        .mc-toggle { all: unset; position: absolute; top: 10px; right: 10px; display: inline-flex; align-items: center; justify-content: center; cursor: pointer; line-height: 1; padding: 0; margin: 0; pointer-events: auto; }
        .mc-toggle:focus-visible { outline: 2px solid var(--focus, #2563eb); outline-offset: 2px; border-radius: 4px; }
        .mc-caret { width: 14px; height: 14px; transition: transform .18s ease, opacity .18s ease; opacity: .85; transform: rotate(0deg); display: block; }
        .mc-caret.open { transform: rotate(90deg); }
        .mc-extras { display: none; height: 0; grid-template-columns: 1fr; row-gap: 8px; padding-bottom: 2px; width: 100%; }
        .mc-option-label{ display:grid; grid-template-columns:auto 1fr; column-gap:8px; align-items:center; cursor:pointer; line-height:1.25; }
        .mc-option-label > span{ white-space:normal; word-break:break-word; }
        .mc-option-checkbox{ align-self:center; margin-top:0; transform:none; }
      `;
      document.head.appendChild(s);
    })();

    const mount = els.formMount;
    mount.innerHTML = '';

    if (!STATE.schema || !Array.isArray(STATE.schema.fields) || !STATE.schema.fields.length) {
      mount.innerHTML = `<div class="muted">No schema found. Create one in the <a href="builder.html">Builder</a>.</div>`;
      tr.end('no-schema');
      return;
    }

    // Canonical: tables in values are always normalized BEFORE UI mount.
    normalizeAllTablesInValues(STATE.schema, STATE.values);

    const form = document.createElement('form');
    form.classList.add('form-grid');

    if (STATE.schema.title) {
      const h = document.createElement('h4');
      h.textContent = STATE.schema.title;
      h.style.gridColumn = '1 / -1';
      form.appendChild(h);
    }

    const inputRefs = {};
    const mcDateRefs = {};
    const datediffRefs = [];
    const guardPairs = [];

    function getDateForField(fid) {
      const el = inputRefs[fid];
      if (!el) return null;
      const fp = el?._flatpickr;
      if (fp?.selectedDates?.[0] instanceof Date) return fp.selectedDates[0];

      const iso = getValue(fid);
      if (iso) {
        const d = (window.flatpickr && window.flatpickr.parseDate)
          ? window.flatpickr.parseDate(String(iso), 'Y-m-d')
          : new Date(String(iso));
        return (d && !isNaN(d)) ? d : null;
      }
      return null;
    }

    function recomputeDatediffs() {
      datediffRefs.forEach(({ storeKey, outEl, resolve }) => {
        const { a, b } = resolve();
        if (!a || !b) {
          outEl.textContent = '—';
          STATE.values[storeKey] = null;
          return;
        }
        const days = diffInDays(a, b);
        const months = diffInMonths(a, b);
        const years = diffInYears(a, b);
        const display = `${days}D ${months}M ${years}Y (${days} Days total)`;
        outEl.textContent = display;
        STATE.values[storeKey] = { days, months, years, formatted: display };
      });
      markDirty();
      scheduleSaveValues();
    }
    window.recomputeDatediffs = recomputeDatediffs;

    // ---- Fields ----
    (STATE.schema.fields || []).forEach(f => {
      const wrap = document.createElement('div');
      wrap.className = 'field';
      try { wrap.dataset.fieldId = String(f.id || ''); } catch {}

      if (f.type === 'address' || f.type === 'datediff') wrap.classList.add('span-2');
      if (f.type === 'table') wrap.classList.add('full', 'field--table');
      if (f.type === 'multichoice') wrap.classList.add('full', 'field--multichoice');
      if (f.wide === true) wrap.classList.add('span-2');
      if (f.full === true) wrap.classList.add('full');

      if (f.type !== 'address') {
        const label = document.createElement('label');
        label.htmlFor = f.id;
        label.textContent = f.label || f.id;
        if (f.required) {
          const star = document.createElement('span');
          star.textContent = ' *';
          star.style.color = '#ef4444';
          label.appendChild(star);
        }
        wrap.appendChild(label);
      }

      // Text
      if (f.type === 'text') {
        const input = document.createElement('input');
        input.type = 'text';
        input.id = f.id; input.name = f.id; input.style.width = '100%';
        if (f.required) input.required = true;
        if (getValue(f.id) != null) input.value = getValue(f.id);

        const commit = () => { setValue(f.id, input.value); applyFieldVisibility(); };
        input.addEventListener('input', commit);
        input.addEventListener('change', commit);

        wrap.appendChild(input);
        inputRefs[f.id] = input;
      }

      // Number
      else if (f.type === 'number') {
        const input = document.createElement('input');
        input.type = 'number';
        input.id = f.id; input.name = f.id; input.style.width = '100%';
        if (f.required) input.required = true;
        if (getValue(f.id) != null) input.value = getValue(f.id);

        const commit = () => {
          const v = input.value;
          setValue(f.id, (v === '' ? '' : Number(v)));
          applyFieldVisibility();
        };
        input.addEventListener('input', commit);
        input.addEventListener('change', commit);

        wrap.appendChild(input);
        inputRefs[f.id] = input;
      }

      // Select
      else if (f.type === 'select') {
        const input = document.createElement('select');
        input.id = f.id; input.name = f.id; input.style.width = '100%';

        const opts = normOptions(f);
        const empty = document.createElement('option');
        empty.value = '';
        empty.textContent = '— select —';
        input.appendChild(empty);

        opts.forEach(({value,label}) => {
          const o = document.createElement('option');
          o.value = value;
          o.textContent = label;
          input.appendChild(o);
        });

        if (f.required) input.required = true;
        if (getValue(f.id) != null) input.value = String(getValue(f.id));

        input.addEventListener('change', () => { setValue(f.id, input.value); applyFieldVisibility(); });

        wrap.appendChild(input);
        inputRefs[f.id] = input;
      }

      // Date
      else if (f.type === 'date') {
        const input = document.createElement('input');
        input.type = 'text';
        input.dataset.type = 'date';
        input.id = f.id; input.name = f.id; input.style.width = '100%';
        if (f.required) input.required = true;
        wrap.appendChild(input);

        const fp = createPrettyDatepicker(input, {
          dateFormat: 'Y-m-d',
          altInput: true,
          altFormat: 'D, j M Y',
          allowInput: false,
          clickOpens: true,
          defaultDate: getValue(f.id) || null,
          onChange: () => { setValue(f.id, input.value); recomputeDatediffs(); applyFieldVisibility(); },
          onValueUpdate: () => { setValue(f.id, input.value); recomputeDatediffs(); applyFieldVisibility(); }
        });
        fp.set('allowInput', false);
        if (fp.altInput) fp.altInput.readOnly = true;
        inputRefs[f.id] = input;
      }

      // Address (optional component)
      else if (f.type === 'address') {
        const host = document.createElement('div');
        host.className = 'addr-host';
        wrap.appendChild(host);

        const initial =
          typeof getValue(f.id) === 'string'
            ? { formatted: getValue(f.id) }
            : (getValue(f.id) || null);

        if (window.AddressAuto?.mount) {
          AddressAuto.mount(host, {
            id: f.id,
            label: f.label || 'Address',
            required: !!f.required,
            value: initial || null,
            onChange: (val) => { setValue(f.id, val); }
          });
        } else {
          // Hard fallback: plain text input if component missing
          const input = document.createElement('input');
          input.type = 'text';
          input.id = f.id; input.name = f.id; input.style.width = '100%';
          input.value = (initial && typeof initial === 'object') ? (initial.formatted || '') : (initial || '');
          input.addEventListener('input', () => setValue(f.id, input.value));
          input.addEventListener('change', () => setValue(f.id, input.value));
          host.appendChild(input);
          inputRefs[f.id] = input;
        }
      }

      // Table (FULL FIX: canonical persistence; no implicit writes; deterministic add/edit/delete)
      else if (f.type === 'table') {
        renderTableField(wrap, f);
      }

      // Datediff
      else if (f.type === 'datediff') {
        const fromId = f.fromId || f.from || '';
        const toId = f.toId || f.to || '';

        const out = document.createElement('div');
        out.id = f.id;
        out.className = 'datediff-out kbd';
        out.setAttribute('role', 'status');
        out.setAttribute('aria-live', 'polite');
        out.textContent = '—';
        wrap.appendChild(out);

        datediffRefs.push({
          storeKey: f.id,
          outEl: out,
          resolve: () => ({ a: getDateForField(fromId), b: getDateForField(toId) })
        });

        guardPairs.push({ fromId, toId });
      }

      // Multichoice (kept; all writes through STATE)
      else if (f.type === 'multichoice') {
        const mcContainer = document.createElement('div');
        mcContainer.className = 'mc-container';
        mcContainer.style.display = 'block';

        const items = [];
        if (f.mc && Array.isArray(f.mc.groups) && f.mc.groups.length) {
          f.mc.groups.forEach(g => (g.items || []).forEach(it => {
            items.push({
              value: String(it.value ?? it.label ?? ''),
              alwaysSelected: !!it.alwaysSelected,
              preselected: !!it.preselected,
              fields: Array.isArray(it.fields) ? it.fields : []
            });
          }));
        } else if (Array.isArray(f.options)) {
          f.options.forEach(v => {
            if (v && typeof v === 'object') {
              items.push({
                value: String(v.value ?? v.label ?? ''),
                alwaysSelected: !!v.alwaysSelected,
                preselected: !!v.preselected,
                fields: Array.isArray(v.fields) ? v.fields : []
              });
            } else {
              items.push({ value: String(v), alwaysSelected: false, preselected: false, fields: [] });
            }
          });
        }

        if (!Array.isArray(getValue(f.id))) {
          const initial = items.filter(it => it.alwaysSelected || it.preselected).map(it => it.value);
          if (initial.length) STATE.values[f.id] = initial.slice();
        }
        const selected = new Set(Array.isArray(getValue(f.id)) ? getValue(f.id).map(String) : []);

        function persistMainSelection() {
          const boxes = mcContainer.querySelectorAll(`input[type="checkbox"][data-mc="1"]`);
          STATE.values[f.id] = Array.from(boxes).filter(b => b.checked).map(b => b.value);
          markDirty();
          scheduleSaveValues();
        }

        function setExtrasOpen(extras, caretEl, open) {
          if (!extras) return;
          const DURATION = 220;

          if (extras._animTimer) { clearTimeout(extras._animTimer); extras._animTimer = null; }
          if (extras._onTe) { extras.removeEventListener('transitionend', extras._onTe); extras._onTe = null; }

          const onEnd = () => {
            extras.style.transition = '';
            extras.style.willChange = '';
            extras.style.opacity = open ? '1' : '0';
            extras.style.marginTop = open ? '8px' : '0px';
            extras.style.height = open ? 'auto' : '0px';
            extras.style.overflow = 'visible';
            if (!open) extras.style.display = 'none';
            if (extras._onTe) {
              extras.removeEventListener('transitionend', extras._onTe);
              extras._onTe = null;
            }
          };
          extras._onTe = onEnd;
          extras.addEventListener('transitionend', onEnd);

          if (caretEl) caretEl.classList.toggle('open', !!open);

          if (open) {
            extras.style.display = 'grid';
            extras.style.overflow = 'visible';
            extras.style.willChange = 'height, opacity, margin-top';
            extras.style.opacity = '0';
            extras.style.marginTop = '0px';
            extras.style.height = '0px';

            requestAnimationFrame(() => {
              const h = extras.scrollHeight;
              extras.classList.add('open');
              extras.style.transition = `height ${DURATION}ms ease, opacity ${DURATION}ms ease, margin-top ${DURATION}ms ease`;
              extras.style.height = h + 'px';
              extras.style.opacity = '1';
              extras.style.marginTop = '8px';
              extras._animTimer = setTimeout(onEnd, DURATION + 40);
            });
          } else {
            const current = extras.offsetHeight || extras.scrollHeight || 0;
            extras.classList.remove('open');
            extras.style.display = 'grid';
            extras.style.overflow = 'hidden';
            extras.style.willChange = 'height, opacity, margin-top';
            extras.style.transition = '';
            extras.style.height = current + 'px';
            extras.style.opacity = '1';
            extras.style.marginTop = '8px';

            requestAnimationFrame(() => {
              extras.style.transition = `height ${DURATION}ms ease, opacity ${DURATION}ms ease, margin-top ${DURATION}ms ease`;
              extras.style.height = '0px';
              extras.style.opacity = '0';
              extras.style.marginTop = '0px';
              extras._animTimer = setTimeout(onEnd, DURATION + 40);
            });
          }
        }

        function getDateForExtraKey(key) {
          const el = mcDateRefs[key];
          const fp = el?._flatpickr;
          if (fp?.selectedDates?.[0] instanceof Date) return fp.selectedDates[0];

          const iso = STATE.values[key];
          if (iso) {
            const d = (window.flatpickr && window.flatpickr.parseDate)
              ? window.flatpickr.parseDate(String(iso), 'Y-m-d')
              : new Date(String(iso));
            return (d && !isNaN(d)) ? d : null;
          }
          return null;
        }

        function drawOption(item, parentHost) {
          const optVal = item.value;
          const optId = `${f.id}__${slugifyMc(optVal)}`;
          const hasExtras = Array.isArray(item.fields) && item.fields.length > 0;

          const card = document.createElement('div');
          card.className = 'mc-item';
          try { card.dataset.optId = `${f.id}__opt__${slugifyMc(optVal)}`; } catch {}

          card.style.position = 'relative';
          card.style.display = 'flex';
          card.style.flexDirection = 'column';
          card.style.alignItems = 'stretch';
          card.style.background = 'var(--card)';
          card.style.border = '1px solid var(--border-strong)';
          card.style.borderRadius = '8px';
          card.style.padding = '10px 10px';

          const row1 = document.createElement('div');
          row1.className = 'row';
          row1.style.alignItems = 'center';
          row1.style.gap = '8px';
          row1.style.width = '100%';

          const left = document.createElement('label');
          left.className = 'mc-option-label';
          left.setAttribute('for', optId);
          left.style.flex = '1';

          const cb = document.createElement('input');
          cb.type = 'checkbox';
          cb.dataset.mc = '1';
          cb.name = f.id;
          cb.id = optId;
          cb.value = optVal;
          cb.className = 'mc-option-checkbox';

          const locked = !!item.alwaysSelected;
          const isPreselected = !!item.preselected;
          cb.checked = locked || selected.has(optVal) || (!selected.size && isPreselected);
          if (locked) cb.disabled = true;

          const txt = document.createElement('span');
          txt.textContent = optVal;

          left.appendChild(cb);
          left.appendChild(txt);
          row1.appendChild(left);

          let extrasWrap = null;
          if (hasExtras) {
            extrasWrap = document.createElement('div');
            extrasWrap.className = 'mc-extras';
            extrasWrap.style.display = 'none';
            extrasWrap.style.height = '0px';

            const mountExtraFields = () => {
              extrasWrap.innerHTML = '';
              if (!item.fields.length) return;

              item.fields.forEach(ex => {
                const exType = String(ex?.type || 'text');
                const exId = String(ex?.id || '');
                if (!exId) return;

                const exKey = mcExtraKey(f.id, optVal, exId);

                const line = document.createElement('div');
                line.className = 'row';
                line.style.gap = '8px';
                line.style.alignItems = 'center';
                line.style.marginTop = '2px';

                const lab = document.createElement('label');
                lab.textContent = String(ex?.label || exId);
                lab.style.minWidth = '120px';
                lab.style.color = 'var(--muted)';

                if (exType === 'date') {
                  const input = document.createElement('input');
                  input.type = 'text';
                  input.dataset.type = 'date';
                  input.style.minWidth = '180px';

                  extrasWrap.appendChild(line);
                  line.appendChild(lab);
                  line.appendChild(input);

                  const fp = createPrettyDatepicker(input, {
                    dateFormat: 'Y-m-d',
                    altInput: true,
                    altFormat: 'D, j M Y',
                    defaultDate: STATE.values[exKey] || null,
                    onChange: () => { STATE.values[exKey] = input.value; markDirty(); scheduleSaveValues(); recomputeDatediffs(); },
                    onValueUpdate: () => { STATE.values[exKey] = input.value; markDirty(); scheduleSaveValues(); recomputeDatediffs(); }
                  });
                  fp.set('allowInput', false);
                  if (fp.altInput) fp.altInput.readOnly = true;

                  mcDateRefs[exKey] = input;
                  return;
                }

                if (exType === 'number') {
                  const input = document.createElement('input');
                  input.type = 'number';
                  input.value = STATE.values[exKey] ?? '';
                  input.addEventListener('input', () => { STATE.values[exKey] = (input.value === '' ? '' : Number(input.value)); markDirty(); scheduleSaveValues(); });
                  input.addEventListener('change', () => { STATE.values[exKey] = (input.value === '' ? '' : Number(input.value)); markDirty(); scheduleSaveValues(); });
                  extrasWrap.appendChild(line);
                  line.appendChild(lab);
                  line.appendChild(input);
                  return;
                }

                if (exType === 'datediff') {
                  const fromId = ex.fromId || ex.from || '';
                  const toId = ex.toId || ex.to || '';
                  const fromKey = mcExtraKey(f.id, optVal, fromId);
                  const toKey = mcExtraKey(f.id, optVal, toId);

                  const out = document.createElement('div');
                  out.className = 'datediff-out kbd';
                  out.setAttribute('role', 'status');
                  out.setAttribute('aria-live', 'polite');
                  out.textContent = '—';

                  extrasWrap.appendChild(line);
                  line.appendChild(lab);
                  line.appendChild(out);

                  datediffRefs.push({
                    storeKey: exKey,
                    outEl: out,
                    resolve: () => ({ a: getDateForExtraKey(fromKey), b: getDateForExtraKey(toKey) })
                  });
                  return;
                }

                const input = document.createElement('input');
                input.type = 'text';
                input.value = STATE.values[exKey] ?? '';
                input.addEventListener('input', () => { STATE.values[exKey] = input.value; markDirty(); scheduleSaveValues(); });
                input.addEventListener('change', () => { STATE.values[exKey] = input.value; markDirty(); scheduleSaveValues(); });
                extrasWrap.appendChild(line);
                line.appendChild(lab);
                line.appendChild(input);
              });
            };

            mountExtraFields();
          }

          if (hasExtras) {
            const caretBtn = document.createElement('button');
            caretBtn.type = 'button';
            caretBtn.className = 'mc-toggle';
            caretBtn.setAttribute('aria-expanded', 'false');
            caretBtn.setAttribute('aria-label', 'Details ein-/ausklappen');

            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('viewBox', '0 0 24 24');
            svg.setAttribute('width', '14');
            svg.setAttribute('height', '14');
            svg.classList.add('mc-caret');

            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', 'M9 18l6-6-6-6');
            path.setAttribute('fill', 'none');
            path.setAttribute('stroke', 'currentColor');
            path.setAttribute('stroke-width', '2');
            path.setAttribute('stroke-linecap', 'round');
            path.setAttribute('stroke-linejoin', 'round');
            svg.appendChild(path);

            caretBtn.appendChild(svg);
            row1.appendChild(caretBtn);

            setExtrasOpen(extrasWrap, svg, false);

            caretBtn.addEventListener('click', (e) => {
              e.preventDefault();
              const willOpen = !extrasWrap.classList.contains('open');
              caretBtn.setAttribute('aria-expanded', String(willOpen));
              setExtrasOpen(extrasWrap, svg, willOpen);
            });
          }

          cb.addEventListener('change', () => {
            if (locked) { cb.checked = true; return; }
            persistMainSelection();
            applyFieldVisibility();
          });

          card.appendChild(row1);
          if (extrasWrap) card.appendChild(extrasWrap);
          parentHost.appendChild(card);
        }

        if (f.mc && Array.isArray(f.mc.groups) && f.mc.groups.length) {
          f.mc.groups.forEach(g => {
            const section = document.createElement('div');
            section.className = 'mc-group-section';
            section.style.marginBottom = '10px';

            if (g.title) {
              const h = document.createElement('div');
              h.className = 'mc-group-title';
              h.textContent = String(g.title);
              h.style.color = 'var(--muted)';
              h.style.fontWeight = '600';
              h.style.fontSize = '.95rem';
              h.style.margin = '4px 0 6px';
              section.appendChild(h);
            }

            const host = document.createElement('div');
            host.className = 'mc-group';
            host.style.display = 'grid';
            host.style.gridTemplateColumns = 'repeat(auto-fill,minmax(260px,1fr))';
            host.style.gap = '8px 16px';
            host.style.alignItems = 'start';

            if (Number.isFinite(+f.columns) && +f.columns > 0) {
              host.style.gridTemplateColumns = `repeat(${+f.columns}, minmax(220px, 1fr))`;
            }

            (g.items || []).forEach(it => drawOption({
              value: String(it.value ?? it.label ?? ''),
              alwaysSelected: !!it.alwaysSelected,
              preselected: !!it.preselected,
              fields: Array.isArray(it.fields) ? it.fields : []
            }, host));

            section.appendChild(host);
            mcContainer.appendChild(section);
          });
        } else {
          const host = document.createElement('div');
          host.className = 'mc-group';
          host.style.display = 'grid';
          host.style.gridTemplateColumns = 'repeat(auto-fill,minmax(260px,1fr))';
          host.style.gap = '8px 16px';
          host.style.alignItems = 'start';

          if (Number.isFinite(+f.columns) && +f.columns > 0) {
            host.style.gridTemplateColumns = `repeat(${+f.columns}, minmax(220px, 1fr))`;
          }

          items.forEach(it => drawOption(it, host));
          mcContainer.appendChild(host);
        }

        STATE.values[f.id] = Array.from(mcContainer.querySelectorAll(`input[type="checkbox"][data-mc="1"]`))
          .filter(b => b.checked)
          .map(b => b.value);
        markDirty();
        scheduleSaveValues();

        wrap.appendChild(mcContainer);
      }

      // Fallback
      else {
        const input = document.createElement('input');
        input.type = 'text';
        input.id = f.id; input.name = f.id; input.style.width = '100%';
        if (getValue(f.id) != null) input.value = getValue(f.id);

        const commit = () => { setValue(f.id, input.value); };
        input.addEventListener('input', commit);
        input.addEventListener('change', commit);

        wrap.appendChild(input);
        inputRefs[f.id] = input;
      }

      form.appendChild(wrap);
    });

    form.addEventListener('change', () => applyFieldVisibility());
    mount.appendChild(form);

    (function wireTopLevelDateGuards() {
      function nextDay(d) {
        if (!d) return null;
        const n = new Date(d.getFullYear(), d.getMonth(), d.getDate());
        n.setDate(n.getDate() + 1);
        return n;
      }

      guardPairs.forEach(({ fromId, toId }) => {
        const fromEl = inputRefs[fromId];
        const toEl = inputRefs[toId];
        const fpFrom = fromEl?._flatpickr;
        const fpTo = toEl?._flatpickr;
        if (!fpFrom || !fpTo) return;

        fpFrom.set('allowInput', false);
        fpTo.set('allowInput', false);
        if (fpFrom.altInput) fpFrom.altInput.readOnly = true;
        if (fpTo.altInput) fpTo.altInput.readOnly = true;

        const syncToWithFrom = (opts = { snap: true, jump: true }) => {
          const from = fpFrom.selectedDates?.[0] || null;
          const minForTo = nextDay(from);
          fpTo.set('minDate', minForTo || null);

          const toSel = fpTo.selectedDates?.[0] || null;
          if (!toSel && minForTo && opts.snap) fpTo.setDate(minForTo, true);
          if (from && toSel && toSel <= from && opts.snap) fpTo.setDate(minForTo, true);
          if (minForTo && opts.jump) { try { fpTo.jumpToDate(minForTo); } catch {} }

          recomputeDatediffs();
        };

        syncToWithFrom({ snap: true, jump: false });
        fpFrom.config.onChange.push(() => syncToWithFrom({ snap: true, jump: true }));
        fpFrom.config.onValueUpdate.push(() => syncToWithFrom({ snap: true, jump: true }));
        fpTo.config.onOpen.push(() => syncToWithFrom({ snap: false, jump: true }));

        const recompute = () => recomputeDatediffs();
        fpTo.config.onChange.push(recompute);
        fpTo.config.onValueUpdate.push(recompute);
      });
    })();

    recomputeDatediffs();
    applyFieldVisibility();

    tr.end();
  }

  // ============================================================
  // TABLE FIELD — FULL FIX
  // Deterministic behavior:
  //  - Table rows in STATE.values[field.id] are CANONICAL data (no draft rows)
  //  - Editor has a separate draft buffer; draft is NOT persisted until "Add row"
  //  - Editing existing rows persists immediately (like other fields)
  //  - All saves go through STATE + canonical sanitizer (filters empties + min/max)
  // ============================================================
  function renderTableField(container, field) {
    const fid = String(field?.id || '');
    const tr = TRACE('renderTableField', { fid, cols: (field?.columns||[]).length });

    // Canonical committed rows
    let rows = ensureTableValue(field);

    // UI state
    let selectedIndex = null;          // index in rows or null
    let draft = emptyRow(field);       // not persisted
    let statusText = '';

    // UI root
    const editorWrap = document.createElement('div');
    editorWrap.style.display = 'flex';
    editorWrap.style.flexWrap = 'wrap';
    editorWrap.style.gap = '10px';

    const toolbar = document.createElement('div');
    toolbar.className = 'row';
    toolbar.style.gap = '8px';
    toolbar.style.alignItems = 'center';

    const status = document.createElement('div');
    status.className = 'muted';
    status.style.minHeight = '1.2em';

    const tableWrap = document.createElement('div');
    tableWrap.style.overflow = 'auto';

    const table = document.createElement('table');
    table.style.width = '100%';

    const thead = document.createElement('thead');
    const trh = document.createElement('tr');
    thead.appendChild(trh);

    const tbody = document.createElement('tbody');

    table.appendChild(thead);
    table.appendChild(tbody);
    tableWrap.appendChild(table);

    // Buttons
    const btnAdd = document.createElement('button');
    btnAdd.type = 'button';
    btnAdd.textContent = 'Zeile hinzufügen';

    const btnNew = document.createElement('button');
    btnNew.type = 'button';
    btnNew.className = 'secondary';
    btnNew.textContent = 'Neue Zeile';

    const btnDelete = document.createElement('button');
    btnDelete.type = 'button';
    btnDelete.className = 'ghost';
    btnDelete.textContent = 'Zeile löschen';

    const btnCancel = document.createElement('button');
    btnCancel.type = 'button';
    btnCancel.className = 'ghost';
    btnCancel.textContent = 'Abbrechen';

    toolbar.appendChild(btnAdd);
    toolbar.appendChild(btnNew);
    toolbar.appendChild(btnDelete);
    toolbar.appendChild(btnCancel);

    // Header cells
    (field.columns || []).forEach(col => {
      const th = document.createElement('th');
      th.textContent = col.label || col.id;
      trh.appendChild(th);
    });

    // Editor inputs
    const editorInputs = {};
    const measurer = document.createElement('canvas').getContext('2d');
    function textPx(str) {
      try { measurer.font = getComputedStyle(document.body).font; } catch {}
      return Math.ceil(measurer.measureText(String(str || '')).width);
    }
    function longest(arr) {
      return (arr || []).reduce((a, b) => (String(b).length > String(a).length ? String(b) : String(a)), '');
    }

    function currentModel() {
      // editing existing row -> that row; else draft buffer
      if (typeof selectedIndex === 'number' && selectedIndex >= 0 && selectedIndex < rows.length) return rows[selectedIndex];
      return draft;
    }

    function setSelected(idxOrNull) {
      selectedIndex = (typeof idxOrNull === 'number') ? idxOrNull : null;
      // When selecting a row, editor shows that row. When clearing, editor shows draft.
      syncEditorFromModel();
      updateToolbar();
      drawTable();
    }

    function syncEditorFromModel() {
      const model = currentModel();
      (field.columns || []).forEach(c => {
        const el = editorInputs[c.id];
        if (!el) return;
        const v = (model && Object.prototype.hasOwnProperty.call(model, c.id)) ? model[c.id] : '';
        // If flatpickr exists, setting input value is ok; widget reads it
        el.value = (v == null) ? '' : String(v);
        try { if (el._flatpickr && el.value) el._flatpickr.setDate(el.value, false); } catch {}
        try { if (el._flatpickr && !el.value) el._flatpickr.clear(); } catch {}
      });
    }

    function syncModelFromEditor(colId, value) {
      const model = currentModel();
      model[colId] = value;

      // Editing existing row is immediately canonical -> normalize & persist
      if (typeof selectedIndex === 'number') {
        rows[selectedIndex] = { ...emptyRow(field), ...(rows[selectedIndex] || {}) };
        // canonical normalize + persist
        STATE.values[fid] = normalizeTableArray(field, rows);
        rows = STATE.values[fid];
        markDirty();
        scheduleSaveValues();
      } else {
        // draft is transient; enable Add if non-empty
        updateToolbar();
      }
      statusText = '';
      status.textContent = statusText;
    }

    (field.columns || []).forEach(col => {
      const pair = document.createElement('label');
      pair.style.display = 'flex';
      pair.style.alignItems = 'center';
      pair.style.gap = '8px';

      const lbl = document.createElement('span');
      lbl.textContent = col.label || col.id;

      let el;
      if (col.type === 'select') {
        el = document.createElement('select');
        const opts = Array.isArray(col.options) ? col.options : [];
        const empty = document.createElement('option');
        empty.value = '';
        empty.textContent = '— wählen —';
        el.appendChild(empty);
        opts.forEach(opt => {
          const o = document.createElement('option');
          o.value = String(opt);
          o.textContent = String(opt);
          el.appendChild(o);
        });
        el.style.minWidth = Math.max(140, Math.min(360, textPx(longest(opts)) + 56)) + 'px';
        el.addEventListener('change', () => syncModelFromEditor(col.id, el.value));
      } else if (col.type === 'date') {
        el = document.createElement('input');
        el.type = 'text';
        el.dataset.type = 'date';
        el.style.minWidth = Math.max(140, Math.min(360, textPx('YYYY-MM-DD') + 20)) + 'px';

        // Use pretty datepicker (consistent with other dates)
        createPrettyDatepicker(el, {
          dateFormat: 'Y-m-d',
          altInput: true,
          altFormat: 'D, j M Y',
          allowInput: false,
          clickOpens: true,
          defaultDate: '',
          onChange: () => syncModelFromEditor(col.id, el.value),
          onValueUpdate: () => syncModelFromEditor(col.id, el.value),
        });
      } else if (col.type === 'number') {
        el = document.createElement('input');
        el.type = 'number';
        el.style.minWidth = Math.max(120, Math.min(360, textPx('000000') + 20)) + 'px';
        el.addEventListener('input', () => syncModelFromEditor(col.id, el.value === '' ? '' : Number(el.value)));
        el.addEventListener('change', () => syncModelFromEditor(col.id, el.value === '' ? '' : Number(el.value)));
      } else {
        el = document.createElement('input');
        el.type = 'text';
        el.style.minWidth = Math.max(160, Math.min(360, textPx(lbl.textContent) + 20)) + 'px';
        el.addEventListener('input', () => syncModelFromEditor(col.id, el.value));
        el.addEventListener('change', () => syncModelFromEditor(col.id, el.value));
      }

      editorInputs[col.id] = el;
      pair.appendChild(lbl);
      pair.appendChild(el);
      editorWrap.appendChild(pair);
    });

    function committedCount() {
      rows = ensureTableValue(field);
      return rows.filter(r => !rowIsEmpty(field, r)).length;
    }

    function updateToolbar() {
      rows = ensureTableValue(field);
      const min = Math.max(0, parseInt(field.minRows || 0, 10));
      const max = Math.max(0, parseInt(field.maxRows || 0, 10));
      const isEditingExisting = (typeof selectedIndex === 'number' && selectedIndex >= 0 && selectedIndex < rows.length);

      // Add button is ONLY for draft
      const draftHasData = !rowIsEmpty(field, draft);
      btnAdd.style.display = isEditingExisting ? 'none' : '';
      btnAdd.disabled = !draftHasData || (!!max && committedCount() >= max);

      // New row is available always; it clears selection and clears draft
      btnNew.style.display = '';
      btnNew.disabled = false;

      // Delete/Cancel only if editing an existing row
      btnDelete.style.display = isEditingExisting ? '' : 'none';
      btnCancel.style.display = isEditingExisting ? '' : 'none';

      btnDelete.disabled = !isEditingExisting || (!!min && committedCount() <= min);
    }

    function drawTable() {
      rows = ensureTableValue(field);
      tbody.innerHTML = '';

      const hasAny = rows.some(r => !rowIsEmpty(field, r));
      tableWrap.style.display = hasAny ? '' : 'none';

      rows.forEach((row, idx) => {
        // If schema padded minRows with empties, hide empties in preview
        if (rowIsEmpty(field, row)) return;

        const trEl = document.createElement('tr');
        const isSel = (idx === selectedIndex);

        if (isSel) {
          trEl.style.background = '#DBEAFE';
          trEl.style.outline = '2px solid #93C5FD';
          trEl.style.outlineOffset = '-2px';
        }

        trEl.addEventListener('click', () => {
          // Select row for editing
          setSelected(idx);
          statusText = '';
          status.textContent = statusText;
        });

        (field.columns || []).forEach(col => {
          const td = document.createElement('td');
          td.textContent = row[col.id] ?? '';
          trEl.appendChild(td);
        });

        tbody.appendChild(trEl);
      });
    }

    // Actions
    btnAdd.addEventListener('click', () => {
      rows = ensureTableValue(field);

      if (rowIsEmpty(field, draft)) {
        statusText = 'Keine Eingaben zum Hinzufügen.';
        status.textContent = statusText;
        updateToolbar();
        return;
      }

      const max = Math.max(0, parseInt(field.maxRows || 0, 10));
      if (max && committedCount() >= max) {
        statusText = 'Maximale Anzahl Zeilen erreicht.';
        status.textContent = statusText;
        updateToolbar();
        return;
      }

      // Commit draft into canonical rows
      rows.push({ ...emptyRow(field), ...draft });
      STATE.values[fid] = normalizeTableArray(field, rows);
      rows = STATE.values[fid];

      // Clear draft and remain in draft mode (so next row can be entered)
      draft = emptyRow(field);
      syncEditorFromModel();

      markDirty();
      scheduleSaveValues();

      statusText = 'Zeile hinzugefügt.';
      status.textContent = statusText;

      updateToolbar();
      drawTable();
    });

    btnNew.addEventListener('click', () => {
      // Always go back to draft (new row entry)
      selectedIndex = null;
      draft = emptyRow(field);
      syncEditorFromModel();
      updateToolbar();
      drawTable();
      statusText = 'Neue Zeile.';
      status.textContent = statusText;
    });

    btnDelete.addEventListener('click', () => {
      rows = ensureTableValue(field);

      const min = Math.max(0, parseInt(field.minRows || 0, 10));
      if (!(typeof selectedIndex === 'number') || selectedIndex < 0 || selectedIndex >= rows.length) return;
      if (min && committedCount() <= min) return;

      rows.splice(selectedIndex, 1);
      STATE.values[fid] = normalizeTableArray(field, rows);
      rows = STATE.values[fid];

      selectedIndex = null;
      draft = emptyRow(field);
      syncEditorFromModel();

      markDirty();
      scheduleSaveValues();

      statusText = 'Zeile gelöscht.';
      status.textContent = statusText;

      updateToolbar();
      drawTable();
    });

    btnCancel.addEventListener('click', () => {
      // Cancel editing existing row: drop selection, revert editor to draft (does not undo saved edits)
      // (Edits are already persisted immediately; Cancel is just "stop editing this row")
      selectedIndex = null;
      syncEditorFromModel();
      updateToolbar();
      drawTable();
      statusText = 'Bearbeitung beendet.';
      status.textContent = statusText;
    });

    // Mount
    container.appendChild(editorWrap);
    container.appendChild(toolbar);
    container.appendChild(status);
    container.appendChild(tableWrap);

    // Init
    updateToolbar();
    syncEditorFromModel();
    drawTable();

    tr.end({ rows: rows.length });
  }

  // ============================================================
  // Expose for cross-callbacks
  // ============================================================
  try { window.applyFieldVisibility = applyFieldVisibility; } catch {}

  // Keep existing behavior
  try { installLogoFocusNav(); } catch {}
  </script>
</body>
</html>
