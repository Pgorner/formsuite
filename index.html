<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Form Suite — Form</title>
  <link rel="icon" href="favicon.ico" type="image/gif" sizes="32x32">
  <link rel="shortcut icon" href="favicon.ico" type="image/gif">
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/themes/material_blue.css">
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <header>
    <div class="row">
      <span class="brand logo-md">
        <img src="logo.gif" alt="Form Suite logo" class="logo" />
        <strong>Form Suite</strong>
      </span>
      <span class="muted">·</span><span class="muted">Form</span>
      <span class="muted">·</span><a href="builder.html">Form Builder</a>
      <span class="muted">·</span><a href="matcher.html">Tag Matcher</a>
      <span class="muted">·</span><a href="rules.html">Rules</a>
      <span class="muted">·</span><a href="extractor.html">Extractor</a>
    </div>
  </header>

  <main>
    <section class="panel">
      <div class="title-row"></div>
      <div class="row" style="margin-top:8px;">
        <span id="docStatus" class="muted">No active document. Open one in the <a href="extractor.html">Extractor</a>.</span>
      </div>
      <div id="permNote" class="note warn" style="display:none; margin-top:10px">
        This DOCX was opened via picker but I don’t have write permission to the original file.
        You can still work from the cached copy, but changes cannot be written back until permission is granted.
        <button id="btnRegrant" class="ghost" style="margin-left:8px">Grant write access</button>
      </div>
    </section>

    <section class="panel">
      <div id="formMount"></div>
    </section>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

  <!-- Canonical single coordination layer -->
  <script src="persistence.js"></script>

  <!-- Canonical rules normalization + visibility eval -->
  <script src="rules-core.js"></script>

  <!-- DOCX utilities (used by persistence hydrate helpers) -->
  <script src="docx-core.js"></script>

  <!-- UI helper -->
  <script src="fs-focus-nav.js"></script>

  <!-- Optional component -->
  <script src="address-autocomplete.js"></script>

  <script>
  'use strict';

  // ============================================================
  // TRACE (debug logs everywhere)
  // ============================================================
  (function ensureTrace() {
    if (typeof window.TRACE === 'function') return;
    const DEBUG = { on: true, seq: 0 };
    const ts = () => new Date().toISOString().slice(11, 23);
    window.TRACE = function TRACE(name, details) {
      const id = ++DEBUG.seq;
      const prefix = `[Form ${ts()} #${id}] ${name}`;
      if (DEBUG.on) console.log(prefix, details ?? '');
      const t0 = (typeof performance !== 'undefined' ? performance.now() : Date.now());
      return {
        step(msg, data) { if (DEBUG.on) console.log(`${prefix}  ↳ ${msg}`, data ?? ''); },
        warn(msg, data) { if (DEBUG.on) console.warn(`${prefix}  ⚠ ${msg}`, data ?? ''); },
        error(msg, err) { if (DEBUG.on) console.error(`${prefix}  ✖ ${msg}`, err); },
        end(extra) {
          if (!DEBUG.on) return;
          const t1 = (typeof performance !== 'undefined' ? performance.now() : Date.now());
          const ms = Math.round((t1 - t0) * 1000) / 1000;
          console.log(`${prefix} done (${ms}ms)`, extra ?? '');
        }
      };
    };
  })();

  // ============================================================
  // DOM
  // ============================================================
  const els = {
    docStatus:  document.getElementById('docStatus'),
    formMount:  document.getElementById('formMount'),
    permNote:   document.getElementById('permNote'),
    btnRegrant: document.getElementById('btnRegrant'),
  };

  function setStatus(html) { els.docStatus.innerHTML = html; }

  // ============================================================
  // Canonical single coordination layer
  // ============================================================
  function P() { return window.formSuitePersist; }
  function U() { return window.formSuiteUtils; }

  // Canonical channels (must match persistence.js)
  const BC_ACTIVE  = 'fs-active-doc';
  const BC_PAYLOAD = 'fs-payload-v1';

  // ============================================================
  // App State (in-memory)
  // ============================================================
  let currentDoc = null;       // {docId, name}
  let schema = null;
  let values = {};
  let fieldRules = [];

  // ============================================================
  // Local schema fallback (ONLY when no active doc)
  // ============================================================
  const LS_SCHEMA_FALLBACK = 'FORM_SCHEMA_V1';
  function saveLocalSchemaFallback(s) { try { localStorage.setItem(LS_SCHEMA_FALLBACK, JSON.stringify(s || {})); } catch {} }
  function loadLocalSchemaFallback()  { try { return JSON.parse(localStorage.getItem(LS_SCHEMA_FALLBACK) || 'null'); } catch { return null; } }

  // ============================================================
  // Sanitizers (canonical: from formSuiteUtils)
  // ============================================================
  function sanitizeValues(schemaObj, vals) {
    try {
      if (U()?.sanitizeValues) return U().sanitizeValues(schemaObj, vals || {});
    } catch {}
    return (vals && typeof vals === 'object') ? vals : {};
  }

  // ============================================================
  // Permission Banner (canonical via persistence)
  // ============================================================
  async function updateWriteAccessBanner({ tryPrompt = false } = {}) {
    const tr = TRACE('updateWriteAccessBanner', { tryPrompt, docId: currentDoc?.docId });
    try {
      if (!('showSaveFilePicker' in window)) { els.permNote.style.display = 'none'; tr.end('unsupported'); return 'unsupported'; }
      if (!currentDoc?.docId)               { els.permNote.style.display = 'none'; tr.end('no-doc'); return 'no-doc'; }

      const h = await P()?.getHandle?.(currentDoc.docId);
      if (!h?.queryPermission) { els.permNote.style.display = 'none'; tr.end('no-handle'); return 'no-handle'; }

      let p = await h.queryPermission({ mode: 'readwrite' });
      if (p !== 'granted' && tryPrompt) {
        try { p = await h.requestPermission({ mode: 'readwrite' }) || p; } catch {}
      }

      els.permNote.style.display = (p === 'granted') ? 'none' : 'block';
      tr.end({ perm: p });
      return p || 'denied';
    } catch (e) {
      tr.warn('failed (showing banner)', e);
      els.permNote.style.display = 'block';
      tr.end('error');
      return 'error';
    }
  }

  els.btnRegrant?.addEventListener('click', async () => {
    const tr = TRACE('btnRegrant click');
    const p = await updateWriteAccessBanner({ tryPrompt: true });
    tr.step('perm result', p);
    if (p === 'granted') await refreshFromCanonical({ reason: 'regrant' });
    tr.end();
  });

  // ============================================================
  // Canonical save (workspace only)
  // ============================================================
  let __saveTimer = null;

  function scheduleSaveValues() {
    clearTimeout(__saveTimer);
    __saveTimer = setTimeout(saveValuesNow, 150);
  }

  function saveValuesNow() {
    const tr = TRACE('saveValuesNow', { docId: currentDoc?.docId });
    try {
      if (!currentDoc?.docId) { tr.end('no-doc'); return; }
      const cleanValues = sanitizeValues(schema, values);
      values = cleanValues; // keep in-memory aligned with sanitized

      // Canonical: write ONLY to workspace state. No docx embed / no export logic here.
      P()?.saveState?.(currentDoc.docId, { values: cleanValues });

      tr.end({ keys: Object.keys(cleanValues || {}).length });
    } catch (e) {
      tr.error('failed', e);
      tr.end('error');
    }
  }

  window.addEventListener('beforeunload', () => {
    try {
      if (currentDoc?.docId) saveValuesNow();
      else if (schema) saveLocalSchemaFallback(schema);
    } catch {}
  });

  // ============================================================
  // Canonical hydration: persistence helper only
  // ============================================================
  async function hydrateWorkspaceIfEmpty(docId) {
    const tr = TRACE('hydrateWorkspaceIfEmpty', { docId });
    try {
      if (!docId) { tr.end('no-docId'); return false; }
      const did = await P()?.hydrateFromDocxIfEmpty?.(docId);
      tr.end({ didHydrate: !!did });
      return !!did;
    } catch (e) {
      tr.warn('failed', e);
      tr.end('error');
      return false;
    }
  }

  // ============================================================
  // Canonical normalization (single workflow)
  // ============================================================
  function normalizeRulesForCurrentState(st) {
    const tr = TRACE('normalizeRulesForCurrentState', {
      docId: currentDoc?.docId,
      hasSchema: !!st?.schema,
      rulesLen: Array.isArray(st?.rules) ? st.rules.length : null,
      fieldRulesLen: Array.isArray(st?.fieldRules) ? st.fieldRules.length : null,
    });

    try {
      const hasDeriver = (typeof window.deriveNormalizedRulesForDoc === 'function');
      if (!hasDeriver) { tr.end('no-deriver'); return { fieldRules: Array.isArray(st?.fieldRules) ? st.fieldRules : [] }; }

      const baseline = {
        flat: Array.isArray(st?.headingsFlat) ? st.headingsFlat : (Array.isArray(st?.headings) ? st.headings : []),
        tree: Array.isArray(st?.headingsTree) ? st.headingsTree : [],
      };

      // IMPORTANT: always pass a schema object (avoid passing null)
      const schemaForDerive = st?.schema || schema || { title: 'Form', fields: [] };

      const normalized = window.deriveNormalizedRulesForDoc(st || {}, schemaForDerive, baseline) || {};
      const nextHeadingRules = Array.isArray(normalized.headingRules)
        ? normalized.headingRules
        : (Array.isArray(st?.rules) ? st.rules : []);
      const nextFieldRules = Array.isArray(normalized.fieldRules)
        ? normalized.fieldRules
        : (Array.isArray(st?.fieldRules) ? st.fieldRules : []);

      const curHeading = Array.isArray(st?.rules) ? st.rules : [];
      const curField   = Array.isArray(st?.fieldRules) ? st.fieldRules : [];

      const same = (a,b) => { try { return JSON.stringify(a||[]) === JSON.stringify(b||[]); } catch { return false; } };

      if (currentDoc?.docId && (!same(curHeading, nextHeadingRules) || !same(curField, nextFieldRules))) {
        tr.step('persist normalized rules (replace)', {
          headingChanged: !same(curHeading, nextHeadingRules),
          fieldChanged: !same(curField, nextFieldRules),
        });
        // May be async depending on implementation; we keep fire-and-forget but safe.
        try { Promise.resolve(P()?.saveState?.(currentDoc.docId, { rules: nextHeadingRules, fieldRules: nextFieldRules })); } catch {}
      }

      tr.end({ nextFieldRulesLen: nextFieldRules.length });
      return { fieldRules: nextFieldRules };
    } catch (e) {
      tr.warn('failed', e);
      tr.end('error');
      return { fieldRules: Array.isArray(st?.fieldRules) ? st.fieldRules : [] };
    }
  }

  // ============================================================
  // Canonical refresh from workspace (override-safe)
  // ============================================================
  let __refreshLock = false;
  let __refreshPending = false;

  async function refreshFromCanonical({ reason = '' } = {}) {
    const tr = TRACE('refreshFromCanonical', { reason });

    if (__refreshLock) {
      __refreshPending = true;
      tr.end('coalesced');
      return;
    }

    __refreshLock = true;
    try {
      const meta = await P()?.getActiveDocMeta?.();
      currentDoc = (meta && meta.docId) ? meta : null;

      if (!currentDoc?.docId) {
        await hardResetOpenForm(`no active doc${reason ? ' ('+reason+')' : ''}`);
        tr.end('no-doc');
        return;
      }

      await hydrateWorkspaceIfEmpty(currentDoc.docId);

      const st = await P()?.loadState?.(currentDoc.docId);
      schema = st?.schema || null;
      values = st?.values || {};

      const norm = normalizeRulesForCurrentState(st);
      fieldRules = norm.fieldRules || [];

      setStatus(`Active DOCX: <span class="kbd">${currentDoc.name || currentDoc.docId}</span>${schema ? '' : ' — <span class="muted">no schema yet</span>'}`);

      await updateWriteAccessBanner();

      const ae = document.activeElement;
      const isEditing = !!(ae && (ae.tagName === 'INPUT' || ae.tagName === 'TEXTAREA' || ae.tagName === 'SELECT'));

      if (!isEditing) {
        renderForm();
      } else {
        try { applyFieldVisibility(); } catch {}
        try { if (typeof window.recomputeDatediffs === 'function') window.recomputeDatediffs(); } catch {}
      }

      tr.end({ isEditing, hasSchema: !!schema, valuesKeys: Object.keys(values||{}).length });
    } catch (e) {
      tr.error('failed', e);
      tr.end('error');
    } finally {
      __refreshLock = false;
      if (__refreshPending) {
        __refreshPending = false;
        refreshFromCanonical({ reason: 'pending' });
      }
    }
  }

  async function hardResetOpenForm(reason = '') {
    const tr = TRACE('hardResetOpenForm', { reason });
    schema = null;
    values = {};
    fieldRules = [];

    els.permNote.style.display = 'none';
    setStatus(`No active document${reason ? ` (${reason})` : ''}. Open one in the <a href="extractor.html">Extractor</a>.`);

    if (els.formMount) {
      els.formMount.innerHTML = `<div class="muted">No schema found. Create one in the <a href="builder.html">Builder</a>.</div>`;
    }
    tr.end();
  }

  // ============================================================
  // Canonical listeners
  // ============================================================
  function installCanonicalListeners() {
    const tr = TRACE('installCanonicalListeners');

    try {
      const bcActive = new BroadcastChannel(BC_ACTIVE);
      bcActive.addEventListener('message', (ev) => {
        const m = ev?.data || {};
        if (!m?.type) return;

        if (m.type === 'active:clear') {
          TRACE('BC_ACTIVE', m);
          refreshFromCanonical({ reason: 'active:clear' });
          return;
        }
        if ((m.type === 'active:set' || m.type === 'active:updated') && m.docId) {
          TRACE('BC_ACTIVE', m);
          refreshFromCanonical({ reason: m.type });
        }
      });
      tr.step('listening', { channel: BC_ACTIVE });
    } catch (e) {
      tr.warn('BC_ACTIVE failed', e);
    }

    try {
      const bcPayload = new BroadcastChannel(BC_PAYLOAD);
      bcPayload.addEventListener('message', (ev) => {
        const msg = ev?.data || {};
        if (msg?.t !== 'payload') return;

        const docId = msg.docId;
        if (!docId || docId !== currentDoc?.docId) return;

        const patch = msg.patch || {};
        const touches =
          ('schema' in patch) ||
          ('rules' in patch) ||
          ('fieldRules' in patch) ||
          ('values' in patch) ||
          ('tagMap' in patch);

        if (!touches) return;

        TRACE('BC_PAYLOAD', { docId, keys: Object.keys(patch || {}) });
        refreshFromCanonical({ reason: 'payload-patch' });
      });
      tr.step('listening', { channel: BC_PAYLOAD });
    } catch (e) {
      tr.warn('BC_PAYLOAD failed', e);
    }

    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible') refreshFromCanonical({ reason: 'visible' });
    });
    window.addEventListener('focus', () => refreshFromCanonical({ reason: 'focus' }));

    tr.end();
  }

  // ============================================================
  // Init
  // ============================================================
  init().catch((e) => console.error('[Form] init failed', e));

  async function init() {
    const tr = TRACE('init');

    if (!P()) {
      tr.error('persistence layer missing', new Error('window.formSuitePersist not found'));
      await hardResetOpenForm('persistence missing');
      tr.end('fatal');
      return;
    }

    installCanonicalListeners();

    currentDoc = await P()?.getActiveDocMeta?.();
    if (currentDoc?.docId) {
      await refreshFromCanonical({ reason: 'init' });
    } else {
      schema = loadLocalSchemaFallback();
      values = {};
      fieldRules = [];
      renderForm();
    }

    tr.end();
  }

  // ============================================================
  // Date helpers (datediff)
  // ============================================================
  function diffInDays(a, b) {
    const A = new Date(a.getFullYear(), a.getMonth(), a.getDate());
    const B = new Date(b.getFullYear(), b.getMonth(), b.getDate());
    return Math.floor((B - A) / (24 * 60 * 60 * 1000));
  }
  function diffInMonths(a, b) {
    let months = (b.getFullYear() - a.getFullYear()) * 12 + (b.getMonth() - a.getMonth());
    if (b.getDate() < a.getDate()) months -= 1;
    return months;
  }
  function diffInYears(a, b) {
    let years = b.getFullYear() - a.getFullYear();
    const beforeAnniversary =
      (b.getMonth() < a.getMonth()) ||
      (b.getMonth() === a.getMonth() && b.getDate() < a.getDate());
    if (beforeAnniversary) years -= 1;
    return years;
  }

  function createPrettyDatepicker(input, extraOpts = {}) {
    if (!document.getElementById('fp-zindex-fix')) {
      const st = document.createElement('style');
      st.id = 'fp-zindex-fix';
      st.textContent = `
        .flatpickr-calendar { z-index: 50; }
        .flatpickr-wrapper { position: relative; }
      `;
      document.head.appendChild(st);
    }

    const baseOpts = {
      dateFormat: 'Y-m-d',
      altInput: true,
      altFormat: 'D, j M Y',
      allowInput: false,
      clickOpens: true,
      disableMobile: true,
      static: true,
      wrap: false,
      monthSelectorType: 'dropdown',
      weekNumbers: true,
      prevArrow: '‹',
      nextArrow: '›',
      onReady: (_sel, _str, inst) => {
        if (inst.altInput) {
          inst.altInput.readOnly = true;
          inst.altInput.tabIndex = 0;
          inst.altInput.style.pointerEvents = 'auto';
          const wrap = inst.altInput.parentElement;
          if (wrap && !wrap.classList.contains('flatpickr-wrapper')) {
            wrap.classList.add('flatpickr-wrapper');
            if (getComputedStyle(wrap).position === 'static') wrap.style.position = 'relative';
          }
        }
      }
    };

    return flatpickr(input, { ...baseOpts, ...extraOpts });
  }

  function slugifyMc(s) {
    return String(s || '')
      .normalize('NFKD')
      .replace(/[\u0300-\u036f]/g, '')
      .replace(/[^a-zA-Z0-9]+/g, '_')
      .replace(/^_+|_+$/g, '')
      .toLowerCase();
  }
  function mcExtraKey(fieldId, optionValue, extraId) {
    return `${fieldId}__${slugifyMc(optionValue)}__${slugifyMc(extraId)}`;
  }

  // ============================================================
  // Field visibility (UI), using rules-core evaluateFieldRulesToVisibility
  // ============================================================
  function applyFieldVisibility() {
    const tr = TRACE('applyFieldVisibility', { hasSchema: !!schema, fields: schema?.fields?.length, rules: fieldRules?.length });
    try {
      if (!schema || !Array.isArray(schema.fields)) { tr.end('no-schema'); return; }
      if (typeof window.evaluateFieldRulesToVisibility !== 'function') { tr.end('no-evaluator'); return; }

      const visMap = window.evaluateFieldRulesToVisibility(schema, values || {}, fieldRules || []);

      const clearDisabled = (el) => {
        el.style.opacity = '';
        el.style.pointerEvents = '';
        el.removeAttribute('aria-disabled');
        el.querySelectorAll('input,select,textarea,button').forEach(i => { try { i.disabled = false; } catch {} });
      };

      document.querySelectorAll('.field[data-field-id]').forEach(node => { node.style.display = ''; clearDisabled(node); });
      document.querySelectorAll('.mc-item[data-opt-id]').forEach(node => { node.style.display = ''; clearDisabled(node); });

      const esc = (window.CSS && CSS.escape)
        ? CSS.escape
        : (s => String(s)
          .replace(/\\/g,'\\\\')
          .replace(/"/g,'\\"')
          .replace(/\]/g,'\\]')
          .replace(/\[/g,'\\[')
          .replace(/\(/g,'\\(')
          .replace(/\)/g,'\\)')
          .replace(/\./g,'\\.')
        );

      const deselectMcItem = (mcEl) => {
        const cb = mcEl.querySelector('input[type="checkbox"][data-mc="1"]');
        if (!cb) return;
        const fid = cb.name;
        const optVal = cb.value;

        if (cb.checked) cb.checked = false;
        const arr = Array.isArray(values[fid]) ? values[fid].map(String) : [];
        values[fid] = arr.filter(v => v !== String(optVal));
        scheduleSaveValues();
      };

      const deselectFieldWrapper = (wrapEl) => {
        const fid = wrapEl?.dataset?.fieldId || '';
        if (!fid) return;

        const fld = (schema?.fields || []).find(f => String(f.id) === String(fid));
        const t = String(fld?.type || '').toLowerCase();

        if (t === 'multichoice') {
          wrapEl.querySelectorAll('input[type="checkbox"][data-mc="1"]').forEach(cb => { cb.checked = false; });
          values[fid] = [];
          scheduleSaveValues();
          return;
        }

        if (t === 'select') {
          const sel = wrapEl.querySelector('select');
          if (sel) { sel.value = ''; values[fid] = ''; scheduleSaveValues(); }
          return;
        }

        if (t === 'text') {
          const inp = wrapEl.querySelector('input[type="text"]:not([data-type="date"])');
          if (inp) { inp.value = ''; values[fid] = ''; scheduleSaveValues(); }
          return;
        }

        if (t === 'number') {
          const inp = wrapEl.querySelector('input[type="number"]');
          if (inp) { inp.value = ''; values[fid] = ''; scheduleSaveValues(); }
          return;
        }

        if (t === 'date') {
          const inp = wrapEl.querySelector('input[data-type="date"]');
          if (inp) {
            try { if (inp._flatpickr) inp._flatpickr.clear(); } catch {}
            inp.value = '';
            values[fid] = '';
            scheduleSaveValues();
          }
        }
      };

      for (const id of Object.keys(visMap || {})) {
        const dir = visMap[id];

        if (typeof id === 'string' && id.includes('__opt__')) {
          document.querySelectorAll(`.mc-item[data-opt-id="${esc(id)}"]`).forEach(el => {
            deselectMcItem(el);
            if (dir === 'HIDE') {
              el.style.display = 'none';
            } else {
              el.style.display = '';
              el.style.opacity = '0.5';
              el.style.pointerEvents = 'none';
              el.setAttribute('aria-disabled', 'true');
              el.querySelectorAll('input,select,textarea,button').forEach(i => { try { i.disabled = true; } catch {} });
            }
          });
          continue;
        }

        document.querySelectorAll(`.field[data-field-id="${esc(id)}"]`).forEach(el => {
          deselectFieldWrapper(el);
          if (dir === 'HIDE') {
            el.style.display = 'none';
          } else {
            el.style.display = '';
            el.style.opacity = '0.5';
            el.style.pointerEvents = 'none';
            el.setAttribute('aria-disabled', 'true');
            el.querySelectorAll('input,select,textarea,button').forEach(i => { try { i.disabled = true; } catch {} });
          }
        });
      }

      tr.end({ visKeys: Object.keys(visMap || {}).length });
    } catch (e) {
      tr.warn('failed (UI kept resilient)', e);
      tr.end('error');
    }
  }

  // ============================================================
  // TABLE helpers
  // ============================================================
  function emptyRow(field){ const r={}; (field.columns||[]).forEach(c=>r[c.id]=''); return r; }

  // ============================================================
  // Safe option normalization (fix: avoid [object Object] in selects)
  // ============================================================
  function normOptions(field){
    const raw = (field && field.options) || [];
    return (Array.isArray(raw) ? raw : []).map(o => {
      if (o && typeof o === "object") {
        const value = (o.value ?? o.id ?? o.key ?? o.code ?? String(o));
        const label = (o.label ?? o.text ?? o.name ?? String(value));
        return { value:String(value), label:String(label) };
      }
      return { value:String(o), label:String(o) };
    });
  }

  // ============================================================
  // Render Form (behavior preserved; coordination cleaned)
  // ============================================================
  function renderForm() {
    const tr = TRACE('renderForm', { hasSchema: !!schema, fields: schema?.fields?.length, docId: currentDoc?.docId });

    (function injectMcStyles() {
      const ID = 'mc-caret-styles';
      if (document.getElementById(ID)) return;
      const s = document.createElement('style');
      s.id = ID;
      s.textContent = `
        .mc-item { position: relative; }
        .mc-toggle { all: unset; position: absolute; top: 10px; right: 10px; display: inline-flex; align-items: center; justify-content: center; cursor: pointer; line-height: 1; padding: 0; margin: 0; pointer-events: auto; }
        .mc-toggle:focus-visible { outline: 2px solid var(--focus, #2563eb); outline-offset: 2px; border-radius: 4px; }
        .mc-caret { width: 14px; height: 14px; transition: transform .18s ease, opacity .18s ease; opacity: .85; transform: rotate(0deg); display: block; }
        .mc-caret.open { transform: rotate(90deg); }
        .mc-extras { display: none; height: 0; grid-template-columns: 1fr; row-gap: 8px; padding-bottom: 2px; width: 100%; }
        .mc-option-label{ display:grid; grid-template-columns:auto 1fr; column-gap:8px; align-items:center; cursor:pointer; line-height:1.25; }
        .mc-option-label > span{ white-space:normal; word-break:break-word; }
        .mc-option-checkbox{ align-self:center; margin-top:0; transform:none; }
      `;
      document.head.appendChild(s);
    })();

    const mount = els.formMount;
    mount.innerHTML = '';

    if (!schema || !Array.isArray(schema.fields) || !schema.fields.length) {
      mount.innerHTML = `<div class="muted">No schema found. Create one in the <a href="builder.html">Builder</a>.</div>`;
      tr.end('no-schema');
      return;
    }

    // Ensure tables have correct row shape
    (schema.fields || []).forEach(f => {
      if (f.type !== 'table') return;
      if (!Array.isArray(values[f.id])) {
        const min = Math.max(0, parseInt(f.minRows || 0, 10));
        values[f.id] = Array.from({ length: min }, () => emptyRow(f));
      } else {
        values[f.id] = values[f.id].map(r => ({ ...emptyRow(f), ...(r || {}) }));
      }
    });

    const form = document.createElement('form');
    form.classList.add('form-grid');

    if (schema.title) {
      const h = document.createElement('h4');
      h.textContent = schema.title;
      h.style.gridColumn = '1 / -1';
      form.appendChild(h);
    }

    const inputRefs = {};
    const mcDateRefs = {};
    const datediffRefs = [];
    const guardPairs = [];

    function setExtrasOpen(extras, caretEl, open) {
      if (!extras) return;
      const DURATION = 220;

      if (extras._animTimer) { clearTimeout(extras._animTimer); extras._animTimer = null; }
      if (extras._onTe) { extras.removeEventListener('transitionend', extras._onTe); extras._onTe = null; }

      const onEnd = () => {
        extras.style.transition = '';
        extras.style.willChange = '';
        extras.style.opacity = open ? '1' : '0';
        extras.style.marginTop = open ? '8px' : '0px';
        extras.style.height = open ? 'auto' : '0px';
        extras.style.overflow = 'visible';
        if (!open) extras.style.display = 'none';
        if (extras._onTe) {
          extras.removeEventListener('transitionend', extras._onTe);
          extras._onTe = null;
        }
      };
      extras._onTe = onEnd;
      extras.addEventListener('transitionend', onEnd);

      if (caretEl) caretEl.classList.toggle('open', !!open);

      if (open) {
        extras.style.display = 'grid';
        extras.style.overflow = 'visible';
        extras.style.willChange = 'height, opacity, margin-top';
        extras.style.opacity = '0';
        extras.style.marginTop = '0px';
        extras.style.height = '0px';

        requestAnimationFrame(() => {
          const h = extras.scrollHeight;
          extras.classList.add('open');
          extras.style.transition = `height ${DURATION}ms ease, opacity ${DURATION}ms ease, margin-top ${DURATION}ms ease`;
          extras.style.height = h + 'px';
          extras.style.opacity = '1';
          extras.style.marginTop = '8px';
          extras._animTimer = setTimeout(onEnd, DURATION + 40);
        });
      } else {
        const current = extras.offsetHeight || extras.scrollHeight || 0;
        extras.classList.remove('open');
        extras.style.display = 'grid';
        extras.style.overflow = 'hidden';
        extras.style.willChange = 'height, opacity, margin-top';
        extras.style.transition = '';
        extras.style.height = current + 'px';
        extras.style.opacity = '1';
        extras.style.marginTop = '8px';

        requestAnimationFrame(() => {
          extras.style.transition = `height ${DURATION}ms ease, opacity ${DURATION}ms ease, margin-top ${DURATION}ms ease`;
          extras.style.height = '0px';
          extras.style.opacity = '0';
          extras.style.marginTop = '0px';
          extras._animTimer = setTimeout(onEnd, DURATION + 40);
        });
      }
    }

    function getDateForField(fid) {
      const el = inputRefs[fid];
      if (!el) return null;
      const fp = el?._flatpickr;
      if (fp?.selectedDates?.[0] instanceof Date) return fp.selectedDates[0];

      const iso = values[fid];
      if (iso) {
        const d = (window.flatpickr && window.flatpickr.parseDate)
          ? window.flatpickr.parseDate(String(iso), 'Y-m-d')
          : new Date(String(iso));
        return (d && !isNaN(d)) ? d : null;
      }
      return null;
    }

    function recomputeDatediffs() {
      datediffRefs.forEach(({ storeKey, outEl, resolve }) => {
        const { a, b } = resolve();
        if (!a || !b) {
          outEl.textContent = '—';
          values[storeKey] = null;
          return;
        }
        const days = diffInDays(a, b);
        const months = diffInMonths(a, b);
        const years = diffInYears(a, b);
        const display = `${days}D ${months}M ${years}Y (${days} Days total)`;
        outEl.textContent = display;
        values[storeKey] = { days, months, years, formatted: display };
      });
      scheduleSaveValues();
    }
    window.recomputeDatediffs = recomputeDatediffs;

    // ---- Fields ----
    (schema.fields || []).forEach(f => {
      const wrap = document.createElement('div');
      wrap.className = 'field';
      try { wrap.dataset.fieldId = String(f.id || ''); } catch {}

      if (f.type === 'address' || f.type === 'datediff') wrap.classList.add('span-2');
      if (f.type === 'table') wrap.classList.add('full', 'field--table');
      if (f.type === 'multichoice') wrap.classList.add('full', 'field--multichoice');
      if (f.wide === true) wrap.classList.add('span-2');
      if (f.full === true) wrap.classList.add('full');

      if (f.type !== 'address') {
        const label = document.createElement('label');
        label.htmlFor = f.id;
        label.textContent = f.label || f.id;
        if (f.required) {
          const star = document.createElement('span');
          star.textContent = ' *';
          star.style.color = '#ef4444';
          label.appendChild(star);
        }
        wrap.appendChild(label);
      }

      // Text
      if (f.type === 'text') {
        const input = document.createElement('input');
        input.type = 'text';
        input.id = f.id; input.name = f.id; input.style.width = '100%';
        if (f.required) input.required = true;
        if (values[f.id] != null) input.value = values[f.id];
        input.addEventListener('change', () => { values[f.id] = input.value; scheduleSaveValues(); applyFieldVisibility(); });
        wrap.appendChild(input);
        inputRefs[f.id] = input;
      }

      // Number
      else if (f.type === 'number') {
        const input = document.createElement('input');
        input.type = 'number';
        input.id = f.id; input.name = f.id; input.style.width = '100%';
        if (f.required) input.required = true;
        if (values[f.id] != null) input.value = values[f.id];
        input.addEventListener('change', () => { values[f.id] = Number(input.value); scheduleSaveValues(); applyFieldVisibility(); });
        wrap.appendChild(input);
        inputRefs[f.id] = input;
      }

      // Select (FIXED)
      else if (f.type === 'select') {
        const input = document.createElement('select');
        input.id = f.id; input.name = f.id; input.style.width = '100%';

        const opts = normOptions(f);
        // Optional empty option for better UX (keeps required enforcement via HTML if required=true)
        const empty = document.createElement('option');
        empty.value = '';
        empty.textContent = '— select —';
        input.appendChild(empty);

        opts.forEach(({value,label}) => {
          const o = document.createElement('option');
          o.value = value;
          o.textContent = label;
          input.appendChild(o);
        });

        if (f.required) input.required = true;
        if (values[f.id] != null) input.value = String(values[f.id]);
        input.addEventListener('change', () => { values[f.id] = input.value; scheduleSaveValues(); applyFieldVisibility(); });
        wrap.appendChild(input);
        inputRefs[f.id] = input;
      }

      // Date
      else if (f.type === 'date') {
        const input = document.createElement('input');
        input.type = 'text';
        input.dataset.type = 'date';
        input.id = f.id; input.name = f.id; input.style.width = '100%';
        if (f.required) input.required = true;
        wrap.appendChild(input);

        const fp = createPrettyDatepicker(input, {
          dateFormat: 'Y-m-d',
          altInput: true,
          altFormat: 'D-d-M-Y',
          allowInput: false,
          clickOpens: true,
          defaultDate: values[f.id] || null,
          onReady: (_sel, _str, inst) => { if (inst.altInput) inst.altInput.readOnly = true; },
          onChange: () => { values[f.id] = input.value; scheduleSaveValues(); recomputeDatediffs(); applyFieldVisibility(); },
          onValueUpdate: () => { values[f.id] = input.value; scheduleSaveValues(); recomputeDatediffs(); applyFieldVisibility(); }
        });
        fp.set('allowInput', false);
        if (fp.altInput) fp.altInput.readOnly = true;
        inputRefs[f.id] = input;
      }

      // Address
      else if (f.type === 'address') {
        const host = document.createElement('div');
        host.className = 'addr-host';
        wrap.appendChild(host);

        const initial =
          typeof values[f.id] === 'string'
            ? { formatted: values[f.id] }
            : (values[f.id] || null);

        AddressAuto.mount(host, {
          id: f.id,
          label: f.label || 'Address',
          required: !!f.required,
          value: initial || null,
          onChange: (val) => { values[f.id] = val; scheduleSaveValues(); }
        });
      }

      // Table
      else if (f.type === 'table') {
        renderTableField(wrap, f);
      }

      // Datediff (top level)
      else if (f.type === 'datediff') {
        const fromId = f.fromId || f.from || '';
        const toId = f.toId || f.to || '';

        const out = document.createElement('div');
        out.id = f.id;
        out.className = 'datediff-out kbd';
        out.setAttribute('role', 'status');
        out.setAttribute('aria-live', 'polite');
        out.textContent = '—';
        wrap.appendChild(out);

        datediffRefs.push({
          storeKey: f.id,
          outEl: out,
          resolve: () => ({ a: getDateForField(fromId), b: getDateForField(toId) })
        });

        guardPairs.push({ fromId, toId });
      }

      // Multichoice (unchanged from your version)
      else if (f.type === 'multichoice') {
        /* ... unchanged block ... */
        const mcContainer = document.createElement('div');
        mcContainer.className = 'mc-container';
        mcContainer.style.display = 'block';

        const items = [];
        if (f.mc && Array.isArray(f.mc.groups) && f.mc.groups.length) {
          f.mc.groups.forEach(g => (g.items || []).forEach(it => {
            items.push({
              value: String(it.value ?? it.label ?? ''),
              alwaysSelected: !!it.alwaysSelected,
              preselected: !!it.preselected,
              fields: Array.isArray(it.fields) ? it.fields : []
            });
          }));
        } else if (Array.isArray(f.options)) {
          f.options.forEach(v => {
            if (v && typeof v === 'object') {
              items.push({
                value: String(v.value ?? v.label ?? ''),
                alwaysSelected: !!v.alwaysSelected,
                preselected: !!v.preselected,
                fields: Array.isArray(v.fields) ? v.fields : []
              });
            } else {
              items.push({ value: String(v), alwaysSelected: false, preselected: false, fields: [] });
            }
          });
        }

        if (!Array.isArray(values[f.id])) {
          const initial = items.filter(it => it.alwaysSelected || it.preselected).map(it => it.value);
          if (initial.length) values[f.id] = initial.slice();
        }
        const selected = new Set(Array.isArray(values[f.id]) ? values[f.id].map(String) : []);

        function persistMainSelection() {
          const boxes = mcContainer.querySelectorAll(`input[type="checkbox"][data-mc="1"]`);
          values[f.id] = Array.from(boxes).filter(b => b.checked).map(b => b.value);
          scheduleSaveValues();
        }

        function getDateForExtraKey(key) {
          const el = mcDateRefs[key];
          const fp = el?._flatpickr;
          if (fp?.selectedDates?.[0] instanceof Date) return fp.selectedDates[0];

          const iso = values[key];
          if (iso) {
            const d = (window.flatpickr && window.flatpickr.parseDate)
              ? window.flatpickr.parseDate(String(iso), 'Y-m-d')
              : new Date(String(iso));
            return (d && !isNaN(d)) ? d : null;
          }
          return null;
        }

        function drawOption(item, parentHost) {
          const optVal = item.value;
          const optId = `${f.id}__${slugifyMc(optVal)}`;
          const hasExtras = Array.isArray(item.fields) && item.fields.length > 0;

          const card = document.createElement('div');
          card.className = 'mc-item';
          try { card.dataset.optId = `${f.id}__opt__${slugifyMc(optVal)}`; } catch {}

          card.style.position = 'relative';
          card.style.display = 'flex';
          card.style.flexDirection = 'column';
          card.style.alignItems = 'stretch';
          card.style.background = 'var(--card)';
          card.style.border = '1px solid var(--border-strong)';
          card.style.borderRadius = '8px';
          card.style.padding = '10px 10px';

          const row1 = document.createElement('div');
          row1.className = 'row';
          row1.style.alignItems = 'center';
          row1.style.gap = '8px';
          row1.style.width = '100%';

          const left = document.createElement('label');
          left.className = 'mc-option-label';
          left.setAttribute('for', optId);
          left.style.flex = '1';

          const cb = document.createElement('input');
          cb.type = 'checkbox';
          cb.dataset.mc = '1';
          cb.name = f.id;
          cb.id = optId;
          cb.value = optVal;
          cb.className = 'mc-option-checkbox';

          const locked = !!item.alwaysSelected;
          const isPreselected = !!item.preselected;
          cb.checked = locked || selected.has(optVal) || (!selected.size && isPreselected);
          if (locked) cb.disabled = true;

          const txt = document.createElement('span');
          txt.textContent = optVal;

          left.appendChild(cb);
          left.appendChild(txt);
          row1.appendChild(left);

          let extrasWrap = null;
          if (hasExtras) {
            extrasWrap = document.createElement('div');
            extrasWrap.className = 'mc-extras';
            extrasWrap.style.display = 'none';
            extrasWrap.style.height = '0px';

            const mountExtraFields = () => {
              extrasWrap.innerHTML = '';
              if (!item.fields.length) return;

              item.fields.forEach(ex => {
                const exType = String(ex?.type || 'text');
                const exId = String(ex?.id || '');
                if (!exId) return;

                const exKey = mcExtraKey(f.id, optVal, exId);

                const line = document.createElement('div');
                line.className = 'row';
                line.style.gap = '8px';
                line.style.alignItems = 'center';
                line.style.marginTop = '2px';

                const lab = document.createElement('label');
                lab.textContent = String(ex?.label || exId);
                lab.style.minWidth = '120px';
                lab.style.color = 'var(--muted)';

                if (exType === 'date') {
                  const input = document.createElement('input');
                  input.type = 'text';
                  input.dataset.type = 'date';
                  input.style.minWidth = '180px';

                  extrasWrap.appendChild(line);
                  line.appendChild(lab);
                  line.appendChild(input);

                  const fp = createPrettyDatepicker(input, {
                    dateFormat: 'Y-m-d',
                    altInput: true,
                    altFormat: 'D, j M Y',
                    defaultDate: values[exKey] || null,
                    onChange: () => { values[exKey] = input.value; scheduleSaveValues(); recomputeDatediffs(); },
                    onValueUpdate: () => { values[exKey] = input.value; scheduleSaveValues(); recomputeDatediffs(); }
                  });
                  fp.set('allowInput', false);
                  if (fp.altInput) fp.altInput.readOnly = true;

                  mcDateRefs[exKey] = input;
                  return;
                }

                if (exType === 'number') {
                  const input = document.createElement('input');
                  input.type = 'number';
                  input.value = values[exKey] ?? '';
                  input.addEventListener('change', () => { values[exKey] = Number(input.value); scheduleSaveValues(); });
                  extrasWrap.appendChild(line);
                  line.appendChild(lab);
                  line.appendChild(input);
                  return;
                }

                if (exType === 'datediff') {
                  const fromId = ex.fromId || ex.from || '';
                  const toId = ex.toId || ex.to || '';
                  const fromKey = mcExtraKey(f.id, optVal, fromId);
                  const toKey = mcExtraKey(f.id, optVal, toId);

                  const out = document.createElement('div');
                  out.className = 'datediff-out kbd';
                  out.setAttribute('role', 'status');
                  out.setAttribute('aria-live', 'polite');
                  out.textContent = '—';

                  extrasWrap.appendChild(line);
                  line.appendChild(lab);
                  line.appendChild(out);

                  datediffRefs.push({
                    storeKey: exKey,
                    outEl: out,
                    resolve: () => ({ a: getDateForExtraKey(fromKey), b: getDateForExtraKey(toKey) })
                  });
                  return;
                }

                const input = document.createElement('input');
                input.type = 'text';
                input.value = values[exKey] ?? '';
                input.addEventListener('change', () => { values[exKey] = input.value; scheduleSaveValues(); });
                extrasWrap.appendChild(line);
                line.appendChild(lab);
                line.appendChild(input);
              });
            };

            mountExtraFields();
          }

          if (hasExtras) {
            const caretBtn = document.createElement('button');
            caretBtn.type = 'button';
            caretBtn.className = 'mc-toggle';
            caretBtn.setAttribute('aria-expanded', 'false');
            caretBtn.setAttribute('aria-label', 'Details ein-/ausklappen');

            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('viewBox', '0 0 24 24');
            svg.setAttribute('width', '14');
            svg.setAttribute('height', '14');
            svg.classList.add('mc-caret');

            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', 'M9 18l6-6-6-6');
            path.setAttribute('fill', 'none');
            path.setAttribute('stroke', 'currentColor');
            path.setAttribute('stroke-width', '2');
            path.setAttribute('stroke-linecap', 'round');
            path.setAttribute('stroke-linejoin', 'round');
            svg.appendChild(path);

            caretBtn.appendChild(svg);
            row1.appendChild(caretBtn);

            setExtrasOpen(extrasWrap, svg, false);

            caretBtn.addEventListener('click', (e) => {
              e.preventDefault();
              const willOpen = !extrasWrap.classList.contains('open');
              caretBtn.setAttribute('aria-expanded', String(willOpen));
              setExtrasOpen(extrasWrap, svg, willOpen);
            });
          }

          cb.addEventListener('change', () => {
            if (locked) { cb.checked = true; return; }
            persistMainSelection();
            applyFieldVisibility();
          });

          card.appendChild(row1);
          if (extrasWrap) card.appendChild(extrasWrap);
          parentHost.appendChild(card);
        }

        if (f.mc && Array.isArray(f.mc.groups) && f.mc.groups.length) {
          f.mc.groups.forEach(g => {
            const section = document.createElement('div');
            section.className = 'mc-group-section';
            section.style.marginBottom = '10px';

            if (g.title) {
              const h = document.createElement('div');
              h.className = 'mc-group-title';
              h.textContent = String(g.title);
              h.style.color = 'var(--muted)';
              h.style.fontWeight = '600';
              h.style.fontSize = '.95rem';
              h.style.margin = '4px 0 6px';
              section.appendChild(h);
            }

            const host = document.createElement('div');
            host.className = 'mc-group';
            host.style.display = 'grid';
            host.style.gridTemplateColumns = 'repeat(auto-fill,minmax(260px,1fr))';
            host.style.gap = '8px 16px';
            host.style.alignItems = 'start';

            if (Number.isFinite(+f.columns) && +f.columns > 0) {
              host.style.gridTemplateColumns = `repeat(${+f.columns}, minmax(220px, 1fr))`;
            }

            (g.items || []).forEach(it => drawOption({
              value: String(it.value ?? it.label ?? ''),
              alwaysSelected: !!it.alwaysSelected,
              preselected: !!it.preselected,
              fields: Array.isArray(it.fields) ? it.fields : []
            }, host));

            section.appendChild(host);
            mcContainer.appendChild(section);
          });
        } else {
          const host = document.createElement('div');
          host.className = 'mc-group';
          host.style.display = 'grid';
          host.style.gridTemplateColumns = 'repeat(auto-fill,minmax(260px,1fr))';
          host.style.gap = '8px 16px';
          host.style.alignItems = 'start';

          if (Number.isFinite(+f.columns) && +f.columns > 0) {
            host.style.gridTemplateColumns = `repeat(${+f.columns}, minmax(220px, 1fr))`;
          }

          items.forEach(it => drawOption(it, host));
          mcContainer.appendChild(host);
        }

        values[f.id] = Array.from(mcContainer.querySelectorAll(`input[type="checkbox"][data-mc="1"]`))
          .filter(b => b.checked)
          .map(b => b.value);
        scheduleSaveValues();

        wrap.appendChild(mcContainer);
      }

      // Fallback
      else {
        const input = document.createElement('input');
        input.type = 'text';
        input.id = f.id; input.name = f.id; input.style.width = '100%';
        if (values[f.id] != null) input.value = values[f.id];
        input.addEventListener('change', () => { values[f.id] = input.value; scheduleSaveValues(); });
        wrap.appendChild(input);
        inputRefs[f.id] = input;
      }

      form.appendChild(wrap);
    });

    form.addEventListener('change', () => applyFieldVisibility());
    mount.appendChild(form);

    (function wireTopLevelDateGuards() {
      function nextDay(d) {
        if (!d) return null;
        const n = new Date(d.getFullYear(), d.getMonth(), d.getDate());
        n.setDate(n.getDate() + 1);
        return n;
      }

      guardPairs.forEach(({ fromId, toId }) => {
        const fromEl = inputRefs[fromId];
        const toEl = inputRefs[toId];
        const fpFrom = fromEl?._flatpickr;
        const fpTo = toEl?._flatpickr;
        if (!fpFrom || !fpTo) return;

        fpFrom.set('allowInput', false);
        fpTo.set('allowInput', false);
        if (fpFrom.altInput) fpFrom.altInput.readOnly = true;
        if (fpTo.altInput) fpTo.altInput.readOnly = true;

        const syncToWithFrom = (opts = { snap: true, jump: true }) => {
          const from = fpFrom.selectedDates?.[0] || null;
          const minForTo = nextDay(from);
          fpTo.set('minDate', minForTo || null);

          const toSel = fpTo.selectedDates?.[0] || null;
          if (!toSel && minForTo && opts.snap) fpTo.setDate(minForTo, true);
          if (from && toSel && toSel <= from && opts.snap) fpTo.setDate(minForTo, true);
          if (minForTo && opts.jump) { try { fpTo.jumpToDate(minForTo); } catch {} }

          recomputeDatediffs();
        };

        syncToWithFrom({ snap: true, jump: false });
        fpFrom.config.onChange.push(() => syncToWithFrom({ snap: true, jump: true }));
        fpFrom.config.onValueUpdate.push(() => syncToWithFrom({ snap: true, jump: true }));
        fpTo.config.onOpen.push(() => syncToWithFrom({ snap: false, jump: true }));

        const recompute = () => recomputeDatediffs();
        fpTo.config.onChange.push(recompute);
        fpTo.config.onValueUpdate.push(recompute);
      });
    })();

    recomputeDatediffs();
    applyFieldVisibility();

    tr.end();
  }

  // ============================================================
  // TABLE FIELD (behavior preserved)
  // ============================================================
// ============================================================
// TABLE FIELD (FIXED: write-through to values + autosave)
// ============================================================
function renderTableField(container, field) {
  // Canonical backing array
  if (!Array.isArray(values[field.id])) values[field.id] = [];
  const data = values[field.id];

  const editorWrap = document.createElement('div');
  editorWrap.style.display = 'flex';
  editorWrap.style.flexWrap = 'wrap';
  editorWrap.style.gap = '10px';

  const editorInputs = {};
  let editorState = emptyRow(field);

  const measurer = document.createElement('canvas').getContext('2d');
  function textPx(str) {
    try { measurer.font = getComputedStyle(document.body).font; } catch {}
    return Math.ceil(measurer.measureText(String(str || '')).width);
  }
  function longest(arr) {
    return arr.reduce((a, b) => (String(b).length > String(a).length ? String(b) : String(a)), '');
  }

  function rowIsEmpty(row) {
    return !(field.columns || []).some(c => String(row?.[c.id] ?? '').trim() !== '');
  }

  // Selected row index in the *data* array
  let selectedIndex = -1;

  // Ensure minRows exist (but keep them empty until user fills them)
  const minRows = Math.max(0, parseInt(field.minRows || 0, 10));
  if (data.length < minRows) {
    for (let i = data.length; i < minRows; i++) data.push(emptyRow(field));
  }

  // --- UI: per-column editor inputs ---
  (field.columns || []).forEach(col => {
    const pair = document.createElement('label');
    pair.style.display = 'flex';
    pair.style.alignItems = 'center';
    pair.style.gap = '8px';

    const lbl = document.createElement('span');
    lbl.textContent = col.label || col.id;

    let el;
    if (col.type === 'select') {
      el = document.createElement('select');
      const opts = (col.options || []);
      const empty = document.createElement('option');
      empty.value = '';
      empty.textContent = '— wählen —';
      el.appendChild(empty);
      opts.forEach(opt => {
        const o = document.createElement('option');
        o.value = String(opt);
        o.textContent = String(opt);
        el.appendChild(o);
      });
      el.style.minWidth = Math.max(140, Math.min(360, textPx(longest(opts)) + 56)) + 'px';
    } else if (col.type === 'date') {
      el = document.createElement('input');
      el.type = 'text';
      el.style.minWidth = Math.max(140, Math.min(360, textPx('YYYY-MM-DD') + 20)) + 'px';
      setTimeout(() => {
        flatpickr(el, {
          allowInput: true,
          dateFormat: 'Y-m-d',
          onChange: () => onEditorInput(col.id, el.value),
          onValueUpdate: () => onEditorInput(col.id, el.value),
        });
      }, 0);
    } else if (col.type === 'number') {
      el = document.createElement('input');
      el.type = 'number';
      el.style.minWidth = Math.max(120, Math.min(360, textPx('000000') + 20)) + 'px';
    } else {
      el = document.createElement('input');
      el.type = 'text';
      el.style.minWidth = Math.max(160, Math.min(360, textPx(lbl.textContent) + 20)) + 'px';
    }

    // KEY FIX: use input+change and write-through
    const onAny = () => onEditorInput(col.id, el.value);
    el.addEventListener('input', onAny);
    el.addEventListener('change', onAny);

    editorInputs[col.id] = el;
    pair.appendChild(lbl);
    pair.appendChild(el);
    editorWrap.appendChild(pair);
  });

  function onEditorInput(colId, value) {
    editorState[colId] = value;

    // If editing an existing row, write-through immediately
    if (selectedIndex >= 0 && selectedIndex < data.length) {
      data[selectedIndex] = { ...data[selectedIndex], ...editorState };
      scheduleSaveValues();
      drawTable(); // keep preview row in sync
    }
  }

  // --- Toolbar ---
  const toolbar = document.createElement('div');
  toolbar.className = 'row';
  toolbar.style.gap = '8px';

  const btnAdd = document.createElement('button');
  btnAdd.type = 'button';
  btnAdd.textContent = 'Zeile hinzufügen';

  const btnSave = document.createElement('button');
  btnSave.type = 'button';
  btnSave.className = 'secondary';
  btnSave.textContent = 'Änderungen speichern';

  const btnDelete = document.createElement('button');
  btnDelete.type = 'button';
  btnDelete.className = 'ghost';
  btnDelete.textContent = 'Zeile löschen';

  const btnCancel = document.createElement('button');
  btnCancel.type = 'button';
  btnCancel.className = 'ghost';
  btnCancel.textContent = 'Abbrechen';

  toolbar.appendChild(btnAdd);
  toolbar.appendChild(btnSave);
  toolbar.appendChild(btnDelete);
  toolbar.appendChild(btnCancel);

  const status = document.createElement('div');
  status.className = 'muted';
  status.style.minHeight = '1.2em';

  // --- Table preview ---
  const tableWrap = document.createElement('div');
  tableWrap.style.overflow = 'auto';

  const table = document.createElement('table');
  table.style.width = '100%';

  const thead = document.createElement('thead');
  const trh = document.createElement('tr');
  thead.appendChild(trh);

  const tbody = document.createElement('tbody');

  table.appendChild(thead);
  table.appendChild(tbody);
  tableWrap.appendChild(table);

  (field.columns || []).forEach(col => {
    const th = document.createElement('th');
    th.textContent = col.label || col.id;
    trh.appendChild(th);
  });

  function applyPreviewVisibility() {
    const hasAnyNonEmpty = data.some(r => !rowIsEmpty(r));
    tableWrap.style.display = hasAnyNonEmpty ? '' : 'none';
  }

  function updateToolbar() {
    const min = Math.max(0, parseInt(field.minRows || 0, 10));
    const max = Math.max(0, parseInt(field.maxRows || 0, 10));

    btnAdd.disabled = (max && data.length >= max);

    const showEdit = selectedIndex >= 0;
    btnSave.style.display = showEdit ? '' : 'none';
    btnDelete.style.display = showEdit ? '' : 'none';
    btnCancel.style.display = showEdit ? '' : 'none';

    btnDelete.disabled = !showEdit || (min && data.length <= min);
  }

  function loadIntoEditor(i) {
    const rec = data[i] || emptyRow(field);
    (field.columns || []).forEach(c => {
      const el = editorInputs[c.id];
      if (!el) return;
      el.value = rec[c.id] || '';
    });
    editorState = { ...rec };
    updateToolbar();
  }

  function resetEditor() {
    editorState = emptyRow(field);
    (field.columns || []).forEach(c => {
      const el = editorInputs[c.id];
      if (el) el.value = '';
    });
  }

  function clearSelection() {
    selectedIndex = -1;
    updateToolbar();
  }

  function drawTable() {
    tbody.innerHTML = '';

    data.forEach((row, realIdx) => {
      if (rowIsEmpty(row)) return;

      const tr = document.createElement('tr');
      const isSel = realIdx === selectedIndex;

      if (isSel) {
        tr.style.background = '#DBEAFE';
        tr.style.outline = '2px solid #93C5FD';
        tr.style.outlineOffset = '-2px';
      }

      tr.addEventListener('click', () => {
        selectedIndex = realIdx;
        loadIntoEditor(realIdx);
        drawTable();
      });

      (field.columns || []).forEach(col => {
        const td = document.createElement('td');
        td.textContent = row[col.id] || '';
        tr.appendChild(td);
      });

      tbody.appendChild(tr);
    });

    applyPreviewVisibility();
    updateToolbar();
  }

  // --- Actions ---
  btnAdd.addEventListener('click', () => {
    const max = Math.max(0, parseInt(field.maxRows || 0, 10));
    if (max && data.length >= max) return;

    // Add a cloned row from current editorState
    data.push({ ...editorState });
    scheduleSaveValues();

    // Prepare for next entry
    clearSelection();
    resetEditor();
    drawTable();

    status.textContent = 'Zeile hinzugefügt.';
  });

  btnSave.addEventListener('click', () => {
    if (selectedIndex < 0 || selectedIndex >= data.length) return;
    data[selectedIndex] = { ...editorState };
    scheduleSaveValues();
    drawTable();
    status.textContent = 'Änderungen gespeichert.';
  });

  btnDelete.addEventListener('click', () => {
    const min = Math.max(0, parseInt(field.minRows || 0, 10));
    if (selectedIndex < 0) return;
    if (min && data.length <= min) return;

    data.splice(selectedIndex, 1);
    scheduleSaveValues();

    clearSelection();
    resetEditor();
    drawTable();

    status.textContent = 'Zeile gelöscht.';
  });

  btnCancel.addEventListener('click', () => {
    clearSelection();
    resetEditor();
    drawTable();
    status.textContent = 'Auswahl aufgehoben.';
  });

  // Mount
  container.appendChild(editorWrap);
  container.appendChild(toolbar);
  container.appendChild(status);
  container.appendChild(tableWrap);

  drawTable();
  applyPreviewVisibility();
}

  // ============================================================
  // Expose for cross-callbacks
  // ============================================================
  try { window.applyFieldVisibility = applyFieldVisibility; } catch {}

  // Keep existing behavior
  installLogoFocusNav();
  </script>
</body>
</html>
