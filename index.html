<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Form Suite — Form</title>
  <link rel="icon" href="favicon.ico" type="image/gif" sizes="32x32">
  <link rel="shortcut icon" href="favicon.ico" type="image/gif">
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/themes/material_blue.css">
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <header>
    <div class="row">
      <span class="brand logo-md">
        <img src="logo.gif" alt="Form Suite logo" class="logo" />
        <strong>Form Suite</strong>
      </span>
      <span class="muted">·</span><span class="muted">Form</span>
      <span class="muted">·</span><a href="builder.html">Form Builder</a>
      <span class="muted">·</span><a href="matcher.html">Tag Matcher</a>
      <span class="muted">·</span><a href="rules.html">Rules</a>
      <span class="muted">·</span><a href="extractor.html">Extractor</a>
    </div>
  </header>

  <main>
    <section class="panel">
      <div class="title-row"></div>
      <div class="row" style="margin-top:8px;">
        <span id="docStatus" class="muted">No active document. Open one in the <a href="extractor.html">Extractor</a>.</span>
      </div>
      <div id="permNote" class="note warn" style="display:none; margin-top:10px">
        This DOCX was opened via picker but I don’t have write permission to the original file.
        Exports will download a copy instead of writing back.
        <button id="btnRegrant" class="ghost" style="margin-left:8px">Grant write access</button>
      </div>
    </section>

    <section class="panel">
      <div id="formMount"></div>
    </section>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <script src="persistence.js"></script>
  <script src="address-autocomplete.js"></script>
  <script>
    const STORAGE_KEY = 'FORM_SCHEMA_V1';
    const PAYLOAD_KEY = 'CRONOS_PAYLOAD';
    const supportsFS = 'showSaveFilePicker' in window;

    const els = {
      docStatus: document.getElementById('docStatus'),
      formMount: document.getElementById('formMount'),
      permNote:  document.getElementById('permNote'),
      btnRegrant:document.getElementById('btnRegrant'),
    };

    let currentDoc = null, schema = null, values = {}, fieldRules = [];
    let btnExportMain = null;

    // ---------- Status + Hard Reset ----------
    function setStatus(s) { els.docStatus.innerHTML = s; }
    async function hardResetOpenForm(reason = '') {
      try {} catch {}
      schema = null;
      values = {};
      if (els.formMount) els.formMount.innerHTML = `<div class="muted">No schema found. Create one in the <a href="builder.html">Builder</a>.</div>`;
      if (btnExportMain) btnExportMain.disabled = true;
      els.permNote.style.display = 'none';
      if (reason) setStatus(`No active document (${reason}). Open one in the <a href="extractor.html">Extractor</a>.`);
      else setStatus(`No active document. Open one in the <a href="extractor.html">Extractor</a>.`);
    }

    // ---------- One Active-Doc Signal (canonical) ----------
    const ACTIVE_DOC_KEY = 'FS_ACTIVE_DOC_META'; // unified key across the app

    function readActiveDocSync() {
      // Prefer live persistence info in this tab
      const p = window.formSuitePersist?.getCurrentDocMeta?.()
             || window.formSuitePersist?.getActiveDoc?.sync?.();
      if (p?.docId) {
        const meta = { docId: p.docId, name: p.name || p.docTitle || 'document' };
        try { localStorage.setItem(ACTIVE_DOC_KEY, JSON.stringify(meta)); } catch {}
        return meta;
      }
      // Canonical LS
      try { const v = localStorage.getItem(ACTIVE_DOC_KEY); if (v) return JSON.parse(v); } catch {}
      // Legacy migration (older Extractor)
      try {
        const legacy = localStorage.getItem('FS_CURRENT_DOC_META');
        if (legacy) {
          const m = JSON.parse(legacy);
          if (m?.docId) {
            localStorage.setItem(ACTIVE_DOC_KEY, legacy);
            return m;
          }
        }
      } catch {}
      return null;
    }

    function installActiveDocListener(onChange) {
      const bcLegacy = ('BroadcastChannel' in window) ? new BroadcastChannel('form-suite-doc') : null;
      const bcCanon  = ('BroadcastChannel' in window) ? new BroadcastChannel('fs-active-doc') : null;

      function emit(meta) {
        if (meta?.docId) {
          try { localStorage.setItem(ACTIVE_DOC_KEY, JSON.stringify({ docId: meta.docId, name: meta.name })); } catch {}
        } else {
          try { localStorage.removeItem(ACTIVE_DOC_KEY); } catch {}
        }
        onChange(meta || null);
      }

      bcLegacy?.addEventListener('message', (ev) => {
        const m = ev?.data || {};
        if (m.type === 'doc-cleared') { emit(null); return; }
        if (m.type === 'doc-switched' || m.type === 'doc-updated') {
          emit((m.docId) ? { docId: m.docId, name: m.name } : readActiveDocSync());
        }
        if (m.type === 'schema-updated') {
          const meta = readActiveDocSync();
          if (meta?.docId && (!m.docId || m.docId === meta.docId)) emit(meta);
        }
      });

      bcCanon?.addEventListener('message', (ev) => {
        const m = ev?.data || {};
        if (m.type === 'active:set')   emit({ docId: m.docId, name: m.name });
        if (m.type === 'active:clear') emit(null);
        if (m.type === 'active:updated') {
          const meta = readActiveDocSync();
          if (meta?.docId) emit(meta);
        }
      });

      window.addEventListener('storage', (e) => {
        if (e.key === ACTIVE_DOC_KEY) {
          const v = e.newValue ? JSON.parse(e.newValue) : null;
          emit(v);
        }
        if (e.key === 'FS_CURRENT_DOC_META' && !localStorage.getItem(ACTIVE_DOC_KEY)) {
          const v = e.newValue ? JSON.parse(e.newValue) : null;
          if (v?.docId) {
            try { localStorage.setItem(ACTIVE_DOC_KEY, e.newValue); } catch {}
            emit(v);
          }
        }
      });
    }

    installActiveDocListener(async (meta) => {
      currentDoc = meta;
      if (!currentDoc?.docId) { await hardResetOpenForm('cleared'); return; }
      const st = await window.formSuitePersist.loadState?.(currentDoc.docId);
      schema = st?.schema || null;
      values = st?.values || {};
      fieldRules = Array.isArray(st?.fieldRules) ? st.fieldRules : [];
      if (!schema) {
        // Attempt one-time hydration from DOCX payload so Form loads without visiting Extractor
        await hydrateWorkspaceFromDocxIfEmpty();
      }
      setStatus(`Active DOCX: <span class="kbd">${currentDoc.name}</span>${schema ? '' : ' — <span class="muted">no schema yet</span>'}`);
      renderForm();
      await updateWriteAccessBanner();
    });

    // ---------- Foreground refresh (coalesced) ----------
    let __refreshLock = false;
    let __refreshPending = false;

    async function ensureActiveDocOrReset() {
      if (__refreshLock) { __refreshPending = true; return; }
      __refreshLock = true;
      try {
        currentDoc = readActiveDocSync() || currentDoc;
        if (!currentDoc?.docId) { await hardResetOpenForm('no active doc'); return; }

        const st = await window.formSuitePersist.loadState?.(currentDoc.docId);
        schema = st?.schema || null;
        values = st?.values || {};
        fieldRules = Array.isArray(st?.fieldRules) ? st.fieldRules : [];
        if (!schema) {
          await hydrateWorkspaceFromDocxIfEmpty();
        }
        setStatus(`Active DOCX: <span class="kbd">${currentDoc.name}</span>${schema ? '' : ' — <span class="muted">no schema yet</span>'}`);
        renderForm();
        await updateWriteAccessBanner();
      } catch (e) {
        console.warn('ensureActiveDocOrReset failed:', e);
      } finally {
        __refreshLock = false;
        if (__refreshPending) { __refreshPending = false; ensureActiveDocOrReset(); }
      }
    }

    document.addEventListener('visibilitychange', async () => {
      if (document.visibilityState !== 'visible') return;
      await ensureActiveDocOrReset();
    });
    window.addEventListener('focus', async () => { await ensureActiveDocOrReset(); });

    // ---------- Permission banner ----------
    async function updateWriteAccessBanner({ tryPrompt = false } = {}) {
      try {
        if (!supportsFS || !currentDoc?.docId) { els.permNote.style.display = 'none'; return 'unsupported'; }
        const h = await window.formSuitePersist.getHandle?.(currentDoc.docId);
        if (!h?.queryPermission) { els.permNote.style.display = 'none'; return 'no-handle'; }

        let p = await h.queryPermission({ mode: 'readwrite' });
        if (p !== 'granted' && tryPrompt) {
          try { p = await h.requestPermission({ mode: 'readwrite' }) || p; } catch {}
        }
        els.permNote.style.display = (p === 'granted') ? 'none' : 'block';
        return p || 'denied';
      } catch (e) {
        console.warn('updateWriteAccessBanner failed:', e);
        els.permNote.style.display = 'block';
        return 'error';
      }
    }
    els.btnRegrant?.addEventListener('click', async () => {
      const p = await updateWriteAccessBanner({ tryPrompt: true });
      if (p === 'granted') {
        await ensureActiveDocOrReset();
      }
    });

    // ---------- Pyodide (robust) ----------
    let pyLoaded = false;
    let py = null;

    async function ensurePy(forceReinit = false) {
      if (forceReinit && py && py._module) { pyLoaded = false; py = null; }
      if (!pyLoaded) {
        await new Promise((res, rej) => {
          if (window.loadPyodide) return res();
          const s = document.createElement('script');
          s.src = "https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js";
          s.onload = res; s.onerror = rej; document.head.appendChild(s);
        });
        py = await loadPyodide({ indexURL: "https://cdn.jsdelivr.net/pyodide/v0.24.1/full/" });

        await py.runPythonAsync(`
import io, zipfile, json
import xml.etree.ElementTree as ET

_W_NS = "http://schemas.openxmlformats.org/wordprocessingml/2006/main"
def _q(local): return "{%s}%s" % (_W_NS, local)

# ---------------------- existing functions ----------------------
def write_docvar(u8, var_name, value):
    data = bytes(u8); outbuf = io.BytesIO()
    with zipfile.ZipFile(io.BytesIO(data), "r") as zfin, zipfile.ZipFile(outbuf,"w",compression=zipfile.ZIP_DEFLATED) as zfout:
        try: names = set(zfin.namelist())
        except: names = set()
        if "word/settings.xml" in names:
            try: root = ET.fromstring(zfin.read("word/settings.xml"))
            except ET.ParseError: root = ET.Element(_q("settings"))
        else:
            root = ET.Element(_q("settings"))
        doc_vars = root.find(_q("docVars"))
        if doc_vars is None:
            doc_vars = ET.SubElement(root, _q("docVars"))
        target = None
        for dv in doc_vars.findall(_q("docVar")):
            if dv.get(_q("name")) == var_name:
                target = dv; break
        if target is None:
            target = ET.SubElement(doc_vars, _q("docVar"), {_q("name"): var_name, _q("val"): value})
        else:
            target.set(_q("val"), value)
        settings_bytes = ET.tostring(root, encoding="utf-8", xml_declaration=True)
        for n in zfin.namelist():
            if n == "word/settings.xml": continue
            zfout.writestr(n, zfin.read(n))
        zfout.writestr("word/settings.xml", settings_bytes)
    return outbuf.getvalue()

def read_docvar_settings(u8, var_name):
    data = bytes(u8)
    with zipfile.ZipFile(io.BytesIO(data), "r") as zf:
        try:
            xml = zf.read("word/settings.xml")
        except KeyError:
            return None
        try:
            root = ET.fromstring(xml)
        except ET.ParseError:
            return None
        W_NS = "http://schemas.openxmlformats.org/wordprocessingml/2006/main"
        def _q(local):
            return "{%s}%s" % (W_NS, local)
        doc_vars = root.find(_q("docVars"))
        if doc_vars is None:
            return None
        for dv in doc_vars.findall(_q("docVar")):
            if dv.get(_q("name")) == var_name:
                return dv.get(_q("val"))
    return None

def read_docvar_custom(u8, var_name):
    # Try docProps/custom.xml docVars fallback
    data = bytes(u8)
    name = str(var_name or "")
    with zipfile.ZipFile(io.BytesIO(data), "r") as zf:
        try:
            xml = zf.read("docProps/custom.xml")
        except KeyError:
            return None
        try:
            root = ET.fromstring(xml)
        except ET.ParseError:
            return None
        # Namespaces for custom properties
        ns = {
            'cp': 'http://schemas.openxmlformats.org/officeDocument/2006/custom-properties',
            'vt': 'http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes'
        }
        for prop in root.findall('cp:property', ns):
            if prop.get('name') == name:
                # value could be vt:lpwstr or other types
                for child in list(prop):
                    if child.text is not None:
                        return child.text
    return None

def _set_sdt_text(content_el, value):
    texts = content_el.findall(".//w:t", {"w": _W_NS})
    if texts:
        first = True
        for t in texts:
            if first:
                t.text = value
                first = False
            else:
                t.text = ""
        return
    has_block = (content_el.find(".//w:p", {"w": _W_NS}) is not None) or (content_el.find(".//w:tbl", {"w": _W_NS}) is not None)
    for ch in list(content_el): content_el.remove(ch)
    if has_block:
        p = ET.SubElement(content_el, _q("p")); r = ET.SubElement(p, _q("r"))
    else:
        r = ET.SubElement(content_el, _q("r"))
    t = ET.SubElement(r, _q("t")); t.text = value
    if (value.strip() != value) or ("\\n" in value) or ("  " in value):
        t.set("{http://www.w3.org/XML/1998/namespace}space", "preserve")

def write_sdts_by_tag(u8, tag_to_text_json):
    try: mapping = json.loads(tag_to_text_json or "{}")
    except Exception: mapping = {}
    if not mapping: return u8
    data = bytes(u8); outbuf = io.BytesIO()
    with zipfile.ZipFile(io.BytesIO(data), "r") as zfin, zipfile.ZipFile(outbuf,"w",compression=zipfile.ZIP_DEFLATED) as zfout:
        names = zfin.namelist()
        def is_target(name):
            if not (name.startswith("word/") and name.endswith(".xml")): return False
            skip = {"word/styles.xml","word/numbering.xml","word/theme/theme1.xml","word/fontTable.xml","word/settings.xml","word/webSettings.xml"}
            return name not in skip and not name.startswith("word/_rels/")
        for n in names:
            if not is_target(n):
                zfout.writestr(n, zfin.read(n)); continue
            try:
                root = ET.fromstring(zfin.read(n))
            except ET.ParseError:
                zfout.writestr(n, zfin.read(n)); continue
            changed = False
            for sdt in root.findall(".//w:sdt", {"w": _W_NS}):
                pr = sdt.find("w:sdtPr", {"w": _W_NS})
                if pr is None: continue
                tag_el = pr.find("w:tag", {"w": _W_NS})
                tag_val = tag_el.get(_q("val")) if tag_el is not None else ""
                if not tag_val or tag_val not in mapping: continue
                content_el = sdt.find("w:sdtContent", {"w": _W_NS}) or sdt
                val = mapping.get(tag_val, "")
                if not isinstance(val, str):
                    try: val = json.dumps(val, ensure_ascii=False)
                    except Exception: val = str(val)
                _set_sdt_text(content_el, val); changed = True
            out_xml = ET.tostring(root, encoding="utf-8", xml_declaration=True) if changed else zfin.read(n)
            zfout.writestr(n, out_xml)
    return outbuf.getvalue()

# ---------------------- NEW: visibility tooling ----------------------
def _ensure_fsHidden_style(zfin, zfout, names):
    if "word/styles.xml" in names:
        try: root = ET.fromstring(zfin.read("word/styles.xml"))
        except ET.ParseError: root = ET.Element(_q("styles"))
    else:
        root = ET.Element(_q("styles"))
    have = False
    for st in root.findall(_q("style")):
        if st.get(_q("type")) == "character" and st.get(_q("styleId")) == "fsHidden":
            have = True; break
    if not have:
        st = ET.Element(_q("style"), {_q("type"): "character", _q("styleId"): "fsHidden"})
        ET.SubElement(st, _q("name"), {_q("val"): "fsHidden"})
        rpr = ET.SubElement(st, _q("rPr"))
        ET.SubElement(rpr, _q("vanish"))
        root.append(st)
    zfout.writestr("word/styles.xml", ET.tostring(root, encoding="utf-8", xml_declaration=True))

def _heading_level(p_el):
    ppr = p_el.find(_q("pPr"))
    if ppr is not None:
        ol = ppr.find(_q("outlineLvl"))
        if ol is not None and ol.get(_q("val")) is not None:
            try: return int(ol.get(_q("val"))) + 1
            except: pass
        ps = ppr.find(_q("pStyle"))
        if ps is not None and ps.get(_q("val")):
            v = ps.get(_q("val")).lower()
            if v.startswith("heading"):
                try: return int(v.replace("heading","").strip())
                except: return None
    return None

def _apply_rStyle_hidden_to_runs(el):
    for r in el.findall(".//w:r", {"w": _W_NS}):
        rpr = r.find(_q("rPr"))
        if rpr is None:
            rpr = ET.SubElement(r, _q("rPr"))
        has = False
        for rs in rpr.findall(_q("rStyle")):
            if rs.get(_q("val")) == "fsHidden":
                has = True; break
        if not has:
            ET.SubElement(rpr, _q("rStyle"), {_q("val"): "fsHidden"})

def _clear_table_hidden_markers(tbl_el):
    tbl_pr = tbl_el.find(_q("tblPr"))
    if tbl_pr is not None:
        for node in list(tbl_pr.findall(_q("hidden"))):
            tbl_pr.remove(node)
    for tr in tbl_el.findall(".//w:tr", {"w": _W_NS}):
        tr_pr = tr.find(_q("trPr"))
        if tr_pr is None:
            continue
        for node in list(tr_pr.findall(_q("hidden"))):
            tr_pr.remove(node)

def _mark_table_hidden(tbl_el):
    tbl_pr = tbl_el.find(_q("tblPr"))
    if tbl_pr is None:
        tbl_pr = ET.SubElement(tbl_el, _q("tblPr"))
    hidden = tbl_pr.find(_q("hidden"))
    if hidden is None:
        ET.SubElement(tbl_pr, _q("hidden"), {_q("val"): "true"})
    else:
        hidden.set(_q("val"), "true")
    for tr in tbl_el.findall(".//w:tr", {"w": _W_NS}):
        tr_pr = tr.find(_q("trPr"))
        if tr_pr is None:
            tr_pr = ET.SubElement(tr, _q("trPr"))
        hidden = tr_pr.find(_q("hidden"))
        if hidden is None:
            ET.SubElement(tr_pr, _q("hidden"), {_q("val"): "true"})
        else:
            hidden.set(_q("val"), "true")

def _iter_blocks_within(container, top_level):
    for node in list(container):
        if node.tag == _q("sdt"):
            inner = node.find(_q("sdtContent"))
            if inner is not None:
                yield from _iter_blocks_within(inner, top_level)
            else:
                yield {"element": node, "type": "other", "level": None, "top": top_level}
        elif node.tag == _q("p"):
            yield {"element": node, "type": "p", "level": _heading_level(node), "top": top_level}
        elif node.tag == _q("tbl"):
            yield {"element": node, "type": "tbl", "level": None, "top": top_level}
        else:
            yield {"element": node, "type": "other", "level": None, "top": top_level}

def _collect_body_blocks(body_el):
    blocks = []
    for child in list(body_el):
        if child.tag == _q("sdt"):
            content = child.find(_q("sdtContent"))
            if content is not None:
                blocks.extend(_iter_blocks_within(content, child))
            else:
                blocks.append({"element": child, "type": "other", "level": None, "top": child})
        elif child.tag == _q("p"):
            blocks.append({"element": child, "type": "p", "level": _heading_level(child), "top": child})
        elif child.tag == _q("tbl"):
            blocks.append({"element": child, "type": "tbl", "level": None, "top": child})
        else:
            blocks.append({"element": child, "type": "other", "level": None, "top": child})
    return blocks

def _mark_block_hidden(el):
    if el is None:
        return
    _apply_rStyle_hidden_to_runs(el)
    if el.tag == _q("tbl"):
        _mark_table_hidden(el)
    for tbl in el.findall(".//w:tbl", {"w": _W_NS}):
        _apply_rStyle_hidden_to_runs(tbl)
        _mark_table_hidden(tbl)

def apply_visibility(u8, idx_to_action_json):
    """
    idx_to_action_json: {"12":"HIDE","13":"SHOW", ...}
    Semantics:
      - First, remove ALL occurrences of our own rStyle=fsHidden (global reset).
      - Then, apply HIDE to current target ranges.
      - SHOW is accepted but redundant post-reset.
    """
    try: idx_to_action = {int(k): v for (k,v) in json.loads(idx_to_action_json).items()}
    except Exception: idx_to_action = {}
    data = bytes(u8)
    outbuf = io.BytesIO()
    with zipfile.ZipFile(io.BytesIO(data), "r") as zfin, zipfile.ZipFile(outbuf, "w", compression=zipfile.ZIP_DEFLATED) as zfout:
        names = zfin.namelist()

        # Copy everything except styles.xml (we rewrite after ensuring fsHidden)
        for n in names:
            if n == "word/styles.xml": continue
            zfout.writestr(n, zfin.read(n))

        _ensure_fsHidden_style(zfin, zfout, set(names))

        def is_doc_part(n):
            if not (n.startswith("word/") and n.endswith(".xml")): return False
            skip = {"word/styles.xml","word/numbering.xml","word/theme/theme1.xml","word/fontTable.xml","word/settings.xml","word/webSettings.xml"}
            return n not in skip and not n.startswith("word/_rels/")

        # PASS 1: global reset (remove fsHidden rStyle everywhere)
        parts_roots = {}
        for n in names:
            if not is_doc_part(n): continue
            try:
                root = ET.fromstring(zfin.read(n))
            except ET.ParseError:
                parts_roots[n] = None
                continue
            for r in root.findall(".//w:r", {"w": _W_NS}):
                rpr = r.find(_q("rPr"))
                if rpr is None: continue
                for rs in list(rpr.findall(_q("rStyle"))):
                    if rs.get(_q("val")) == "fsHidden":
                        rpr.remove(rs)
            for tbl in root.findall(".//w:tbl", {"w": _W_NS}):
                _clear_table_hidden_markers(tbl)
            parts_roots[n] = root

    # PASS 2: apply current HIDE ranges
    global_idx = 0
    for n in names:
        if not is_doc_part(n): continue
        root = parts_roots.get(n)
        if root is None: continue

        body = root.find(_q("body"))
        if body is None:
            zfout.writestr(n, ET.tostring(root, encoding="utf-8", xml_declaration=True)); continue

        elems = _collect_body_blocks(body)

        heading_positions = []
        for i, blk in enumerate(elems):
            if blk.get("type") == "p" and blk.get("level") is not None:
                global_idx += 1
                heading_positions.append((i, blk.get("level"), global_idx))

        for h_i, (pos, lvl, idx) in enumerate(heading_positions):
            if idx_to_action.get(idx) != "HIDE":
                continue
            if h_i + 1 < len(heading_positions):
                end = len(elems)
                for j in range(h_i + 1, len(heading_positions)):
                    np, nl, _ = heading_positions[j]
                    if nl <= lvl:
                        end = np
                        break
            else:
                end = len(elems)

            seen = set()
            for j in range(pos, end):
                blk = elems[j]
                top = blk.get("top")
                if top is None:
                    continue
                key = id(top)
                if key in seen:
                    continue
                seen.add(key)
                if top.tag in {_q("p"), _q("tbl"), _q("sdt")}:
                    _mark_block_hidden(top)

        zfout.writestr(n, ET.tostring(root, encoding="utf-8", xml_declaration=True))

    return outbuf.getvalue()
`);

        pyLoaded = true;
      }
    }

    // Minimal readers for CRONOS_PAYLOAD using pyodide helpers
    async function readDocVarSettings(arrayBufferOrBytes, name) {
      await ensurePy();
      const u8in = arrayBufferOrBytes instanceof Uint8Array ? arrayBufferOrBytes : new Uint8Array(arrayBufferOrBytes);
      const fn = py.globals.get('read_docvar_settings');
      const pyBytes = py.toPy(u8in);
      let pyOut;
      try { pyOut = fn(pyBytes, name); }
      finally { try{fn.destroy();}catch{} try{pyBytes.destroy();}catch{} }
      let txt = null;
      if (pyOut && typeof pyOut.toJs === 'function') txt = pyOut.toJs({ create_proxies:false });
      else txt = pyOut ?? null;
      try { pyOut?.destroy?.(); } catch {}
      return txt;
    }

    async function readDocVarCustom(arrayBufferOrBytes, name) {
      await ensurePy();
      const u8in = arrayBufferOrBytes instanceof Uint8Array ? arrayBufferOrBytes : new Uint8Array(arrayBufferOrBytes);
      const fn = py.globals.get('read_docvar_custom');
      const pyBytes = py.toPy(u8in);
      let pyOut;
      try { pyOut = fn(pyBytes, name); }
      finally { try{fn.destroy();}catch{} try{pyBytes.destroy();}catch{} }
      let txt = null;
      if (pyOut && typeof pyOut.toJs === 'function') txt = pyOut.toJs({ create_proxies:false });
      else txt = pyOut ?? null;
      try { pyOut?.destroy?.(); } catch {}
      return txt;
    }

    // PAYLOAD_KEY is defined earlier in this script
    // Lightweight JSZip-based payload reader (no Pyodide dependency on index)
    async function ensureJSZip(){
      if (window.JSZip) return;
      await new Promise((res, rej) => {
        const s = document.createElement('script');
        s.src = 'https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js';
        s.onload = res; s.onerror = rej; document.head.appendChild(s);
      });
    }

    async function readPayloadFromDocx(bytes){
      try {
        await ensureJSZip();
        const zip = await window.JSZip.loadAsync(bytes);
        // Try settings.xml → w:docVars/w:docVar
        const settings = zip.file('word/settings.xml');
        if (settings) {
          const xmlText = await settings.async('string');
          const parser = new DOMParser();
          const xml = parser.parseFromString(xmlText, 'application/xml');
          const W_NS = 'http://schemas.openxmlformats.org/wordprocessingml/2006/main';
          const docVars = xml.getElementsByTagNameNS(W_NS, 'docVars')[0];
          if (docVars) {
            const vars = docVars.getElementsByTagNameNS(W_NS, 'docVar');
            for (let i = 0; i < vars.length; i++) {
              const dv = vars[i];
              const name = dv.getAttributeNS(W_NS, 'name') || dv.getAttribute('w:name') || dv.getAttribute('name');
              if (name === PAYLOAD_KEY) {
                const val = dv.getAttributeNS(W_NS, 'val') || dv.getAttribute('w:val') || dv.getAttribute('val') || '';
                return val || null;
              }
            }
          }
        }
        // Fallback: docProps/custom.xml → cp:property[name=PAYLOAD_KEY]
        const custom = zip.file('docProps/custom.xml');
        if (custom) {
          const xmlText = await custom.async('string');
          const parser = new DOMParser();
          const xml = parser.parseFromString(xmlText, 'application/xml');
          const props = xml.getElementsByTagName('property');
          for (let i = 0; i < props.length; i++) {
            const p = props[i];
            const nm = p.getAttribute('name');
            if (nm === PAYLOAD_KEY) {
              const child = p.firstElementChild;
              return child && child.textContent ? child.textContent : null;
            }
          }
        }
      } catch (e) { console.warn('readPayloadFromDocx failed', e); }
      return null;
    }

    let __hydrating = false;
    async function hydrateWorkspaceFromDocxIfEmpty() {
      try {
        if (__hydrating) return false;
        if (!currentDoc?.docId) return false;
        const st = await window.formSuitePersist.loadState?.(currentDoc.docId);
        const hasSchema = Array.isArray(st?.schema?.fields) && st.schema.fields.length > 0;
        if (hasSchema) return false; // nothing to do
        setStatus('Restoring from document…');
        const bytes = await fetchWorkingDocBytes();
        if (!bytes) return false;
        __hydrating = true;
        let payloadRaw = await readPayloadFromDocx(bytes);
        if (!payloadRaw) return false;
        let payload = null;
        try { payload = JSON.parse(payloadRaw); } catch { payload = null; }
        if (!payload || !Array.isArray(payload.fields) || !payload.fields.length) return false;

        const nextSchema = { title: payload.title || 'Form', fields: payload.fields };
        const cleanValues = sanitizeValues(nextSchema, payload.values || {});
        const tagMap = payload.tagMap || {};
        const rules  = Array.isArray(payload.rules) ? payload.rules : [];
        await window.formSuitePersist.saveState(currentDoc.docId, {
          schema: nextSchema,
          values: cleanValues,
          tagMap,
          rules,
          schemaUpdatedAt: new Date().toISOString()
        });
        // refresh local variables + UI
        schema = nextSchema;
        values = cleanValues;
        renderForm();
        setStatus(`Active DOCX: <span class="kbd">${currentDoc.name}</span>`);
        return true;
      } catch (e) {
        console.warn('hydrateWorkspaceFromDocxIfEmpty failed:', e);
        return false;
      } finally {
        __hydrating = false;
      }
    }

    async function writeDocVar(bytes, name, value) {
      await ensurePy();
      const fn = py.globals.get('write_docvar');
      const pyBytes = py.toPy(new Uint8Array(bytes));
      let pyOut;
      try { pyOut = fn(pyBytes, name, value); }
      finally { try{fn.destroy();}catch{} try{pyBytes.destroy();}catch{} }
      let u8;
      if (pyOut?.toJs) u8 = pyOut.toJs({ create_proxies:false });
      else if (pyOut?.getBuffer) u8 = new Uint8Array(pyOut.getBuffer());
      else u8 = new Uint8Array([]);
      try { pyOut.destroy?.(); } catch {}
      return u8;
    }

    async function writeSDTs(arrayBufferOrBytes, tagToTextObj) {
      await ensurePy();
      const u8in = arrayBufferOrBytes instanceof Uint8Array ? arrayBufferOrBytes : new Uint8Array(arrayBufferOrBytes);
      const fn = py.globals.get('write_sdts_by_tag');
      const pyBytes = py.toPy(u8in);
      const pyMap   = py.toPy(JSON.stringify(tagToTextObj || {}));
      let pyOut;
      try { pyOut = fn(pyBytes, pyMap); }
      finally { try{fn.destroy();}catch{} try{pyBytes.destroy();}catch{} try{pyMap.destroy();}catch{} }
      let u8;
      if (pyOut?.toJs) u8 = pyOut.toJs({ create_proxies:false });
      else if (pyOut?.getBuffer) u8 = new Uint8Array(pyOut.getBuffer());
      else u8 = new Uint8Array([]);
      try { pyOut.destroy?.(); } catch {}
      return u8;
    }

    // ---------- Helpers: sanitize ----------
    // ---------- Helpers: sanitize ----------
    function sanitizeValues(schema, vals) {
      const out = {};
      const fields = Array.isArray(schema?.fields) ? schema.fields : [];

      for (const f of fields) {
        const id = f.id;
        let v = vals?.[id];

        // DATEDIFF — store the computed object
        if (f.type === 'datediff') {
          const d = vals?.[id];
          if (d && typeof d === 'object') {
            const outObj = {
              days: Number(d.days ?? 0),
              months: Number(d.months ?? 0),
              years: Number(d.years ?? 0),
              formatted: String(d.formatted ?? '')
            };
            if (outObj.formatted) out[id] = outObj;
          } else if (Number.isFinite(Number(d))) {
            const n = Number(d);
            out[id] = { days: n, months: 0, years: 0, formatted: `${n}-0-0 (${n})` };
          }
          continue;
        }

        // ADDRESS
        if (f.type === 'address') {
          const vv = vals?.[id];
          if (typeof vv === 'string') {
            const s = vv.trim();
            if (s || f.required) out[id] = s ? { formatted: s } : { formatted: '' };
          } else if (vv && typeof vv === 'object') {
            const o = {
              formatted: vv.formatted || '',
              street: vv.street || '',
              houseNumber: vv.houseNumber || '',
              postcode: vv.postcode || '',
              city: vv.city || '',
              country: vv.country || '',
              lat: (vv.lat ?? null),
              lon: (vv.lon ?? null)
            };
            if (o.formatted || f.required) out[id] = o;
          }
          continue;
        }

        // MULTICHOICE (options + conditional extras)
        if (f.type === 'multichoice') {
          // main value: array of selected options
          let arr = Array.isArray(v) ? v.slice() : (typeof v === 'string' ? v.split(',') : []);
          arr = arr.map(x => String(x).trim()).filter(Boolean);

          let allowed = null;
          if (Array.isArray(f.options) && f.options.length) {
            allowed = new Set(
              f.options.map(o => (o && typeof o === 'object')
                ? String(o.value ?? o.label ?? '')
                : String(o)
              )
            );
          } else if (f.mc && Array.isArray(f.mc.groups)) {
            allowed = new Set(
              f.mc.groups.flatMap(g => (g.items || []).map(it => String((it?.value ?? it?.label ?? ''))))
            );
          }
          if (allowed) arr = arr.filter(x => allowed.has(String(x)));
          if (arr.length) out[id] = arr;
          else if (f.required) out[id] = [];

          // conditional extras under synthesized keys
          if (f.mc && Array.isArray(f.mc.groups)) {
            for (const g of f.mc.groups) {
              for (const it of (g.items || [])) {
                const optVal = String(it?.value || '');
                const extras = Array.isArray(it?.fields) ? it.fields : [];
                for (const ex of extras) {
                  const exId = String(ex?.id || '');
                  if (!exId) continue;
                  const k = mcExtraKey(f.id, optVal, exId);
                  const raw = vals?.[k];

                  if (ex.type === 'date') {
                    const s = String(raw ?? '');
                    if (s) out[k] = s;
                    continue;
                  }

                  if (ex.type === 'number') {
                    if (raw === '' || raw == null) continue;
                    const num = (typeof raw === 'number') ? raw : Number(String(raw).replace(',', '.'));
                    if (Number.isFinite(num)) out[k] = num;
                    continue;
                  }

                  // NEW: datediff inside MC — store same object shape as top-level
                  if (ex.type === 'datediff') {
                    if (raw && typeof raw === 'object' && typeof raw.days !== 'undefined') {
                      const o = {
                        days: Number(raw.days ?? 0),
                        months: Number(raw.months ?? 0),
                        years: Number(raw.years ?? 0),
                        formatted: String(raw.formatted ?? '')
                      };
                      if (o.formatted) out[k] = o;
                    }
                    continue;
                  }

                  // default: text
                  const s = String(raw ?? '');
                  if (s) out[k] = s;
                }
              }
            }
          }
          continue;
        }

        // SELECT
        if (f.type === 'select') {
          let s = Array.isArray(v) ? String(v[0] ?? '') : String(v ?? '');
          if (Array.isArray(f.options) && f.options.length) {
            const allowed = new Set(f.options.map(String));
            if (!allowed.has(s)) s = '';
          }
          if (s === '') { if (f.required) out[id] = s; }
          else out[id] = s;
          continue;
        }

        // NUMBER
        if (f.type === 'number') {
          if (v === '' || v == null) continue;
          const num = (typeof v === 'number') ? v : Number(String(v).replace(',', '.'));
          if (Number.isFinite(num)) out[id] = num;
          continue;
        }

        // DATE
        if (f.type === 'date') { out[id] = String(v ?? ''); continue; }

        // TABLE
        if (f.type === 'table') {
          const cols = Array.isArray(f.columns) ? f.columns : [];
          const colIds = cols.map(c => c.id);
          const arr = Array.isArray(v) ? v : [];
          const cleaned = arr.map(row => {
            const o = {};
            for (const cid of colIds) {
              let cell = row?.[cid];
              if (cell == null) cell = '';
              o[cid] = (typeof cell === 'string') ? cell : String(cell);
            }
            return o;
          }).filter(r => Object.values(r).some(val => String(val).trim() !== ''));
          const min = Math.max(0, parseInt(f.minRows || 0, 10));
          while (cleaned.length < min) {
            const empty = {}; colIds.forEach(cid => empty[cid] = '', cleaned.push(empty));
          }
          if (cleaned.length) out[id] = cleaned;
          else if (f.required) out[id] = [];
          continue;
        }

        // TEXT-ish default
        const s = String(v ?? '');
        if (s || f.required) out[id] = s;
      }

      return out;
    }

    function sanitizeTagMap(tagMap, validIds) {
      const out = {};
      for (const [tag, fid] of Object.entries(tagMap || {})) {
        if (validIds.has(fid)) out[tag] = fid;
      }
      return out;
    }

    // ---------- Init ----------
    init().catch(console.error);

    async function init() {
      currentDoc = readActiveDocSync();

      if (currentDoc?.docId) {
        const bytes = await fetchWorkingDocBytes();
        if (!bytes) { await hardResetOpenForm('no bytes / no permission'); return; }

        const st = await window.formSuitePersist.loadState?.(currentDoc.docId);
        schema = st?.schema || null;
        values = st?.values || {};
        setStatus(`Active DOCX: <span class="kbd">${currentDoc.name}</span>${schema ? '' : ' — <span class="muted">no schema yet</span>'}`);
        await updateWriteAccessBanner();
      } else {
        schema = loadLS();
        values = {};
      }

      renderForm();
    }

    // ---------- Robust bytes fetcher ----------
    async function fetchWorkingDocBytes() {
      try { const b = await window.formSuitePersist.getCurrentDocBytes?.(); if (b && b.byteLength) return b; } catch {}
      try { if (currentDoc?.docId) { const b2 = await window.formSuitePersist.getBytes?.(currentDoc.docId); if (b2 && b2.byteLength) return b2; } } catch {}
      try {
        const h = await window.formSuitePersist.getHandle?.(currentDoc?.docId);
        if (h?.getFile) {
          let p = await window.formSuitePersist.ensurePermission?.(h, 'readwrite');
          if (p !== 'granted') p = await window.formSuitePersist.ensurePermission?.(h, 'read');
          if (p === 'granted') { const f = await h.getFile(); return await f.arrayBuffer(); }
        }
      } catch {}
      try { await window.formSuitePersist.regrantAll?.(); const b3 = await window.formSuitePersist.getCurrentDocBytes?.(); if (b3 && b3.byteLength) return b3; } catch {}
      return null;
    }

    // ---- DATEDIFF helpers ----
    function parseDateByFormat(str, fmt) {
      if (!str) return null;
      try {
        // use flatpickr's own parser so we honor custom formats
        const d = (window.flatpickr && window.flatpickr.parseDate)
          ? window.flatpickr.parseDate(String(str), fmt || 'Y-m-d')
          : new Date(String(str));
        return (d && !isNaN(d.getTime())) ? d : null;
      } catch { return null; }
    }

    function diffInDays(a, b) {
      // normalize to midnight to avoid TZ drift
      const A = new Date(a.getFullYear(), a.getMonth(), a.getDate());
      const B = new Date(b.getFullYear(), b.getMonth(), b.getDate());
      const ms = B - A; // to - from
      return Math.floor(ms / (24*60*60*1000));
    }
    function diffInMonths(a, b) {
      // calendar months between a -> b (subtract 1 if day-of-month hasn't been reached)
      let months = (b.getFullYear() - a.getFullYear()) * 12 + (b.getMonth() - a.getMonth());
      if (b.getDate() < a.getDate()) months -= 1;
      return months;
    }
    function diffInYears(a, b) {
      // full calendar years between a -> b
      let years = b.getFullYear() - a.getFullYear();
      const bBeforeAnniversary = (b.getMonth() < a.getMonth()) || (b.getMonth() === a.getMonth() && b.getDate() < a.getDate());
      if (bBeforeAnniversary) years -= 1;
      return years;
    }

    // returns number or null
    function computeDateDiff(fromDate, toDate, unit = 'days') {
      if (!fromDate || !toDate) return null;
      const u = String(unit || 'days').toLowerCase();
      if (u === 'years')  return diffInYears(fromDate, toDate);
      if (u === 'months') return diffInMonths(fromDate, toDate);
      return diffInDays(fromDate, toDate); // default days
    }

    // Modern, pretty flatpickr with sensible defaults for our app.
    // - Non-editable (click-to-pick), ISO storage via value, nice alt display.
    // - Month dropdown, week numbers, nicer arrows, better mobile behavior.
    // - Will add a CSS class on the first allowed day so it pops visually.
    function createPrettyDatepicker(input, extraOpts = {}) {
      // Make sure the calendar can render above the card
      if (!document.getElementById('fp-zindex-fix')) {
        const st = document.createElement('style');
        st.id = 'fp-zindex-fix';
        st.textContent = `
          .flatpickr-calendar { z-index: 50; } /* above .mc-item content */
          .flatpickr-wrapper { position: relative; } /* for static positioning */
        `;
        document.head.appendChild(st);
      }

      const baseOpts = {
        dateFormat: 'Y-m-d',
        altInput: true,
        altFormat: 'D, j M Y',
        allowInput: false,
        clickOpens: true,        // make explicit
        disableMobile: true,
        static: true,            // embed under the input (works with our grid)
        wrap: false,             // we manage our own wrappers
        monthSelectorType: 'dropdown',
        weekNumbers: true,
        prevArrow: '‹',
        nextArrow: '›',
        onReady: (_sel, _str, inst) => {
          // alt input should be clickable and focusable
          if (inst.altInput) {
            inst.altInput.readOnly = true;
            inst.altInput.tabIndex = 0;
            inst.altInput.style.pointerEvents = 'auto';
            // ensure there is a positioned wrapper for static calendar
            const wrap = inst.altInput.parentElement;
            if (wrap && !wrap.classList.contains('flatpickr-wrapper')) {
              wrap.classList.add('flatpickr-wrapper');
              // do not interfere with height measurements
              if (getComputedStyle(wrap).position === 'static') {
                wrap.style.position = 'relative';
              }
            }
          }
        }
      };

      return flatpickr(input, { ...baseOpts, ...extraOpts });
    }


    // --- MC helpers: stable key for a conditional sub-field of a multichoice option
    function slugifyMc(s) {
      return String(s || '')
        .normalize('NFKD')
        .replace(/[\u0300-\u036f]/g, '')
        .replace(/[^a-zA-Z0-9]+/g, '_')
        .replace(/^_+|_+$/g, '')
        .toLowerCase();
    }
    function mcExtraKey(fieldId, optionValue, extraId) {
      return `${fieldId}__${slugifyMc(optionValue)}__${slugifyMc(extraId)}`;
    }

    // ---------- Render whole form ----------
    function renderForm() {
      // --- one-time CSS for caret + collapse animation + MC label alignment ---
      (function injectMcStyles(){
        const ID = 'mc-caret-styles';
        if (document.getElementById(ID)) return;
        const s = document.createElement('style');
        s.id = ID;
        s.textContent = `
          .mc-item { position: relative; }
          .mc-toggle {
            all: unset;
            position: absolute;
            top: 10px;
            right: 10px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            line-height: 1;
            padding: 0;
            margin: 0;
            pointer-events: auto;
          }
          .mc-toggle:focus-visible {
            outline: 2px solid var(--focus, #2563eb);
            outline-offset: 2px;
            border-radius: 4px;
          }
          .mc-caret {
            width: 14px;
            height: 14px;
            transition: transform .18s ease, opacity .18s ease;
            opacity: .85;
            transform: rotate(0deg);
            display: block;
          }
          .mc-caret.open { transform: rotate(90deg); }

          /* Keep this simple; JS controls height/display during animation */
          .mc-extras {
            display: none;     /* collapsed = removed from flow */
            height: 0;         /* safety for measure/animate */
            grid-template-columns: 1fr;
            row-gap: 8px;
            padding-bottom: 2px;
            width: 100%;
          }
          .mc-extras.open { }

          /* ---------- New: checkbox + text alignment (Option 1) ---------- */
          .mc-option-label{
            display:grid;
            grid-template-columns:auto 1fr;
            column-gap:8px;
            align-items:center;     /* center checkbox with first text line */
            cursor:pointer;
            line-height:1.25;
          }
          .mc-option-label > span{
            white-space:normal;
            word-break:break-word;
          }
          .mc-option-checkbox{
            align-self:center;      /* no extra nudge */
            margin-top:0;
            transform:none;
          }
        `;
        document.head.appendChild(s);
      })();

      // local fallbacks
      const __slugifyMc = (window.slugifyMc) ? window.slugifyMc : function (s) {
        return String(s || '')
          .normalize('NFKD')
          .replace(/[\u0300-\u036f]/g, '')
          .replace(/[^a-zA-Z0-9]+/g, '_')
          .replace(/^_+|_+$/g, '')
          .toLowerCase();
      };
      const __mcExtraKey = (window.mcExtraKey) ? window.mcExtraKey : function (fieldId, optionValue, extraId) {
        return `${fieldId}__${__slugifyMc(optionValue)}__${__slugifyMc(extraId)}`;
      };

      const mount = els.formMount;
      mount.innerHTML = '';
      if (!schema || !Array.isArray(schema.fields) || !schema.fields.length) {
        mount.innerHTML = `<div class="muted">No schema found. Create one in the <a href="builder.html">Builder</a>.</div>`;
        if (btnExportMain) btnExportMain.disabled = true;
        return;
      }

      // hydrate defaults for tables
      (schema.fields || []).forEach(f => {
        if (f.type === 'table') {
          if (!Array.isArray(values[f.id])) {
            const min = Math.max(0, parseInt(f.minRows || 0, 10));
            values[f.id] = Array.from({ length: min }, () => emptyRow(f));
          } else {
            values[f.id] = values[f.id].map(r => ({ ...emptyRow(f), ...(r || {}) }));
          }
        }
      });

      // form shell
      const form = document.createElement('form');
      form.classList.add('form-grid');

      if (schema.title) {
        const h = document.createElement('h4');
        h.textContent = schema.title;
        h.style.gridColumn = '1 / -1';
        form.appendChild(h);
      }

      // refs
      const inputRefs  = {};
      const mcDateRefs = {};
      const datediffRefs = []; // [{storeKey, outEl, resolve}]
      const guardPairs = [];   // [{fromId, toId}]

      // ---------- helpers ----------
      function scheduleSaveState() {
        clearTimeout(scheduleSaveState._t);
        scheduleSaveState._t = setTimeout(() => {
          if (!currentDoc?.docId) return;
          const cleanValues = sanitizeValues(schema, values);
          window.formSuitePersist.saveState(currentDoc.docId, { schema, values: cleanValues });
        }, 150);
      }

      // Animate extras open/close; collapsed = display:none so it takes no height.
      function setExtrasOpen(extras, caretEl, open) {
        if (!extras) return;
        const DURATION = 220;

        // cancel previous
        if (extras._animTimer) { clearTimeout(extras._animTimer); extras._animTimer = null; }
        if (extras._onTe) { extras.removeEventListener('transitionend', extras._onTe); extras._onTe = null; }

        const onEnd = () => {
          extras.style.transition = '';
          extras.style.willChange = '';
          extras.style.opacity = open ? '1' : '0';
          extras.style.marginTop = open ? '8px' : '0px';
          extras.style.height = open ? 'auto' : '0px';
          extras.style.overflow = 'visible';     // keep it visible so calendars can overflow
          if (!open) extras.style.display = 'none';
          if (extras._onTe) {
            extras.removeEventListener('transitionend', extras._onTe);
            extras._onTe = null;
          }
        };
        extras._onTe = onEnd;
        extras.addEventListener('transitionend', onEnd);

        if (caretEl) caretEl.classList.toggle('open', !!open);

        if (open) {
          extras.style.display = 'grid';
          extras.style.overflow = 'visible';
          extras.style.willChange = 'height, opacity, margin-top';
          extras.style.opacity = '0';
          extras.style.marginTop = '0px';
          extras.style.height = '0px';

          requestAnimationFrame(() => {
            const h = extras.scrollHeight;
            extras.classList.add('open');
            extras.style.transition = `height ${DURATION}ms ease, opacity ${DURATION}ms ease, margin-top ${DURATION}ms ease`;
            extras.style.height = h + 'px';
            extras.style.opacity = '1';
            extras.style.marginTop = '8px';
            extras._animTimer = setTimeout(onEnd, DURATION + 40);
          });
        } else {
          const current = extras.offsetHeight || extras.scrollHeight || 0;
          extras.classList.remove('open');
          extras.style.display = 'grid';
          extras.style.overflow = 'hidden';
          extras.style.willChange = 'height, opacity, margin-top';
          extras.style.transition = '';
          extras.style.height = current + 'px';
          extras.style.opacity = '1';
          extras.style.marginTop = '8px';

          requestAnimationFrame(() => {
            extras.style.transition = `height ${DURATION}ms ease, opacity ${DURATION}ms ease, margin-top ${DURATION}ms ease`;
            extras.style.height = '0px';
            extras.style.opacity = '0';
            extras.style.marginTop = '0px';
            extras._animTimer = setTimeout(onEnd, DURATION + 40);
          });
        }
      }

      // ---------- fields ----------
      (schema.fields || []).forEach(f => {
        const wrap = document.createElement('div');
        wrap.className = 'field';
        try { wrap.dataset.fieldId = String(f.id || ''); } catch {}
        if (f.type === 'address' || f.type === 'datediff') wrap.classList.add('span-2');
        if (f.type === 'table') wrap.classList.add('full', 'field--table');
        if (f.type === 'multichoice') wrap.classList.add('full', 'field--multichoice');
        if (f.wide === true) wrap.classList.add('span-2');
        if (f.full === true) wrap.classList.add('full');

        // label (address renders own)
        if (f.type !== 'address') {
          const label = document.createElement('label');
          label.htmlFor = f.id;
          label.textContent = f.label || f.id;
          if (f.required) {
            const star = document.createElement('span');
            star.textContent = ' *';
            star.style.color = '#ef4444';
            label.appendChild(star);
          }
          wrap.appendChild(label);
        }

        // TEXT
        if (f.type === 'text') {
          const input = document.createElement('input');
          input.type = 'text';
          input.id = f.id; input.name = f.id; input.style.width = '100%';
          if (f.required) input.required = true;
          if (values[f.id] != null) input.value = values[f.id];
          input.addEventListener('change', () => { values[f.id] = input.value; scheduleSaveState(); try{ applyFieldVisibility(); }catch{} });
          wrap.appendChild(input);
          inputRefs[f.id] = input;

        // NUMBER
        } else if (f.type === 'number') {
          const input = document.createElement('input');
          input.type = 'number';
          input.id = f.id; input.name = f.id; input.style.width = '100%';
          if (f.required) input.required = true;
          if (values[f.id] != null) input.value = values[f.id];
          input.addEventListener('change', () => { values[f.id] = Number(input.value); scheduleSaveState(); try{ applyFieldVisibility(); }catch{} });
          wrap.appendChild(input);
          inputRefs[f.id] = input;

        // SELECT
        } else if (f.type === 'select') {
          const input = document.createElement('select');
          input.id = f.id; input.name = f.id; input.style.width = '100%';
          (f.options || []).forEach(v => {
            const o = document.createElement('option');
            o.value = String(v); o.textContent = String(v);
            input.appendChild(o);
          });
          if (f.required) input.required = true;
          if (values[f.id] != null) input.value = values[f.id];
          input.addEventListener('change', () => { values[f.id] = input.value; scheduleSaveState(); try{ applyFieldVisibility(); }catch{} });
          wrap.appendChild(input);
          inputRefs[f.id] = input;

        // MULTICHOICE
        } else if (f.type === 'multichoice') {
          // Container for all groups
          const mcContainer = document.createElement('div');
          mcContainer.className = 'mc-container';
          mcContainer.style.display = 'block';

          // normalize items
          const items = [];
          if (f.mc && Array.isArray(f.mc.groups) && f.mc.groups.length) {
            f.mc.groups.forEach(g => (g.items || []).forEach(it =>
              items.push({
                value: String(it.value ?? it.label ?? ''),
                alwaysSelected: !!it.alwaysSelected,
                preselected: !!it.preselected,
                fields: Array.isArray(it.fields) ? it.fields : []
              })
            ));
          } else if (Array.isArray(f.options)) {
            f.options.forEach(v => {
              if (v && typeof v === 'object') {
                items.push({
                  value: String(v.value ?? v.label ?? ''),
                  alwaysSelected: !!v.alwaysSelected,
                  preselected: !!v.preselected,
                  fields: Array.isArray(v.fields) ? v.fields : []
                });
              } else {
                items.push({ value: String(v), alwaysSelected: false, preselected: false, fields: [] });
              }
            });
          }

          // default selections
          if (!Array.isArray(values[f.id])) {
            const initial = items.filter(it => it.alwaysSelected || it.preselected).map(it => it.value);
            if (initial.length) values[f.id] = initial.slice();
          }
          const selected = new Set(Array.isArray(values[f.id]) ? values[f.id].map(String) : []);

          function persistMainSelection() {
            const boxes = mcContainer.querySelectorAll(`input[type="checkbox"][data-mc="1"]`);
            values[f.id] = Array.from(boxes).filter(b => b.checked).map(b => b.value);
            scheduleSaveState();
          }

          function drawOption(item, parentHost) {
            const optVal = item.value;
            const optId  = `${f.id}__${__slugifyMc(optVal)}`;
            const hasExtras = Array.isArray(item.fields) && item.fields.length > 0;

          // CARD
          const card = document.createElement('div');
          card.className = 'mc-item';
          try { card.dataset.optId = `${f.id}__opt__${__slugifyMc(optVal)}`; } catch {}
          card.style.position = 'relative';
            card.style.display = 'flex';
            card.style.flexDirection = 'column';
            card.style.alignItems = 'stretch';
            card.style.background = 'var(--card)';
            card.style.border = '1px solid var(--border-strong)';
            card.style.borderRadius = '8px';
            card.style.padding = '10px 10px';

            // HEADER
            const row1 = document.createElement('div');
            row1.className = 'row';
            row1.style.alignItems = 'center';
            row1.style.gap = '8px';
            row1.style.width = '100%';

            const left = document.createElement('label');
            left.className = 'mc-option-label';
            left.setAttribute('for', optId);
            left.style.flex = '1';

            const cb = document.createElement('input');
            cb.type = 'checkbox';
            cb.dataset.mc = '1';
            cb.name = f.id;
            cb.id = optId;
            cb.value = optVal;
            cb.className = 'mc-option-checkbox';

            const locked = !!item.alwaysSelected;
            const isPreselected = !!item.preselected;
            cb.checked = locked || selected.has(optVal) || (!selected.size && isPreselected);
            if (locked) cb.disabled = true;

            const txt = document.createElement('span');
            txt.textContent = optVal;

            left.appendChild(cb);
            left.appendChild(txt);
            row1.appendChild(left);

            // EXTRAS
            let extrasWrap = null;
            if (hasExtras) {
              extrasWrap = document.createElement('div');
              extrasWrap.className = 'mc-extras';
              extrasWrap.style.display = 'none';
              extrasWrap.style.height  = '0px';

              const mountExtraFields = () => {
                extrasWrap.innerHTML = '';
                if (!item.fields.length) return;

                // helper for extras: read a date for a given MC extra key
                function getDateForExtraKey(key) {
                  const el = mcDateRefs[key];
                  const fp = el?._flatpickr;
                  if (fp?.selectedDates?.[0] instanceof Date) return fp.selectedDates[0];
                  const iso = values[key];
                  if (iso) {
                    const d = (window.flatpickr && window.flatpickr.parseDate)
                      ? window.flatpickr.parseDate(String(iso), 'Y-m-d')
                      : new Date(String(iso));
                    return (d && !isNaN(d)) ? d : null;
                  }
                  return null;
                }

                item.fields.forEach(ex => {
                  const exType = (ex?.type) ? String(ex.type) : 'text';
                  const exId   = String(ex?.id || '');
                  if (!exId) return;
                  const exKey  = __mcExtraKey(f.id, optVal, exId);

                  const line = document.createElement('div');
                  line.className = 'row';
                  line.style.gap = '8px';
                  line.style.alignItems = 'center';
                  line.style.marginTop = '2px';

                  const lab = document.createElement('label');
                  lab.textContent = String(ex?.label || exId);
                  lab.style.minWidth = '120px';
                  lab.style.color = 'var(--muted)';

                  if (exType === 'date') {
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.dataset.type = 'date';
                    input.style.minWidth = '180px';

                    extrasWrap.appendChild(line);
                    line.appendChild(lab);
                    line.appendChild(input);

                    const fp = createPrettyDatepicker(input, {
                      dateFormat: 'Y-m-d',
                      altInput: true,
                      altFormat: 'D, j M Y',
                      defaultDate: values[exKey] || null,
                      onChange: () => { values[exKey] = input.value; scheduleSaveState(); if (window.recomputeDatediffs) window.recomputeDatediffs(); },
                      onValueUpdate: () => { values[exKey] = input.value; scheduleSaveState(); if (window.recomputeDatediffs) window.recomputeDatediffs(); }
                    });
                    fp.set('allowInput', false);
                    if (fp.altInput) fp.altInput.readOnly = true;

                    mcDateRefs[exKey] = input;
                    return;
                  }

                  if (exType === 'number') {
                    const input = document.createElement('input');
                    input.type = 'number';
                    input.value = values[exKey] ?? '';
                    input.addEventListener('change', () => {
                      values[exKey] = Number(input.value);
                      scheduleSaveState();
                    });
                    extrasWrap.appendChild(line);
                    line.appendChild(lab);
                    line.appendChild(input);
                    return;
                  }

                  // NEW: computed DATEDIFF inside MC (read-only, not editable)
                  if (exType === 'datediff') {
                    const fromId = ex.fromId || ex.from || '';
                    const toId   = ex.toId   || ex.to   || '';
                    const fromKey = __mcExtraKey(f.id, optVal, fromId);
                    const toKey   = __mcExtraKey(f.id, optVal, toId);

                    const out = document.createElement('div');
                    out.className = 'datediff-out kbd';
                    out.setAttribute('role', 'status');
                    out.setAttribute('aria-live', 'polite');
                    out.textContent = '—';

                    extrasWrap.appendChild(line);
                    line.appendChild(lab);
                    line.appendChild(out);

                    // register in global recompute list
                    datediffRefs.push({
                      storeKey: exKey,
                      outEl: out,
                      resolve: () => ({ a: getDateForExtraKey(fromKey), b: getDateForExtraKey(toKey) })
                    });
                    return;
                  }

                  // default text
                  const input = document.createElement('input');
                  input.type = 'text';
                  input.value = values[exKey] ?? '';
                  input.addEventListener('change', () => {
                    values[exKey] = input.value;
                    scheduleSaveState();
                  });
                  extrasWrap.appendChild(line);
                  line.appendChild(lab);
                  line.appendChild(input);
                });
              };
              mountExtraFields();
            }

            // CARET
            let caretBtn = null, caretIcon = null;
            if (hasExtras) {
              caretBtn = document.createElement('button');
              caretBtn.type = 'button';
              caretBtn.className = 'mc-toggle';
              caretBtn.setAttribute('aria-expanded', 'false');
              caretBtn.setAttribute('aria-label', 'Details ein-/ausklappen');

              const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
              svg.setAttribute('viewBox', '0 0 24 24');
              svg.setAttribute('width', '14');
              svg.setAttribute('height', '14');
              svg.classList.add('mc-caret');
              const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
              path.setAttribute('d', 'M9 18l6-6-6-6');
              path.setAttribute('fill', 'none');
              path.setAttribute('stroke', 'currentColor');
              path.setAttribute('stroke-width', '2');
              path.setAttribute('stroke-linecap', 'round');
              path.setAttribute('stroke-linejoin', 'round');
              svg.appendChild(path);

              caretIcon = svg;
              caretBtn.appendChild(svg);
              row1.appendChild(caretBtn);

              // start collapsed
              setExtrasOpen(extrasWrap, caretIcon, false);

              caretBtn.addEventListener('click', (e) => {
                e.preventDefault();
                const willOpen = !extrasWrap.classList.contains('open');
                caretBtn.setAttribute('aria-expanded', String(willOpen));
                setExtrasOpen(extrasWrap, caretIcon, willOpen);
              });
            }

            // checkbox persists selection; no auto-open
            cb.addEventListener('change', () => {
              if (locked) { cb.checked = true; return; }
              persistMainSelection();
              try { applyFieldVisibility(); } catch {}
            });

            // assemble
            card.appendChild(row1);
            if (extrasWrap) card.appendChild(extrasWrap);
            parentHost.appendChild(card);
          }

          // Render grouped when mc.groups exist; otherwise single grid
          if (f.mc && Array.isArray(f.mc.groups) && f.mc.groups.length) {
            f.mc.groups.forEach(g => {
              const section = document.createElement('div');
              section.className = 'mc-group-section';
              section.style.marginBottom = '10px';

              if (g.title) {
                const h = document.createElement('div');
                h.className = 'mc-group-title';
                h.textContent = String(g.title);
                h.style.color = 'var(--muted)';
                h.style.fontWeight = '600';
                h.style.fontSize = '.95rem';
                h.style.margin = '4px 0 6px';
                section.appendChild(h);
              }

              const host = document.createElement('div');
              host.className = 'mc-group';
              host.style.display = 'grid';
              host.style.gridTemplateColumns = 'repeat(auto-fill,minmax(260px,1fr))';
              host.style.gap = '8px 16px';
              host.style.alignItems = 'start';
              if (Number.isFinite(+f.columns) && +f.columns > 0) {
                host.style.gridTemplateColumns = `repeat(${+f.columns}, minmax(220px, 1fr))`;
              }

              (g.items || []).forEach(it => drawOption({
                value: String(it.value ?? it.label ?? ''),
                alwaysSelected: !!it.alwaysSelected,
                preselected: !!it.preselected,
                fields: Array.isArray(it.fields) ? it.fields : []
              }, host));

              section.appendChild(host);
              mcContainer.appendChild(section);
            });
          } else {
            const host = document.createElement('div');
            host.className = 'mc-group';
            host.style.display = 'grid';
            host.style.gridTemplateColumns = 'repeat(auto-fill,minmax(260px,1fr))';
            host.style.gap = '8px 16px';
            host.style.alignItems = 'start';
            if (Number.isFinite(+f.columns) && +f.columns > 0) {
              host.style.gridTemplateColumns = `repeat(${+f.columns}, minmax(220px, 1fr))`;
            }
            items.forEach(it => drawOption(it, host));
            mcContainer.appendChild(host);
          }

          values[f.id] = Array.from(mcContainer.querySelectorAll(`input[type="checkbox"][data-mc="1"]`))
            .filter(b => b.checked)
            .map(b => b.value);
          scheduleSaveState();

          wrap.appendChild(mcContainer);

        // DATE
        } else if (f.type === 'date') {
          const input = document.createElement('input');
          input.type = 'text';
          input.dataset.type = 'date';
          input.id = f.id; input.name = f.id; input.style.width = '100%';
          if (f.required) input.required = true;
          wrap.appendChild(input);

          const fp = createPrettyDatepicker(input, {
            dateFormat: 'Y-m-d',
            altInput: true,
            altFormat: 'D-d-M-Y',
            allowInput: false,
            clickOpens: true,
            defaultDate: values[f.id] || null,
            onReady: (_sel, _str, inst) => { if (inst.altInput) inst.altInput.readOnly = true; },
            onChange: () => { values[f.id] = input.value; scheduleSaveState(); if (window.recomputeDatediffs) window.recomputeDatediffs(); try{ applyFieldVisibility(); }catch{} },
            onValueUpdate: () => { values[f.id] = input.value; scheduleSaveState(); if (window.recomputeDatediffs) window.recomputeDatediffs(); try{ applyFieldVisibility(); }catch{} }
          });
          fp.set('allowInput', false);
          if (fp.altInput) fp.altInput.readOnly = true;
          inputRefs[f.id] = input;

        // ADDRESS
        } else if (f.type === 'address') {
          const host = document.createElement('div');
          host.className = 'addr-host';
          wrap.appendChild(host);

          const initial =
            typeof values[f.id] === 'string'
              ? { formatted: values[f.id] }
              : (values[f.id] || null);

          AddressAuto.mount(host, {
            id: f.id,
            label: f.label || 'Address',
            required: !!f.required,
            value: initial || null,
            onChange: (val) => { values[f.id] = val; scheduleSaveState(); }
          });

        // TABLE
        } else if (f.type === 'table') {
          renderTableField(wrap, f);

        // DATEDIFF (top-level)
        } else if (f.type === 'datediff') {
          const fromId = f.fromId || f.from || '';
          const toId   = f.toId   || f.to   || '';

          const out = document.createElement('div');
          out.id = f.id;
          out.className = 'datediff-out kbd';
          out.setAttribute('role', 'status');
          out.setAttribute('aria-live', 'polite');
          out.textContent = '—';
          wrap.appendChild(out);

          datediffRefs.push({
            storeKey: f.id,
            outEl: out,
            resolve: () => ({ a: getDateForField(fromId), b: getDateForField(toId) })
          });

          guardPairs.push({ fromId, toId });

        // DEFAULT
        } else {
          const input = document.createElement('input');
          input.type = 'text';
          input.id = f.id; input.name = f.id; input.style.width = '100%';
          if (values[f.id] != null) input.value = values[f.id];
          input.addEventListener('change', () => { values[f.id] = input.value; scheduleSaveState(); });
          wrap.appendChild(input);
          inputRefs[f.id] = input;
        }

        form.appendChild(wrap);
      });

      // bottom bar
      const bar = document.createElement('div');
      bar.className = 'bar';
      bar.style.gridColumn = '1 / -1';
      btnExportMain = document.createElement('button');
      btnExportMain.type = 'button';
      btnExportMain.className = 'secondary';
      btnExportMain.textContent = 'Export…';
      btnExportMain.disabled = !currentDoc;
      btnExportMain.addEventListener('click', onExportFromOpenForm);
      bar.appendChild(btnExportMain);
      form.appendChild(bar);
      // reactively apply field visibility on any change within the form
      form.addEventListener('change', () => { try { applyFieldVisibility(); } catch {} });
      mount.appendChild(form);

      // initial apply based on current values
      try { applyFieldVisibility(); } catch {}

      // date helpers
      function getDateForField(fid) {
        const el = inputRefs[fid];
        if (!el) return null;
        const fp = el?._flatpickr;
        if (fp?.selectedDates?.[0] instanceof Date) return fp.selectedDates[0];
        const iso = values[fid];
        if (iso) {
          const d = (window.flatpickr && window.flatpickr.parseDate)
            ? window.flatpickr.parseDate(String(iso), 'Y-m-d')
            : new Date(String(iso));
          return (d && !isNaN(d)) ? d : null;
        }
        return null;
      }

      // labeled datediff (works for top-level AND MC extras we pushed)
      function recomputeDatediffs() {
        datediffRefs.forEach(({ storeKey, outEl, resolve }) => {
          const { a, b } = resolve();
          if (!a || !b) {
            outEl.textContent = '—';
            values[storeKey] = null;
            return;
          }
          const days   = diffInDays(a, b);
          const months = diffInMonths(a, b);
          const years  = diffInYears(a, b);
          const display = `${days}D ${months}M ${years}Y (${days} Days total)`;
          outEl.textContent = display;
          values[storeKey] = { days, months, years, formatted: display };
        });
        scheduleSaveState();
      }
      window.recomputeDatediffs = recomputeDatediffs;

      // guards for top-level pairs
      (function wireTopLevelDateGuards() {
        function nextDay(d) {
          if (!d) return null;
          const n = new Date(d.getFullYear(), d.getMonth(), d.getDate());
          n.setDate(n.getDate() + 1);
          return n;
        }
        guardPairs.forEach(({ fromId, toId }) => {
          const fromEl = inputRefs[fromId];
          const toEl   = inputRefs[toId];
          const fpFrom = fromEl?._flatpickr;
          const fpTo   = toEl?._flatpickr;
          if (!fpFrom || !fpTo) return;

          fpFrom.set('allowInput', false);
          fpTo.set('allowInput', false);
          if (fpFrom.altInput) fpFrom.altInput.readOnly = true;
          if (fpTo.altInput)   fpTo.altInput.readOnly   = true;

          const syncToWithFrom = (opts = { snap: true, jump: true }) => {
            const from = fpFrom.selectedDates?.[0] || null;
            const minForTo = nextDay(from);
            fpTo.set('minDate', minForTo || null);

            const toSel = fpTo.selectedDates?.[0] || null;
            if (!toSel && minForTo && opts.snap) fpTo.setDate(minForTo, true);
            if (from && toSel && toSel <= from && opts.snap) fpTo.setDate(minForTo, true);
            if (minForTo && opts.jump) { try { fpTo.jumpToDate(minForTo); } catch {} }

            if (typeof window.recomputeDatediffs === 'function') window.recomputeDatediffs();
          };

          syncToWithFrom({ snap: true, jump: false });
          fpFrom.config.onChange.push(() => syncToWithFrom({ snap: true, jump: true }));
          fpFrom.config.onValueUpdate.push(() => syncToWithFrom({ snap: true, jump: true }));
          fpTo.config.onOpen.push(() => syncToWithFrom({ snap: false, jump: true }));

          const recompute = () => { if (window.recomputeDatediffs) window.recomputeDatediffs(); };
          fpTo.config.onChange.push(recompute);
          fpTo.config.onValueUpdate.push(recompute);
        });
      })();

      // initial compute
      recomputeDatediffs();
    }




// ----- TABLE FIELD -----
    function renderTableField(container, field) {
      if (!Array.isArray(values[field.id])) values[field.id] = [];
      const data = values[field.id];

      // --- Inline editor (no special card/container) ---
      const editorWrap = document.createElement('div');
      editorWrap.style.display = 'flex';
      editorWrap.style.flexWrap = 'wrap';
      editorWrap.style.gap = '10px';

      const editorInputs = {};
      let editorState = emptyRow(field);

      // helpers for sizing
      const measurer = document.createElement('canvas').getContext('2d');
      function textPx(str) {
        try { measurer.font = getComputedStyle(document.body).font; } catch {}
        return Math.ceil(measurer.measureText(String(str || '')).width);
      }
      function longest(arr) {
        return arr.reduce((a, b) => (String(b).length > String(a).length ? String(b) : String(a)), '');
      }

      // helper: is a table row effectively empty?
      function rowIsEmpty(row) {
        return !(field.columns || []).some(c => String(row?.[c.id] ?? '').trim() !== '');
      }

      (field.columns || []).forEach(col => {
        const pair = document.createElement('label');
        pair.style.display = 'flex';
        pair.style.alignItems = 'center';
        pair.style.gap = '8px';

        const lbl = document.createElement('span');
        lbl.textContent = col.label || col.id;

        let el;
        if (col.type === 'select') {
          el = document.createElement('select');
          const opts = (col.options || []);
          const empty = document.createElement('option'); empty.value = ''; empty.textContent = '— wählen —';
          el.appendChild(empty);
          opts.forEach(opt => {
            const o = document.createElement('option');
            o.value = String(opt); o.textContent = String(opt);
            el.appendChild(o);
          });
          el.style.minWidth = Math.max(140, Math.min(360, textPx(longest(opts)) + 56)) + 'px';
          el.addEventListener('change', () => { editorState[col.id] = el.value; });
        } else if (col.type === 'date') {
          el = document.createElement('input');
          el.type = 'text';
          el.style.minWidth = Math.max(140, Math.min(360, textPx('YYYY-MM-DD') + 20)) + 'px';
          setTimeout(() => {
            flatpickr(el, { allowInput: true, dateFormat: 'Y-m-d', onChange: () => { editorState[col.id] = el.value; } });
          }, 0);
          el.addEventListener('change', () => { editorState[col.id] = el.value; });
        } else if (col.type === 'number') {
          el = document.createElement('input');
          el.type = 'number';
          el.style.minWidth = Math.max(120, Math.min(360, textPx('000000') + 20)) + 'px';
          el.addEventListener('change', () => { editorState[col.id] = el.value; });
        } else {
          el = document.createElement('input');
          el.type = 'text';
          el.style.minWidth = Math.max(160, Math.min(360, textPx(lbl.textContent) + 20)) + 'px';
          el.addEventListener('change', () => { editorState[col.id] = el.value; });
        }

        editorInputs[col.id] = el;
        pair.appendChild(lbl);
        pair.appendChild(el);
        editorWrap.appendChild(pair);
      });

      // --- Toolbar ---
      const toolbar = document.createElement('div');
      toolbar.className = 'row';
      toolbar.style.gap = '8px';

      const btnAdd = document.createElement('button');
      btnAdd.type = 'button';
      btnAdd.textContent = 'Zeile hinzufügen';

      const btnSave = document.createElement('button');
      btnSave.type = 'button';
      btnSave.className = 'secondary';
      btnSave.textContent = 'Änderungen speichern';

      const btnDelete = document.createElement('button');
      btnDelete.type = 'button';
      btnDelete.className = 'ghost';
      btnDelete.textContent = 'Zeile löschen';

      const btnCancel = document.createElement('button');
      btnCancel.type = 'button';
      btnCancel.className = 'ghost';
      btnCancel.textContent = 'Abbrechen';

      toolbar.appendChild(btnAdd);
      toolbar.appendChild(btnSave);
      toolbar.appendChild(btnDelete);
      toolbar.appendChild(btnCancel);

      const status = document.createElement('div');
      status.className = 'muted';
      status.style.minHeight = '1.2em';

      // --- Table preview (hidden until we have at least one non-empty row) ---
      const tableWrap = document.createElement('div');
      tableWrap.style.overflow = 'auto';
      const table = document.createElement('table');
      table.style.width = '100%';
      const thead = document.createElement('thead');
      const trh = document.createElement('tr');
      thead.appendChild(trh);
      const tbody = document.createElement('tbody');
      table.appendChild(thead);
      table.appendChild(tbody);
      tableWrap.appendChild(table);

      (field.columns || []).forEach(col => {
        const th = document.createElement('th');
        th.textContent = col.label || col.id;
        trh.appendChild(th);
      });

      let selectedIndex = -1;          // index in the *data* array
      let visibleIndexMap = [];        // maps rendered row index -> data index

      function applyPreviewVisibility() {
        const hasAnyNonEmpty = data.some(r => !rowIsEmpty(r));
        tableWrap.style.display = hasAnyNonEmpty ? '' : 'none';
      }

      function drawTable() {
        tbody.innerHTML = '';
        visibleIndexMap = [];

        // render ONLY non-empty rows
        data.forEach((row, realIdx) => {
          if (rowIsEmpty(row)) return;

          const tr = document.createElement('tr');
          const isSel = realIdx === selectedIndex;

          if (isSel) {
            tr.style.background = '#DBEAFE';
            tr.style.outline = '2px solid #93C5FD';
            tr.style.outlineOffset = '-2px';
          } else {
            tr.style.background = '';
            tr.style.outline = '';
            tr.style.outlineOffset = '';
          }

          tr.addEventListener('click', () => {
            selectedIndex = realIdx;      // keep selection in terms of the real data index
            drawTable();
            loadIntoEditor(realIdx);
          });

          (field.columns || []).forEach(col => {
            const td = document.createElement('td');
            td.textContent = row[col.id] || '';
            tr.appendChild(td);
          });

          tbody.appendChild(tr);
          visibleIndexMap.push(realIdx);
        });

        applyPreviewVisibility();
        updateToolbar();
      }

      function clearSelection() { selectedIndex = -1; updateToolbar(); }
      function updateToolbar() {
        const min = Math.max(0, parseInt(field.minRows || 0, 10));
        const max = Math.max(0, parseInt(field.maxRows || 0, 10));

        btnAdd.disabled = (max && data.length >= max);

        const showEdit = selectedIndex >= 0;
        btnSave.style.display   = showEdit ? '' : 'none';
        btnDelete.style.display = showEdit ? '' : 'none';
        btnCancel.style.display = showEdit ? '' : 'none';

        btnSave.disabled   = !showEdit;
        btnDelete.disabled = !showEdit || (min && data.length <= min);
        btnCancel.disabled = !showEdit;
      }

      function loadIntoEditor(i) {
        const rec = data[i] || emptyRow(field);
        for (const c of (field.columns || [])) {
          const el = editorInputs[c.id];
          if (!el) continue;
          el.value = rec[c.id] || '';
        }
        editorState = { ...rec };
        updateToolbar();
      }

      function resetEditor() {
        editorState = emptyRow(field);
        for (const c of (field.columns || [])) {
          const el = editorInputs[c.id];
          if (!el) continue;
          el.value = '';
        }
      }

      // initial rows (respect minRows) + first draw
      if (!data.length) {
        const min = Math.max(0, parseInt(field.minRows || 0, 10));
        for (let i = 0; i < min; i++) data.push(emptyRow(field)); // these are empty placeholders
      }
      drawTable(); // preview stays hidden unless a non-empty row exists

      // actions
      btnAdd.addEventListener('click', () => {
        const max = Math.max(0, parseInt(field.maxRows || 0, 10));
        if (max && data.length >= max) return;

        data.push({ ...editorState });
        drawTable();
        scheduleSaveState();
        status.textContent = 'Zeile hinzugefügt.';
      });

      btnSave.addEventListener('click', () => {
        if (selectedIndex < 0 || selectedIndex >= data.length) return;
        data[selectedIndex] = { ...editorState };
        drawTable();
        scheduleSaveState();
        status.textContent = 'Änderungen gespeichert.';
      });

      btnDelete.addEventListener('click', () => {
        const min = Math.max(0, parseInt(field.minRows || 0, 10));
        if (selectedIndex < 0) return;
        if (min && data.length <= min) return;
        data.splice(selectedIndex, 1);
        clearSelection();
        resetEditor();
        drawTable();
        scheduleSaveState();
        status.textContent = 'Zeile gelöscht.';
      });

      btnCancel.addEventListener('click', () => {
        clearSelection();
        resetEditor();
        drawTable();
        status.textContent = 'Auswahl aufgehoben.';
      });

      // append so preview appears BELOW the buttons
      container.appendChild(editorWrap);
      container.appendChild(toolbar);
      container.appendChild(status);
      container.appendChild(tableWrap);

      // initial visibility check
      applyPreviewVisibility();
    }

    function emptyRow(field){ const r={}; (field.columns||[]).forEach(c=>r[c.id]=''); return r; }

    // Debounced state save
    let __saveTimer = null;
    function scheduleSaveState() {
      clearTimeout(__saveTimer);
      __saveTimer = setTimeout(saveState, 150);
    }
    function saveState() {
      if (!currentDoc?.docId) return;
      const cleanValues = sanitizeValues(schema, values);
      window.formSuitePersist.saveState(currentDoc.docId, { schema, values: cleanValues });
    }
    function saveLS(s) { try { localStorage.setItem(STORAGE_KEY, JSON.stringify(s||{})); } catch {} }
    function loadLS() { try { return JSON.parse(localStorage.getItem(STORAGE_KEY)||'null'); } catch { return null; } }
    window.addEventListener('beforeunload', () => {
      try { if (currentDoc?.docId) saveState(); else if (schema) saveLS(schema); } catch {}
    });

    // ---------- Export (Open Form) ----------
    async function onExportFromOpenForm() {
      if (!currentDoc?.docId) { alert('No active document. Open or pick a DOCX first.'); return; }

      const canBytes = await fetchWorkingDocBytes();
      if (!canBytes) { await hardResetOpenForm('no bytes / no permission'); return; }

      const attempt = async () => {
        await ensurePy();
        const docBytes = await fetchWorkingDocBytes(); if (!docBytes) return;

        const state  = await window.formSuitePersist.loadState?.(currentDoc.docId);
        const tagMap = (state?.payload?.CRONOS_PAYLOAD?.tagMap)
                    || (state?.cronos_payload?.tagMap)
                    || (state?.CRONOS_PAYLOAD?.tagMap)
                    || (state?.tagMap)
                    || {};

        const validIds = new Set((schema?.fields || []).map(f => f.id));
        const safeValues = sanitizeValues(schema, values || {});
        const cleanTagMap = sanitizeTagMap(tagMap, validIds);

        const payload = JSON.stringify({
          title: schema?.title || 'Form',
          fields: schema?.fields || [],
          values: safeValues,
          tagMap: cleanTagMap
        });

        // 1) write CRONOS_PAYLOAD → settings.xml
        const updated = await writeDocVar(docBytes, PAYLOAD_KEY, payload);

        // 2) fill SDTs (prefer formatted string for address objects)
        const sdtMap = {};
        for (const [tag, fieldId] of Object.entries(cleanTagMap)) {
          let v = safeValues?.[fieldId];
          if (v == null) v = '';
          if (typeof v === 'object') {
            v = v.formatted ?? (function(){ try { return JSON.stringify(v); } catch { return String(v); } })();
          }
          sdtMap[tag] = String(v);
        }
        let updated2 = await writeSDTs(updated, sdtMap);

        // 3) evaluate rules → visibility map (SHOW overrides HIDE)
        const rules = loadRulesForDoc(state);
        const visibilityMap = evaluateRulesToVisibility(schema, safeValues, rules);

        // 4) apply visibility using fsHidden (non-destructive)
        if (Object.keys(visibilityMap).length) {
          updated2 = await applyVisibilityByRules(updated2, visibilityMap);
        }

        // keep OPFS in sync for the workspace
        await window.formSuitePersist.putBytes?.(currentDoc.docId, updated2);

        // 5) Save As...
        if (supportsFS && window.showSaveFilePicker) {
          try {
            const suggested = (currentDoc.name?.replace(/\.docx$/i,'') || 'document') + ' (export).docx';
            const handle = await showSaveFilePicker({
              suggestedName: suggested,
              types: [{ description: 'Word document', accept: { 'application/vnd.openxmlformats-officedocument.wordprocessingml.document': ['.docx'] } }]
            });
            const stream = await handle.createWritable(); await stream.write(updated2); await stream.close();
          } catch (e) { if (e?.name === 'AbortError') return; throw e; }
        } else {
          const blob = new Blob([updated2], { type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' });
          const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
          a.download = (currentDoc?.name||'document').replace(/\.docx$/i,' (export).docx');
          a.click(); setTimeout(() => URL.revokeObjectURL(a.href), 2000);
        }
      };

      try { await attempt(); }
      catch (e) {
        const msg = String(e?.message || e || '');
        if (msg.includes('already been destroyed') || msg.includes('proxy has been destroyed')) {
          await ensurePy(true);
          try { await attempt(); return; } catch (e2) {
            if (e2?.name === 'AbortError' || /export canceled/.test((e2?.message||'').toLowerCase())) return;
            console.error('Export failed after retry:', e2); alert('Export failed: ' + (e2?.message || e2)); return;
          }
        }
        if (e?.name === 'AbortError' || /export canceled/.test((e?.message||'').toLowerCase())) return;
        console.error('Export failed (Open Form):', e); alert('Export failed: ' + (e?.message || e));
      }
    }

    // ---------- Rules → Visibility map (SHOW supersedes HIDE) ----------
    function loadRulesForDoc(state) {
      return (
        state?.rules ||
        state?.payload?.rules ||
        state?.CRONOS_RULES ||
        state?.cronos_rules ||
        []
      );
    }

    function ruleMatchesValue(op, expected, actual) {
      const a = actual;
      if (op === 'equals')    return String(a) === String(expected);
      if (op === 'notEquals') return String(a) !== String(expected);
      if (op === 'anyOf') {
        const arr = Array.isArray(expected) ? expected.map(String) : [String(expected)];
        if (Array.isArray(a)) return a.map(String).some(v => arr.includes(v));
        return arr.includes(String(a));
      }
      if (op === 'allOf') {
        const arr = Array.isArray(expected) ? expected.map(String) : [String(expected)];
        if (!Array.isArray(a)) return false;
        const aset = new Set(a.map(String));
        return arr.every(v => aset.has(v));
      }
      if (op === 'contains') {
        return String(a ?? '').toLowerCase().includes(String(expected ?? '').toLowerCase());
      }
      return false;
    }

    function evaluateRulesToVisibility(schema, values, rules) {
      const out = Object.create(null);
      if (!Array.isArray(rules) || !rules.length) return out;

      const cleanVals = sanitizeValues(schema, values || {});
      const getVal = (fid) => cleanVals[fid];

      for (const r of rules) {
        if (!r) continue;
        const action = (String(r.action || '').toUpperCase() === 'SHOW') ? 'SHOW'
                    : (String(r.action || '').toUpperCase() === 'HIDE') ? 'HIDE'
                    : null;
        if (!action) continue;

        const fieldId = r.fieldId || r.field || r.whenField;
        const op      = r.op || r.operator || 'equals';
        const exp     = r.values ?? r.value ?? r.expected;
        const targets = Array.isArray(r.targets) ? r.targets : [];

        // New matching supporting boolean pseudo options and date ops
        let match = false;
        if (typeof fieldId === 'string' && fieldId.includes('__opt__')) {
          const [baseId, slug] = fieldId.split('__opt__');
          const raw = getVal(baseId);
          const arr = Array.isArray(raw) ? raw.map(String) : [];
          const toSlug = (s) => String(s||'')
            .normalize('NFKD')
            .replace(/[\u0300-\u036f]/g, '')
            .replace(/[^a-zA-Z0-9]+/g, '_')
            .replace(/^_+|_+$/g, '')
            .toLowerCase();
          const selected = arr.some(v => toSlug(v) === String(slug||'').replace(/^_+/,'').toLowerCase());
          const expect = Array.isArray(exp) ? exp[0] : exp;
          const expectBool = (String(expect) === 'true');
          if (op === 'equals') match = (selected === expectBool);
        } else {
          const fld = (schema?.fields||[]).find(f => String(f.id) === String(fieldId));
          const t = String(fld?.type||'').toLowerCase();
          const actual = getVal(fieldId);
          if (t === 'date') {
            const expStr = Array.isArray(exp) ? String(exp[0]||'') : String(exp||'');
            const toDay = (s) => { if (!s) return NaN; const d = new Date(s); return isNaN(d) ? NaN : Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()); };
            const a = toDay(actual);
            const b = toDay(expStr);
            if (!Number.isNaN(a) && !Number.isNaN(b)) {
              if (op === 'before') match = a < b;
              else if (op === 'after') match = a > b;
              else if (op === 'equals') match = a === b;
            }
          } else if (t === 'text' || t === 'number' || t === 'select') {
            const expVal = Array.isArray(exp) ? exp[0] : exp;
            if (op === 'equals') match = String(actual) === String(expVal);
            else if (op === 'notEquals') match = String(actual) !== String(expVal);
            else if (t === 'text' && op === 'contains') match = String(actual ?? '').toLowerCase().includes(String(expVal ?? '').toLowerCase());
          } else if (t === 'multichoice') {
            match = ruleMatchesValue(op, exp, actual);
          } else {
            match = ruleMatchesValue(op, exp, actual);
          }
        }
        if (!match) continue;

        for (const t of targets) {
          const key = t?.key ?? t?.idx ?? t?.id;
          if (key == null) continue;
          const idx = Number(key);
          if (!Number.isFinite(idx)) continue;
          const prev = out[idx];
          if (action === 'SHOW') out[idx] = 'SHOW';
          else if (action === 'HIDE' && prev !== 'SHOW') out[idx] = 'HIDE';
        }
      }
      return out;
    }

    // ---------- Field Rules (UI visibility) ----------
    function loadFieldRulesForDoc(state) {
      return (
        state?.fieldRules ||
        state?.payload?.fieldRules ||
        state?.CRONOS_FIELD_RULES ||
        state?.cronos_field_rules ||
        []
      );
    }

    function evaluateFieldRulesToVisibility(schema, values, rules) {
      const out = Object.create(null); // fieldId -> 'SHOW'|'HIDE'|'DISABLE'
      if (!Array.isArray(rules) || !rules.length) return out;

      const cleanVals = sanitizeValues(schema, values || {});
      const getVal = (fid) => cleanVals[fid];

      for (const r of rules) {
        if (!r) continue;
        const action = (String(r.action || '').toUpperCase() === 'SHOW') ? 'SHOW'
                    : (String(r.action || '').toUpperCase() === 'HIDE') ? 'HIDE'
                    : null;
        if (!action) continue;

        const fieldId = r.fieldId || r.field || r.whenField;
        const op      = r.op || r.operator || 'equals';
        const exp     = r.values ?? r.value ?? r.expected;
        const targets = Array.isArray(r.targets) ? r.targets : [];
        const effect = (String(r.hideMode||'hide').toLowerCase() === 'disable') ? 'DISABLE' : 'HIDE';

        // Support boolean pseudo-field for multichoice option: <fieldId>__opt__<slug>
        let match = false;
        if (typeof fieldId === 'string' && fieldId.includes('__opt__')) {
          const [baseId, slug] = fieldId.split('__opt__');
          const base = baseId;
          const raw = getVal(base);
          const arr = Array.isArray(raw) ? raw.map(String) : [];
          // slugify comparable
          const toSlug = (s) => String(s||'')
            .normalize('NFKD')
            .replace(/[\u0300-\u036f]/g, '')
            .replace(/[^a-zA-Z0-9]+/g, '_')
            .replace(/^_+|_+$/g, '')
            .toLowerCase();
          const selected = arr.some(v => toSlug(v) === String(slug||'').replace(/^_+/,'').toLowerCase());
          const expect = Array.isArray(exp) ? exp[0] : exp;
          const expectBool = (String(expect) === 'true');
          if (op === 'equals') match = (selected === expectBool);
        } else {
          // Resolve field type
          const fld = (schema?.fields||[]).find(f => String(f.id) === String(fieldId));
          const t = String(fld?.type||'').toLowerCase();
          const actual = getVal(fieldId);
          if (t === 'date') {
            const expStr = Array.isArray(exp) ? String(exp[0]||'') : String(exp||'');
            const toDay = (s) => { if (!s) return NaN; const d = new Date(s); return isNaN(d) ? NaN : Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()); };
            const a = toDay(actual);
            const b = toDay(expStr);
            if (Number.isNaN(a) || Number.isNaN(b)) match = false;
            else if (op === 'before') match = a < b;
            else if (op === 'after') match = a > b;
            else if (op === 'equals') match = a === b;
          } else if (t === 'text' || t === 'number') {
            const expVal = Array.isArray(exp) ? exp[0] : exp;
            if (op === 'equals') match = String(actual) === String(expVal);
            else if (op === 'notEquals') match = String(actual) !== String(expVal);
          } else if (t === 'select') {
            const expVal = Array.isArray(exp) ? exp[0] : exp;
            if (op === 'equals') match = String(actual) === String(expVal);
            else if (op === 'notEquals') match = String(actual) !== String(expVal);
          } else if (t === 'multichoice') {
            // legacy compatibility: anyOf/allOf/equals
            match = ruleMatchesValue(op, exp, actual);
          } else {
            // fallback to generic
            match = ruleMatchesValue(op, exp, actual);
          }
        }
        if (!match) continue;

        for (const t of targets) {
          const id = String(t?.id ?? t?.fieldId ?? '');
          if (!id) continue;
          const prev = out[id];
          if (action === 'SHOW') out[id] = 'SHOW';
          else if (action === 'HIDE' && prev !== 'SHOW') {
            if (prev === 'HIDE') out[id] = 'HIDE';
            else out[id] = effect; // DISABLE or HIDE
          }
        }
      }
      return out;
    }

    function applyFieldVisibility() {
      try {
        if (!schema || !Array.isArray(schema.fields)) return;
        const visMap = evaluateFieldRulesToVisibility(schema, values || {}, fieldRules || []);
        // First reset shown/enabled state
        const clearDisabled = (el) => {
          el.style.opacity = '';
          el.style.pointerEvents = '';
          el.removeAttribute('aria-disabled');
          el.querySelectorAll('input,select,textarea,button').forEach(i => { try { i.disabled = false; } catch {} });
        };
        document.querySelectorAll('.field[data-field-id]').forEach(node => { node.style.display = ''; clearDisabled(node); });
        document.querySelectorAll('.mc-item[data-opt-id]').forEach(node => { node.style.display = ''; clearDisabled(node); });
        // Apply per mapping key
        const esc = (window.CSS && CSS.escape) ? CSS.escape : (s => String(s)
          .replace(/\\/g,'\\\\')
          .replace(/"/g,'\\"')
          .replace(/\]/g,'\\]')
          .replace(/\[/g,'\\[')
        );
        // helpers to clear selections when hiding/greying
        const deselectMcItem = (mcEl) => {
          const cb = mcEl.querySelector('input[type="checkbox"][data-mc="1"]');
          if (!cb) return;
          const fid = cb.name;
          const optVal = cb.value;
          if (cb.checked) cb.checked = false;
          const arr = Array.isArray(values[fid]) ? values[fid].map(String) : [];
          const next = arr.filter(v => v !== String(optVal));
          values[fid] = next;
          scheduleSaveState();
        };
                const deselectFieldWrapper = (wrapEl) => {
          const fid = wrapEl?.dataset?.fieldId || '';
          if (!fid) return;
          const fld = (schema?.fields || []).find(f => String(f.id) === String(fid));
          const t = String(fld?.type || '').toLowerCase();
          if (t === 'multichoice') {
            wrapEl.querySelectorAll('input[type="checkbox"][data-mc="1"]').forEach(cb => { cb.checked = false; });
            values[fid] = [];
            scheduleSaveState();
          } else if (t === 'select') {
            const sel = wrapEl.querySelector('select');
            if (sel) { sel.value = ''; values[fid] = ''; scheduleSaveState(); }
          } else if (t === 'text') {
            const inp = wrapEl.querySelector('input[type="text"]:not([data-type="date"])');
            if (inp) { inp.value = ''; values[fid] = ''; scheduleSaveState(); }
          } else if (t === 'number') {
            const inp = wrapEl.querySelector('input[type="number"]');
            if (inp) { inp.value = ''; values[fid] = ''; scheduleSaveState(); }
          } else if (t === 'date') {
            const inp = wrapEl.querySelector('input[data-type="date"]');
            if (inp) {
              try { if (inp._flatpickr) inp._flatpickr.clear(); } catch {}
              inp.value = '';
              values[fid] = '';
              scheduleSaveState();
            }
          }
        };

        Object.keys(visMap || {}).forEach(id => {
          const dir = visMap[id];
          if (typeof id === 'string' && id.includes('__opt__')) {
            document.querySelectorAll(`.mc-item[data-opt-id="${esc(id)}"]`).forEach(el => {
              deselectMcItem(el);
              if (dir === 'HIDE') el.style.display = 'none';
              else { el.style.display=''; el.style.opacity = '0.5'; el.style.pointerEvents = 'none'; el.setAttribute('aria-disabled','true'); el.querySelectorAll('input,select,textarea,button').forEach(i => { try { i.disabled = true; } catch {} }); }
            });
          } else {
            document.querySelectorAll(`.field[data-field-id="${esc(id)}"]`).forEach(el => {
              deselectFieldWrapper(el);
              if (dir === 'HIDE') el.style.display = 'none';
              else { el.style.display=''; el.style.opacity = '0.5'; el.style.pointerEvents = 'none'; el.setAttribute('aria-disabled','true'); el.querySelectorAll('input,select,textarea,button').forEach(i => { try { i.disabled = true; } catch {} }); }
            });
          }
        });
      } catch (e) { /* no-op */ }
    }

    // Expose for cross-callbacks
    try { window.applyFieldVisibility = applyFieldVisibility; } catch {}

    // ---------- Bridge to Python: apply visibility using fsHidden ----------
    async function applyVisibilityByRules(bytesU8, visibilityMap) {
      if (!visibilityMap || !Object.keys(visibilityMap).length) return bytesU8;
      await ensurePy();
      const fn = py.globals.get('apply_visibility');
      const pyBytes = py.toPy(bytesU8 instanceof Uint8Array ? bytesU8 : new Uint8Array(bytesU8));
      const pyMap   = py.toPy(JSON.stringify(visibilityMap));
      let pyOut;
      try { pyOut = fn(pyBytes, pyMap); }
      finally { try{fn.destroy();}catch{} try{pyBytes.destroy();}catch{} try{pyMap.destroy();}catch{} }
      let u8;
      if (pyOut?.toJs) u8 = pyOut.toJs({ create_proxies:false });
      else if (pyOut?.getBuffer) u8 = new Uint8Array(pyOut.getBuffer());
      else u8 = new Uint8Array([]);
      try { pyOut.destroy?.(); } catch {}
      return u8;
    }

    // ---------- Logo triple-click: focus mode (kept minimal) ----------
    (function() {
      const logo = document.querySelector('header .logo');
      const header = document.querySelector('header .row');
      if (!logo || !header) return;

      let clickCount = 0;
      let clickTimer = null;
      let focusMode = false;

      logo.addEventListener('click', () => {
        clickCount++;
        clearTimeout(clickTimer);
        clickTimer = setTimeout(() => { clickCount = 0; }, 600);

        if (clickCount === 3) {
          clickCount = 0;
          focusMode = !focusMode;

          if (focusMode) {
            header.querySelectorAll('a, span.muted').forEach(el => {
              if (!el.closest('.brand')) el.style.display = 'none';
            });
            if (!location.pathname.endsWith('index.html')) {
              location.href = 'index.html';
            }
          } else {
            header.querySelectorAll('a, span.muted').forEach(el => { el.style.display = ''; });
          }
        }
      });
    })();
  </script>
</body>
</html>

