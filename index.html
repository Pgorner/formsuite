<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Form Suite — Form</title>
  <link rel="icon" href="favicon.ico" type="image/gif" sizes="32x32">
  <link rel="shortcut icon" href="favicon.ico" type="image/gif">
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/themes/material_blue.css">
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <header>
    <div class="row">
      <span class="brand logo-md">
        <img src="logo.gif" alt="Form Suite logo" class="logo" />
        <strong>Form Suite</strong>
      </span>
      <span class="muted">·</span><span class="muted">Form</span>
      <span class="muted">·</span><a href="builder.html">Form Builder</a>
      <span class="muted">·</span><a href="matcher.html">Tag Matcher</a>
      <span class="muted">·</span><a href="rules.html">Rules</a>
      <span class="muted">·</span><a href="extractor.html">Extractor</a>
    </div>
  </header>

  <main>
    <section class="panel">
      <div class="title-row"></div>
      <div class="row" style="margin-top:8px;">
        <span id="docStatus" class="muted">No active document. Open one in the <a href="extractor.html">Extractor</a>.</span>
      </div>
      <div id="permNote" class="note warn" style="display:none; margin-top:10px">
        This DOCX was opened via picker but I don’t have write permission to the original file.
        Exports will download a copy instead of writing back.
        <button id="btnRegrant" class="ghost" style="margin-left:8px">Grant write access</button>
      </div>
    </section>

    <section class="panel">
      <div id="formMount"></div>
    </section>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <script src="persistence.js"></script>
  <script src="address-autocomplete.js"></script>
  <script>
    const STORAGE_KEY = 'FORM_SCHEMA_V1';
    const PAYLOAD_KEY = 'CRONOS_PAYLOAD';
    const supportsFS = 'showSaveFilePicker' in window;

    const els = {
      docStatus: document.getElementById('docStatus'),
      formMount: document.getElementById('formMount'),
      permNote:  document.getElementById('permNote'),
      btnRegrant:document.getElementById('btnRegrant'),
    };

    let currentDoc = null, schema = null, values = {}, fieldRules = [];
    let btnExportMain = null;
    let btnExportDebug = null;
    let lastExportDebug = null;
    let exportDebugEscHandler = null;

    function clearExportDebugPanel() {
      if (exportDebugEscHandler) {
        try { document.removeEventListener('keydown', exportDebugEscHandler); } catch {}
        exportDebugEscHandler = null;
      }
      try {
        const panel = document.getElementById('exportDebugPanel');
        if (panel) panel.remove();
      } catch {}
      lastExportDebug = null;
    }

    // ---------- Status + Hard Reset ----------
    function setStatus(s) { els.docStatus.innerHTML = s; }
    async function hardResetOpenForm(reason = '') {
      try {} catch {}
      schema = null;
      values = {};
      if (els.formMount) els.formMount.innerHTML = `<div class="muted">No schema found. Create one in the <a href="builder.html">Builder</a>.</div>`;
      if (btnExportMain) btnExportMain.disabled = true;
      if (btnExportDebug) btnExportDebug.disabled = true;
      els.permNote.style.display = 'none';
      clearExportDebugPanel();
      if (reason) setStatus(`No active document (${reason}). Open one in the <a href="extractor.html">Extractor</a>.`);
      else setStatus(`No active document. Open one in the <a href="extractor.html">Extractor</a>.`);
    }

    // ---------- One Active-Doc Signal (canonical) ----------
    const ACTIVE_DOC_KEY = 'FS_ACTIVE_DOC_META'; // unified key across the app

    function readActiveDocSync() {
      // Prefer live persistence info in this tab
      const p = window.formSuitePersist?.getCurrentDocMeta?.()
             || window.formSuitePersist?.getActiveDoc?.sync?.();
      if (p?.docId) {
        const meta = { docId: p.docId, name: p.name || p.docTitle || 'document' };
        try { localStorage.setItem(ACTIVE_DOC_KEY, JSON.stringify(meta)); } catch {}
        return meta;
      }
      // Canonical LS
      try { const v = localStorage.getItem(ACTIVE_DOC_KEY); if (v) return JSON.parse(v); } catch {}
      // Legacy migration (older Extractor)
      try {
        const legacy = localStorage.getItem('FS_CURRENT_DOC_META');
        if (legacy) {
          const m = JSON.parse(legacy);
          if (m?.docId) {
            localStorage.setItem(ACTIVE_DOC_KEY, legacy);
            return m;
          }
        }
      } catch {}
      return null;
    }

    function installActiveDocListener(onChange) {
      const bcLegacy = ('BroadcastChannel' in window) ? new BroadcastChannel('form-suite-doc') : null;
      const bcCanon  = ('BroadcastChannel' in window) ? new BroadcastChannel('fs-active-doc') : null;

      function emit(meta) {
        if (meta?.docId) {
          try { localStorage.setItem(ACTIVE_DOC_KEY, JSON.stringify({ docId: meta.docId, name: meta.name })); } catch {}
        } else {
          try { localStorage.removeItem(ACTIVE_DOC_KEY); } catch {}
        }
        onChange(meta || null);
      }

      bcLegacy?.addEventListener('message', (ev) => {
        const m = ev?.data || {};
        if (m.type === 'doc-cleared') { emit(null); return; }
        if (m.type === 'doc-switched' || m.type === 'doc-updated') {
          emit((m.docId) ? { docId: m.docId, name: m.name } : readActiveDocSync());
        }
        if (m.type === 'schema-updated') {
          const meta = readActiveDocSync();
          if (meta?.docId && (!m.docId || m.docId === meta.docId)) emit(meta);
        }
      });

      bcCanon?.addEventListener('message', (ev) => {
        const m = ev?.data || {};
        if (m.type === 'active:set')   emit({ docId: m.docId, name: m.name });
        if (m.type === 'active:clear') emit(null);
        if (m.type === 'active:updated') {
          const meta = readActiveDocSync();
          if (meta?.docId) emit(meta);
        }
      });

      window.addEventListener('storage', (e) => {
        if (e.key === ACTIVE_DOC_KEY) {
          const v = e.newValue ? JSON.parse(e.newValue) : null;
          emit(v);
        }
        if (e.key === 'FS_CURRENT_DOC_META' && !localStorage.getItem(ACTIVE_DOC_KEY)) {
          const v = e.newValue ? JSON.parse(e.newValue) : null;
          if (v?.docId) {
            try { localStorage.setItem(ACTIVE_DOC_KEY, e.newValue); } catch {}
            emit(v);
          }
        }
      });
    }

    installActiveDocListener(async (meta) => {
      currentDoc = meta;
      if (!currentDoc?.docId) { await hardResetOpenForm('cleared'); return; }
      const st = await window.formSuitePersist.loadState?.(currentDoc.docId);
      schema = st?.schema || null;
      values = st?.values || {};
      fieldRules = Array.isArray(st?.fieldRules) ? st.fieldRules : [];
      if (!schema) {
        // Attempt one-time hydration from DOCX payload so Form loads without visiting Extractor
        await hydrateWorkspaceFromDocxIfEmpty();
      }
      setStatus(`Active DOCX: <span class="kbd">${currentDoc.name}</span>${schema ? '' : ' — <span class="muted">no schema yet</span>'}`);
      renderForm();
      await updateWriteAccessBanner();
    });

    // ---------- Foreground refresh (coalesced) ----------
    let __refreshLock = false;
    let __refreshPending = false;

    async function ensureActiveDocOrReset() {
      if (__refreshLock) { __refreshPending = true; return; }
      __refreshLock = true;
      try {
        currentDoc = readActiveDocSync() || currentDoc;
        if (!currentDoc?.docId) { await hardResetOpenForm('no active doc'); return; }

        const st = await window.formSuitePersist.loadState?.(currentDoc.docId);
        schema = st?.schema || null;
        values = st?.values || {};
        fieldRules = Array.isArray(st?.fieldRules) ? st.fieldRules : [];
        if (!schema) {
          await hydrateWorkspaceFromDocxIfEmpty();
        }
        setStatus(`Active DOCX: <span class="kbd">${currentDoc.name}</span>${schema ? '' : ' — <span class="muted">no schema yet</span>'}`);
        renderForm();
        await updateWriteAccessBanner();
      } catch (e) {
        console.warn('ensureActiveDocOrReset failed:', e);
      } finally {
        __refreshLock = false;
        if (__refreshPending) { __refreshPending = false; ensureActiveDocOrReset(); }
      }
    }

    document.addEventListener('visibilitychange', async () => {
      if (document.visibilityState !== 'visible') return;
      await ensureActiveDocOrReset();
    });
    window.addEventListener('focus', async () => { await ensureActiveDocOrReset(); });

    // ---------- Permission banner ----------
    async function updateWriteAccessBanner({ tryPrompt = false } = {}) {
      try {
        if (!supportsFS || !currentDoc?.docId) { els.permNote.style.display = 'none'; return 'unsupported'; }
        const h = await window.formSuitePersist.getHandle?.(currentDoc.docId);
        if (!h?.queryPermission) { els.permNote.style.display = 'none'; return 'no-handle'; }

        let p = await h.queryPermission({ mode: 'readwrite' });
        if (p !== 'granted' && tryPrompt) {
          try { p = await h.requestPermission({ mode: 'readwrite' }) || p; } catch {}
        }
        els.permNote.style.display = (p === 'granted') ? 'none' : 'block';
        return p || 'denied';
      } catch (e) {
        console.warn('updateWriteAccessBanner failed:', e);
        els.permNote.style.display = 'block';
        return 'error';
      }
    }
    els.btnRegrant?.addEventListener('click', async () => {
      const p = await updateWriteAccessBanner({ tryPrompt: true });
      if (p === 'granted') {
        await ensureActiveDocOrReset();
      }
    });

    // ---------- Pyodide (robust) ----------
    let pyLoaded = false;
    let py = null;

    async function ensurePy(forceReinit = false) {
      if (forceReinit && py && py._module) { pyLoaded = false; py = null; }
      if (!pyLoaded) {
        await new Promise((res, rej) => {
          if (window.loadPyodide) return res();
          const s = document.createElement('script');
          s.src = "https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js";
          s.onload = res; s.onerror = rej; document.head.appendChild(s);
        });
        py = await loadPyodide({ indexURL: "https://cdn.jsdelivr.net/pyodide/v0.24.1/full/" });

        await py.runPythonAsync(`
import io, zipfile, json, re
import xml.etree.ElementTree as ET

_W_NS = "http://schemas.openxmlformats.org/wordprocessingml/2006/main"
def _q(local): return "{%s}%s" % (_W_NS, local)

# ---------------------- existing helpers ----------------------
def write_docvar(u8, var_name, value):
    data = bytes(u8); outbuf = io.BytesIO()
    with zipfile.ZipFile(io.BytesIO(data), "r") as zfin, zipfile.ZipFile(outbuf,"w",compression=zipfile.ZIP_DEFLATED) as zfout:
        try: names = set(zfin.namelist())
        except: names = set()
        if "word/settings.xml" in names:
            try: root = ET.fromstring(zfin.read("word/settings.xml"))
            except ET.ParseError: root = ET.Element(_q("settings"))
        else:
            root = ET.Element(_q("settings"))
        doc_vars = root.find(_q("docVars"))
        if doc_vars is None:
            doc_vars = ET.SubElement(root, _q("docVars"))
        target = None
        for dv in doc_vars.findall(_q("docVar")):
            if dv.get(_q("name")) == var_name:
                target = dv; break
        if target is None:
            target = ET.SubElement(doc_vars, _q("docVar"), {_q("name"): var_name, _q("val"): value})
        else:
            target.set(_q("val"), value)
        settings_bytes = ET.tostring(root, encoding="utf-8", xml_declaration=True)
        for n in zfin.namelist():
            if n == "word/settings.xml": continue
            zfout.writestr(n, zfin.read(n))
        zfout.writestr("word/settings.xml", settings_bytes)
    return outbuf.getvalue()

def read_docvar_settings(u8, var_name):
    data = bytes(u8)
    with zipfile.ZipFile(io.BytesIO(data), "r") as zf:
        try:
            xml = zf.read("word/settings.xml")
        except KeyError:
            return None
        try:
            root = ET.fromstring(xml)
        except ET.ParseError:
            return None
        W_NS = "http://schemas.openxmlformats.org/wordprocessingml/2006/main"
        def _q(local):
            return "{%s}%s" % (W_NS, local)
        doc_vars = root.find(_q("docVars"))
        if doc_vars is None:
            return None
        for dv in doc_vars.findall(_q("docVar")):
            if dv.get(_q("name")) == var_name:
                return dv.get(_q("val"))
    return None

def read_docvar_custom(u8, var_name):
    data = bytes(u8)
    name = str(var_name or "")
    with zipfile.ZipFile(io.BytesIO(data), "r") as zf:
        try:
            xml = zf.read("docProps/custom.xml")
        except KeyError:
            return None
        try:
            root = ET.fromstring(xml)
        except ET.ParseError:
            return None
        ns = {
            'cp': 'http://schemas.openxmlformats.org/officeDocument/2006/custom-properties',
            'vt': 'http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes'
        }
        for prop in root.findall('cp:property', ns):
            if prop.get('name') == name:
                for child in list(prop):
                    if child.text is not None:
                        return child.text
    return None

def _set_sdt_text(content_el, value):
    texts = content_el.findall(".//w:t", {"w": _W_NS})
    if texts:
        first = True
        for t in texts:
            if first:
                t.text = value
                first = False
            else:
                t.text = ""
        return
    has_block = (content_el.find(".//w:p", {"w": _W_NS}) is not None) or (content_el.find(".//w:tbl", {"w": _W_NS}) is not None)
    for ch in list(content_el): content_el.remove(ch)
    if has_block:
        p = ET.SubElement(content_el, _q("p")); r = ET.SubElement(p, _q("r"))
    else:
        r = ET.SubElement(content_el, _q("r"))
    t = ET.SubElement(r, _q("t")); t.text = value
    if (value.strip() != value) or ("\\n" in value) or ("  " in value):
        t.set("{http://www.w3.org/XML/1998/namespace}space", "preserve")

def write_sdts_by_tag(u8, tag_to_text_json):
    try: mapping = json.loads(tag_to_text_json or "{}")
    except Exception: mapping = {}
    if not mapping: return u8
    data = bytes(u8); outbuf = io.BytesIO()
    with zipfile.ZipFile(io.BytesIO(data), "r") as zfin, zipfile.ZipFile(outbuf,"w",compression=zipfile.ZIP_DEFLATED) as zfout:
        names = zfin.namelist()
        def is_target(name):
            if not (name.startswith("word/") and name.endswith(".xml")): return False
            skip = {"word/styles.xml","word/numbering.xml","word/theme/theme1.xml","word/fontTable.xml","word/settings.xml","word/webSettings.xml"}
            return name not in skip and not name.startswith("word/_rels/")
        for n in names:
            if not is_target(n):
                zfout.writestr(n, zfin.read(n)); continue
            try:
                root = ET.fromstring(zfin.read(n))
            except ET.ParseError:
                zfout.writestr(n, zfin.read(n)); continue
            changed = False
            for sdt in root.findall(".//w:sdt", {"w": _W_NS}):
                pr = sdt.find("w:sdtPr", {"w": _W_NS})
                if pr is None: continue
                tag_el = pr.find("w:tag", {"w": _W_NS})
                tag_val = tag_el.get(_q("val")) if tag_el is not None else ""
                if not tag_val or tag_val not in mapping: continue
                content_el = sdt.find("w:sdtContent", {"w": _W_NS}) or sdt
                val = mapping.get(tag_val, "")
                if not isinstance(val, str):
                    try: val = json.dumps(val, ensure_ascii=False)
                    except Exception: val = str(val)
                _set_sdt_text(content_el, val); changed = True
            out_xml = ET.tostring(root, encoding="utf-8", xml_declaration=True) if changed else zfin.read(n)
            zfout.writestr(n, out_xml)
    return outbuf.getvalue()

# ---------- heading + block collectors ----------
_STYLE_HINT_PATTERNS = [
    re.compile(r"heading\s*([1-9])", re.IGNORECASE),
    re.compile(r"überschrift\s*([1-9])", re.IGNORECASE),
    re.compile(r"titre\s*([1-9])", re.IGNORECASE),
    re.compile(r"t[ií]tulo\s*([1-9])", re.IGNORECASE),
    re.compile(r"encabezado\s*([1-9])", re.IGNORECASE),
    re.compile(r"rubrik\s*([1-9])", re.IGNORECASE),
    re.compile(r"zagolovok\s*([1-9])", re.IGNORECASE),
    re.compile(r"заголовок\s*([1-9])", re.IGNORECASE),
]

def _level_from_style_hint(value):
    if not value:
        return 0
    s = str(value).strip()
    if not s:
        return 0
    for pattern in _STYLE_HINT_PATTERNS:
        m = pattern.search(s)
        if m:
            try:
                return int(m.group(1))
            except Exception:
                return 0
    m2 = re.match(r"^heading([1-9])$", s, re.IGNORECASE)
    if m2:
        try:
            return int(m2.group(1))
        except Exception:
            return 0
    return 0

def _build_heading_style_map(zip_file):
    try:
        raw = zip_file.read("word/styles.xml")
    except KeyError:
        return {}
    try:
        root = ET.fromstring(raw)
    except ET.ParseError:
        return {}

    by_id = {}
    for style in root.findall("w:style", {"w": _W_NS}):
        st_type = (style.get(_q("type")) or style.get("type") or "").strip().lower()
        if st_type and st_type != "paragraph":
            continue
        style_id = style.get(_q("styleId")) or style.get("styleId") or ""
        if not style_id:
            continue
        name_el = style.find(_q("name"))
        name = ""
        if name_el is not None:
            name = name_el.get(_q("val")) or name_el.get("val") or ""
        based_on_el = style.find(_q("basedOn"))
        based_on = ""
        if based_on_el is not None:
            based_on = based_on_el.get(_q("val")) or based_on_el.get("val") or ""
        lvl = 0
        ppr = style.find(_q("pPr"))
        if ppr is not None:
            ol = ppr.find(_q("outlineLvl"))
            if ol is not None:
                val = ol.get(_q("val")) or ol.get("val")
                if val not in (None, ""):
                    try:
                        num = int(val)
                        if num >= 0:
                            lvl = max(1, min(9, num + 1))
                    except Exception:
                        pass
        if not lvl:
            lvl = _level_from_style_hint(style_id) or _level_from_style_hint(name)
        by_id[style_id] = {"basedOn": based_on or "", "rawLevel": int(lvl) if lvl else 0}

    resolved = {}

    def resolve(style_id, depth=0):
        if not style_id or style_id not in by_id or depth > 12:
            return 0
        if style_id in resolved:
            return resolved[style_id]
        info = by_id[style_id]
        lvl = info.get("rawLevel") or 0
        if lvl:
            resolved[style_id] = lvl
            return lvl
        parent = resolve(info.get("basedOn") or "", depth + 1)
        resolved[style_id] = parent or 0
        return resolved[style_id]

    for style_id in list(by_id.keys()):
        resolve(style_id)

    return resolved

def _heading_level_trace(p_el, style_map=None):
    ppr = p_el.find(_q("pPr"))
    if ppr is None:
        return (None, None)
    ol = ppr.find(_q("outlineLvl"))
    if ol is not None and ol.get(_q("val")) is not None:
        try:
            raw = int(ol.get(_q("val")))
            lvl = max(1, min(9, raw + 1))
            return (lvl, f"outlineLvl:{raw}")
        except Exception:
            pass
    ps = ppr.find(_q("pStyle"))
    if ps is not None:
        style_id = ps.get(_q("val")) or ps.get("val")
        if style_id:
            if style_map:
                lvl = style_map.get(style_id)
                if isinstance(lvl, int) and lvl > 0:
                    return (lvl, f"style:{style_id}")
            v = style_id.lower()
            if v.startswith("heading"):
                try:
                    lvl = int(v.replace("heading", "").strip())
                    if lvl > 0:
                        return (lvl, f"builtin:{style_id}")
                except Exception:
                    return (None, None)
    return (None, None)

def _heading_level(p_el, style_map=None):
    lvl, _ = _heading_level_trace(p_el, style_map)
    return lvl

def _iter_blocks_within(container, top_level, style_map=None):
    for node in list(container):
        if node.tag == _q("sdt"):
            inner = node.find(_q("sdtContent"))
            if inner is not None:
                yield from _iter_blocks_within(inner, top_level, style_map)
            else:
                yield {"element": node, "type": "other", "level": None, "top": top_level}
        elif node.tag == _q("p"):
            yield {"element": node, "type": "p", "level": _heading_level(node, style_map), "top": top_level}
        elif node.tag == _q("tbl"):
            yield {"element": node, "type": "tbl", "level": None, "top": top_level}
        else:
            yield {"element": node, "type": "other", "level": None, "top": top_level}

def _collect_body_blocks(body_el, style_map=None):
    blocks = []
    for child in list(body_el):
        if child.tag == _q("sdt"):
            content = child.find(_q("sdtContent"))
            if content is not None:
                blocks.extend(_iter_blocks_within(content, child, style_map))
            else:
                blocks.append({"element": child, "type": "other", "level": None, "top": child})
        elif child.tag == _q("p"):
            blocks.append({"element": child, "type": "p", "level": _heading_level(child, style_map), "top": child})
        elif child.tag == _q("tbl"):
            blocks.append({"element": child, "type": "tbl", "level": None, "top": child})
        else:
            blocks.append({"element": child, "type": "other", "level": None, "top": child})
    return blocks

def _paragraph_plain_text(p_el):
    if p_el is None:
        return ""
    parts = []
    for t in p_el.findall(".//w:t", {"w": _W_NS}):
        if t.text:
            parts.append(t.text)
    return "".join(parts)

def inspect_export_removal_plan(u8, idx_to_action_json):
    data = bytes(u8)
    try:
        raw_actions = json.loads(idx_to_action_json or "{}")
        if not isinstance(raw_actions, dict):
            raw_actions = {}
    except Exception:
        raw_actions = {}

    normalized_actions = {}
    for k, v in raw_actions.items():
        try:
            idx = int(k)
        except Exception:
            continue
        normalized_actions[idx] = str(v).upper()

    plan = {
        "styleMap": {},
        "styleMapSize": 0,
        "hasStylesXml": False,
        "parts": [],
        "idxToAction": normalized_actions,
        "rawActions": raw_actions,
        "unmatchedActions": [],
        "totalHeadings": 0,
    }

    try:
        zf = zipfile.ZipFile(io.BytesIO(data), "r")
    except Exception as exc:
        plan["error"] = f"zip-error:{exc}"
        return json.dumps(plan, ensure_ascii=False)

    with zf as zfin:
        names = set(zfin.namelist())
        plan["hasStylesXml"] = "word/styles.xml" in names
        style_map = _build_heading_style_map(zfin)
        plan["styleMap"] = style_map
        plan["styleMapSize"] = len(style_map)

        doc_parts = [n for n in names if n == "word/document.xml"]
        global_idx = 0
        seen_indices = set()

        for part in doc_parts:
            info = {
                "name": part,
                "headings": [],
                "removalRanges": [],
                "blockCount": 0,
                "errors": [],
            }
            try:
                raw = zfin.read(part)
            except KeyError:
                info["errors"].append("missing-part")
                plan["parts"].append(info)
                continue
            try:
                root = ET.fromstring(raw)
            except ET.ParseError as exc:
                info["errors"].append(f"parse-error:{exc}")
                plan["parts"].append(info)
                continue
            body = root.find(_q("body"))
            if body is None:
                info["errors"].append("no-body")
                plan["parts"].append(info)
                continue

            elems = _collect_body_blocks(body, style_map)
            info["blockCount"] = len(elems)

            heading_positions = []

            for pos, blk in enumerate(elems):
                if blk.get("type") != "p":
                    continue
                lvl = blk.get("level")
                if not isinstance(lvl, int) or lvl <= 0:
                    continue
                idx = global_idx
                global_idx += 1
                trace_lvl, reason = _heading_level_trace(blk.get("element"), style_map)
                if isinstance(trace_lvl, int) and trace_lvl > 0:
                    lvl = trace_lvl
                heading_positions.append((pos, lvl, idx))
                heading_info = {
                    "idx": idx,
                    "level": lvl,
                    "position": pos,
                    "text": _paragraph_plain_text(blk.get("element")),
                    "action": normalized_actions.get(idx),
                    "detectedBy": reason or "",
                }
                info["headings"].append(heading_info)
                seen_indices.add(idx)

            for h_i, (pos, lvl, idx) in enumerate(heading_positions):
                if normalized_actions.get(idx) != "HIDE":
                    continue
                end = len(elems)
                for j in range(h_i + 1, len(heading_positions)):
                    np, nl, _ = heading_positions[j]
                    if nl <= lvl:
                        end = np
                        break
                removal = {
                    "idx": idx,
                    "level": lvl,
                    "startBlock": pos,
                    "endBlock": end,
                    "blockCount": max(0, end - pos),
                }
                for h in info["headings"]:
                    if h.get("idx") == idx:
                        removal["headingText"] = h.get("text")
                        break
                info["removalRanges"].append(removal)

            plan["parts"].append(info)

        plan["totalHeadings"] = global_idx
        unmatched = []
        for idx in sorted(normalized_actions.keys()):
            if idx not in seen_indices:
                unmatched.append(idx)
        plan["unmatchedActions"] = unmatched

    return json.dumps(plan, ensure_ascii=False)

def _paragraph_plain_text(p_el):
    if p_el is None:
        return ""
    parts = []
    for t in p_el.findall(".//w:t", {"w": _W_NS}):
        if t.text:
            parts.append(t.text)
    return "".join(parts)

def inspect_export_removal_plan(u8, idx_to_action_json):
    data = bytes(u8)
    try:
        raw_actions = json.loads(idx_to_action_json or "{}")
        if not isinstance(raw_actions, dict):
            raw_actions = {}
    except Exception:
        raw_actions = {}

    normalized_actions = {}
    for k, v in raw_actions.items():
        try:
            idx = int(k)
        except Exception:
            continue
        normalized_actions[idx] = str(v).upper()

    plan = {
        "styleMap": {},
        "styleMapSize": 0,
        "hasStylesXml": False,
        "parts": [],
        "idxToAction": normalized_actions,
        "rawActions": raw_actions,
        "unmatchedActions": [],
        "totalHeadings": 0,
    }

    try:
        zf = zipfile.ZipFile(io.BytesIO(data), "r")
    except Exception as exc:
        plan["error"] = f"zip-error:{exc}"
        return json.dumps(plan, ensure_ascii=False)

    with zf as zfin:
        names = set(zfin.namelist())
        plan["hasStylesXml"] = "word/styles.xml" in names
        style_map = _build_heading_style_map(zfin)
        plan["styleMap"] = style_map
        plan["styleMapSize"] = len(style_map)

        doc_parts = [n for n in names if n == "word/document.xml"]
        global_idx = 0
        seen_indices = set()

        for part in doc_parts:
            info = {
                "name": part,
                "headings": [],
                "removalRanges": [],
                "blockCount": 0,
                "errors": [],
            }
            try:
                raw = zfin.read(part)
            except KeyError:
                info["errors"].append("missing-part")
                plan["parts"].append(info)
                continue
            try:
                root = ET.fromstring(raw)
            except ET.ParseError as exc:
                info["errors"].append(f"parse-error:{exc}")
                plan["parts"].append(info)
                continue
            body = root.find(_q("body"))
            if body is None:
                info["errors"].append("no-body")
                plan["parts"].append(info)
                continue

            elems = _collect_body_blocks(body, style_map)
            info["blockCount"] = len(elems)

            heading_positions = []

            for pos, blk in enumerate(elems):
                if blk.get("type") != "p":
                    continue
                lvl = blk.get("level")
                if not isinstance(lvl, int) or lvl <= 0:
                    continue
                idx = global_idx
                global_idx += 1
                trace_lvl, reason = _heading_level_trace(blk.get("element"), style_map)
                if isinstance(trace_lvl, int) and trace_lvl > 0:
                    lvl = trace_lvl
                heading_positions.append((pos, lvl, idx))
                heading_info = {
                    "idx": idx,
                    "level": lvl,
                    "position": pos,
                    "text": _paragraph_plain_text(blk.get("element")),
                    "action": normalized_actions.get(idx),
                    "detectedBy": reason or "",
                }
                info["headings"].append(heading_info)
                seen_indices.add(idx)

            for h_i, (pos, lvl, idx) in enumerate(heading_positions):
                if normalized_actions.get(idx) != "HIDE":
                    continue
                end = len(elems)
                for j in range(h_i + 1, len(heading_positions)):
                    np, nl, _ = heading_positions[j]
                    if nl <= lvl:
                        end = np
                        break
                removal = {
                    "idx": idx,
                    "level": lvl,
                    "startBlock": pos,
                    "endBlock": end,
                    "blockCount": max(0, end - pos),
                }
                for h in info["headings"]:
                    if h.get("idx") == idx:
                        removal["headingText"] = h.get("text")
                        break
                info["removalRanges"].append(removal)

            plan["parts"].append(info)

        plan["totalHeadings"] = global_idx
        unmatched = []
        for idx in sorted(normalized_actions.keys()):
            if idx not in seen_indices:
                unmatched.append(idx)
        plan["unmatchedActions"] = unmatched

    return json.dumps(plan, ensure_ascii=False)

def _paragraph_plain_text(p_el):
    if p_el is None:
        return ""
    parts = []
    for t in p_el.findall(".//w:t", {"w": _W_NS}):
        if t.text:
            parts.append(t.text)
    return "".join(parts)

def inspect_export_removal_plan(u8, idx_to_action_json):
    data = bytes(u8)
    try:
        raw_actions = json.loads(idx_to_action_json or "{}")
        if not isinstance(raw_actions, dict):
            raw_actions = {}
    except Exception:
        raw_actions = {}

    normalized_actions = {}
    for k, v in raw_actions.items():
        try:
            idx = int(k)
        except Exception:
            continue
        normalized_actions[idx] = str(v).upper()

    plan = {
        "styleMap": {},
        "styleMapSize": 0,
        "hasStylesXml": False,
        "parts": [],
        "idxToAction": normalized_actions,
        "rawActions": raw_actions,
        "unmatchedActions": [],
        "totalHeadings": 0,
    }

    try:
        zf = zipfile.ZipFile(io.BytesIO(data), "r")
    except Exception as exc:
        plan["error"] = f"zip-error:{exc}"
        return json.dumps(plan, ensure_ascii=False)

    with zf as zfin:
        names = set(zfin.namelist())
        plan["hasStylesXml"] = "word/styles.xml" in names
        style_map = _build_heading_style_map(zfin)
        plan["styleMap"] = style_map
        plan["styleMapSize"] = len(style_map)

        doc_parts = [n for n in names if n == "word/document.xml"]
        global_idx = 0
        seen_indices = set()

        for part in doc_parts:
            info = {
                "name": part,
                "headings": [],
                "removalRanges": [],
                "blockCount": 0,
                "errors": [],
            }
            try:
                raw = zfin.read(part)
            except KeyError:
                info["errors"].append("missing-part")
                plan["parts"].append(info)
                continue
            try:
                root = ET.fromstring(raw)
            except ET.ParseError as exc:
                info["errors"].append(f"parse-error:{exc}")
                plan["parts"].append(info)
                continue
            body = root.find(_q("body"))
            if body is None:
                info["errors"].append("no-body")
                plan["parts"].append(info)
                continue

            elems = _collect_body_blocks(body, style_map)
            info["blockCount"] = len(elems)

            heading_positions = []

            for pos, blk in enumerate(elems):
                if blk.get("type") != "p":
                    continue
                lvl = blk.get("level")
                if not isinstance(lvl, int) or lvl <= 0:
                    continue
                idx = global_idx
                global_idx += 1
                trace_lvl, reason = _heading_level_trace(blk.get("element"), style_map)
                if isinstance(trace_lvl, int) and trace_lvl > 0:
                    lvl = trace_lvl
                heading_positions.append((pos, lvl, idx))
                heading_info = {
                    "idx": idx,
                    "level": lvl,
                    "position": pos,
                    "text": _paragraph_plain_text(blk.get("element")),
                    "action": normalized_actions.get(idx),
                    "detectedBy": reason or "",
                }
                info["headings"].append(heading_info)
                seen_indices.add(idx)

            for h_i, (pos, lvl, idx) in enumerate(heading_positions):
                if normalized_actions.get(idx) != "HIDE":
                    continue
                end = len(elems)
                for j in range(h_i + 1, len(heading_positions)):
                    np, nl, _ = heading_positions[j]
                    if nl <= lvl:
                        end = np
                        break
                removal = {
                    "idx": idx,
                    "level": lvl,
                    "startBlock": pos,
                    "endBlock": end,
                    "blockCount": max(0, end - pos),
                }
                for h in info["headings"]:
                    if h.get("idx") == idx:
                        removal["headingText"] = h.get("text")
                        break
                info["removalRanges"].append(removal)

            plan["parts"].append(info)

        plan["totalHeadings"] = global_idx
        unmatched = []
        for idx in sorted(normalized_actions.keys()):
            if idx not in seen_indices:
                unmatched.append(idx)
        plan["unmatchedActions"] = unmatched

    return json.dumps(plan, ensure_ascii=False)

# ---------- removal/backup/cleanup helpers ----------
def _is_empty_para(p):
    if p.findall(".//w:fldSimple", {"w": _W_NS}): return False
    if p.findall(".//w:drawing", {"w": _W_NS}): return False
    if p.findall(".//w:object",  {"w": _W_NS}): return False
    if p.findall(".//w:pict",    {"w": _W_NS}): return False
    ts = p.findall(".//w:t", {"w": _W_NS})
    return all(((t.text or "").strip() == "") for t in ts)

def _has_page_break_run(p):
    for br in p.findall(".//w:br", {"w": _W_NS}):
        t = br.get(_q("type"))
        if (t or "").lower() == "page":
            return True
    return False

def _has_page_break_before(p):
    pPr = p.find(_q("pPr"))
    if pPr is None: return False
    return pPr.find(_q("pageBreakBefore")) is not None

def _compact_whitespace(root):
    body = root.find(_q("body")) or root
    # remove empty paragraphs unless they carry a page break
    for node in list(body):
        if node.tag == _q("p"):
            keep_for_page = _has_page_break_run(node) or _has_page_break_before(node)
            if (not keep_for_page) and _is_empty_para(node):
                try: body.remove(node)
                except: pass
    # collapse duplicate page-break-only paras
    def _is_pure_pb(p):
        if p.tag != _q("p"): return False
        if not _has_page_break_run(p): return False
        ts = p.findall(".//w:t", {"w": _W_NS})
        return all(((t.text or "").strip() == "") for t in ts)
    prev_pb = False
    for node in list(body):
        if _is_pure_pb(node):
            if prev_pb:
                try: body.remove(node)
                except: pass
            else:
                prev_pb = True
        else:
            prev_pb = False

def _prune_empty_sdts(root):
    # best-effort: remove SDTs whose content has only empty paragraphs (no tables)
    for sdt in list(root.findall(".//w:sdt", {"w": _W_NS})):
        content = sdt.find(_q("sdtContent"))
        if content is None:
            continue
        if content.find(".//w:tbl", {"w": _W_NS}) is not None:
            continue
        keep = False
        for p in content.findall(".//w:p", {"w": _W_NS}):
            if not _is_empty_para(p):
                keep = True
                break
        if not keep:
            # remove sdt by scanning parent
            removed = False
            for cand in root.iter():
                for ch in list(cand):
                    if ch is sdt:
                        try: cand.remove(ch); removed = True
                        except: pass
                        break
                if removed: break

def _prune_dead_tables(root):
    for tbl in list(root.findall(".//w:tbl", {"w": _W_NS})):
        trs = tbl.findall(".//w:tr", {"w": _W_NS})
        has_cell = False
        for tr in trs:
            if tr.find(".//w:tc", {"w": _W_NS}) is not None:
                has_cell = True; break
        if not has_cell:
            # remove this <w:tbl>
            removed = False
            for cand in root.iter():
                for ch in list(cand):
                    if ch is tbl:
                        try: cand.remove(ch); removed = True
                        except: pass
                        break
                if removed: break

def _ensure_backup_embedded(zfin, zfout, names, backup_path="customXml/originalDocument.xml", override_bytes=None):
    if backup_path in names:
        # Already present → keep existing backup to preserve the untouched original
        return
    if override_bytes is not None:
        try:
            zfout.writestr(backup_path, override_bytes)
        except Exception:
            pass
        return
    try:
        orig = zfin.read("word/document.xml")
        zfout.writestr(backup_path, orig)
    except KeyError:
        pass

def restore_document_from_backup(u8, backup_path="customXml/originalDocument.xml"):
    data = bytes(u8)
    with zipfile.ZipFile(io.BytesIO(data), "r") as zfin:
        try:
            original = zfin.read(backup_path)
        except KeyError:
            return data
        outbuf = io.BytesIO()
        with zipfile.ZipFile(outbuf, "w", compression=zipfile.ZIP_DEFLATED) as zfout:
            for name in zfin.namelist():
                if name == "word/document.xml":
                    continue
                zfout.writestr(name, zfin.read(name))
            zfout.writestr("word/document.xml", original)
    return outbuf.getvalue()

def _ensure_update_fields(zfin, zfout):
    try:
        raw = zfin.read("word/settings.xml")
        try:
            root = ET.fromstring(raw)
        except ET.ParseError:
            root = ET.Element(_q("settings"))
    except KeyError:
        root = ET.Element(_q("settings"))

    upd = root.find(_q("updateFields"))
    if upd is None:
        upd = ET.SubElement(root, _q("updateFields"))
    upd.set(_q("val"), "true")

    zfout.writestr("word/settings.xml", ET.tostring(root, encoding="utf-8", xml_declaration=True))

def _extract_part_from_bytes(data_like, part_name):
    if data_like is None:
        return None
    try:
        data = bytes(data_like)
    except Exception:
        return None
    try:
        with zipfile.ZipFile(io.BytesIO(data), "r") as zf:
            return zf.read(part_name)
    except Exception:
        return None

# ----- TOC minimal rebuild -----
def _next_in_doc_order(node, root):
    if node is None: return None
    found = False
    for el in root.iter():
        if found: return el
        if el is node: found = True
    return None

def _find_toc_ranges(root):
    ranges = []
    body = root.find(_q("body")) or root
    fldChars = root.findall(".//w:fldChar", {"w": _W_NS})
    for begin in fldChars:
        if begin.get(_q("val")) != "begin":
            continue
        cur = begin
        instr = ""
        separate = None
        end = None
        while True:
            cur = _next_in_doc_order(cur, body)
            if cur is None: break
            if cur.tag == _q("instrText"): instr += (cur.text or "")
            if cur.tag == _q("fldChar"):
                v = cur.get(_q("val"))
                if v == "separate": separate = cur
                if v == "end":
                    end = cur
                    break
        u = (instr or "").strip().upper()
        if u.startswith("TOC"):
            if separate is not None and end is not None:
                ranges.append((begin, separate, end, instr))
    return ranges

def _rebuild_toc(root): 
    # Replace existing complex range with a minimal fldSimple paragraph
    for (begin, separate, end, instr) in _find_toc_ranges(root):
        switches = (instr.strip() if instr else r'TOC \\o "1-3" \\h \\z \\u')
        # locate host paragraph of 'begin'
        host_p = None
        for par in root.findall(".//w:p", {"w": _W_NS}):
            for el in par.iter():
                if el is begin:
                    host_p = par; break
            if host_p is not None: break
        if host_p is None: continue
        # parent of host_p
        parent = None
        for cand in root.iter():
            for ch in list(cand):
                if ch is host_p:
                    parent = cand; break
            if parent is not None: break
        if parent is None: continue

        # new paragraph with simple TOC field
        p = ET.Element(_q("p"))
        fld = ET.SubElement(p, _q("fldSimple"), {_q("instr"): switches})
        r = ET.SubElement(fld, _q("r")); ET.SubElement(r, _q("t")).text = ""

        idx = list(parent).index(host_p)
        parent.insert(idx, p)

        # remove host_p and following siblings up to node that contains 'end'
        # Simplest: rebuild parent's children excluding nodes that belong to the TOC range
        new_children = []
        skipping = False
        end_reached = False
        for ch in list(parent):
            if not skipping and ch is host_p:
                skipping = True
                continue
            if skipping:
                hit_end = False
                for el in ch.iter():
                    if el is end:
                        hit_end = True; break
                if hit_end:
                    skipping = False
                    end_reached = True
                    continue
                else:
                    continue
            new_children.append(ch)
        # replace
        for ch in list(parent): parent.remove(ch)
        for ch in new_children: parent.append(ch)

# ---------- CORE: remove ranges & embed backup ----------
def apply_removal_with_backup(u8, idx_to_action_json, backup_path="customXml/originalDocument.xml", original_bytes=None):
    """
    idx_to_action_json: {"12":"HIDE","13":"SHOW", ...}
      - For headings where action == "HIDE": remove [heading .. next heading with <= level)
      - Embed original as customXml/originalDocument.xml (if not already present)
      - Cleanup empty SDTs, dead tables, whitespace
      - Rebuild TOC (minimal fldSimple form)
    """
    try:
        idx_to_action = {int(k): v for (k, v) in json.loads(idx_to_action_json).items()}
    except Exception:
        idx_to_action = {}

    data = bytes(u8)
    override_backup = _extract_part_from_bytes(original_bytes, "word/document.xml")
    outbuf = io.BytesIO()

    with zipfile.ZipFile(io.BytesIO(data), "r") as zfin, \
         zipfile.ZipFile(outbuf, "w", compression=zipfile.ZIP_DEFLATED) as zfout:

        names = zfin.namelist()
        # Copy everything first
        for n in names:
            zfout.writestr(n, zfin.read(n))

        # Ensure embedded backup exists (using untouched original if provided)
        _ensure_backup_embedded(zfin, zfout, names, backup_path=backup_path, override_bytes=override_backup)

        # Process primary document (you can extend to headers/footers if needed)
        doc_parts = [n for n in names if n == "word/document.xml"]
        style_map = _build_heading_style_map(zfin)

        global_idx = 0
        for part in doc_parts:
            try:
                root = ET.fromstring(zfin.read(part))
            except ET.ParseError:
                continue

            body = root.find(_q("body"))
            if body is None:
                zfout.writestr(part, ET.tostring(root, encoding="utf-8", xml_declaration=True))
                continue

            elems = _collect_body_blocks(body, style_map)

            heading_positions = []
            for i, blk in enumerate(elems):
                if blk.get("type") != "p":
                    continue
                lvl = blk.get("level")
                if not isinstance(lvl, int) or lvl <= 0:
                    continue
                idx = global_idx
                global_idx += 1
                heading_positions.append((i, lvl, idx))

            to_remove_top_nodes = set()
            for h_i, (pos, lvl, idx) in enumerate(heading_positions):
                if idx_to_action.get(idx) != "HIDE":
                    continue
                # compute end boundary
                if h_i + 1 < len(heading_positions):
                    end = len(elems)
                    for j in range(h_i + 1, len(heading_positions)):
                        np, nl, _ = heading_positions[j]
                        if nl <= lvl:
                            end = np
                            break
                else:
                    end = len(elems)
                # gather distinct top nodes to remove (no duplicates)
                seen = set()
                for j in range(pos, end):
                    top = elems[j].get("top")
                    if top is None: continue
                    k = id(top)
                    if k in seen: continue
                    seen.add(k)
                    to_remove_top_nodes.add(top)

            # Remove nodes by scanning parents (xml.etree has no getparent)
            if to_remove_top_nodes:
                for cand in root.iter():
                    for ch in list(cand):
                        if ch in to_remove_top_nodes:
                            try: cand.remove(ch)
                            except: pass

            # Cleanup & TOC rebuild
            _prune_empty_sdts(root)
            _prune_dead_tables(root)
            _compact_whitespace(root)
            _rebuild_toc(root)

            zfout.writestr(part, ET.tostring(root, encoding="utf-8", xml_declaration=True))

        # Align settings with Word expectations (updateFields must be true)
        _ensure_update_fields(zfin, zfout)

    return outbuf.getvalue()
`);

        pyLoaded = true;
      }
    }

    // Minimal readers for CRONOS_PAYLOAD using pyodide helpers
    async function readDocVarSettings(arrayBufferOrBytes, name) {
      await ensurePy();
      const u8in = arrayBufferOrBytes instanceof Uint8Array ? arrayBufferOrBytes : new Uint8Array(arrayBufferOrBytes);
      const fn = py.globals.get('read_docvar_settings');
      const pyBytes = py.toPy(u8in);
      let pyOut;
      try { pyOut = fn(pyBytes, name); }
      finally { try{fn.destroy();}catch{} try{pyBytes.destroy();}catch{} }
      let txt = null;
      if (pyOut && typeof pyOut.toJs === 'function') txt = pyOut.toJs({ create_proxies:false });
      else txt = pyOut ?? null;
      try { pyOut?.destroy?.(); } catch {}
      return txt;
    }

    async function readDocVarCustom(arrayBufferOrBytes, name) {
      await ensurePy();
      const u8in = arrayBufferOrBytes instanceof Uint8Array ? arrayBufferOrBytes : new Uint8Array(arrayBufferOrBytes);
      const fn = py.globals.get('read_docvar_custom');
      const pyBytes = py.toPy(u8in);
      let pyOut;
      try { pyOut = fn(pyBytes, name); }
      finally { try{fn.destroy();}catch{} try{pyBytes.destroy();}catch{} }
      let txt = null;
      if (pyOut && typeof pyOut.toJs === 'function') txt = pyOut.toJs({ create_proxies:false });
      else txt = pyOut ?? null;
      try { pyOut?.destroy?.(); } catch {}
      return txt;
    }

    // PAYLOAD_KEY is defined earlier in this script
    // Lightweight JSZip-based payload reader (no Pyodide dependency on index)
    async function ensureJSZip(){
      if (window.JSZip) return;
      await new Promise((res, rej) => {
        const s = document.createElement('script');
        s.src = 'https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js';
        s.onload = res; s.onerror = rej; document.head.appendChild(s);
      });
    }

    async function readPayloadFromDocx(bytes){
      try {
        await ensureJSZip();
        const zip = await window.JSZip.loadAsync(bytes);
        // Try settings.xml → w:docVars/w:docVar
        const settings = zip.file('word/settings.xml');
        if (settings) {
          const xmlText = await settings.async('string');
          const parser = new DOMParser();
          const xml = parser.parseFromString(xmlText, 'application/xml');
          const W_NS = 'http://schemas.openxmlformats.org/wordprocessingml/2006/main';
          const docVars = xml.getElementsByTagNameNS(W_NS, 'docVars')[0];
          if (docVars) {
            const vars = docVars.getElementsByTagNameNS(W_NS, 'docVar');
            for (let i = 0; i < vars.length; i++) {
              const dv = vars[i];
              const name = dv.getAttributeNS(W_NS, 'name') || dv.getAttribute('w:name') || dv.getAttribute('name');
              if (name === PAYLOAD_KEY) {
                const val = dv.getAttributeNS(W_NS, 'val') || dv.getAttribute('w:val') || dv.getAttribute('val') || '';
                return val || null;
              }
            }
          }
        }
        // Fallback: docProps/custom.xml → cp:property[name=PAYLOAD_KEY]
        const custom = zip.file('docProps/custom.xml');
        if (custom) {
          const xmlText = await custom.async('string');
          const parser = new DOMParser();
          const xml = parser.parseFromString(xmlText, 'application/xml');
          const props = xml.getElementsByTagName('property');
          for (let i = 0; i < props.length; i++) {
            const p = props[i];
            const nm = p.getAttribute('name');
            if (nm === PAYLOAD_KEY) {
              const child = p.firstElementChild;
              return child && child.textContent ? child.textContent : null;
            }
          }
        }
      } catch (e) { console.warn('readPayloadFromDocx failed', e); }
      return null;
    }

    let __hydrating = false;
    async function hydrateWorkspaceFromDocxIfEmpty() {
      try {
        if (__hydrating) return false;
        if (!currentDoc?.docId) return false;

        const st = await window.formSuitePersist.loadState?.(currentDoc.docId);
        const hasSchema = Array.isArray(st?.schema?.fields) && st.schema.fields.length > 0;
        if (hasSchema) return false; // nothing to do

        setStatus('Restoring from document…');
        const bytes = await fetchWorkingDocBytes();
        if (!bytes) return false;

        __hydrating = true;

        let payloadRaw = await readPayloadFromDocx(bytes);
        if (!payloadRaw) return false;

        let payload = null;
        try { payload = JSON.parse(payloadRaw); } catch { payload = null; }

        if (!payload || !Array.isArray(payload.fields) || !payload.fields.length) return false;

        // Build next schema/values
        const nextSchema = { title: payload.title || 'Form', fields: payload.fields };
        const cleanValues = sanitizeValues(nextSchema, payload.values || {});
        const tagMap = payload.tagMap || {};

        // Read BOTH rule sets (be tolerant of legacy key names/typos)
        const rules =
          Array.isArray(payload.rules) ? payload.rules :
          Array.isArray(payload.headingRules) ? payload.headingRules : [];

        const fieldRules =
          Array.isArray(payload.fieldRules) ? payload.fieldRules :
          Array.isArray(payload.fieldsRules) ? payload.fieldsRules : []; // legacy guard

        // Persist complete state back into workspace
        await window.formSuitePersist.saveState(currentDoc.docId, {
          schema: nextSchema,
          values: cleanValues,
          tagMap,
          rules,
          fieldRules,
          schemaUpdatedAt: new Date().toISOString()
        });

        // refresh local variables + UI
        schema = nextSchema;
        values = cleanValues;
        renderForm();
        setStatus(`Active DOCX: <span class="kbd">${currentDoc.name}</span>`);
        return true;
      } catch (e) {
        console.warn('hydrateWorkspaceFromDocxIfEmpty failed:', e);
        return false;
      } finally {
        __hydrating = false;
      }
    }

    async function writeDocVar(bytes, name, value) {
      await ensurePy();
      const fn = py.globals.get('write_docvar');
      const pyBytes = py.toPy(new Uint8Array(bytes));
      let pyOut;
      try { pyOut = fn(pyBytes, name, value); }
      finally { try{fn.destroy();}catch{} try{pyBytes.destroy();}catch{} }
      let u8;
      if (pyOut?.toJs) u8 = pyOut.toJs({ create_proxies:false });
      else if (pyOut?.getBuffer) u8 = new Uint8Array(pyOut.getBuffer());
      else u8 = new Uint8Array([]);
      try { pyOut.destroy?.(); } catch {}
      return u8;
    }

    async function writeSDTs(arrayBufferOrBytes, tagToTextObj) {
      await ensurePy();
      const u8in = arrayBufferOrBytes instanceof Uint8Array ? arrayBufferOrBytes : new Uint8Array(arrayBufferOrBytes);
      const fn = py.globals.get('write_sdts_by_tag');
      const pyBytes = py.toPy(u8in);
      const pyMap   = py.toPy(JSON.stringify(tagToTextObj || {}));
      let pyOut;
      try { pyOut = fn(pyBytes, pyMap); }
      finally { try{fn.destroy();}catch{} try{pyBytes.destroy();}catch{} try{pyMap.destroy();}catch{} }
      let u8;
      if (pyOut?.toJs) u8 = pyOut.toJs({ create_proxies:false });
      else if (pyOut?.getBuffer) u8 = new Uint8Array(pyOut.getBuffer());
      else u8 = new Uint8Array([]);
      try { pyOut.destroy?.(); } catch {}
      return u8;
    }

    // ---------- Helpers: sanitize ----------
    function sanitizeValues(schema, vals) {
      const out = {};
      const fields = Array.isArray(schema?.fields) ? schema.fields : [];

      for (const f of fields) {
        const id = f.id;
        let v = vals?.[id];

        if (f.type === 'datediff') {
          const d = vals?.[id];
          if (d && typeof d === 'object') {
            const outObj = {
              days: Number(d.days ?? 0),
              months: Number(d.months ?? 0),
              years: Number(d.years ?? 0),
              formatted: String(d.formatted ?? '')
            };
            if (outObj.formatted) out[id] = outObj;
          } else if (Number.isFinite(Number(d))) {
            const n = Number(d);
            out[id] = { days: n, months: 0, years: 0, formatted: `${n}-0-0 (${n})` };
          }
          continue;
        }

        if (f.type === 'address') {
          const vv = vals?.[id];
          if (typeof vv === 'string') {
            const s = vv.trim();
            if (s || f.required) out[id] = s ? { formatted: s } : { formatted: '' };
          } else if (vv && typeof vv === 'object') {
            const o = {
              formatted: vv.formatted || '',
              street: vv.street || '',
              houseNumber: vv.houseNumber || '',
              postcode: vv.postcode || '',
              city: vv.city || '',
              country: vv.country || '',
              lat: (vv.lat ?? null),
              lon: (vv.lon ?? null)
            };
            if (o.formatted || f.required) out[id] = o;
          }
          continue;
        }

        if (f.type === 'multichoice') {
          let arr = Array.isArray(v) ? v.slice() : (typeof v === 'string' ? v.split(',') : []);
          arr = arr.map(x => String(x).trim()).filter(Boolean);

          let allowed = null;
          if (Array.isArray(f.options) && f.options.length) {
            allowed = new Set(
              f.options.map(o => (o && typeof o === 'object')
                ? String(o.value ?? o.label ?? '')
                : String(o)
              )
            );
          } else if (f.mc && Array.isArray(f.mc.groups)) {
            allowed = new Set(
              f.mc.groups.flatMap(g => (g.items || []).map(it => String((it?.value ?? it?.label ?? ''))))
            );
          }
          if (allowed) arr = arr.filter(x => allowed.has(String(x)));
          if (arr.length) out[id] = arr;
          else if (f.required) out[id] = [];

          if (f.mc && Array.isArray(f.mc.groups)) {
            for (const g of f.mc.groups) {
              for (const it of (g.items || [])) {
                const optVal = String(it?.value || '');
                const extras = Array.isArray(it?.fields) ? it.fields : [];
                for (const ex of extras) {
                  const exId = String(ex?.id || '');
                  if (!exId) continue;
                  const k = mcExtraKey(f.id, optVal, exId);
                  const raw = vals?.[k];

                  if (ex.type === 'date') {
                    const s = String(raw ?? '');
                    if (s) out[k] = s;
                    continue;
                  }

                  if (ex.type === 'number') {
                    if (raw === '' || raw == null) continue;
                    const num = (typeof raw === 'number') ? raw : Number(String(raw).replace(',', '.'));
                    if (Number.isFinite(num)) out[k] = num;
                    continue;
                  }

                  if (ex.type === 'datediff') {
                    if (raw && typeof raw === 'object' && typeof raw.days !== 'undefined') {
                      const o = {
                        days: Number(raw.days ?? 0),
                        months: Number(raw.months ?? 0),
                        years: Number(raw.years ?? 0),
                        formatted: String(raw.formatted ?? '')
                      };
                      if (o.formatted) out[k] = o;
                    }
                    continue;
                  }

                  const s = String(raw ?? '');
                  if (s) out[k] = s;
                }
              }
            }
          }
          continue;
        }

        if (f.type === 'select') {
          let s = Array.isArray(v) ? String(v[0] ?? '') : String(v ?? '');
          if (Array.isArray(f.options) && f.options.length) {
            const allowed = new Set(f.options.map(String));
            if (!allowed.has(s)) s = '';
          }
          if (s === '') { if (f.required) out[id] = s; }
          else out[id] = s;
          continue;
        }

        if (f.type === 'number') {
          if (v === '' || v == null) continue;
          const num = (typeof v === 'number') ? v : Number(String(v).replace(',', '.'));
          if (Number.isFinite(num)) out[id] = num;
          continue;
        }

        if (f.type === 'date') { out[id] = String(v ?? ''); continue; }

        if (f.type === 'table') {
          const cols = Array.isArray(f.columns) ? f.columns : [];
          const colIds = cols.map(c => c.id);
          const arr = Array.isArray(v) ? v : [];
          const cleaned = arr.map(row => {
            const o = {};
            for (const cid of colIds) {
              let cell = row?.[cid];
              if (cell == null) cell = '';
              o[cid] = (typeof cell === 'string') ? cell : String(cell);
            }
            return o;
          }).filter(r => Object.values(r).some(val => String(val).trim() !== ''));
          const min = Math.max(0, parseInt(f.minRows || 0, 10));
          while (cleaned.length < min) {
            const empty = {}; colIds.forEach(cid => empty[cid] = '', cleaned.push(empty));
          }
          if (cleaned.length) out[id] = cleaned;
          else if (f.required) out[id] = [];
          continue;
        }

        const s = String(v ?? '');
        if (s || f.required) out[id] = s;
      }

      return out;
    }

    function sanitizeTagMap(tagMap, validIds) {
      const out = {};
      for (const [tag, fid] of Object.entries(tagMap || {})) {
        if (validIds.has(fid)) out[tag] = fid;
      }
      return out;
    }

    // ---------- Init ----------
    init().catch(console.error);

    async function init() {
      currentDoc = readActiveDocSync();

      if (currentDoc?.docId) {
        const bytes = await fetchWorkingDocBytes();
        if (!bytes) { await hardResetOpenForm('no bytes / no permission'); return; }

        const st = await window.formSuitePersist.loadState?.(currentDoc.docId);
        schema = st?.schema || null;
        values = st?.values || {};
        setStatus(`Active DOCX: <span class="kbd">${currentDoc.name}</span>${schema ? '' : ' — <span class="muted">no schema yet</span>'}`);
        await updateWriteAccessBanner();
      } else {
        schema = loadLS();
        values = {};
      }

      renderForm();
    }

    // ---------- Robust bytes fetcher ----------
    async function fetchWorkingDocBytes() {
      try { const b = await window.formSuitePersist.getCurrentDocBytes?.(); if (b && b.byteLength) return b; } catch {}
      try { if (currentDoc?.docId) { const b2 = await window.formSuitePersist.getBytes?.(currentDoc.docId); if (b2 && b2.byteLength) return b2; } } catch {}
      try {
        const h = await window.formSuitePersist.getHandle?.(currentDoc?.docId);
        if (h?.getFile) {
          let p = await window.formSuitePersist.ensurePermission?.(h, 'readwrite');
          if (p !== 'granted') p = await window.formSuitePersist.ensurePermission?.(h, 'read');
          if (p === 'granted') { const f = await h.getFile(); return await f.arrayBuffer(); }
        }
      } catch {}
      try { await window.formSuitePersist.regrantAll?.(); const b3 = await window.formSuitePersist.getCurrentDocBytes?.(); if (b3 && b3.byteLength) return b3; } catch {}
      return null;
    }

    // ---- DATEDIFF helpers ----
    function diffInDays(a, b) {
      const A = new Date(a.getFullYear(), a.getMonth(), a.getDate());
      const B = new Date(b.getFullYear(), b.getMonth(), b.getDate());
      const ms = B - A;
      return Math.floor(ms / (24*60*60*1000));
    }
    function diffInMonths(a, b) {
      let months = (b.getFullYear() - a.getFullYear()) * 12 + (b.getMonth() - a.getMonth());
      if (b.getDate() < a.getDate()) months -= 1;
      return months;
    }
    function diffInYears(a, b) {
      let years = b.getFullYear() - a.getFullYear();
      const bBeforeAnniversary = (b.getMonth() < a.getMonth()) || (b.getMonth() === a.getMonth() && b.getDate() < a.getDate());
      if (bBeforeAnniversary) years -= 1;
      return years;
    }

    function createPrettyDatepicker(input, extraOpts = {}) {
      if (!document.getElementById('fp-zindex-fix')) {
        const st = document.createElement('style');
        st.id = 'fp-zindex-fix';
        st.textContent = `
          .flatpickr-calendar { z-index: 50; }
          .flatpickr-wrapper { position: relative; }
        `;
        document.head.appendChild(st);
      }

      const baseOpts = {
        dateFormat: 'Y-m-d',
        altInput: true,
        altFormat: 'D, j M Y',
        allowInput: false,
        clickOpens: true,
        disableMobile: true,
        static: true,
        wrap: false,
        monthSelectorType: 'dropdown',
        weekNumbers: true,
        prevArrow: '‹',
        nextArrow: '›',
        onReady: (_sel, _str, inst) => {
          if (inst.altInput) {
            inst.altInput.readOnly = true;
            inst.altInput.tabIndex = 0;
            inst.altInput.style.pointerEvents = 'auto';
            const wrap = inst.altInput.parentElement;
            if (wrap && !wrap.classList.contains('flatpickr-wrapper')) {
              wrap.classList.add('flatpickr-wrapper');
              if (getComputedStyle(wrap).position === 'static') {
                wrap.style.position = 'relative';
              }
            }
          }
        }
      };

      return flatpickr(input, { ...baseOpts, ...extraOpts });
    }

    function slugifyMc(s) {
      return String(s || '')
        .normalize('NFKD')
        .replace(/[\u0300-\u036f]/g, '')
        .replace(/[^a-zA-Z0-9]+/g, '_')
        .replace(/^_+|_+$/g, '')
        .toLowerCase();
    }
    function mcExtraKey(fieldId, optionValue, extraId) {
      return `${fieldId}__${slugifyMc(optionValue)}__${slugifyMc(extraId)}`;
    }

    // ---------- Render whole form ----------
    function renderForm() {
      (function injectMcStyles(){
        const ID = 'mc-caret-styles';
        if (document.getElementById(ID)) return;
        const s = document.createElement('style');
        s.id = ID;
        s.textContent = `
          .mc-item { position: relative; }
          .mc-toggle { all: unset; position: absolute; top: 10px; right: 10px; display: inline-flex; align-items: center; justify-content: center; cursor: pointer; line-height: 1; padding: 0; margin: 0; pointer-events: auto; }
          .mc-toggle:focus-visible { outline: 2px solid var(--focus, #2563eb); outline-offset: 2px; border-radius: 4px; }
          .mc-caret { width: 14px; height: 14px; transition: transform .18s ease, opacity .18s ease; opacity: .85; transform: rotate(0deg); display: block; }
          .mc-caret.open { transform: rotate(90deg); }
          .mc-extras { display: none; height: 0; grid-template-columns: 1fr; row-gap: 8px; padding-bottom: 2px; width: 100%; }
          .mc-option-label{ display:grid; grid-template-columns:auto 1fr; column-gap:8px; align-items:center; cursor:pointer; line-height:1.25; }
          .mc-option-label > span{ white-space:normal; word-break:break-word; }
          .mc-option-checkbox{ align-self:center; margin-top:0; transform:none; }
        `;
        document.head.appendChild(s);
      })();

      const __slugifyMc = (window.slugifyMc) ? window.slugifyMc : function (s) {
        return String(s || '')
          .normalize('NFKD')
          .replace(/[\u0300-\u036f]/g, '')
          .replace(/[^a-zA-Z0-9]+/g, '_')
          .replace(/^_+|_+$/g, '')
          .toLowerCase();
      };
      const __mcExtraKey = (window.mcExtraKey) ? window.mcExtraKey : function (fieldId, optionValue, extraId) {
        return `${fieldId}__${__slugifyMc(optionValue)}__${__slugifyMc(extraId)}`;
      };

      const mount = els.formMount;
      mount.innerHTML = '';
      if (!schema || !Array.isArray(schema.fields) || !schema.fields.length) {
        mount.innerHTML = `<div class="muted">No schema found. Create one in the <a href="builder.html">Builder</a>.</div>`;
        if (btnExportMain) btnExportMain.disabled = true;
        if (btnExportDebug) btnExportDebug.disabled = true;
        return;
      }

      (schema.fields || []).forEach(f => {
        if (f.type === 'table') {
          if (!Array.isArray(values[f.id])) {
            const min = Math.max(0, parseInt(f.minRows || 0, 10));
            values[f.id] = Array.from({ length: min }, () => emptyRow(f));
          } else {
            values[f.id] = values[f.id].map(r => ({ ...emptyRow(f), ...(r || {}) }));
          }
        }
      });

      const form = document.createElement('form');
      form.classList.add('form-grid');

      if (schema.title) {
        const h = document.createElement('h4');
        h.textContent = schema.title;
        h.style.gridColumn = '1 / -1';
        form.appendChild(h);
      }

      const inputRefs  = {};
      const mcDateRefs = {};
      const datediffRefs = [];
      const guardPairs = [];

      function scheduleSaveState() {
        clearTimeout(scheduleSaveState._t);
        scheduleSaveState._t = setTimeout(() => {
          if (!currentDoc?.docId) return;
          const cleanValues = sanitizeValues(schema, values);
          window.formSuitePersist.saveState(currentDoc.docId, { schema, values: cleanValues });
        }, 150);
      }

      function setExtrasOpen(extras, caretEl, open) {
        if (!extras) return;
        const DURATION = 220;

        if (extras._animTimer) { clearTimeout(extras._animTimer); extras._animTimer = null; }
        if (extras._onTe) { extras.removeEventListener('transitionend', extras._onTe); extras._onTe = null; }

        const onEnd = () => {
          extras.style.transition = '';
          extras.style.willChange = '';
          extras.style.opacity = open ? '1' : '0';
          extras.style.marginTop = open ? '8px' : '0px';
          extras.style.height = open ? 'auto' : '0px';
          extras.style.overflow = 'visible';
          if (!open) extras.style.display = 'none';
          if (extras._onTe) {
            extras.removeEventListener('transitionend', extras._onTe);
            extras._onTe = null;
          }
        };
        extras._onTe = onEnd;
        extras.addEventListener('transitionend', onEnd);

        if (caretEl) caretEl.classList.toggle('open', !!open);

        if (open) {
          extras.style.display = 'grid';
          extras.style.overflow = 'visible';
          extras.style.willChange = 'height, opacity, margin-top';
          extras.style.opacity = '0';
          extras.style.marginTop = '0px';
          extras.style.height = '0px';

          requestAnimationFrame(() => {
            const h = extras.scrollHeight;
            extras.classList.add('open');
            extras.style.transition = `height ${DURATION}ms ease, opacity ${DURATION}ms ease, margin-top ${DURATION}ms ease`;
            extras.style.height = h + 'px';
            extras.style.opacity = '1';
            extras.style.marginTop = '8px';
            extras._animTimer = setTimeout(onEnd, DURATION + 40);
          });
        } else {
          const current = extras.offsetHeight || extras.scrollHeight || 0;
          extras.classList.remove('open');
          extras.style.display = 'grid';
          extras.style.overflow = 'hidden';
          extras.style.willChange = 'height, opacity, margin-top';
          extras.style.transition = '';
          extras.style.height = current + 'px';
          extras.style.opacity = '1';
          extras.style.marginTop = '8px';

          requestAnimationFrame(() => {
            extras.style.transition = `height ${DURATION}ms ease, opacity ${DURATION}ms ease, margin-top ${DURATION}ms ease`;
            extras.style.height = '0px';
            extras.style.opacity = '0';
            extras.style.marginTop = '0px';
            extras._animTimer = setTimeout(onEnd, DURATION + 40);
          });
        }
      }

      (schema.fields || []).forEach(f => {
        const wrap = document.createElement('div');
        wrap.className = 'field';
        try { wrap.dataset.fieldId = String(f.id || ''); } catch {}
        if (f.type === 'address' || f.type === 'datediff') wrap.classList.add('span-2');
        if (f.type === 'table') wrap.classList.add('full', 'field--table');
        if (f.type === 'multichoice') wrap.classList.add('full', 'field--multichoice');
        if (f.wide === true) wrap.classList.add('span-2');
        if (f.full === true) wrap.classList.add('full');

        if (f.type !== 'address') {
          const label = document.createElement('label');
          label.htmlFor = f.id;
          label.textContent = f.label || f.id;
          if (f.required) {
            const star = document.createElement('span');
            star.textContent = ' *';
            star.style.color = '#ef4444';
            label.appendChild(star);
          }
          wrap.appendChild(label);
        }

        if (f.type === 'text') {
          const input = document.createElement('input');
          input.type = 'text';
          input.id = f.id; input.name = f.id; input.style.width = '100%';
          if (f.required) input.required = true;
          if (values[f.id] != null) input.value = values[f.id];
          input.addEventListener('change', () => { values[f.id] = input.value; scheduleSaveState(); try{ applyFieldVisibility(); }catch{} });
          wrap.appendChild(input);
          inputRefs[f.id] = input;

        } else if (f.type === 'number') {
          const input = document.createElement('input');
          input.type = 'number';
          input.id = f.id; input.name = f.id; input.style.width = '100%';
          if (f.required) input.required = true;
          if (values[f.id] != null) input.value = values[f.id];
          input.addEventListener('change', () => { values[f.id] = Number(input.value); scheduleSaveState(); try{ applyFieldVisibility(); }catch{} });
          wrap.appendChild(input);
          inputRefs[f.id] = input;

        } else if (f.type === 'select') {
          const input = document.createElement('select');
          input.id = f.id; input.name = f.id; input.style.width = '100%';
          (f.options || []).forEach(v => {
            const o = document.createElement('option');
            o.value = String(v); o.textContent = String(v);
            input.appendChild(o);
          });
          if (f.required) input.required = true;
          if (values[f.id] != null) input.value = values[f.id];
          input.addEventListener('change', () => { values[f.id] = input.value; scheduleSaveState(); try{ applyFieldVisibility(); }catch{} });
          wrap.appendChild(input);
          inputRefs[f.id] = input;

        } else if (f.type === 'multichoice') {
          const mcContainer = document.createElement('div');
          mcContainer.className = 'mc-container';
          mcContainer.style.display = 'block';

          const items = [];
          if (f.mc && Array.isArray(f.mc.groups) && f.mc.groups.length) {
            f.mc.groups.forEach(g => (g.items || []).forEach(it =>
              items.push({
                value: String(it.value ?? it.label ?? ''),
                alwaysSelected: !!it.alwaysSelected,
                preselected: !!it.preselected,
                fields: Array.isArray(it.fields) ? it.fields : []
              })
            ));
          } else if (Array.isArray(f.options)) {
            f.options.forEach(v => {
              if (v && typeof v === 'object') {
                items.push({
                  value: String(v.value ?? v.label ?? ''),
                  alwaysSelected: !!v.alwaysSelected,
                  preselected: !!v.preselected,
                  fields: Array.isArray(v.fields) ? v.fields : []
                });
              } else {
                items.push({ value: String(v), alwaysSelected: false, preselected: false, fields: [] });
              }
            });
          }

          if (!Array.isArray(values[f.id])) {
            const initial = items.filter(it => it.alwaysSelected || it.preselected).map(it => it.value);
            if (initial.length) values[f.id] = initial.slice();
          }
          const selected = new Set(Array.isArray(values[f.id]) ? values[f.id].map(String) : []);

          function persistMainSelection() {
            const boxes = mcContainer.querySelectorAll(`input[type="checkbox"][data-mc="1"]`);
            values[f.id] = Array.from(boxes).filter(b => b.checked).map(b => b.value);
            scheduleSaveState();
          }

          function drawOption(item, parentHost) {
            const optVal = item.value;
            const optId  = `${f.id}__${__slugifyMc(optVal)}`;
            const hasExtras = Array.isArray(item.fields) && item.fields.length > 0;

            const card = document.createElement('div');
            card.className = 'mc-item';
            try { card.dataset.optId = `${f.id}__opt__${__slugifyMc(optVal)}`; } catch {}
            card.style.position = 'relative';
            card.style.display = 'flex';
            card.style.flexDirection = 'column';
            card.style.alignItems = 'stretch';
            card.style.background = 'var(--card)';
            card.style.border = '1px solid var(--border-strong)';
            card.style.borderRadius = '8px';
            card.style.padding = '10px 10px';

            const row1 = document.createElement('div');
            row1.className = 'row';
            row1.style.alignItems = 'center';
            row1.style.gap = '8px';
            row1.style.width = '100%';

            const left = document.createElement('label');
            left.className = 'mc-option-label';
            left.setAttribute('for', optId);
            left.style.flex = '1';

            const cb = document.createElement('input');
            cb.type = 'checkbox';
            cb.dataset.mc = '1';
            cb.name = f.id;
            cb.id = optId;
            cb.value = optVal;
            cb.className = 'mc-option-checkbox';

            const locked = !!item.alwaysSelected;
            const isPreselected = !!item.preselected;
            cb.checked = locked || selected.has(optVal) || (!selected.size && isPreselected);
            if (locked) cb.disabled = true;

            const txt = document.createElement('span');
            txt.textContent = optVal;

            left.appendChild(cb);
            left.appendChild(txt);
            row1.appendChild(left);

            let extrasWrap = null;
            if (hasExtras) {
              extrasWrap = document.createElement('div');
              extrasWrap.className = 'mc-extras';
              extrasWrap.style.display = 'none';
              extrasWrap.style.height  = '0px';

              const mountExtraFields = () => {
                extrasWrap.innerHTML = '';
                if (!item.fields.length) return;

                function getDateForExtraKey(key) {
                  const el = mcDateRefs[key];
                  const fp = el?._flatpickr;
                  if (fp?.selectedDates?.[0] instanceof Date) return fp.selectedDates[0];
                  const iso = values[key];
                  if (iso) {
                    const d = (window.flatpickr && window.flatpickr.parseDate)
                      ? window.flatpickr.parseDate(String(iso), 'Y-m-d')
                      : new Date(String(iso));
                    return (d && !isNaN(d)) ? d : null;
                  }
                  return null;
                }

                item.fields.forEach(ex => {
                  const exType = (ex?.type) ? String(ex.type) : 'text';
                  const exId   = String(ex?.id || '');
                  if (!exId) return;
                  const exKey  = __mcExtraKey(f.id, optVal, exId);

                  const line = document.createElement('div');
                  line.className = 'row';
                  line.style.gap = '8px';
                  line.style.alignItems = 'center';
                  line.style.marginTop = '2px';

                  const lab = document.createElement('label');
                  lab.textContent = String(ex?.label || exId);
                  lab.style.minWidth = '120px';
                  lab.style.color = 'var(--muted)';

                  if (exType === 'date') {
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.dataset.type = 'date';
                    input.style.minWidth = '180px';

                    extrasWrap.appendChild(line);
                    line.appendChild(lab);
                    line.appendChild(input);

                    const fp = createPrettyDatepicker(input, {
                      dateFormat: 'Y-m-d',
                      altInput: true,
                      altFormat: 'D, j M Y',
                      defaultDate: values[exKey] || null,
                      onChange: () => { values[exKey] = input.value; scheduleSaveState(); if (window.recomputeDatediffs) window.recomputeDatediffs(); },
                      onValueUpdate: () => { values[exKey] = input.value; scheduleSaveState(); if (window.recomputeDatediffs) window.recomputeDatediffs(); }
                    });
                    fp.set('allowInput', false);
                    if (fp.altInput) fp.altInput.readOnly = true;

                    mcDateRefs[exKey] = input;
                    return;
                  }

                  if (exType === 'number') {
                    const input = document.createElement('input');
                    input.type = 'number';
                    input.value = values[exKey] ?? '';
                    input.addEventListener('change', () => {
                      values[exKey] = Number(input.value);
                      scheduleSaveState();
                    });
                    extrasWrap.appendChild(line);
                    line.appendChild(lab);
                    line.appendChild(input);
                    return;
                  }

                  if (exType === 'datediff') {
                    const fromId = ex.fromId || ex.from || '';
                    const toId   = ex.toId   || ex.to   || '';
                    const fromKey = __mcExtraKey(f.id, optVal, fromId);
                    const toKey   = __mcExtraKey(f.id, optVal, toId);

                    const out = document.createElement('div');
                    out.className = 'datediff-out kbd';
                    out.setAttribute('role', 'status');
                    out.setAttribute('aria-live', 'polite');
                    out.textContent = '—';

                    extrasWrap.appendChild(line);
                    line.appendChild(lab);
                    line.appendChild(out);

                    datediffRefs.push({
                      storeKey: exKey,
                      outEl: out,
                      resolve: () => ({ a: getDateForExtraKey(fromKey), b: getDateForExtraKey(toKey) })
                    });
                    return;
                  }

                  const input = document.createElement('input');
                  input.type = 'text';
                  input.value = values[exKey] ?? '';
                  input.addEventListener('change', () => {
                    values[exKey] = input.value;
                    scheduleSaveState();
                  });
                  extrasWrap.appendChild(line);
                  line.appendChild(lab);
                  line.appendChild(input);
                });
              };
              mountExtraFields();
            }

            let caretBtn = null, caretIcon = null;
            if (hasExtras) {
              caretBtn = document.createElement('button');
              caretBtn.type = 'button';
              caretBtn.className = 'mc-toggle';
              caretBtn.setAttribute('aria-expanded', 'false');
              caretBtn.setAttribute('aria-label', 'Details ein-/ausklappen');

              const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
              svg.setAttribute('viewBox', '0 0 24 24');
              svg.setAttribute('width', '14');
              svg.setAttribute('height', '14');
              svg.classList.add('mc-caret');
              const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
              path.setAttribute('d', 'M9 18l6-6-6-6');
              path.setAttribute('fill', 'none');
              path.setAttribute('stroke', 'currentColor');
              path.setAttribute('stroke-width', '2');
              path.setAttribute('stroke-linecap', 'round');
              path.setAttribute('stroke-linejoin', 'round');
              svg.appendChild(path);

              caretIcon = svg;
              caretBtn.appendChild(svg);
              row1.appendChild(caretBtn);

              setExtrasOpen(extrasWrap, caretIcon, false);

              caretBtn.addEventListener('click', (e) => {
                e.preventDefault();
                const willOpen = !extrasWrap.classList.contains('open');
                caretBtn.setAttribute('aria-expanded', String(willOpen));
                setExtrasOpen(extrasWrap, caretIcon, willOpen);
              });
            }

            cb.addEventListener('change', () => {
              if (locked) { cb.checked = true; return; }
              persistMainSelection();
              try { applyFieldVisibility(); } catch {}
            });

            card.appendChild(row1);
            if (extrasWrap) card.appendChild(extrasWrap);
            parentHost.appendChild(card);
          }

          if (f.mc && Array.isArray(f.mc.groups) && f.mc.groups.length) {
            f.mc.groups.forEach(g => {
              const section = document.createElement('div');
              section.className = 'mc-group-section';
              section.style.marginBottom = '10px';

              if (g.title) {
                const h = document.createElement('div');
                h.className = 'mc-group-title';
                h.textContent = String(g.title);
                h.style.color = 'var(--muted)';
                h.style.fontWeight = '600';
                h.style.fontSize = '.95rem';
                h.style.margin = '4px 0 6px';
                section.appendChild(h);
              }

              const host = document.createElement('div');
              host.className = 'mc-group';
              host.style.display = 'grid';
              host.style.gridTemplateColumns = 'repeat(auto-fill,minmax(260px,1fr))';
              host.style.gap = '8px 16px';
              host.style.alignItems = 'start';
              if (Number.isFinite(+f.columns) && +f.columns > 0) {
                host.style.gridTemplateColumns = `repeat(${+f.columns}, minmax(220px, 1fr))`;
              }

              (g.items || []).forEach(it => drawOption({
                value: String(it.value ?? it.label ?? ''),
                alwaysSelected: !!it.alwaysSelected,
                preselected: !!it.preselected,
                fields: Array.isArray(it.fields) ? it.fields : []
              }, host));

              section.appendChild(host);
              mcContainer.appendChild(section);
            });
          } else {
            const host = document.createElement('div');
            host.className = 'mc-group';
            host.style.display = 'grid';
            host.style.gridTemplateColumns = 'repeat(auto-fill,minmax(260px,1fr))';
            host.style.gap = '8px 16px';
            host.style.alignItems = 'start';
            if (Number.isFinite(+f.columns) && +f.columns > 0) {
              host.style.gridTemplateColumns = `repeat(${+f.columns}, minmax(220px, 1fr))`;
            }
            items.forEach(it => drawOption(it, host));
            mcContainer.appendChild(host);
          }

          values[f.id] = Array.from(mcContainer.querySelectorAll(`input[type="checkbox"][data-mc="1"]`))
            .filter(b => b.checked)
            .map(b => b.value);
          scheduleSaveState();

          wrap.appendChild(mcContainer);

        } else if (f.type === 'date') {
          const input = document.createElement('input');
          input.type = 'text';
          input.dataset.type = 'date';
          input.id = f.id; input.name = f.id; input.style.width = '100%';
          if (f.required) input.required = true;
          wrap.appendChild(input);

          const fp = createPrettyDatepicker(input, {
            dateFormat: 'Y-m-d',
            altInput: true,
            altFormat: 'D-d-M-Y',
            allowInput: false,
            clickOpens: true,
            defaultDate: values[f.id] || null,
            onReady: (_sel, _str, inst) => { if (inst.altInput) inst.altInput.readOnly = true; },
            onChange: () => { values[f.id] = input.value; scheduleSaveState(); if (window.recomputeDatediffs) window.recomputeDatediffs(); try{ applyFieldVisibility(); }catch{} },
            onValueUpdate: () => { values[f.id] = input.value; scheduleSaveState(); if (window.recomputeDatediffs) window.recomputeDatediffs(); try{ applyFieldVisibility(); }catch{} }
          });
          fp.set('allowInput', false);
          if (fp.altInput) fp.altInput.readOnly = true;
          inputRefs[f.id] = input;

        } else if (f.type === 'address') {
          const host = document.createElement('div');
          host.className = 'addr-host';
          wrap.appendChild(host);

          const initial =
            typeof values[f.id] === 'string'
              ? { formatted: values[f.id] }
              : (values[f.id] || null);

          AddressAuto.mount(host, {
            id: f.id,
            label: f.label || 'Address',
            required: !!f.required,
            value: initial || null,
            onChange: (val) => { values[f.id] = val; scheduleSaveState(); }
          });

        } else if (f.type === 'table') {
          renderTableField(wrap, f);

        } else if (f.type === 'datediff') {
          const fromId = f.fromId || f.from || '';
          const toId   = f.toId   || f.to   || '';

          const out = document.createElement('div');
          out.id = f.id;
          out.className = 'datediff-out kbd';
          out.setAttribute('role', 'status');
          out.setAttribute('aria-live', 'polite');
          out.textContent = '—';
          wrap.appendChild(out);

          datediffRefs.push({
            storeKey: f.id,
            outEl: out,
            resolve: () => ({ a: getDateForField(fromId), b: getDateForField(toId) })
          });

          guardPairs.push({ fromId, toId });

        } else {
          const input = document.createElement('input');
          input.type = 'text';
          input.id = f.id; input.name = f.id; input.style.width = '100%';
          if (values[f.id] != null) input.value = values[f.id];
          input.addEventListener('change', () => { values[f.id] = input.value; scheduleSaveState(); });
          wrap.appendChild(input);
          inputRefs[f.id] = input;
        }

        form.appendChild(wrap);
      });

      const bar = document.createElement('div');
      bar.className = 'bar';
      bar.style.gridColumn = '1 / -1';
      btnExportMain = document.createElement('button');
      btnExportMain.type = 'button';
      btnExportMain.className = 'secondary';
      btnExportMain.textContent = 'Export…';
      btnExportMain.disabled = !currentDoc;
      btnExportMain.addEventListener('click', onExportFromOpenForm);
      bar.appendChild(btnExportMain);

      btnExportDebug = document.createElement('button');
      btnExportDebug.type = 'button';
      btnExportDebug.className = 'ghost';
      btnExportDebug.textContent = 'Debug export…';
      btnExportDebug.disabled = !currentDoc;
      btnExportDebug.addEventListener('click', onExportDebugFromOpenForm);
      bar.appendChild(btnExportDebug);
      form.appendChild(bar);
      form.addEventListener('change', () => { try { applyFieldVisibility(); } catch {} });
      mount.appendChild(form);

      try { applyFieldVisibility(); } catch {}

      function getDateForField(fid) {
        const el = inputRefs[fid];
        if (!el) return null;
        const fp = el?._flatpickr;
        if (fp?.selectedDates?.[0] instanceof Date) return fp.selectedDates[0];
        const iso = values[fid];
        if (iso) {
          const d = (window.flatpickr && window.flatpickr.parseDate)
            ? window.flatpickr.parseDate(String(iso), 'Y-m-d')
            : new Date(String(iso));
          return (d && !isNaN(d)) ? d : null;
        }
        return null;
      }

      function recomputeDatediffs() {
        datediffRefs.forEach(({ storeKey, outEl, resolve }) => {
          const { a, b } = resolve();
          if (!a || !b) {
            outEl.textContent = '—';
            values[storeKey] = null;
            return;
          }
          const days   = diffInDays(a, b);
          const months = diffInMonths(a, b);
          const years  = diffInYears(a, b);
          const display = `${days}D ${months}M ${years}Y (${days} Days total)`;
          outEl.textContent = display;
          values[storeKey] = { days, months, years, formatted: display };
        });
        scheduleSaveState();
      }
      window.recomputeDatediffs = recomputeDatediffs;

      (function wireTopLevelDateGuards() {
        function nextDay(d) {
          if (!d) return null;
          const n = new Date(d.getFullYear(), d.getMonth(), d.getDate());
          n.setDate(n.getDate() + 1);
          return n;
        }
        guardPairs.forEach(({ fromId, toId }) => {
          const fromEl = inputRefs[fromId];
          const toEl   = inputRefs[toId];
          const fpFrom = fromEl?._flatpickr;
          const fpTo   = toEl?._flatpickr;
          if (!fpFrom || !fpTo) return;

          fpFrom.set('allowInput', false);
          fpTo.set('allowInput', false);
          if (fpFrom.altInput) fpFrom.altInput.readOnly = true;
          if (fpTo.altInput)   fpTo.altInput.readOnly   = true;

          const syncToWithFrom = (opts = { snap: true, jump: true }) => {
            const from = fpFrom.selectedDates?.[0] || null;
            const minForTo = nextDay(from);
            fpTo.set('minDate', minForTo || null);

            const toSel = fpTo.selectedDates?.[0] || null;
            if (!toSel && minForTo && opts.snap) fpTo.setDate(minForTo, true);
            if (from && toSel && toSel <= from && opts.snap) fpTo.setDate(minForTo, true);
            if (minForTo && opts.jump) { try { fpTo.jumpToDate(minForTo); } catch {} }

            if (typeof window.recomputeDatediffs === 'function') window.recomputeDatediffs();
          };

          syncToWithFrom({ snap: true, jump: false });
          fpFrom.config.onChange.push(() => syncToWithFrom({ snap: true, jump: true }));
          fpFrom.config.onValueUpdate.push(() => syncToWithFrom({ snap: true, jump: true }));
          fpTo.config.onOpen.push(() => syncToWithFrom({ snap: false, jump: true }));

          const recompute = () => { if (window.recomputeDatediffs) window.recomputeDatediffs(); };
          fpTo.config.onChange.push(recompute);
          fpTo.config.onValueUpdate.push(recompute);
        });
      })();

      recomputeDatediffs();
    }



    // ----- TABLE FIELD -----
    function renderTableField(container, field) {
      if (!Array.isArray(values[field.id])) values[field.id] = [];
      const data = values[field.id];

      const editorWrap = document.createElement('div');
      editorWrap.style.display = 'flex';
      editorWrap.style.flexWrap = 'wrap';
      editorWrap.style.gap = '10px';

      const editorInputs = {};
      let editorState = emptyRow(field);

      const measurer = document.createElement('canvas').getContext('2d');
      function textPx(str) {
        try { measurer.font = getComputedStyle(document.body).font; } catch {}
        return Math.ceil(measurer.measureText(String(str || '')).width);
      }
      function longest(arr) {
        return arr.reduce((a, b) => (String(b).length > String(a).length ? String(b) : String(a)), '');
      }

      function rowIsEmpty(row) {
        return !(field.columns || []).some(c => String(row?.[c.id] ?? '').trim() !== '');
      }

      (field.columns || []).forEach(col => {
        const pair = document.createElement('label');
        pair.style.display = 'flex';
        pair.style.alignItems = 'center';
        pair.style.gap = '8px';

        const lbl = document.createElement('span');
        lbl.textContent = col.label || col.id;

        let el;
        if (col.type === 'select') {
          el = document.createElement('select');
          const opts = (col.options || []);
          const empty = document.createElement('option'); empty.value = ''; empty.textContent = '— wählen —';
          el.appendChild(empty);
          opts.forEach(opt => {
            const o = document.createElement('option');
            o.value = String(opt); o.textContent = String(opt);
            el.appendChild(o);
          });
          el.style.minWidth = Math.max(140, Math.min(360, textPx(longest(opts)) + 56)) + 'px';
          el.addEventListener('change', () => { editorState[col.id] = el.value; });
        } else if (col.type === 'date') {
          el = document.createElement('input');
          el.type = 'text';
          el.style.minWidth = Math.max(140, Math.min(360, textPx('YYYY-MM-DD') + 20)) + 'px';
          setTimeout(() => {
            flatpickr(el, { allowInput: true, dateFormat: 'Y-m-d', onChange: () => { editorState[col.id] = el.value; } });
          }, 0);
          el.addEventListener('change', () => { editorState[col.id] = el.value; });
        } else if (col.type === 'number') {
          el = document.createElement('input');
          el.type = 'number';
          el.style.minWidth = Math.max(120, Math.min(360, textPx('000000') + 20)) + 'px';
          el.addEventListener('change', () => { editorState[col.id] = el.value; });
        } else {
          el = document.createElement('input');
          el.type = 'text';
          el.style.minWidth = Math.max(160, Math.min(360, textPx(lbl.textContent) + 20)) + 'px';
          el.addEventListener('change', () => { editorState[col.id] = el.value; });
        }

        editorInputs[col.id] = el;
        pair.appendChild(lbl);
        pair.appendChild(el);
        editorWrap.appendChild(pair);
      });

      const toolbar = document.createElement('div');
      toolbar.className = 'row';
      toolbar.style.gap = '8px';

      const btnAdd = document.createElement('button');
      btnAdd.type = 'button';
      btnAdd.textContent = 'Zeile hinzufügen';

      const btnSave = document.createElement('button');
      btnSave.type = 'button';
      btnSave.className = 'secondary';
      btnSave.textContent = 'Änderungen speichern';

      const btnDelete = document.createElement('button');
      btnDelete.type = 'button';
      btnDelete.className = 'ghost';
      btnDelete.textContent = 'Zeile löschen';

      const btnCancel = document.createElement('button');
      btnCancel.type = 'button';
      btnCancel.className = 'ghost';
      btnCancel.textContent = 'Abbrechen';

      toolbar.appendChild(btnAdd);
      toolbar.appendChild(btnSave);
      toolbar.appendChild(btnDelete);
      toolbar.appendChild(btnCancel);

      const status = document.createElement('div');
      status.className = 'muted';
      status.style.minHeight = '1.2em';

      const tableWrap = document.createElement('div');
      tableWrap.style.overflow = 'auto';
      const table = document.createElement('table');
      table.style.width = '100%';
      const thead = document.createElement('thead');
      const trh = document.createElement('tr');
      thead.appendChild(trh);
      const tbody = document.createElement('tbody');
      table.appendChild(thead);
      table.appendChild(tbody);
      tableWrap.appendChild(table);

      (field.columns || []).forEach(col => {
        const th = document.createElement('th');
        th.textContent = col.label || col.id;
        trh.appendChild(th);
      });

      let selectedIndex = -1;
      let visibleIndexMap = [];

      function applyPreviewVisibility() {
        const hasAnyNonEmpty = data.some(r => !rowIsEmpty(r));
        tableWrap.style.display = hasAnyNonEmpty ? '' : 'none';
      }

      function drawTable() {
        tbody.innerHTML = '';
        visibleIndexMap = [];

        data.forEach((row, realIdx) => {
          if (rowIsEmpty(row)) return;

          const tr = document.createElement('tr');
          const isSel = realIdx === selectedIndex;

          if (isSel) {
            tr.style.background = '#DBEAFE';
            tr.style.outline = '2px solid #93C5FD';
            tr.style.outlineOffset = '-2px';
          } else {
            tr.style.background = '';
            tr.style.outline = '';
            tr.style.outlineOffset = '';
          }

          tr.addEventListener('click', () => {
            selectedIndex = realIdx;
            drawTable();
            loadIntoEditor(realIdx);
          });

          (field.columns || []).forEach(col => {
            const td = document.createElement('td');
            td.textContent = row[col.id] || '';
            tr.appendChild(td);
          });

          tbody.appendChild(tr);
          visibleIndexMap.push(realIdx);
        });

        applyPreviewVisibility();
        updateToolbar();
      }

      function clearSelection() { selectedIndex = -1; updateToolbar(); }
      function updateToolbar() {
        const min = Math.max(0, parseInt(field.minRows || 0, 10));
        const max = Math.max(0, parseInt(field.maxRows || 0, 10));

        btnAdd.disabled = (max && data.length >= max);

        const showEdit = selectedIndex >= 0;
        btnSave.style.display   = showEdit ? '' : 'none';
        btnDelete.style.display = showEdit ? '' : 'none';
        btnCancel.style.display = showEdit ? '' : 'none';

        btnSave.disabled   = !showEdit;
        btnDelete.disabled = !showEdit || (min && data.length <= min);
        btnCancel.disabled = !showEdit;
      }

      function loadIntoEditor(i) {
        const rec = data[i] || emptyRow(field);
        for (const c of (field.columns || [])) {
          const el = editorInputs[c.id];
          if (!el) continue;
          el.value = rec[c.id] || '';
        }
        editorState = { ...rec };
        updateToolbar();
      }

      function resetEditor() {
        editorState = emptyRow(field);
        for (const c of (field.columns || [])) {
          const el = editorInputs[c.id];
          if (!el) continue;
          el.value = '';
        }
      }

      if (!data.length) {
        const min = Math.max(0, parseInt(field.minRows || 0, 10));
        for (let i = 0; i < min; i++) data.push(emptyRow(field));
      }
      drawTable();

      btnAdd.addEventListener('click', () => {
        const max = Math.max(0, parseInt(field.maxRows || 0, 10));
        if (max && data.length >= max) return;

        data.push({ ...editorState });
        drawTable();
        scheduleSaveState();
        status.textContent = 'Zeile hinzugefügt.';
      });

      btnSave.addEventListener('click', () => {
        if (selectedIndex < 0 || selectedIndex >= data.length) return;
        data[selectedIndex] = { ...editorState };
        drawTable();
        scheduleSaveState();
        status.textContent = 'Änderungen gespeichert.';
      });

      btnDelete.addEventListener('click', () => {
        const min = Math.max(0, parseInt(field.minRows || 0, 10));
        if (selectedIndex < 0) return;
        if (min && data.length <= min) return;
        data.splice(selectedIndex, 1);
        clearSelection();
        resetEditor();
        drawTable();
        scheduleSaveState();
        status.textContent = 'Zeile gelöscht.';
      });

      btnCancel.addEventListener('click', () => {
        clearSelection();
        resetEditor();
        drawTable();
        status.textContent = 'Auswahl aufgehoben.';
      });

      container.appendChild(editorWrap);
      container.appendChild(toolbar);
      container.appendChild(status);
      container.appendChild(tableWrap);

      applyPreviewVisibility();
    }

    function emptyRow(field){ const r={}; (field.columns||[]).forEach(c=>r[c.id]=''); return r; }

    let __saveTimer = null;
    function scheduleSaveState() {
      clearTimeout(__saveTimer);
      __saveTimer = setTimeout(saveState, 150);
    }
    function saveState() {
      if (!currentDoc?.docId) return;
      const cleanValues = sanitizeValues(schema, values);
      window.formSuitePersist.saveState(currentDoc.docId, { schema, values: cleanValues });
    }
    function saveLS(s) { try { localStorage.setItem(STORAGE_KEY, JSON.stringify(s||{})); } catch {} }
    function loadLS() { try { return JSON.parse(localStorage.getItem(STORAGE_KEY)||'null'); } catch { return null; } }
    window.addEventListener('beforeunload', () => {
      try { if (currentDoc?.docId) saveState(); else if (schema) saveLS(schema); } catch {}
    });

    // ---------- Export (Open Form) ----------
    function summarizeForExportDebug(value) {
      const seen = new WeakSet();

      function helper(val, depth) {
        if (val == null) return val;
        const t = typeof val;
        if (t === 'number' || t === 'boolean') return val;
        if (t === 'string') {
          if (val.length <= 2048) return val;
          return {
            type: 'string',
            length: val.length,
            head: val.slice(0, 1024),
            tail: val.slice(-256)
          };
        }
        if (typeof Date !== 'undefined' && val instanceof Date) {
          return { type: 'Date', value: val.toISOString() };
        }
        if (typeof Blob !== 'undefined' && val instanceof Blob) {
          return { type: 'Blob', size: val.size, mime: val.type || '' };
        }
        if (typeof File !== 'undefined' && val instanceof File) {
          return { type: 'File', name: val.name, size: val.size, mime: val.type || '' };
        }
        if (val instanceof Uint8Array) {
          const previewLength = Math.min(32, val.length);
          const preview = Array.from(val.slice(0, previewLength));
          const hexPreview = preview.map(b => b.toString(16).padStart(2, '0')).join(' ');
          return {
            type: 'Uint8Array',
            length: val.length,
            previewHex: hexPreview,
          };
        }
        if (typeof ArrayBuffer !== 'undefined' && val instanceof ArrayBuffer) {
          return { type: 'ArrayBuffer', byteLength: val.byteLength };
        }
        if (val && typeof val.byteLength === 'number' && val.buffer instanceof ArrayBuffer) {
          return { type: val.constructor?.name || 'TypedArray', byteLength: val.byteLength };
        }
        if (t === 'function') {
          return `[Function ${val.name || 'anonymous'}]`;
        }
        if (seen.has(val)) {
          return '[Circular]';
        }
        const nextDepth = depth + 1;
        if (nextDepth > 2) {
          if (Array.isArray(val)) {
            return `[Array length=${val.length}]`;
          }
          const keys = Object.keys(val);
          return `[Object keys=${keys.length}]`;
        }
        seen.add(val);
        try {
          if (Array.isArray(val)) {
            const max = nextDepth === 1 ? 20 : 10;
            const out = val.slice(0, max).map(item => helper(item, nextDepth));
            if (val.length > max) {
              out.push(`… ${val.length - max} more`);
            }
            return out;
          }
          if (val instanceof Map) {
            const entries = Array.from(val.entries());
            const max = nextDepth === 1 ? 20 : 10;
            const mapped = entries.slice(0, max).map(([k, v]) => [helper(k, nextDepth), helper(v, nextDepth)]);
            if (entries.length > max) {
              mapped.push(["__truncated__", `… ${entries.length - max} more`]);
            }
            return mapped;
          }
          const entries = Object.entries(val);
          const max = nextDepth === 1 ? 25 : 12;
          const out = {};
          for (let i = 0; i < entries.length && i < max; i++) {
            const [k, v] = entries[i];
            out[k] = helper(v, nextDepth);
          }
          if (entries.length > max) {
            out.__truncated__ = `… ${entries.length - max} more keys`;
          }
          return out;
        } finally {
          seen.delete(val);
        }
      }

      return helper(value, 0);
    }

    function buildExportDebugSnapshot(plan, context) {
      return {
        generatedAt: new Date().toISOString(),
        plan,
        context: summarizeForExportDebug(context || {}),
      };
    }

    function stringifyExportDebugSnapshot(plan, context) {
      try {
        return JSON.stringify(buildExportDebugSnapshot(plan, context), null, 2);
      } catch (err) {
        console.warn('Failed to stringify export debug snapshot', err);
        return JSON.stringify({
          error: 'stringify-failed',
          message: err?.message || String(err || 'unknown-error'),
        }, null, 2);
      }
    }

    async function gatherExportArtifacts(preloadedBytes = null) {
      if (!currentDoc?.docId) return null;

      let docBytes = preloadedBytes;
      if (!docBytes) {
        docBytes = await fetchWorkingDocBytes();
      }
      if (!docBytes) return null;

      if (!schema || !Array.isArray(schema.fields) || !schema.fields.length) {
        throw new Error('Cannot export: no schema loaded for the current document.');
      }

      const originalBytes = docBytes instanceof Uint8Array ? new Uint8Array(docBytes) : new Uint8Array(docBytes);

      const state  = await window.formSuitePersist.loadState?.(currentDoc.docId);
      const tagMap = (state?.payload?.CRONOS_PAYLOAD?.tagMap)
                  || (state?.cronos_payload?.tagMap)
                  || (state?.CRONOS_PAYLOAD?.tagMap)
                  || (state?.tagMap)
                  || {};
      const validIds   = new Set((schema?.fields || []).map(f => f.id));
      const safeValues = sanitizeValues(schema, values || {});
      const cleanTagMap = sanitizeTagMap(tagMap, validIds);
      const rules = loadRulesForDoc(state);
      const fieldRulesForDoc = loadFieldRulesForDoc(state);

      const headingResolver = buildHeadingTargetIndex({
        flat: Array.isArray(state?.headingsFlat) ? state.headingsFlat : Array.isArray(state?.headings) ? state.headings : [],
        tree: Array.isArray(state?.headingsTree) ? state.headingsTree : []
      });

      const payload = JSON.stringify({
        title: schema?.title || 'Form',
        fields: schema?.fields || [],
        values: safeValues,
        tagMap: cleanTagMap,
        rules,
        fieldRules: fieldRulesForDoc
      });

      const updated = await writeDocVar(originalBytes, PAYLOAD_KEY, payload);

      const sdtMap = {};
      for (const [tag, fieldId] of Object.entries(cleanTagMap)) {
        let v = safeValues?.[fieldId];
        if (v == null) v = '';
        if (typeof v === 'object') {
          v = v.formatted ?? (function(){ try { return JSON.stringify(v); } catch { return String(v); } })();
        }
        sdtMap[tag] = String(v);
      }
      const updated2 = await writeSDTs(updated, sdtMap);

      const visibilityMap = evaluateRulesToVisibility(schema, safeValues, rules, headingResolver);

      return {
        originalBytes,
        updatedBytes: updated2,
        visibilityMap,
        safeValues,
        cleanTagMap,
        rules,
        fieldRulesForDoc,
        headingResolver,
        state,
        payload,
        rawTagMap: tagMap,
      };
    }

    function renderExportDebugPanel(plan, context = {}) {
      if (!plan || typeof plan !== 'object') {
        console.warn('renderExportDebugPanel: invalid plan', plan);
        return;
      }
      clearExportDebugPanel();
      lastExportDebug = { plan, context };
      try { window.lastExportDebug = lastExportDebug; } catch {}

      const overlay = document.createElement('div');
      overlay.id = 'exportDebugPanel';
      overlay.tabIndex = -1;
      overlay.style.position = 'fixed';
      overlay.style.top = '72px';
      overlay.style.right = '24px';
      overlay.style.maxWidth = 'min(90vw, 520px)';
      overlay.style.maxHeight = '70vh';
      overlay.style.overflowY = 'auto';
      overlay.style.background = '#ffffff';
      overlay.style.border = '1px solid rgba(15,23,42,0.12)';
      overlay.style.boxShadow = '0 18px 45px rgba(15,23,42,0.25)';
      overlay.style.padding = '18px';
      overlay.style.borderRadius = '12px';
      overlay.style.zIndex = '4000';
      overlay.style.fontSize = '14px';
      overlay.style.lineHeight = '1.4';

      const header = document.createElement('div');
      header.style.display = 'flex';
      header.style.gap = '12px';
      header.style.alignItems = 'center';
      header.style.marginBottom = '12px';

      const title = document.createElement('h3');
      title.textContent = 'Export removal debug';
      title.style.margin = '0';
      title.style.fontSize = '16px';
      title.style.fontWeight = '600';

      const closeBtn = document.createElement('button');
      closeBtn.type = 'button';
      closeBtn.className = 'ghost';
      closeBtn.textContent = 'Close';
      closeBtn.style.marginLeft = 'auto';
      closeBtn.addEventListener('click', (ev) => { ev.preventDefault(); clearExportDebugPanel(); });

      header.appendChild(title);
      header.appendChild(closeBtn);
      overlay.appendChild(header);

      const summary = document.createElement('div');
      summary.style.marginBottom = '12px';

      const headings = [];
      (plan.parts || []).forEach(part => {
        (part?.headings || []).forEach(h => {
          headings.push({ ...h, part: part?.name || '' });
        });
      });
      headings.sort((a, b) => a.idx - b.idx);

      const unmatched = Array.isArray(plan.unmatchedActions) ? plan.unmatchedActions : [];

      const summaryLines = [];
      summaryLines.push(`<strong>${headings.length}</strong> headings detected.`);
      summaryLines.push(`Style map entries: <strong>${plan.styleMapSize || 0}</strong> (${plan.hasStylesXml ? 'styles.xml present' : 'styles.xml missing'})`);
      summaryLines.push(`Visibility actions: <strong>${Object.keys(context.visibilityMap || {}).length}</strong>.`);
      if (unmatched.length) {
        summaryLines.push(`Unmatched actions: ${unmatched.join(', ')}`);
      }
      summary.innerHTML = summaryLines.map(line => `<div>${line}</div>`).join('');
      overlay.appendChild(summary);

      const headingResolver = context?.headingResolver;
      const labelForHeading = (idx) => {
        let fallback = `Heading ${idx}`;
        if (!headingResolver) return fallback;
        let entry = null;
        try { entry = headingResolver.resolve?.({ idx }); } catch {}
        if (!entry) {
          try { entry = headingResolver.resolve?.(idx); } catch {}
        }
        if (entry && headingResolver.buildLabel) {
          return headingResolver.buildLabel(entry, fallback);
        }
        if (entry?.text) return entry.text;
        if (headingResolver.buildLabel) {
          return headingResolver.buildLabel(null, fallback);
        }
        return fallback;
      };

      const actionsEntries = Object.entries(context.visibilityMap || {}).map(([idx, action]) => {
        const num = Number(idx);
        return { idx: Number.isFinite(num) ? num : idx, action, label: labelForHeading(num) };
      }).sort((a, b) => Number(a.idx) - Number(b.idx));

      const makeTable = () => {
        const table = document.createElement('table');
        table.style.width = '100%';
        table.style.borderCollapse = 'collapse';
        table.style.marginBottom = '12px';
        table.style.fontSize = '13px';
        return table;
      };

      if (actionsEntries.length) {
        const actionsWrap = document.createElement('div');
        actionsWrap.style.marginBottom = '12px';
        const heading = document.createElement('h4');
        heading.textContent = 'Visibility map';
        heading.style.margin = '0 0 6px';
        heading.style.fontSize = '14px';
        heading.style.fontWeight = '600';
        actionsWrap.appendChild(heading);

        const table = makeTable();
        const thead = document.createElement('thead');
        const tr = document.createElement('tr');
        ['Idx', 'Action', 'Label'].forEach(text => {
          const th = document.createElement('th');
          th.textContent = text;
          th.style.textAlign = 'left';
          th.style.padding = '4px 6px';
          th.style.borderBottom = '1px solid rgba(15,23,42,0.1)';
          tr.appendChild(th);
        });
        thead.appendChild(tr);
        table.appendChild(thead);

        const tbody = document.createElement('tbody');
        actionsEntries.forEach(entry => {
          const row = document.createElement('tr');
          row.style.borderBottom = '1px solid rgba(15,23,42,0.08)';
          const cells = [
            String(entry.idx),
            String(entry.action || ''),
            entry.label || ''
          ];
          cells.forEach((value, i) => {
            const td = document.createElement('td');
            td.textContent = value;
            td.style.padding = '4px 6px';
            if (i === 1) td.style.textTransform = 'uppercase';
            row.appendChild(td);
          });
          tbody.appendChild(row);
        });
        table.appendChild(tbody);
        actionsWrap.appendChild(table);
        overlay.appendChild(actionsWrap);
      }

      const headingsWrap = document.createElement('div');
      const headingTitle = document.createElement('h4');
      headingTitle.textContent = 'Detected headings';
      headingTitle.style.margin = '0 0 6px';
      headingTitle.style.fontSize = '14px';
      headingTitle.style.fontWeight = '600';
      headingsWrap.appendChild(headingTitle);

      if (plan.error) {
        const err = document.createElement('div');
        err.textContent = `Unable to analyse document (${plan.error}).`;
        err.style.color = '#b91c1c';
        headingsWrap.appendChild(err);
      }

      if (headings.length) {
        const table = makeTable();
        const thead = document.createElement('thead');
        const headerRow = document.createElement('tr');
        ['Idx', 'Lvl', 'Action', 'Detected by', 'Text'].forEach(text => {
          const th = document.createElement('th');
          th.textContent = text;
          th.style.textAlign = 'left';
          th.style.padding = '4px 6px';
          th.style.borderBottom = '1px solid rgba(15,23,42,0.1)';
          headerRow.appendChild(th);
        });
        thead.appendChild(headerRow);
        table.appendChild(thead);

        const tbody = document.createElement('tbody');
        headings.forEach(h => {
          const row = document.createElement('tr');
          row.style.borderBottom = '1px solid rgba(15,23,42,0.08)';
          if (h.action === 'HIDE') row.style.background = 'rgba(239,68,68,0.08)';
          else if (h.action === 'SHOW') row.style.background = 'rgba(34,197,94,0.1)';
          const cells = [
            String(h.idx),
            String(h.level ?? ''),
            String(h.action || ''),
            h.detectedBy || '',
            `${h.text || ''}${h.part ? ` (${h.part})` : ''}`
          ];
          cells.forEach((value, i) => {
            const td = document.createElement('td');
            td.textContent = value;
            td.style.padding = '4px 6px';
            if (i === 2) td.style.textTransform = 'uppercase';
            row.appendChild(td);
          });
          tbody.appendChild(row);
        });
        table.appendChild(tbody);
        headingsWrap.appendChild(table);
      } else if (!plan.error) {
        const empty = document.createElement('div');
        empty.textContent = 'No headings were detected in the document.';
        headingsWrap.appendChild(empty);
      }

      if (unmatched.length) {
        const warn = document.createElement('div');
        warn.textContent = `Indices without matching headings: ${unmatched.join(', ')}`;
        warn.style.color = '#b45309';
        warn.style.marginBottom = '8px';
        headingsWrap.appendChild(warn);
      }

      overlay.appendChild(headingsWrap);

      const controls = document.createElement('div');
      controls.style.display = 'flex';
      controls.style.flexWrap = 'wrap';
      controls.style.gap = '8px';
      controls.style.marginTop = '12px';

      const copyBtn = document.createElement('button');
      copyBtn.type = 'button';
      copyBtn.className = 'ghost';
      copyBtn.textContent = 'Copy JSON';
      copyBtn.addEventListener('click', async () => {
        try {
          const json = stringifyExportDebugSnapshot(plan, context);
          await navigator.clipboard.writeText(json);
          copyBtn.textContent = 'Copied!';
          setTimeout(() => { copyBtn.textContent = 'Copy JSON'; }, 1500);
        } catch (err) {
          copyBtn.textContent = 'Copy failed';
          setTimeout(() => { copyBtn.textContent = 'Copy JSON'; }, 1500);
        }
      });
      controls.appendChild(copyBtn);

      const downloadBtn = document.createElement('button');
      downloadBtn.type = 'button';
      downloadBtn.className = 'ghost';
      downloadBtn.textContent = 'Download JSON';
      downloadBtn.addEventListener('click', (ev) => {
        ev.preventDefault();
        try {
          const json = stringifyExportDebugSnapshot(plan, context);
          const blob = new Blob([json], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = (currentDoc?.name || 'document') + ' - export-debug.json';
          document.body.appendChild(a);
          a.click();
          setTimeout(() => { URL.revokeObjectURL(url); a.remove(); }, 500);
        } catch (err) {
          console.warn('Download debug JSON failed:', err);
        }
      });
      controls.appendChild(downloadBtn);

      overlay.appendChild(controls);

      const details = document.createElement('details');
      details.style.marginTop = '10px';
      const summaryEl = document.createElement('summary');
      summaryEl.textContent = 'Raw debug payload';
      summaryEl.style.cursor = 'pointer';
      const pre = document.createElement('pre');
      pre.style.whiteSpace = 'pre-wrap';
      pre.style.fontSize = '12px';
      pre.textContent = stringifyExportDebugSnapshot(plan, context);
      details.appendChild(summaryEl);
      details.appendChild(pre);
      overlay.appendChild(details);

      document.body.appendChild(overlay);
      try { overlay.focus({ preventScroll: true }); } catch {}
      exportDebugEscHandler = (ev) => { if (ev.key === 'Escape') { clearExportDebugPanel(); } };
      document.addEventListener('keydown', exportDebugEscHandler);
    }

    async function onExportDebugFromOpenForm() {
      if (!currentDoc?.docId) {
        alert('No active document. Open or pick a DOCX first.');
        return;
      }
      try {
        if (btnExportDebug) btnExportDebug.disabled = true;
        await ensurePy();
        const prepared = await gatherExportArtifacts();
        if (!prepared) {
          alert('Could not access the current DOCX bytes.');
          return;
        }
        const plan = await inspectRemovalPlan(prepared.updatedBytes, prepared.visibilityMap);
        console.groupCollapsed('Export removal debug');
        console.log('Visibility map', prepared.visibilityMap);
        console.log('Removal plan', plan);
        console.groupEnd();
        renderExportDebugPanel(plan, prepared);
      } catch (e) {
        console.error('Export debug failed:', e);
        alert('Export debug failed: ' + (e?.message || e));
      } finally {
        if (btnExportDebug) btnExportDebug.disabled = !currentDoc;
      }
    }

    async function onExportFromOpenForm() {
      if (!currentDoc?.docId) {
        alert('No active document. Open or pick a DOCX first.');
        return;
      }

      const canBytes = await fetchWorkingDocBytes();
      if (!canBytes) { await hardResetOpenForm('no bytes / no permission'); return; }

      let fileHandle = null;
      let skipPickerReason = '';
      if (supportsFS && window.showSaveFilePicker) {
        try {
          const suggested = (currentDoc.name?.replace(/\.docx$/i, '') || 'document') + ' (export).docx';
          fileHandle = await showSaveFilePicker({
            suggestedName: suggested,
            types: [{
              description: 'Word document',
              accept: { 'application/vnd.openxmlformats-officedocument.wordprocessingml.document': ['.docx'] }
            }]
          });
        } catch (e) {
          const msg = String(e?.message || '');
          if (e?.name === 'AbortError' || /canceled/i.test(msg)) return;
          if (e?.name === 'SecurityError' || e?.name === 'NotAllowedError' || /Must be handling a user gesture/i.test(msg)) {
            skipPickerReason = e?.name || 'SecurityError';
          } else {
            console.error('Save picker failed:', e);
            alert('Export failed: ' + (e?.message || e));
            return;
          }
        }
      }

      const attempt = async () => {
        await ensurePy();

        const prepared = await gatherExportArtifacts(canBytes);
        if (!prepared) { await hardResetOpenForm('no bytes / no permission'); return; }

        const updated3 = await applyRemovalWithBackup(prepared.updatedBytes, prepared.visibilityMap, prepared.originalBytes);

        await window.formSuitePersist.putBytes?.(currentDoc.docId, updated3);

        let saved = false;
        if (fileHandle) {
          try {
            const stream = await fileHandle.createWritable();
            await stream.write(updated3);
            await stream.close();
            saved = true;
          } catch (e) {
            const msg = String(e?.message || '');
            if (e?.name === 'AbortError' || /canceled/i.test(msg)) return;
            console.warn('Writing to handle failed, falling back to download:', e);
          }
        }

        if (!saved) {
          if (skipPickerReason) {
            console.info(`Falling back to download due to: ${skipPickerReason}`);
          }
          const blob = new Blob([updated3], {
            type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
          });
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = (currentDoc?.name || 'document').replace(/\.docx$/i, ' (export).docx');
          document.body.appendChild(a);
          a.click();
          setTimeout(() => { URL.revokeObjectURL(a.href); a.remove(); }, 2000);
        }
      };

      try {
        await attempt();
      } catch (e) {
        const msg = String(e?.message || e || '');
        if (msg.includes('already been destroyed') || msg.includes('proxy has been destroyed')) {
          await ensurePy(true);
          try { await attempt(); return; } catch (e2) {
            const m2 = String(e2?.message || '');
            if (e2?.name === 'AbortError' || /export canceled/i.test(m2)) return;
            console.error('Export failed after retry:', e2);
            alert('Export failed: ' + (e2?.message || e2));
            return;
          }
        }
        if (e?.name === 'AbortError' || /export canceled/i.test(msg.toLowerCase())) return;
        console.error('Export failed (Open Form):', e);
        alert('Export failed: ' + (e?.message || e));
      }
    }

    // ---------- Rules → loaders (workspace first, then payload mirror) ----------
    function loadRulesForDoc(state) {
      // workspace (authoritative during editing)
      if (Array.isArray(state?.rules)) return state.rules;

      // payload mirrors (support both nested + flat mirrors)
      const pl = state?.payload?.CRONOS_PAYLOAD
              || state?.CRONOS_PAYLOAD
              || state?.cronos_payload
              || state?.payload;

      if (Array.isArray(pl?.rules)) return pl.rules;

      // very old keys
      return state?.CRONOS_RULES || state?.cronos_rules || [];
    }

    function loadFieldRulesForDoc(state) {
      // workspace (authoritative during editing)
      if (Array.isArray(state?.fieldRules)) return state.fieldRules;

      // payload mirrors (support both nested + flat mirrors)
      const pl = state?.payload?.CRONOS_PAYLOAD
              || state?.CRONOS_PAYLOAD
              || state?.cronos_payload
              || state?.payload;

      if (Array.isArray(pl?.fieldRules)) return pl.fieldRules;

      // very old keys
      return state?.CRONOS_FIELD_RULES || state?.cronos_field_rules || [];
    }


    function buildHeadingTargetIndex(baseline) {
      const flat = Array.isArray(baseline?.flat)
        ? baseline.flat
        : Array.isArray(baseline) ? baseline
        : Array.isArray(baseline?.headings) ? baseline.headings
        : [];
      const tree = Array.isArray(baseline?.tree)
        ? baseline.tree
        : Array.isArray(baseline?.headingsTree) ? baseline.headingsTree
        : [];

      const byIdx = new Map();
      const byUid = new Map();
      const byComposite = new Map();
      const byNumber = new Map();

      const normComposite = (entry) => {
        const idx = Number(entry?.idx ?? entry?.key);
        const text = entry?.text || entry?.title || entry?.label || '';
        const num = entry?.number || entry?.num;
        if (num) return `${String(num)}|${text}`.trim();
        if (Number.isFinite(idx)) return `${idx}|${text}`.trim();
        return text ? `|${text}` : '';
      };

      const add = (entry) => {
        if (!entry) return;
        const idx = Number(entry.idx ?? entry.key);
        if (Number.isFinite(idx) && !byIdx.has(idx)) byIdx.set(idx, entry);
        const uid = entry.uid || entry.id;
        if (uid && !byUid.has(String(uid))) byUid.set(String(uid), entry);
        const num = entry.number || entry.num;
        if (num && !byNumber.has(String(num))) byNumber.set(String(num), entry);
        const composite = entry.compositeKey || normComposite(entry);
        if (composite) {
          if (!byComposite.has(composite)) byComposite.set(composite, entry);
          const head = composite.split('|', 1)[0];
          if (head && !byNumber.has(head)) byNumber.set(head, entry);
        }
      };

      flat.forEach(add);

      const walk = (nodes) => {
        if (!Array.isArray(nodes)) return;
        nodes.forEach((n) => {
          add(n);
          if (Array.isArray(n.children) && n.children.length) walk(n.children);
        });
      };
      walk(tree);

      const parseLegacyIdx = (target) => {
        const raw = (target && typeof target === 'object')
          ? (target.key ?? target.idx ?? target.id ?? target.number ?? target.uid ?? null)
          : target;
        if (raw == null) return NaN;
        if (typeof raw === 'number') return Number.isFinite(raw) ? raw : NaN;
        const str = String(raw).trim();
        if (!str) return NaN;
        if (/^\d+$/.test(str)) return Number(str);
        if (str.includes('|')) {
          const head = str.split('|', 1)[0];
          if (/^\d+$/.test(head)) return Number(head);
        }
        return NaN;
      };

      const resolve = (target) => {
        if (target && typeof target === 'object') {
          if (target.uid && byUid.has(String(target.uid))) return byUid.get(String(target.uid));
          if (target.idx != null) {
            const idx = Number(target.idx);
            if (Number.isFinite(idx) && byIdx.has(idx)) return byIdx.get(idx);
          }
          if (target.key != null) {
            const idx = Number(target.key);
            if (Number.isFinite(idx) && byIdx.has(idx)) return byIdx.get(idx);
            const keyStr = String(target.key);
            if (byComposite.has(keyStr)) return byComposite.get(keyStr);
          }
          if (target.label) {
            const lbl = String(target.label);
            const head = lbl.split(' ')[0];
            if (byNumber.has(head)) return byNumber.get(head);
          }
        }

        const rawStr = String((target && typeof target === 'object')
          ? (target.key ?? target.idx ?? target.id ?? target.uid ?? target.number ?? '')
          : target ?? '').trim();

        if (rawStr) {
          if (byComposite.has(rawStr)) return byComposite.get(rawStr);
          if (byUid.has(rawStr)) return byUid.get(rawStr);
          if (byNumber.has(rawStr)) return byNumber.get(rawStr);
          if (rawStr.includes('|')) {
            const head = rawStr.split('|', 1)[0];
            if (byNumber.has(head)) return byNumber.get(head);
            const num = Number(head);
            if (Number.isFinite(num) && byIdx.has(num)) return byIdx.get(num);
          }
          const num = Number(rawStr);
          if (Number.isFinite(num) && byIdx.has(num)) return byIdx.get(num);
        }
        return null;
      };

      const resolveIdx = (target) => {
        const entry = resolve(target);
        if (entry && Number.isFinite(Number(entry.idx))) return Number(entry.idx);
        const legacy = parseLegacyIdx(target);
        if (Number.isFinite(legacy)) return legacy;
        return NaN;
      };

      const buildLabel = (entry, fallback) => {
        if (!entry) return fallback || '';
        const text = entry.text || entry.title || entry.label || '';
        const num = entry.number || entry.num;
        if (num) return `${num} ${text}`.trim();
        if (text) return text;
        return fallback || '';
      };

      const normalizeTarget = (target) => {
        const entry = resolve(target);
        const idx = entry ? Number(entry.idx) : resolveIdx(target);
        if (!Number.isFinite(idx)) return null;
        const normalized = { key: idx, idx };
        if (entry?.uid) normalized.uid = entry.uid;
        else if (target && typeof target === 'object' && target.uid) normalized.uid = target.uid;
        const fallbackLabel = (target && typeof target === 'object') ? target.label : null;
        const label = buildLabel(entry, fallbackLabel) || `Heading ${idx}`;
        normalized.label = label;
        const number = entry?.number || entry?.num;
        if (number) normalized.number = number;
        return normalized;
      };

      return { resolve, resolveIdx, normalizeTarget, buildLabel };
    }

    function ruleMatchesValue(op, expected, actual) {
      const a = actual;
      if (op === 'equals')    return String(a) === String(expected);
      if (op === 'notEquals') return String(a) !== String(expected);
      if (op === 'anyOf') {
        const arr = Array.isArray(expected) ? expected.map(String) : [String(expected)];
        if (Array.isArray(a)) return a.map(String).some(v => arr.includes(v));
        return arr.includes(String(a));
      }
      if (op === 'allOf') {
        const arr = Array.isArray(expected) ? expected.map(String) : [String(expected)];
        if (!Array.isArray(a)) return false;
        const aset = new Set(a.map(String));
        return arr.every(v => aset.has(v));
      }
      if (op === 'contains') {
        return String(a ?? '').toLowerCase().includes(String(expected ?? '').toLowerCase());
      }
      return false;
    }

    // Small helper: accept targets like  "12"  OR  "12|Heading title"
    function parseTargetIdx(t, headingResolver) {
      if (headingResolver && typeof headingResolver.resolveIdx === 'function') {
        const resolved = headingResolver.resolveIdx(t);
        if (Number.isFinite(resolved)) return resolved;
      }
      const raw = t?.key ?? t?.idx ?? t?.id;
      if (raw == null) return NaN;
      if (typeof raw === 'number') return raw;
      const s = String(raw);
      const head = s.split('|', 1)[0]; // "12|..." → "12"
      const n = Number(head);
      return Number.isFinite(n) ? n : NaN;
    }

    // Keep your existing ruleMatchesValue(...) helper

    function evaluateRulesToVisibility(schema, values, rules, headingResolver) {
      const out = Object.create(null);
      if (!Array.isArray(rules) || !rules.length) return out;

      const cleanVals = sanitizeValues(schema, values || {});
      const getVal = (fid) => cleanVals[fid];

      const toSlug = (s) => String(s||'')
        .normalize('NFKD')
        .replace(/[\u0300-\u036f]/g, '')
        .replace(/[^a-zA-Z0-9]+/g, '_')
        .replace(/^_+|_+$/g, '')
        .toLowerCase();

      for (const r of rules) {
        if (!r) continue;

        const action = (String(r.action || '').toUpperCase() === 'SHOW') ? 'SHOW'
                    : (String(r.action || '').toUpperCase() === 'HIDE') ? 'HIDE'
                    : null;
        if (!action) continue;

        const fieldId = r.fieldId || r.field || r.whenField;
        const op      = r.op || r.operator || 'equals';
        const exp     = r.values ?? r.value ?? r.expected;
        const targets = Array.isArray(r.targets) ? r.targets : [];

        // --- match condition ---
        let match = false;

        // option-sourced boolean (e.g., "services__opt__cleaning")
        if (typeof fieldId === 'string' && fieldId.includes('__opt__')) {
          const [baseId, slug] = fieldId.split('__opt__');
          const actualArr = Array.isArray(getVal(baseId)) ? getVal(baseId).map(String) : [];
          const selected = actualArr.some(v => toSlug(v) === String(slug||'').replace(/^_+/,'').toLowerCase());
          const expect = Array.isArray(exp) ? exp[0] : exp;
          const expectBool = (String(expect) === 'true');
          if (op === 'equals') match = (selected === expectBool);
        } else {
          // normal field comparison
          const fld = (schema?.fields||[]).find(f => String(f.id) === String(fieldId));
          const t = String(fld?.type||'').toLowerCase();
          const actual = getVal(fieldId);

          if (t === 'date') {
            const expStr = Array.isArray(exp) ? String(exp[0]||'') : String(exp||'');
            const toDay = (s) => { if (!s) return NaN; const d = new Date(s); return isNaN(d) ? NaN : Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()); };
            const a = toDay(actual);
            const b = toDay(expStr);
            if (Number.isNaN(a) || Number.isNaN(b)) match = false;
            else if (op === 'before') match = a < b;
            else if (op === 'after')  match = a > b;
            else if (op === 'equals') match = a === b;
          } else if (t === 'text' || t === 'number' || t === 'select') {
            const expVal = Array.isArray(exp) ? exp[0] : exp;
            if (op === 'equals')    match = String(actual) === String(expVal);
            else if (op === 'notEquals') match = String(actual) !== String(expVal);
            else if (t === 'text' && op === 'contains') match = String(actual ?? '').toLowerCase().includes(String(expVal ?? '').toLowerCase());
          } else if (t === 'multichoice') {
            match = ruleMatchesValue(op, exp, actual);
          } else {
            match = ruleMatchesValue(op, exp, actual);
          }
        }

        if (!match) continue;

        // --- apply effect to heading indices ---
        for (const t of targets) {
          const idx = parseTargetIdx(t, headingResolver);
          if (!Number.isFinite(idx)) continue;
          const prev = out[idx];
          if (action === 'SHOW') out[idx] = 'SHOW';
          else if (action === 'HIDE' && prev !== 'SHOW') out[idx] = 'HIDE';
        }
      }
      return out;
    }

    // ---------- Field Rules (UI visibility) ----------
    function loadFieldRulesForDoc(state) {
      return (
        state?.fieldRules ||
        state?.payload?.fieldRules ||
        state?.CRONOS_FIELD_RULES ||
        state?.cronos_field_rules ||
        []
      );
    }

    function evaluateFieldRulesToVisibility(schema, values, rules) {
      const out = Object.create(null);
      if (!Array.isArray(rules) || !rules.length) return out;

      const cleanVals = sanitizeValues(schema, values || {});
      const getVal = (fid) => cleanVals[fid];

      const toSlug = (s) => String(s||'')
        .normalize('NFKD')
        .replace(/[\u0300-\u036f]/g, '')
        .replace(/[^a-zA-Z0-9]+/g, '_')
        .replace(/^_+|_+$/g, '')
        .toLowerCase();

      for (const r of rules) {
        if (!r) continue;

        const action = (String(r.action || '').toUpperCase() === 'SHOW') ? 'SHOW'
                    : (String(r.action || '').toUpperCase() === 'HIDE') ? 'HIDE'
                    : null;
        if (!action) continue;

        const fieldId = r.fieldId || r.field || r.whenField;
        const op      = r.op || r.operator || 'equals';
        const exp     = r.values ?? r.value ?? r.expected;
        const targets = Array.isArray(r.targets) ? r.targets : [];
        const effect  = (String(r.hideMode||'hide').toLowerCase() === 'disable') ? 'DISABLE' : 'HIDE';

        // --- match condition ---
        let match = false;

        if (typeof fieldId === 'string' && fieldId.includes('__opt__')) {
          const [baseId, slug] = fieldId.split('__opt__');
          const actualArr = Array.isArray(getVal(baseId)) ? getVal(baseId).map(String) : [];
          const selected = actualArr.some(v => toSlug(v) === String(slug||'').replace(/^_+/,'').toLowerCase());
          const expect = Array.isArray(exp) ? exp[0] : exp;
          const expectBool = (String(expect) === 'true');
          if (op === 'equals') match = (selected === expectBool);
        } else {
          const fld = (schema?.fields||[]).find(f => String(f.id) === String(fieldId));
          const t = String(fld?.type||'').toLowerCase();
          const actual = getVal(fieldId);

          if (t === 'date') {
            const expStr = Array.isArray(exp) ? String(exp[0]||'') : String(exp||'');
            const toDay = (s) => { if (!s) return NaN; const d = new Date(s); return isNaN(d) ? NaN : Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()); };
            const a = toDay(actual);
            const b = toDay(expStr);
            if (Number.isNaN(a) || Number.isNaN(b)) match = false;
            else if (op === 'before') match = a < b;
            else if (op === 'after')  match = a > b;
            else if (op === 'equals') match = a === b;
          } else if (t === 'text' || t === 'number' || t === 'select') {
            const expVal = Array.isArray(exp) ? exp[0] : exp;
            if (op === 'equals')    match = String(actual) === String(expVal);
            else if (op === 'notEquals') match = String(actual) !== String(expVal);
            else if (t === 'text' && op === 'contains') match = String(actual ?? '').toLowerCase().includes(String(expVal ?? '').toLowerCase());
          } else if (t === 'multichoice') {
            match = ruleMatchesValue(op, exp, actual);
          } else {
            match = ruleMatchesValue(op, exp, actual);
          }
        }

        if (!match) continue;

        // --- apply to field/option targets ---
        for (const t of targets) {
          // field rules target either a field id or a multichoice option id ("field__opt__slug")
          const id = String(t?.id ?? t?.fieldId ?? t?.key ?? '');
          if (!id) continue;
          const prev = out[id];
          if (action === 'SHOW') out[id] = 'SHOW';
          else if (action === 'HIDE' && prev !== 'SHOW') out[id] = effect; // DISABLE or HIDE
        }
      }

      return out;
    }

    function applyFieldVisibility() {
      try {
        if (!schema || !Array.isArray(schema.fields)) return;
        const visMap = evaluateFieldRulesToVisibility(schema, values || {}, fieldRules || []);
        const clearDisabled = (el) => {
          el.style.opacity = '';
          el.style.pointerEvents = '';
          el.removeAttribute('aria-disabled');
          el.querySelectorAll('input,select,textarea,button').forEach(i => { try { i.disabled = false; } catch {} });
        };
        document.querySelectorAll('.field[data-field-id]').forEach(node => { node.style.display = ''; clearDisabled(node); });
        document.querySelectorAll('.mc-item[data-opt-id]').forEach(node => { node.style.display = ''; clearDisabled(node); });

        const esc = (window.CSS && CSS.escape)
          ? CSS.escape
          : (s => String(s)
              .replace(/\\/g,'\\\\')
              .replace(/"/g,'\\"')
              .replace(/\]/g,'\\]')
              .replace(/\[/g,'\\[')
              .replace(/\(/g,'\\(')
              .replace(/\)/g,'\\)')
              .replace(/\./g,'\\.')
            );


        const deselectMcItem = (mcEl) => {
          const cb = mcEl.querySelector('input[type="checkbox"][data-mc="1"]');
          if (!cb) return;
          const fid = cb.name;
          const optVal = cb.value;
          if (cb.checked) cb.checked = false;
          const arr = Array.isArray(values[fid]) ? values[fid].map(String) : [];
          const next = arr.filter(v => v !== String(optVal));
          values[fid] = next;
          scheduleSaveState();
        };
        const deselectFieldWrapper = (wrapEl) => {
          const fid = wrapEl?.dataset?.fieldId || '';
          if (!fid) return;
          const fld = (schema?.fields || []).find(f => String(f.id) === String(fid));
          const t = String(fld?.type || '').toLowerCase();
          if (t === 'multichoice') {
            wrapEl.querySelectorAll('input[type="checkbox"][data-mc="1"]').forEach(cb => { cb.checked = false; });
            values[fid] = [];
            scheduleSaveState();
          } else if (t === 'select') {
            const sel = wrapEl.querySelector('select');
            if (sel) { sel.value = ''; values[fid] = ''; scheduleSaveState(); }
          } else if (t === 'text') {
            const inp = wrapEl.querySelector('input[type="text"]:not([data-type="date"])');
            if (inp) { inp.value = ''; values[fid] = ''; scheduleSaveState(); }
          } else if (t === 'number') {
            const inp = wrapEl.querySelector('input[type="number"]');
            if (inp) { inp.value = ''; values[fid] = ''; scheduleSaveState(); }
          } else if (t === 'date') {
            const inp = wrapEl.querySelector('input[data-type="date"]');
            if (inp) {
              try { if (inp._flatpickr) inp._flatpickr.clear(); } catch {}
              inp.value = '';
              values[fid] = '';
              scheduleSaveState();
            }
          }
        };

        Object.keys(visMap || {}).forEach(id => {
          const dir = visMap[id];
          if (typeof id === 'string' && id.includes('__opt__')) {
            document.querySelectorAll(`.mc-item[data-opt-id="${esc(id)}"]`).forEach(el => {
              deselectMcItem(el);
              if (dir === 'HIDE') el.style.display = 'none';
              else { el.style.display=''; el.style.opacity = '0.5'; el.style.pointerEvents = 'none'; el.setAttribute('aria-disabled','true'); el.querySelectorAll('input,select,textarea,button').forEach(i => { try { i.disabled = true; } catch {} }); }
            });
          } else {
            document.querySelectorAll(`.field[data-field-id="${esc(id)}"]`).forEach(el => {
              deselectFieldWrapper(el);
              if (dir === 'HIDE') el.style.display = 'none';
              else { el.style.display=''; el.style.opacity = '0.5'; el.style.pointerEvents = 'none'; el.setAttribute('aria-disabled','true'); el.querySelectorAll('input,select,textarea,button').forEach(i => { try { i.disabled = true; } catch {} }); }
            });
          }
        });
      } catch (e) { /* no-op */ }
    }

    // ---------- JS bridge to Python removal-with-backup ----------
    async function inspectRemovalPlan(bytesU8, visibilityMap) {
      await ensurePy();
      const fn = py.globals.get('inspect_export_removal_plan');
      const buf = bytesU8 instanceof Uint8Array ? bytesU8 : new Uint8Array(bytesU8 || []);
      const pyBytes = py.toPy(buf);
      const pyMap = py.toPy(JSON.stringify(visibilityMap || {}));
      let pyOut;
      try {
        pyOut = fn(pyBytes, pyMap);
      } finally {
        try { fn.destroy(); } catch {}
        try { pyBytes.destroy(); } catch {}
        try { pyMap.destroy(); } catch {}
      }
      let out = null;
      if (pyOut?.toJs) out = pyOut.toJs({ create_proxies:false });
      else out = pyOut ?? null;
      try { pyOut?.destroy?.(); } catch {}
      if (typeof out === 'string') {
        try { return JSON.parse(out); }
        catch { return { error: 'parse-error', raw: out }; }
      }
      return out;
    }

    async function applyRemovalWithBackup(bytesU8, visibilityMap, originalBytes) {
      await ensurePy();
      const fn = py.globals.get('apply_removal_with_backup');
      const buf = bytesU8 instanceof Uint8Array ? bytesU8 : new Uint8Array(bytesU8);
      const pyBytes = py.toPy(buf);
      const pyMap   = py.toPy(JSON.stringify(visibilityMap || {}));
      const pyPath  = py.toPy('customXml/originalDocument.xml');
      const origBuf = (originalBytes instanceof Uint8Array)
        ? originalBytes
        : (originalBytes ? new Uint8Array(originalBytes) : null);
      let pyOut;
      let pyOrig = null;
      try {
        if (origBuf) {
          pyOrig = py.toPy(origBuf);
          pyOut = fn(pyBytes, pyMap, pyPath, pyOrig);
        } else {
          pyOut = fn(pyBytes, pyMap, pyPath);
        }
      }
      finally {
        try{fn.destroy();}catch{}
        try{pyBytes.destroy();}catch{}
        try{pyMap.destroy();}catch{}
        try{pyPath.destroy();}catch{}
        try{pyOrig?.destroy();}catch{}
      }
      let u8;
      if (pyOut?.toJs) u8 = pyOut.toJs({ create_proxies:false });
      else if (pyOut?.getBuffer) u8 = new Uint8Array(pyOut.getBuffer());
      else u8 = new Uint8Array([]);
      try { pyOut?.destroy?.(); } catch {}
      return u8;
    }

    async function restoreDocxFromBackup(bytesU8, backupPath = 'customXml/originalDocument.xml') {
      await ensurePy();
      const fn = py.globals.get('restore_document_from_backup');
      const buf = bytesU8 instanceof Uint8Array ? bytesU8 : new Uint8Array(bytesU8 || []);
      const pyBytes = py.toPy(buf);
      const pyPath = py.toPy(String(backupPath || 'customXml/originalDocument.xml'));
      let pyOut;
      try {
        pyOut = fn(pyBytes, pyPath);
      } finally {
        try { fn.destroy(); } catch {}
        try { pyBytes.destroy(); } catch {}
        try { pyPath.destroy(); } catch {}
      }
      let u8;
      if (pyOut?.toJs) u8 = pyOut.toJs({ create_proxies:false });
      else if (pyOut?.getBuffer) u8 = new Uint8Array(pyOut.getBuffer());
      else u8 = new Uint8Array(buf);
      try { pyOut?.destroy?.(); } catch {}
      return u8;
    }

    // Expose for cross-callbacks
    try {
      window.applyFieldVisibility = applyFieldVisibility;
      window.restoreDocxFromBackup = restoreDocxFromBackup;
      window.inspectExportRemovalPlan = inspectRemovalPlan;
      window.renderExportDebugPanel = renderExportDebugPanel;
    } catch {}

    // ---------- Logo triple-click: focus mode ----------
    (function() {
      const logo = document.querySelector('header .logo');
      const header = document.querySelector('header .row');
      if (!logo || !header) return;

      let clickCount = 0;
      let clickTimer = null;
      let focusMode = false;

      logo.addEventListener('click', () => {
        clickCount++;
        clearTimeout(clickTimer);
        clickTimer = setTimeout(() => { clickCount = 0; }, 600);

        if (clickCount === 3) {
          clickCount = 0;
          focusMode = !focusMode;

          if (focusMode) {
            header.querySelectorAll('a, span.muted').forEach(el => {
              if (!el.closest('.brand')) el.style.display = 'none';
            });
            if (!location.pathname.endsWith('index.html')) {
              location.href = 'index.html';
            }
          } else {
            header.querySelectorAll('a, span.muted').forEach(el => { el.style.display = ''; });
          }
        }
      });
    })();
  </script>
</body>
</html>
